id	label	hovertext	author	x	y	type	relevance	size	year	umap1d
33081845	I worked at a startup that was built	I worked at a startup that was built on Clojure. It had trouble finding developers for reasonable salaries at the early mid stage. They decided to switch the stack to python at that point. Just an anecdote!	beiller	12.637951	-7.8600507	comment	3.0	23.0	1664897609	-11.114061
33082998	For me, the killer feature of Clojur	"For me, the killer feature of Clojure is ""REPL driven development"". The ability to get rapid feedback as you build things up is incredible. I'll make a comment form and evaluate expressions within it to try things out as I go. By the time I've written any reasonably complex function, all of the pieces have been tested on various examples. Once I'm done, the comment form leaves a helpful record of my thought process.If you're wondering what's so great about the Clojure repl (and other lisp repls) in particular, the thing is that you never have to actually type something into it. You can run evaluations from the code file itself. The structure of lisps makes it clear exactly which code you want to evaluate. To do this, I use the excellent CIDER package for emacs. I understand Calva for VS Co"	hypersoar	12.649342	-7.8990664	comment	3.0	19.0	1664901880	-11.141591
33083517	Some advantages of EDN:* Can represe	"Some advantages of EDN:* Can represent sets `#{1 2 3 4 ""foo"" ""bar"" true false}` (JSON only supports arrays)* Maps/sets can contain arbitrary EDN as keys/values. `{[1 2] ""foo"", 5 :a, ""5"" :b, true -1, false 5}` or `#{[1 2] #{3 4} (5 6)}` (JSON only supports string keys on ""objects"")* Supports clojure types like keywords (`:foo`, `:bar/baz`) and symbols (`foo`, `bar/baz`), and can be extended to support other values as well"	leiferik	12.547852	-7.8099704	comment	3.0	14.0	1664903914	-10.947375
33165559	It's funny, I don't believe Elm itse	"It's funny, I don't believe Elm itself needs much (if any) modification- the language is in a great spot, as are the core libs. If you care about it winning the ""language wars"", it needs more PR, examples, success stories, and tutorials. Here, I'm happy to have contributed in some way(s)."	aaronwhite	13.006966	-7.69234	comment	3.0	13.0	1665506666	-12.758992
33296258	Modern Clojure includes that - it's 	Modern Clojure includes that - it's deps.edn (though I'm good with Leiningen).And ditch Emacs (unless you are already using it/used to it) and try VSCode + Calva that runs basically out of the box.Exceptions... yes.... they are clear when you know what they mean, but it takes time, because they are so long.Startup... you only start a REPL once, so does not really matter (to me at least). For compiled code, you can try GraalVM, that has zero-ish startup time - because all static initialization is resolved at compile-time.Just my $.02Edit: Calva also includes a debugger - never used it, but here it is https://calva.io/debugger/	kimi	12.649695	-7.890904	comment	3.0	28.0	1666423582	9.290583
33296282	> you only start a REPL once, so doe	> you only start a REPL once, so does not really matterPeople say this a lot in Clojure, but don't you worry about global vars that no longer point to what you thought they pointed to?  For this reason alone, I almost always load a new Python REPL.	funstuff007	12.613963	-7.8598742	comment	3.0	18.0	1666423944	-11.098642
33297741	I think this response is a good illu	I think this response is a good illustration of the frustration that I (and I suspect many others) have with Clojure. I’m speaking as someone who’s been excited by it since around 2012, has helped run Clojure meetups, and has tried many times to advocate for its usage.I really _really_ want to love Clojure but the first three points (unfortunately along with the Lisp syntax simply because it’s different enough) alienate too many people from the language and it seems like that’s something that Clojure has at best accepted as not the target audience and at worst is still unwilling to acknowledge.	spinningarrow	12.638122	-7.9158144	comment	3.0	14.0	1666441503	-11.138255
33378758	Cherry: ClojureScript to ES6 Compile	Cherry: ClojureScript to ES6 Compiler	tosh	12.65012	-7.879129	story	3.0	75.0	1666995906	-11.129339
33407545	Elmo is so rich, he doesn't care.  T	Elmo is so rich, he doesn't care.  This recall doesn't matter to him one iota.	JustSomeNobody	13.0133095	-7.696275	comment	3.0	12.0	1667231513	-12.764252
33425467	Is anyone doing Clojure to Wasm?	Is anyone doing Clojure to Wasm?	nerpderp82	12.650338	-7.8984785	comment	3.0	12.0	1667327803	-11.194304
26494155	For those unfamiliar with Common Lis	For those unfamiliar with Common Lisp there is also Babashka which allows for Clojure shell scripting without the JVM startup time.https://github.com/babashka/babashka	lambdaba	12.652478	-7.8905754	comment	3.0	24.0	1616001449	-11.137467
26502562	> Some languages that have CONS cell	> Some languages that have CONS cells:Erlang and Prolog also use cons cells... Prolog is also homoiconic. I don't think I ever heard anyone calling Prolog a Lisp though.Also, Clojure has cons cells. '(3 . 4) is a valid expression in Clojure.Basically, this is an arbitrary, and rather unhelpful, classification. I don't find it interesting, but to each their own, I guess.	klibertp	12.6703	-7.8849673	comment	3.0	13.0	1616074834	-11.076927
26516306	Clojure: Keyword argument functions 	Clojure: Keyword argument functions now also accept maps	tosh	12.541771	-7.852147	story	3.0	48.0	1616176314	-11.133996
26586854	What is the sweat spot for clojure? 	"What is the sweat spot for clojure? Seems like it could be useful in places where the programmers are also responsible for ""data entry"" and it's better to use a lisp instead of xml or java annotations."	wrnr	12.655804	-7.898613	comment	3.0	12.0	1616714128	-11.123494
26633902	Clojure CLR is a thing. And despite 	"Clojure CLR is a thing. And despite the opposite opinions, Clojure is very much ""a proper Lisp""."	iLemming	12.65493	-7.881933	comment	3.0	12.0	1617108159	-11.070281
26714272	The question is funny because on the	The question is funny because on the the list of advantages that Clojurescript offers the syntax / language is quite low on the list imo.Clojurescript has the best client-side build tool I have used in https://shadow-cljs.github.io/docs/UsersGuide.html and everyone uses it.Clojurescript targets/outputs Google Closure compatible code which is easily the most sophisticated JS compiler out there. The reason no one uses it is because writing compatible code by hand is a nightmare.Clojurescript's front end libraries are incredible, they are basically a better expression of Redux because the Clojure language has constructs that enable a more expressive API https://day8.github.io/re-frame/re-frame/Clojurescript's JS interop is actually insane, boosted by the quality of Shadow-cljs. You can write 	pizzeriafrida	12.651031	-7.8416104	comment	3.0	11.0	1617728074	-11.151118
26714939	The benefits of using Clojurescript 	The benefits of using Clojurescript over JS/TS in 2021 are superficial and not worth it IMO. Typescript is great, has good tooling and plays nice with the JS ecosystem. With Clojurescript you spent more time fighting integration with the JS ecosystem than getting any real work done. The mismatch between JS objects and Clojurescript data structures is annoying and tedious and riddle with performance issues, and Clojurescript in general has many performance issues.	Scarbutt	12.645268	-7.877379	comment	3.0	11.0	1617730834	-11.162837
26716038	This is great!What is not so great i	"This is great!What is not so great is that Google's closure team (not be confused with clojure) decided to remove various functions, making breaking changes - for no obvious reasons other than saving a few lines of code.Example Things like `goog.isArray` is gone, a library that was adopted by many (including the CLJS compiler) to help smooth out the differences in JS versions and supported features.The closure team even has great advice for you:""goog.isArray has been deleted. Use Array.isArray instead.""Well, how about you just delegate to that, Google team, and I can just upgrade?This kind of library maintenance is what keeps me away from JS/TS where prior investments seem to be less valuable:React deprecating lifecycle methods, Typescript's breaking changes page is pretty long (but admitt"	beders	12.66057	-7.856096	comment	3.0	10.0	1617736200	-11.086227
37619569	> Most operations on clojure persist	"> Most operations on clojure persistent data structures are an order of magnitude less efficient than they are on the mutable equivalentsIt's not really clear what you mean by ""order of magnitude"" here. The notation you're using suggests that you're thinking in terms of asymptotic algorithmic resource requirements, which are most often characterized by polynomial degree; an order of magnitude (""factor of 10"") is invisible in those terms.But a factor of log n, while not invisible, is nearly so. If you're thinking in terms of polynomial degree, a factor of log n is literally an infinitesimal value - it's more than 0, but less than all positive real numbers."	thaumasiotes	12.624101	-7.8947816	comment	3.0	19.0	1695429561	-11.1533785
37662056	Are there people here that prefer Co	Are there people here that prefer Common Lisp to Clojure for webdev specifically and would like to tell us why?	Capricorn2481	12.6621	-7.8811884	comment	3.0	22.0	1695746880	-11.04844
37662222	Sure:1. I've been using CL for longe	"Sure:1. I've been using CL for longer than Clojure has existed2. SLIME is better than any Clojure dev setup I've seen3. Maybe I'm misunderstanding things, but if I get how Leiningen works, I need to restart my REPL any time I want to add dependencies?4. Kind of a minor thing, but working in a Lisp-1 hits the ""uncanny valley"" of programming for me; I accidentally shadow an important function at least once an hour when working in Clojure or Scheme."	aidenn0	12.642678	-7.892465	comment	3.0	17.0	1695747382	-11.12209
37688962	EDN (Extensible Data Notation) is a 	EDN (Extensible Data Notation) is a subset of Clojure: https://github.com/edn-format/ednIt is:- Unambiguous- Streamable- Extensible- Whitespace-insensitive, but there are formatting conventions for readability	pgt	12.622438	-7.8860803	comment	3.0	11.0	1695905637	-11.099611
37792294	Java 21 VirtualThreads vs. Clojure L	Java 21 VirtualThreads vs. Clojure Lazy Seqs	grzm	12.618511	-7.8810344	story	3.0	215.0	1696607053	9.078612
37792742	The Clojure devs should be aware tha	The Clojure devs should be aware that the synchronization pinning problem is intended to be temporary and doesn't apply at all with GraalVM native images. One of the Loom developers talks about it here:https://mail.openjdk.org/pipermail/loom-dev/2023-September/0...So they could also just choose to ignore this problem for now.	mike_hearn	12.611356	-7.8673716	comment	3.0	95.0	1696609104	-11.181073
37792908	A lot of Clojure projects choose to 	A lot of Clojure projects choose to stick with the LTS releases though, so it might take a while before this problem disappears on its own, even if fixed in the JVM.	fnordsensei	12.652444	-7.904089	comment	3.0	91.0	1696609869	-11.173357
14756304	This feature is really, really a lon	This feature is really, really a long time coming. Myself and other ClojureScript core contributors are happy to answer any questions people may have.	swannodette	12.654987	-7.886674	comment	3.0	19.0	1499891056	-11.161066
14756433	There's no extern inference required	There's no extern inference required here as all the original sources are passed directly through Google Closure Compiler. As a benchmark for feasibility when we started we chose React.js as it's non-trivial and heavily depended upon in the ClojureScript ecosystem. We discovered that over all of React's sources we only need 4 extern definitions for 4 generated names in EventsPlugin. So as long as the JS library in question isn't relying on string-based meta programming everything should work.Granted this rules out some libraries, there are plenty of libraries written in a simple straightforward style that will work just fine. In particular I am bullish about fantastic results with ES6+ libraries written with ES6 classes with static import/export. Closure will eat that stuff up.	swannodette	12.663538	-7.82767	comment	3.0	12.0	1499891866	-11.154555
14756567	The thing I like about Clojurescript	The thing I like about Clojurescript is the ability to escape the node/NPM ecosystem entirely. It's feature, not a bug, that I don't want to interoperate with node/NPM.	nickbauman	12.654897	-7.881897	comment	3.0	12.0	1499892780	-11.169661
14872247	Interesting.  I've mostly been progr	Interesting.  I've mostly been programming clojure for the last couple years.  But I've got one project I'd like to try to make that is very GUI centric.I don't know what it is about GUI programming, but I pretty much hate it.  It's a complete schlep for me... it seems to take so much energy and work for something that is tangential.If I had to go through the same level of effort to print something to the console, I'd never program anything.	DigitalJack	12.643563	-7.893162	comment	3.0	19.0	1501220860	-11.132101
14900034	> There are certain domains for whic	> There are certain domains for which Elm makes a lot of sense, and others for which it would be the wrong choice.No argument here!Elm has this characteristic in common with JavaScript, Java, Scala, C, C++, Python, Ruby, Perl, Haskell, PureScript, Go, Rust... ;)> It's perfectly valid to admit there are some limitations there which may be too much for some projects.Absolutely!I know of one team that specifically switched from Elm to ClojureScript because that made more sense for their project (whose purpose was to stitch together JS libraries on the fly), and I thought they made the right decision. ClojureScript was a better fit for their needs.I also wouldn't use Elm in situations where a virtual DOM would be problematic, such as making a large-scale rich text editor.I don't think anyone w	rtfeldman	12.881852	-7.692999	comment	3.0	14.0	1501591449	-12.713554
14909984	This is great, very small code. The 	"This is great, very small code. The choice of Clojure would make it a bit difficult for a beginner, but hey, then you know a real language.> This is not an official Google product (experimental or otherwise), it is just code that happens to be owned by Google.#1 reason for a hacker to not work for Google, you could program ""Hello, World"" and they wouldn't sign off on it."	thesmallestcat	12.651591	-7.891323	comment	3.0	18.0	1501677173	-11.153182
14911898	I don't know why you assume that I h	I don't know why you assume that I haven't tried Clojure and found the requisite Java knowledge to be a barrier. How did you get into developing Clojure professionally? Personally, learning on my own through resources like Clojure for the Brave and True, I found it difficult.	chickenfries	12.65443	-7.8993416	comment	3.0	13.0	1501690951	-11.176117
14928609	The perfect language to expand your 	The perfect language to expand your brain. In a world dominated by java, php, c++,... In my opinion yes, Clojure could the perfect language to continue learning concepts, at same level would be Haskell.	grouchoboy	12.643648	-7.899506	comment	3.0	22.0	1501854607	-11.154508
14928752	One huge difference is the workflow 	One huge difference is the workflow you have in Clojure. REPL driven development is an experience unique to Lisps. When you're working with Clojure, any code can be run in the context of the live app straight from the editor as you write it. This is an amazing experience and very mind expanding in what a development process can look like.Also, anybody who wants to try FP style programming, but isn't interested in static typing is much better off with Clojure. Type systems in languages like Haskell and Idris add a lot of complexity and mental overhead that's not present in a dynamic language.	yogthos	12.625052	-7.8716116	comment	3.0	19.0	1501855724	-11.099248
14928782	Is there something about clj's repl 	Is there something about clj's repl that makes it any different from ghci's?	drawnwren	12.536883	-7.8439555	comment	3.0	10.0	1501855976	10.453081
14929263	> What on earth does this have to do	"> What on earth does this have to do with clojure? Programmers will do this in any language, there's nothing special about clojure here.I haven't programmed in Java in over ten years, but one if its ""advantages"" (at least back in the day) was what I called its object-oriented handcuffs, which prevented programmers from being too fancy with their code. Every file had to be a class. Every class was an object. Namespaces were clearly and rigidly defined. Setters and getters were standard for defining properties of an object. Etc.The net result was frustration for programmers who detested such rigidity, but relief for any new programmer coming into a project because Java made it very difficult to write the kind of ""specialized beautiful code' that shadowmint laments.Lisps in particular allow t"	magpi3	12.646739	-7.892524	comment	3.0	12.0	1501859547	8.36152
14929372	Any book on clojure and website too 	"Any book on clojure and website too will go over them.  They are fundamental to using clojure.I don't know enough about haskell to say what it does or doesn't have in relation to clojure.  However, it's not simply the data structures, but how the language is built to interact with them from a programmers perspective.From a user interface to the language point of view, I find the ways of interacting with maps to be very nice.In particular the dual purpose of ""keywords"" to serve both as a good index/key in said hash maps, but also as callable look up function for the same key in a hash map leads to simplified code.This, coupled with the extremely high usage of those maps in typical clojure code, makes a big difference.To expand on that a little, ""keywords"" are symbols that begin with a colon"	DigitalJack	12.603063	-7.875535	comment	3.0	12.0	1501860328	-11.1321745
14929745	Are we doing opinion threads now? Ok	Are we doing opinion threads now? Okay. I can do one too!I do like working with clojure. It's my favorite dynamically typed programming language by an easy margin.It's basically everything that was a good idea in Python and Ruby brought under the unifying role of a Lisp syntax, with a good Java FFI. This makes it slightly harder to learn (it's very difficult to learn Clojure if you don't at least know Java).It has a very clean syntax for the most part. Parenthesis handling does need some automation (basically everyone copied paredit) but has the nice property that refactoring is a breeze and extremely predictable.Except for rogue agents like me and a few others, very few programmers go crazy with defmacro, which makes Clojure often a lot more orderly and understandable than lots of Common 	KirinDave	12.650761	-7.8855057	comment	3.0	18.0	1501863063	-11.10783
14929823	> Clojure is a dynamic language.Dyna	> Clojure is a dynamic language.Dynamically typed. As a dynamic language Clojure is less capable than many other Lisp implementations/languages. See for example 'late binding'. In Clojure you either need to define a function before its use or need declare it. Not that 'dynamic'. In a typical Lisp dialect the order of definitions makes much less a difference, since functions can be called late-bound. For an interpreter-based implementation, it makes no difference at all.> It promotes combinations of built-in data structures (lists, maps, vectors) over objectsAn aspect I don't like. This makes debugging of larger systems more difficult, since maps are maps. Whereas objects have a type tag built in, have a list of allowed fields, etc. etc. They simply have more more explicit and standardized 	lispm	12.632786	-7.874637	comment	3.0	19.0	1501863821	-11.074471
14952803	Aren't most of these environments lo	Aren't most of these environments low on memory and thus it doesn't really make sense for them to use Clojure's persistent data structures? Kinda related is this awesome paper: https://blog.acolyer.org/2015/11/27/hamt/	jzelinskie	12.602483	-7.8703055	comment	3.0	10.0	1502156083	-11.166679
14954909	Having written Clojure full-time for	Having written Clojure full-time for the past 5 years while writing cleancoders.com has really spoiled me. Clojure's introspective nature makes for some amazingly fast productivity because you can hook up your IDE to the REPL and have a kind of super-REPL, which can really speed up development a ton if you design your system it right. I'm not sure if this project can keep that aspect because of how it compiles to C++. But if it does, then it could really be invaluable in the Clojure ecosystem.	penpapersw	12.656128	-7.89874	comment	3.0	17.0	1502172584	-11.224132
15006209	Clojure devs: 3.5 is the figure you 	Clojure devs: 3.5 is the figure you are looking for, and it does look very good, at first glance.	devrandomguy	12.653373	-7.9011497	comment	3.0	19.0	1502676479	-11.168769
15063545	No mention of Clojure? In the commen	No mention of Clojure? In the comments the author says that since it was a functional JVM language, he never considered it. OK.	JBiserkov	12.644337	-7.8945556	comment	3.0	19.0	1503312747	-11.171812
15063843	This article is very poorly thought 	"This article is very poorly thought out. First and foremost it talks about the __fall__ of JVM languages yet it forecasts good things for all of those languages.
The author also failed to check out things like the TIOBE index where Java is still at the top.
Not to mention that Clojure hasn't even been mentioned which is a __huge__ letdown since Clojure is the only pure functional language which is native to the JVM."	edem	12.602931	-7.8551807	comment	3.0	11.0	1503316308	-11.172957
15065544	Clojure supports class based OOP? Ne	Clojure supports class based OOP? Never heard of it. Could you give me a link to the relevant documentation page?	Nekorosu	12.575858	-7.8519053	comment	3.0	13.0	1503331757	-11.139862
15074722	I wonder, would it be better to have	I wonder, would it be better to have something like an LLVM frontend for Clojure, rather than another new Scheme? Or, would we still have a long startup time, regardless of the platform? I know Clojure's startup time isn't to be blamed on the JVM, but since Clojurescript does not suffer from that issue, I'm not really sure where the problem is.Looks like that's actually a work in progress: https://github.com/drmeister/clasp	devrandomguy	12.62829	-7.8633204	comment	3.0	15.0	1503423814	-11.163204
12564045	Can confirm. At work we're moving fr	Can confirm. At work we're moving from Clojure 8 to Java 8 partially because IntelliJ is amazing and partially because Java 8 plus the right libraries is close enough to Clojure anyway, except much faster.	sdegutis	12.650399	-7.8986144	comment	3.0	25.0	1474633905	-11.200642
12584726	This is addressing a question I'm in	"This is addressing a question I'm interested in, but on first read I'm struggling to see the value that's being presented here.- ""parameterize"" is great, but seems exactly the same as Clojure's ""binding"" on a dynamic variable. [Edit: modulo being ""sticky"" with regard to continuations... but Clojure doesn't have continuations, so it's a pretty subtle difference.]- Reader macros are an interesting feature, but do move away from the syntactic regularity of LISP -- and were, AFAIK, explicitly rejected in Clojure- Custodians are kind-of interesting -- but I ended up having to do some Googling [1] to find out exactly what they do...Is there anywhere else I should be looking for a more systematic Racket/Clojure comparison?[1] - https://docs.racket-lang.org/reference/eval-model.html#%28pa..."	dasmoth	12.6508255	-7.8833	comment	3.0	10.0	1474917178	-11.081092
12607300	You are referring to, for example: h	You are referring to, for example: http://clojure.org/reference/transientsCombining the two ideasTransient imperative logic in the core (5%), Functional mantle (90%), Side-effecting imperative crust (5%).	harryjo	12.588702	-7.8763156	comment	3.0	19.0	1475171495	-11.191476
12660300	I love Lisp and I'd use it for every	I love Lisp and I'd use it for everything if I could. But the Lisp community spends too much time talking about how awesome it is instead of making good frameworks that anyone can use, even kids just out of college. It doesn't matter how beautifully made your project is. New programmers make trends. If the framework can't be picked up and run without spending years in the Lisp community it won't take off.Look at Clojure. They offered the kids that started with Java something new but with a flair that was familiar. If you know Java, Clojure isn't too hard.	isaiahg	12.671671	-7.8684096	comment	3.0	17.0	1475845448	-10.895493
12660422	The reason why Lisp is not mainstrea	The reason why Lisp is not mainstream is its power. It makes writing DSLs extremely easy so that everyone can write his own DSL to solve a certain problem. Such style of writing however makes Lisp code unsuitable for group working, and hence unmaintainable. It explains (imho) why there are so many unmaintained Lisp projects.Clojure has a different problem. It is based on the JVM infrastructure which was (imho) an unfortunate decision. Access to Java features is nice but dealing with Java stack traces is not fun. Also the usual startup time of clojure apps in the range of seconds is not acceptable (Tcl/Tk apps start in a fraction of a second). AFAIK clojure is also not suitable for mobile app development. The clojure developers should have used their own VM, or they should have provided a C	progman	12.671698	-7.8763423	comment	3.0	10.0	1475846508	-11.013116
12677919	"> ""More powerful editors like Cider "	"> ""More powerful editors like Cider and Cursive manage to do this with some very complex machinery that I could never duplicate. Instead, I decided to rethink the problem. Since Nightlight runs inside the same process as your project, code completion and other advanced features are trivial to implement.""How? What makes it easier to implement code completion when the IDE is running inside your project's JVM? Clojure is still a dynamic language, which means you'll never fully know what vars make actual sense in a given context. For example what vars in the current context make sense as arguments to the function you're about to call, when you have no idea what the type signature of that function is (which may even be a variable). Unless, do you mean very simple context-less code completion? T"	sdegutis	12.642495	-7.8972087	comment	3.0	14.0	1476115711	-11.151182
12704846	Not a super fan of Clojure, but it's	Not a super fan of Clojure, but it's a good language. Shame it's still stuck in the Java ecosystem, though.	qwertyuiop924	12.646322	-7.8916707	comment	3.0	15.0	1476399420	-11.152596
12704829	Thankfully Rich Hickey & co wrote Cl	Thankfully Rich Hickey & co wrote Clojure so we can program on a modern Lisp in the Java Virtual Machine and in the browser! (ClojureScript) (even the .NET CLR is supported)[1] http://clojure.org[2] http://clojurescript.org	JBiserkov	12.641309	-7.8922353	comment	3.0	30.0	1476399279	-11.161498
12719543	And you can inline if-statements wit	"And you can inline if-statements with an IIFE when you need a little more space:    {(() => {
      if (cond1 && cond2)
        return <div>foo</div>
      else 
        ...
    })()}

Though it makes GitHub think it's a Clojure file."	danneu	12.607764	-7.8761024	comment	3.0	10.0	1476636848	-11.13882
12719403	I have quite some background in OOP 	"I have quite some background in OOP and switched to functional programming a few years ago, now working a lot with Clojure, where you actually have the ""code is data"" paradigm. And from my experience, it's way easier to model data with three simple structures; vectors (= arrays), maps and sets. There are other things, too, but most of the time these three types are sufficient. It requires some discipline in the beginning but it can give you a lot of benefits."	cygned	12.529005	-7.820541	comment	3.0	17.0	1476635529	-11.149558
12755090	Is this bad since it can't execute a	"Is this bad since it can't execute a simple command without a library?  Or is it good since the error message was so descriptive?If the consensus is ""bad"": I imagine at some point elm made the decision to make things highly modular (something which people usually like) and lazy (another thing people generally like), so why are those things a problem in this case?Update: Mostly what I'm observing here is that the tweet basically implies that the author(s) of elm should be ashamed of themselves for designing (free) software that is so obviously wrong.  Publicly shaming projects like this is dumb.  I'm not convinced it's ever accomplished anything other than kicking off big flame wars.  He should open or contribute to an issue ticket for the elm project.  Otherwise, he should just stop using "	davesque	13.007658	-7.692011	comment	3.0	10.0	1476989669	-12.750914
27501254	Code Observation: Clojure's Destruct	Code Observation: Clojure's Destructuring	semperos	12.6333	-7.90208	story	3.0	72.0	1623668916	-11.150998
27505536	"""It has a slow startup time. Clojure"	"""It has a slow startup time. Clojure runs on the JVM and has a significantly slower startup time compared to Node. Again, this is only a problem from an outsider’s perspective. We have REPL. You start the app only once, and it keeps running in the background. You can interactively include new changes, without having to startup every time.""I've been using Clojure for about 8 years and this is one of the talking points I find most annoying. The slow startup time is a disadvantage, and it should be owned. It disqualifies clojure from a large class of applications and if you're not honest about it you lose credibility, and you retard potential attempts to solve it. It doesn't mean you can't write software with Clojure, but be honest about the fact that it makes lots of types of usage (not all)"	jjwiseman	12.649202	-7.890285	comment	3.0	10.0	1623692357	-11.133635
27517081	Speaking of clojurescript and bad as	"Speaking of clojurescript and bad assumptions:Clojure and clojurescript are both dynamically typed, but clojure is strongly typed (type errors throw exceptions), and clojurescript is weakly typed (type errors are technically valid code). Too many clojure enthusiasts act like they're both the same language, but that is an absolutely massive difference.Try the following code out in each: (+ ""1"" 1). In clojure you get an exception, in clojurescript you get ""11"" (maybe a warning at compile time which won't show it's face at runtime when the data is fed to you from an API call).That bug silently corrupted analytics data for 3 months for a service I worked on. That alone was the reason I stopped using dynamically typed languages."	darksaints	12.624782	-7.8949547	comment	3.0	12.0	1623771742	-11.157777
27602845	It looks really cool (I love the fla	It looks really cool (I love the flat poly aesthetic), however some hopefully helpful feedback:- Framerate isn't wonderful (20 - 30 fps on my laptop, which will happily run graphically more intensive JS demos at 60fps usually), and I see you're using React: is using a relatively heavy framework the best way to go here? Possibly this is fine and the optimisation is required in other areas instead (e.g., are you creating loads of garbage?),- Car physics and handling is way off: clearly for this game realistic handling probably isn't the goal, but it's bad by the standards of more recent arcade racers (Burnout et al, Cel Damage for something that has a slightly similar aesthetic), or 1980s style 2D racers like OutRun (or more recently 80s/early 90s-esque racing games).It's certainly an intere	bartread	12.640264	-7.8808064	comment	3.0	12.0	1624443879	-11.172475
27650653	All Lisp-like languages incur signif	All Lisp-like languages incur significant complexity, but of these the simplest is probably some form of Scheme, definitely not Clojure. I think even Common Lisp may be simpler than Clojure.	bitwize	12.651327	-7.8857875	comment	3.0	11.0	1624793175	-11.061759
27685875	Data notation in Clojure	Data notation in Clojure	wernerkok	12.613621	-7.881243	story	3.0	111.0	1625037788	-11.139766
27699631	Cider (the clojure plugin for emacs)	Cider (the clojure plugin for emacs) has a variant that prompts you for the the values for those variables.	synthc	12.650106	-7.896319	comment	3.0	13.0	1625151261	-11.163093
27699819	Thanks for introducing me to `add-li	"Thanks for introducing me to `add-lib` This is going to be a huge time saver :)
More info here: https://insideclojure.org/2018/05/04/add-lib/Hopefully there will be some way to just ""reload"" your whole `deps.edn` though""If you get an error, the execution stops by default and you get a stack trace.""I'd say the other missing piece of REPL development is that while you get a stack trace, you don't get a program state like you do with GDB or ELisp. Maybe I'm ""holding it wrong"" but this causes a lot of friction and lost time. I'd be curious how others approach this. And that all being said, the CLI doesn't relaly offer a better alternative here.For entirely replacing the CLI I think that since Clojure is a general purpose language there ends up being a tad more boiler plate than you'd like.. It"	geokon	12.649453	-7.88844	comment	3.0	14.0	1625152077	-11.118284
27784467	The obvious answer why F# wins over 	The obvious answer why F# wins over Clojure in many people's books is static typing.	dimitrios1	12.534412	-7.8456116	comment	3.0	32.0	1625843409	-11.13175
27784907	I think that needs the qualifier 'ma	I think that needs the qualifier 'many (vocal) people's'. Dynamic languages continue to be exceedingly popular. The preference for static typing is I think over-represented in online discourse.I would be very surprised if the amount of Clojure/Clojurescript out there in production isn't several times larger than the amount of F#. Not trying to start a language war but with the exception of Jet which I don't think is around any more I can't recall a single large company using F#.	Barrin92	12.484879	-7.8214245	comment	3.0	13.0	1625845680	-11.111392
27820478	Go is open to forks and PRs though. 	Go is open to forks and PRs though. It’s more “we’ve got a vision, but we’ll hear you out”. Elm is full cathedral, Elm comes down from the gods with no input or transparency into the decision process.The Elm developers have a history of ostracizing people who even mention the possibility of forks from the community; tester89 posted a link with a lot of good context.They take a very heavy handed and adversarial stance to development. I had just started getting into Elm when the news of .19 basically breaking everything and the core team just brushing off peoples cries and it soured me on the entire language.When pre-v1 Go broke things, `go fix` was there to at least try and help.	donatj	13.009467	-7.690921	comment	3.0	15.0	1626181771	-12.772135
27822884	True that.We also ported our Elm cod	True that.We also ported our Elm codebase from 0.18 to 0.19. It took us almost a week working almost 24/7 across two timezones to make the damn thing compile again. Did not see the UI for the entire week, but once it compiled it (mostly) just worked like nothing had changed (that's after 429 files changed, 16422 insertions(+), 12116 deletions(-)).My colleague took notes of the progress at https://gist.github.com/mordrax/efcd34739ed56bb64d2b12d2401b...	girishso	13.0107565	-7.693471	comment	3.0	11.0	1626193385	-12.7592745
35399619	ClojureJavaScriptTypescriptOCamlHask	ClojureJavaScriptTypescriptOCamlHaskellF#	pharmakom	12.645604	-7.9010544	comment	3.0	15.0	1680351221	-11.221456
35497486	I want to be kind, but sometimes you	"I want to be kind, but sometimes you also have to be HONEST.Evan doesn't just hide from confrontation. He and his team bans everyone who are confrontational. Like me. They wouldn't even acknowledge that they banned me, which is just cowardly. No one I worked with who used Elm would go close to talking with their own account on the Elm reddit because they were sure they'd get banned.I argue hard because I was raised that way and I believe it's the best way to quickly find the truth. Like Steve Jobs said: strong opinions, loosely held. You argue hard, then when you are convinced by the other side, you flip with absolutely no time in between trying to ""save face""."	boxed	13.011315	-7.693674	comment	3.0	12.0	1680987013	-12.768874
22323960	ABCL exists and is easier to use jav	ABCL exists and is easier to use java libs from than Clojure	zelcon	12.650188	-7.895502	comment	3.0	11.0	1581654531	-11.154481
22381058	I tried out Clojure for a personal p	I tried out Clojure for a personal project about a year ago, just to see.The tooling situation definitely needs some work. Compared to the batteries-included setup of Cargo or NPM, it felt pretty slapdash. The fact that Leiningen is both the go-to and unofficial was a tad bewildering.Once I got set up, the development experience in VSCode was also quite underwhelming. I've never liked CLI editors and I didn't want to shell out for IntelliJ, so it was my best option, but it didn't offer much beyond indentation and inline eval (the latter was cool, but the lack of basics like autocomplete outweighed it).These factors obviously aren't as relevant at a company that already has a standard way of doing things, and maybe the situation has improved since I tried, but it really put a damper on the 	_bxg1	12.635053	-7.8942685	comment	3.0	14.0	1582261455	-11.117516
22381819	I studied Java at University and the	I studied Java at University and then worked with it for 15 years through various companies, finance mostly. I like the language but the opportunities and my use of it felt very stale in the end.I switched to Clojure a decade ago, around the time I started working with distributed systems. The best move I have ever made. I love working with Clojure and I find a large benefit in my understanding of the JVM.Recently I've built a front end (Clojurescript) and some lambda services (Clojurescript on Node) to complement my startup (Clojure, https://operatr.io - its a tool for Kafka). There's an advantage to using a single language/mindset through your entire stack.I spoke at the last Conj (https://www.youtube.com/watch?v=MnvtPzEH-d8) about my experience, broadly speaking my top reason for loving	d_t_w	12.648084	-7.891295	comment	3.0	28.0	1582275481	-11.161294
22381909	I am wondering how people deal with 	"I am wondering how people deal with complicated domain models, I have many objects that have a lot of properties (from 10 to 30), in Clojure I should represent them somehow, probably with maps, the problem is I would have to memorize all the keys... How this is approached in Clojure in a proper ""clojurian way"", that is without doing something like using Java classes?"	piokoch	12.6279745	-7.8866673	comment	3.0	11.0	1582276744	-11.164221
22396648	A language that young professionals 	A language that young professionals can use right away and can even support complex projects like kubernetes, Prometheus, consul etc. sounds like an excellent choice for companies to adopt. It might not be as elitist as rust or clojure but if collaboration is important for your project I'd rather have simple without foot guns rather then amazing with dragons all over.	gnur	12.533578	-7.845018	comment	3.0	21.0	1582463062	-11.126286
22415024	Just mentioning it for historical re	Just mentioning it for historical reasons (someone correct if this is wrong), Rich Hickey was enlightened by CL after doing lots of Java/C#/C++, after doing much CL he created Clojure.To answer your question, the JVM has wide acceptance in the industry and a big ecosystem of libraries, from a business and practical point of view, it seems the most adequate choice for a Lisp?	Scarbutt	12.66129	-7.8939466	comment	3.0	13.0	1582651233	-11.1429825
22460113	I tried Clojure but ended up hating 	I tried Clojure but ended up hating it for reasons all stemming from its hosted implementation. Whenever I didn't know how to do something, I (and most other Clojure users) would go use some JDK class (or worse, an external Java library) instead of figuring out how to write the Lisp.For some reason this doesn't often happen with regular Lisp even though CFFI is available. There's a tendency to just reimplement it directly in Lisp, which is the more maintainable option.	zelly	12.657476	-7.8820195	comment	3.0	10.0	1583104785	-11.091635
22460266	The situation with windows is weird.	The situation with windows is weird. You have to run a powershell script to install. They should just offer a Zip or Exe like every other programming language.https://github.com/clojure/tools.deps.alpha/wiki/clj-on-Wind...	svnpenn	12.658375	-7.902442	comment	3.0	11.0	1583106498	-11.166818
22460659	What got me started with Clojure was	What got me started with Clojure was a coworker at megacorp.  He's since moved on to a company that makes widespread use of Clojure in production.  Startup time was a huge factor for me because I wanted to write command line tools with it.The leaky abstractions were the other painful part – Clojure itself wasn't so bad, but Clojurescript (which would sidestep the startup issue) always seemed to leave me in callback hell.Ultimately rust (and go to some extent) seemed to fit my use cases better.If I had to do a web app from scratch I would think long and hard about going Clojure if only because it leverages such a widely used VM.  Points 1 & 2 weren't issues for me, but #3 was (and there are similar problems with Elixir).	inferiorhuman	12.649946	-7.8871875	comment	3.0	22.0	1583111115	-11.135806
22461693	Clojure would not gain widespread ad	Clojure would not gain widespread adoption even if all your points were fixed. The sad reality is that 99% of developers out there are instantly turned off by the parens and absence of while loops.	peferron	12.651859	-7.899392	comment	3.0	13.0	1583123677	-11.144823
22462139	You're aware that it's possible to w	You're aware that it's possible to write bad code in any language, even Clojure, right?	hota_mazi	12.61606	-7.893604	comment	3.0	24.0	1583130441	-11.161862
22462257	And poor tooling support on MS Windo	"And poor tooling support on MS Windows. Leiningen does not even have a proper installer on Windows, last time I checked.Having leiningen not bundled into the clojure distribution, is in strong contrast to the ""batteries included"" approach of python.There were also complexities in including local jars into projects, as it required setting up a local maven repository, which is tedious job.Also when exeptions occur clojure does not give an interactive repl like other lisps."	billfruit	12.650943	-7.8947244	comment	3.0	22.0	1583131932	4.392934
22463882	Does Clojure actually force you to u	Does Clojure actually force you to use those abstractions though? Many languages provide concurrency primitives, but Rust will fail to compile if you try to use non-concurrency safe objects from multiple threads.	nicoburns	12.56315	-7.8682632	comment	3.0	20.0	1583153199	-11.186747
22576497	I agree. I wish we could just use ED	"I agree. I wish we could just use EDN and Clojure,
but your DevOps guy is not writing Go or Clojure code.They are also not doing code reviews to enforce security policies.If you have DevOps guys who are also software developers, more power to you, but if I approach my DevOps team with:Hey just code your scripts in this turing-complete languages, they will ask me ""what's your username again?"" BOFH-style ;)"	beders	12.648087	-7.8963904	comment	3.0	10.0	1584203357	-11.214498
15127254	I don't know enough about Clojure, b	I don't know enough about Clojure, but I think you are saying that Clojure itself is using bit operations behind the hood - of course it's ok for a language implementation to use bit operations.But if any of your Java code for applications or libraries used bit operations, I'll call it bad code.	Illniyar	12.637704	-7.893834	comment	3.0	13.0	1504037703	-11.142236
15133673	A. Thanks for the response.B. Intere	A. Thanks for the response.B. Interesting. I saw a recent article on high-performance immutable data-structures[1], and wondered what the odds of Clojure implementing them might be. Sounds like you think the odds are minuscule.C. I've heard great things about your book, and it is on my reading list! Thanks for writing it.D. Given your hesitancy about the future of Clojure, what is your opinion of a more future-proof stack that has similar properties to Clojure (functional, simple, data-oriented, etc)? I can't think of many. ReasonML is interesting, but immature and definitely more complex than Clojure. Elixir seems to be promising, but I don't like the language, and I don't like being constrained to doing everything the BEAM way-- JVM is nice for high-perf computing when needed... Anyway, 	christophilus	12.629924	-7.88365	comment	3.0	10.0	1504111554	-11.177729
15137195	Why I'm ditching Clojure for JavaScr	Why I'm ditching Clojure for JavaScript	_diyu	12.650423	-7.884248	story	3.0	11.0	1504138499	-11.164874
15137816	I feel similarly about ClojureScript	I feel similarly about ClojureScript. It's a neat proof-of-concept, but I'm not really sure what it adds over regular JavaScript (or at least Babel + Webpack) these days.	_sdegutis	12.647555	-7.7605405	comment	3.0	16.0	1504147571	-11.08764
15191343	ClojureCUDA – CUDA programming in Cl	ClojureCUDA – CUDA programming in Clojure	prometheus666	12.634934	-7.89343	story	3.0	164.0	1504788709	7.9510407
15202777	Clojure is trying to do that with Cl	"Clojure is trying to do that with Clojure.spec and specifications being checked at runtime can get you closer to things you could have automatically proved correct only with languages with dependent types, nothing against statically typed languages but I feel that your sweeping generalizations hurt the point you are trying to make.""Checking at runtime* is exactly the problem. Why would checking at runtime be more reliable than compile time?"	scarface74	12.466101	-7.8394337	comment	3.0	12.0	1504895275	-11.141939
15219767	I don't honestly see anything out ri	I don't honestly see anything out right incorrect or difficult about the code you posted other than it's clojure. Mind expanding on that?	Royalaid	12.648205	-7.901005	comment	3.0	12.0	1505147544	-11.16633
15219705	Personally, Given teams writing in j	Personally, Given teams writing in java, python, go, or Clojure, I wouldn't join the Clojure team. It looks too painful...https://github.com/clojurebook/ClojureProgramming/blob/maste...	ronnier	12.656996	-7.9012303	comment	3.0	16.0	1505147216	-11.1613865
15267572	Let's get straight to the really imp	Let's get straight to the really important question, can J9 or AOT help maybe just a little with clojure startup time woes?	ledgerdev	12.634978	-7.8760247	comment	3.0	18.0	1505608406	-9.763102
15319811	https://canpicker.com/It's taking lo	https://canpicker.com/It's taking longer than a weekend though. My usual projects are more complicated and I wanted to do something brain dead and relatively instantly gratifying. Clojure + clojurescript(react based).	deadghost	12.657071	-7.884497	comment	3.0	10.0	1506175996	-11.154578
15384596	"The biggest issue with claims like """	"The biggest issue with claims like ""there are only diminishing results when using a type system better than the one provided in my blub language"" is that it assumes people keep writing the same style of code, regardless of the assurances a better type system gives you.""I don't see the benefit of typed languages if I keep writing code as if it was PHP/JavaScript/Go"" ... OF COURSE YOU DON'T!This is missing most of the benefits, because the main benefits of a better type system isn't realized by writing the same code, the benefits are realized by writing code that leverages the new possibilities.Another benefit of static typing is that it applies to other peoples' code and libraries, not only your own.Being able to look at the signatures and bring certain about what some function _can't_ do i"	simon_o	12.444766	-7.82201	comment	3.0	11.0	1506958478	-11.131121
15420337	 Well I can do runtime checks just a	 Well I can do runtime checks just as easily in Clojure, but I'm really talking about compile time checks.	hellofunk	12.582873	-7.874095	comment	3.0	11.0	1507322796	-11.134743
15426067	Maybe it has gotten better in the la	Maybe it has gotten better in the last year or so, but I’ve been extremely disappointed in a) the scope of semantics divergence between Clojure and clojurescript, and b) the performance of clojurescript for anything larger than toy examples. After reading a blog post about scalajs[0], I came away pretty convinced that battle would be uphill. It’s just too hard to replicate one dynamic language’s semantics in another dynamic language without embedding huge and slow runtimes along with it.[0] http://www.lihaoyi.com/post/FromfirstprinciplesWhyIbetonScal...	saosebastiao	12.637633	-7.8814673	comment	3.0	20.0	1507415900	-11.1611595
15426378	After reading the original article a	After reading the original article and Hickey's response, I'm significantly less sympathetic to Hickey.Here's the question: would Rock Hickey be Rich Hickey without Clojure? Would Cogitech exist without Clojure?I understand both sides. I know the frustration of living with someone's arbitrary decisions. I also know the frustration of getting nothing but attacks from something I have worked hard to give away.But Hickey has a higher standard here. He's gotten a lot more from the community than he admits in his response. It reads like he wants sympathy for all he has missed ot given away because of his work on Clojure. That's not a good response.	mcguire	12.6509285	-7.9078016	comment	3.0	10.0	1507421826	-11.169722
15425913	I've read the original article and, 	I've read the original article and, to be quite honest, couldn't actually determine what point it was trying to make. The action items seemed to have very little to do with the rest of the rant.I actually read the response first and the weird thing is: I couldn't really tell you what exactly the response is replying to. I feel like the whole thing is a huge amount of verbiage expressing frustration and broken motives but any actual solid facts mentioned are peripheral at best to what's being said.I could write multiple pages on how I fell out of love with Clojure but I doubt it would benefit anyone and it'd be a huge pain to do.Clojure is the product of a singular aesthetic, for better or worse.	moomin	12.659577	-7.907721	comment	3.0	24.0	1507413454	-11.166559
15466215	"> ""SPJ in an excellent series of tal"	"> ""SPJ in an excellent series of talks lists these advantages of types... the biggest thing left out of clojure...""> ""The biggest merit he says is in software maintenence, and i really disagree with just a lot of this.  it's not been my experience; the biggest errors are not caught by these type systems; you need extensive testing to do real-world effectiveness checking.""I think Rich is dead wrong on types not providing good tools for software _maintenance_.He is attempting to discredit types because they do not catch all errors, or the toughest errors; that's fine, I don't agree with people that would say types do that for you.I think dynamism is great for speed of development and flexibility; but my impression about trying to debug and maintain clojure code is that one has to spend time "	platz	12.5295	-7.8554296	comment	3.0	23.0	1507906372	-11.156299
15474580	Interesting that job postings for cl	Interesting that job postings for clojure are declining: https://www.indeed.com/jobtrends/q-clojure.htmlAnd clojure isn't even mentioned in zdnet's most popular programming languages: http://www.zdnet.com/article/which-programming-languages-are...	bshur	12.650872	-7.9008474	comment	3.0	15.0	1508018506	-11.163306
15478877	Slightly off-topic, but what's your 	Slightly off-topic, but what's your preferred stack for developing data-intensive applications that involve a lot of preprocessing, heavy statistics and machine learning plus a web front-end?Julia sounds quite appealing as a replacement for MATLAB or R with some Dylan-like semantics plus types and really efficient code generation on LLVM. I wish the Racket - Chez merger lead to something that targeted LLVM to be able to do front-end and back-end stuff using Scheme.A JVM-centric stack is one of my preferred alternatives. Clojure is great for data preprocessing and manipulation, plus ClojureScript for coding all front-end. Datomic, core.spec, core.logic, anglican, plumatic.plumbing just to name a few are a joy to use. Then there's Scala, which is also a great asset, and tons of fantastic Jav	nextos	12.648829	-7.8835177	comment	3.0	16.0	1508096351	-11.07582
15490249	Clojurecademy is now open source	Clojurecademy is now open source	ertucetin	12.654669	-7.896747	story	3.0	83.0	1508242270	-11.185228
15520717	A Guided Tour of Clojure Destructuri	A Guided Tour of Clojure Destructuring Bind in Emacs Lisp (2011)	pmoriarty	12.648312	-7.9017496	story	3.0	59.0	1508561288	3.7162871
15525529	What exactly do average devs struggl	What exactly do average devs struggle with?Who is making these decisions to rewrite?It would be great if we can see a before and after comparison.Clojure is a pretty simple language. Ive taught it to junior devs with only Java experience and they learn it within a few weeks without any major problems.	sheepmullet	12.658726	-7.9048567	comment	3.0	37.0	1508655438	-11.171435
15525566	Ten years ago (appoximately) I read 	Ten years ago (appoximately) I read an article about how PHP was dying, thanks in part to many new languages cropping up. But I see PHP mentioned all the time here on HN, and the PHP meetups in my area are frequent and popular, and major companies run on PHP.For decades, there have been rumors about the death of dynamic languages in general. And yet the decades pass and not only do those languages continue to flourish, but others come along and get popular too.Clojure just turned 10 years old and I see no signs of it slowing down. They did consolidate their 2 major conferences in the States into just one annual conference, so there's that (which may not mean anything). But I am in a large city and companies keep appearing and starting up with Clojure as their key language.With Clojure, it'	hellofunk	12.656362	-7.899566	comment	3.0	30.0	1508656305	-11.169111
15526230	PHP has a massive following. It was 	PHP has a massive following. It was basically the only language for the web 1-2 decades ago, everything had to be written in PHP. Of course, it cannot be extinguished since the existing sites will drag on forever.Clojure never had much usage on real world projects. It cannot be extinguishes as it never took of.	user5994461	12.647014	-7.8933063	comment	3.0	24.0	1508671219	-11.162874
15526840	Python dev here who chooses his own 	"Python dev here who chooses his own tools.  I want to move to Clojure, but Clojure and the JVM just aren't that strong in machine learning and ML is my current ""growth"" area.Even with JVM based solutions, such as Stanford CoreNLP Python has more support/interest than Clojure.I am not here to pump up Python and knock Clojure, just to illustrate there are areas that Clojure has a ton more wood to chop.  And I do understand there have been significant efforts made in this arena lately.  e.g.  Neanderthalhttp://neanderthal.uncomplicate.org/"	jgalt212	12.644034	-7.888402	comment	3.0	12.0	1508680550	-11.153489
15527058	I was productive in Scala far faster	I was productive in Scala far faster than I was when I learned Clojure. To be completely fair, I was newer at programming when I learned Clojure, and knowing Clojure definitely helped me learn Scala, so there’s something to be said for Clojure for sure.But if I had to take an average Java programmer and teach them a new language choosing between Clojure and Scala, I’d choose Scala hands down. The gap in semantics is so much closer, and concepts and libraries are so much more easily translatable. And it is entirely possible to be productive with Scala while knowing <50% of the language.	saosebastiao	12.521283	-7.825164	comment	3.0	10.0	1508683834	11.937852
15527406	Hi, I went on and searched for a ran	"Hi, I went on and searched for a random clojure project in github, and have chosen some function which is of a small size:(defn parse-seq [parse-el form]
  (when (sequential? form)
    (reduce #(if-let [parsed (parse-el %2)]
               (conj %1 parsed)
               (reduced nil))
            [] form)))without knowing really clojure i take it ""[parse-el form]"" are the arguments of this function.  How is it possible with minimal effort to know what am I supposed to pass as parse-el and form? what are they?https://github.com/tonsky/datascript/blob/master/src/datascr..."	tomerbd	12.632927	-7.8878846	comment	3.0	11.0	1508688199	-11.123243
15569002	> I sometimes wish I could tighten d	> I sometimes wish I could tighten down some Clojure code with static type guarantees. These are in small, remote portions of the code that have intricate algorithms. Static types would be very useful there. But that's the exception. In general, I like the flexible information model approach of Clojure better than the statically-typed approach of Haskell.I feel the opposite way. I find a dynamic approach useful in some places, but in most places I miss having static typing to help catch errors faster and give my IDE better auto-completions and make exploring new APIs faster without constantly needing to look things up. And rather than small intricate algorithms, I find the most important place for static typing to be when making big refactorings that span the whole codebase. I think my ide	m12k	12.480756	-7.837877	comment	3.0	17.0	1509116360	-11.138635
15574263	The two issues I have with Reason fo	The two issues I have with Reason for me are:1) It is not compatible with advanced optimizations in Google Closure's compilation process.2) I've been burned by less than ideal implementations of immutable data structures for functional programming in the past, particularly in Elm. I haven't done enough with Immutable-Re to know if it has similar issues, but all functional data structures are not created the same. I'm spoiled by ClojureScript's implementation which has never thrown a stack overflow error for me, unlike Elm. In Elm, if you have a list that gets too large, you have to manually break it up into different lists and do weird concatenation stuff that is quite clunky because somehow it's not doing structural sharing quite right to ensure these things are transparent under the hood	hellofunk	12.622993	-7.749044	comment	3.0	11.0	1509173809	-11.254166
15581272	4Clojure Easy Problems Updated on Cl	4Clojure Easy Problems Updated on Clojurecademy	ertucetin	12.650091	-7.9075956	story	3.0	81.0	1509309242	-11.1886835
15593845	I never said Clojure wasn't producti	I never said Clojure wasn't productive, i'm pointing out that it is too tied to the underlying platform.ClojureScript is an excellent replacement for Javascript, however code is not 100% compatible between Clojure and ClojureScript for the reasons cited in the paragraphs above (plus the limitations of Javascript).	flavio81	12.652528	-7.886443	comment	3.0	15.0	1509463145	-11.15547
15594344	> One tag that stands out is the fun	"> One tag that stands out is the functional language Clojure; almost nobody expresses dislike for it, but it’s still among the most rapidly shrinking (based on question visits, it only started shrinking in the last year or so)That's an interesting observation. Having learned Clojure this year without asking a single StackOverflow question, I don't think this means Clojure is shrinking. I suspect that Clojure's crazy good stability means no new questions are really required for core things.Also, Clojure tends to not be anyone's first language, if Clojure Conj is any indication. Most Clojure developers I've ever met have been programming for > 10 years. Experienced programmers don't tend to ask as many ""how do I do this in language X"" questions."	christophilus	12.65294	-7.902367	comment	3.0	10.0	1509466634	-11.177892
15594832	Right, but most of the statically ty	"Right, but most of the statically typed code in the world is written in C++, Java, etc. If you're presenting Clojure to your organization, the choice isn't going to be Clojure vs Haskell/Idris, it's going to be Clojure vs Java. The sort of boosters for static typing in this domain are the AbstractSingletonProxyFactoryBean people. I think defenders of static typing have at least some burden to defend ""actual existing type systems"" rather than immediately falling back to ""well, in Haskell..."""	james-mcelwain	12.517704	-7.854179	comment	3.0	15.0	1509470257	-11.130459
15595376	What makes you assume Haskell is som	"What makes you assume Haskell is somehow more niche than Clojure?
I would say it depends on the domain. Haskell is certainly more mature (~30 years) and has a lot more tutorials and literature."	willtim	12.484343	-7.8694634	comment	3.0	12.0	1509474409	10.474137
15597035	I found the discussion on /r/haskell	I found the discussion on /r/haskell to be much pleasant and a good take on the points Hickey make https://www.reddit.com/r/haskell/comments/792nl4/clojure_vs_... (it's actually a discussion on a piece discussing his talk).I honestly don't find Hickeys arguments to be very valid, and his take on type systems honestly make him sound like he never touched something like Haskell (maybe OCaml) with much more powerful type systems and type inference. He does not sound like someone that invented a language, and more sounds like a blind evangelist for dynamic typing.> static type systems yield much more heavily coupled systems. And that a big part of that time aspect of the final diagram of what problem we're trying to solve, is dominated by coupling when you're trying to do maintenance, right? F	Tehnix	12.361017	-7.820138	comment	3.0	22.0	1509487913	-11.086618
15601418	I really like this idea and I really	I really like this idea and I really like Clojure. Though I'm curious about performance. And do you know if anyone is doing something similar with Racket? (Looks like there is a Common Lisp shell http://www.cliki.net/CLISP-Shell)	encloser	12.620954	-7.8675528	comment	3.0	12.0	1509546586	13.618156
38021217	Ask HN: What's the state of Clojure'	Ask HN: What's the state of Clojure's ecosystem and community these days?	bgar	12.655049	-7.902462	story	3.0	12.0	1698289716	-11.177757
38152200	Eh, it doesn't seem like character a	"Eh, it doesn't seem like character assassination. Dude chose his management style. That makes his project unfit for purpose for certain people. Those people are allowed to make that determination and state as such.I remember when the Elm team first decided to lock down the Elm compiler, so that only the team in charge had special privileged access to modify it. I thought, ""wow, this looks like a bunch of people who don't want to collaborate, who want to take their ball and tell others how to play with it, really putting the 'dictator' in BDFL."" and you know what? that's fine. I don't harbor anything against them as people. But that left a permanently bad taste in my mouth and I'm unlikely to ever trust that group or a project they're managing."	jurynulifcation	13.008848	-7.6938243	comment	3.0	20.0	1699199650	-12.753226
38270754	> only 3 years, because they were ta	> only 3 years, because they were targeting an existing platform. Clojure took only 2 years and was d̶e̶v̶e̶l̶o̶p̶e̶d̶ ̶b̶y̶ targeting a single person.	fsckboy	12.654887	-7.908392	comment	3.0	16.0	1700001035	-11.212706
38284630	The first example is bad for reasons	"The first example is bad for reasons not related to ifs and fors.  In general, if you can, if you have a ""container"" for something, you should write functions on the contained, domain-level ""Thing"" rather than the container with the domain level thing.As an example I work with - Clojure.  Sometimes I use agents.  I don't write functions for agents, I write functions for things agents might contain.Similar rules for Elixir.  My primary domain level functions don't work off a PID.  They work off the underlying, domain-level data structures.  GenServer calls delegate to that where necessary.This makes them more flexible, and tends to keep a cleaner distinction between a core domain (frobnicate the Walrus) and broader application concerns (maybe the Walrus is there, maybe not... oh yeah, also "	bcrosby95	12.586081	-7.769099	comment	3.0	47.0	1700096353	12.892812
38399215	I experienced this a lot doing mains	I experienced this a lot doing mainstream programming, but when I switched to niche things (Clojure), I never experienced that anymore. Companies trusted me, gave me (and other engineers) autonomy. Maybe try to look into some niche thing? I was pretty burned out of programming before, but it definitely lit the candle once more.	askonomm	12.63312	-7.8542247	comment	3.0	10.0	1700784022	-11.096573
38501464	Personal recommendations are:* Elmo’	Personal recommendations are:* Elmo’s Song* Feist’s Sesame Street version of 1-2-3-4	vr46	13.013892	-7.6958194	comment	3.0	19.0	1701547048	-12.748856
38541332	Last time I spent a couple klines tr	Last time I spent a couple klines trying to write some clojure (+ clojurescript), the big thing was that most of the tooling had some really nasty error states. Python has some of this (ctrl+C out of most Python programs and get that stack trace with a bunch of inscrutible stuff), but given I was just starting out it was tough for me to move forwards.I do think the language + ecosystem has so many innovative and interesting ideas built in. Definitely worth at least reading the history of Clojure paper and internalizing most of the lessons.This is going to be anathema to everyone  but I think there's a nice little ecosystem space for a scripting language that is as serious about performance and code ergonomics as Clojure... but without the parens[0] (and I could do without the nil-punning, 	rtpg	12.649628	-7.8918405	comment	3.0	24.0	1701848129	-11.11375
38542088	I am not sure what a web framework i	"I am not sure what a web framework is, to be honest. The choices for many parts of a web application are really domain-specific and I'm not sure a single ""framework"" would work for everyone.As far as web-related components go, my app uses Rum (as an interface to React), ring, http-kit, pushy (for history manipulation), sente (for websockets), buddy (for authentication tools).If you are looking for a batteries-included ""I want to have some sort of webapp right away"" thing, I think https://kit-clj.github.io would fit the bill, but the general feeling in the Clojure community is that unlike Python with Django or Ruby with Rails, the choice of app components is not predetermined by the language."	jwr	12.651734	-7.834242	comment	3.0	24.0	1701856250	-11.173045
38542814	> The error messages are terrible. I	> The error messages are terrible. I have no apologetics for this. ;-)Could something be done about this? I tried to learn Clojure but I bumped into that fairly early on and gave up. Rust was way more approachable for me because good error messages form learning dialog between the learner and the language.	scotty79	12.6179905	-7.9164453	comment	3.0	16.0	1701864688	-11.162618
38548168	Being a Lisp dialect for the JVM Clo	"Being a Lisp dialect for the JVM Clojure has readability issues: https://tonsky.me/blog/readable-clojure/
That alone will make sure Clojure will always be a niche programming language and ensure job safety for the few ones who can read it. 
But nowadays Clojure brings no advantages anymore over Java. I wouldn't start any new project using Clojure."	amai	12.650712	-7.8923073	comment	3.0	16.0	1701889671	-11.153483
26853587	I'm glad to know that my condition s	I'm glad to know that my condition system book is of some really concrete use; an independent implementation of CL-style conditions and control flow in Clojure is probably the best example I can imagine for that.Congratulations, and thank you!	phoe-krk	12.600816	-7.878204	comment	3.0	26.0	1618761775	15.484689
26861485	The blog website isn't written in El	"The blog website isn't written in Elm. We're using Elm for the product application, not for the blog or for https://www.humio.com/.
I'll transfer the remarks though :)"	jfmengels1	13.009846	-7.692552	comment	3.0	12.0	1618831620	-12.748645
26866514	> It's not like it would stop workin	> It's not like it would stop working out of the blue.Unless the benevolent dictator pushes out a new Elm version that is not backward compatible.And, if the process is the same it was a few years ago, it could happen next month and only a happy few know it. The development is done behind closed doors.It happened to a project of mine, from version 0.17 to 0.18 IIRC. The choice was between letting the code slowly rot, rewriting a large part of it still in Elm but with the new paradigm, or switching to some stable JS framework. I had overall enjoyed working with Elm until that.	idoubtit	13.009947	-7.69153	comment	3.0	10.0	1618858060	-12.761357
27008273	I'm pretty excited by Clojure so thi	I'm pretty excited by Clojure so thinking of delving more into that, and then hoping it maps back onto Elisp, despite it lacking stuff like tail recursion. Would that make sense, or should I stick closer to the tree?Maybe CL is the best route to Elisp... If so, any recommendations on how one might learn CL in 2021?	nanna	12.659987	-7.897677	comment	3.0	11.0	1619891547	-11.028439
27015030	> The other thing for which OO works	> The other thing for which OO works much better than plain data is GUIsThis cannot be further from my experience. Switching from Java/AWT/Swing to ClojureScript/Reagent/Re-frame has been suoer liberating.Every GUI programmer must fiddle with reagent once:https://reagent-project.github.io/	divs1210	12.655132	-7.8889475	comment	3.0	18.0	1619961418	-11.177125
27060280	Nice article.Sadly a lot of people w	"Nice article.Sadly a lot of people won't even try clojure since it is dynamic typed. I see their point but nevertheless clojure does something really well here. As the author obserserves designing around some core data structures results in high code reuse. A library like spec is also way better in encoding business requirements than all the mainstream language typesystems e.g. a number in business context has mostly constraints like a particular range etc.
I really looking forward to see someone come up with a static type system inspired by clojure's approach."	lukashrb	12.494931	-7.8329134	comment	3.0	64.0	1620287523	-11.14428
27061889	> What is mutable by default in Cloj	> What is mutable by default in Clojure? Nothing.All data in Clojure inherits from java.lang.Object. I get what you’re saying, but in real life commercial projects, especially when you use libraries and Java classes, the code ends up with a lot of mutable things. You can never know if any function you call does mutate something without keeping all definitions in your head, and with 20+ people on the project, this is a challenge. Programmers of languages less sexy use frameworks to manage state and effects, but not in FP, which clojurians think they do.> Imperative? What is imperative by default in Clojure? Nothing.Please note that I’m not praising Common Lisp or Racket either - the same criticisms apply to them, except they ship with type systems. In Clojure IO is usually done by calling a	jeofken	12.602297	-7.8777776	comment	3.0	15.0	1620302163	-11.145029
27063013	The runtimes themselves may be great	The runtimes themselves may be great, but the tooling is bloated and uncomfortable.Every time I use Clojure, I am reminded how much I hate using Java. The error messages alone are enough to turn me away. So is having to set up a whole Leiningen project just to get started.A Clojure without Java would be very attractive to me.	thomastjeffery	12.649485	-7.8915324	comment	3.0	12.0	1620308314	-11.145591
27063942	I've used Clojure for going on 10 ye	"I've used Clojure for going on 10 years now and it has been one of the most enjoyable programming languages I've ever used. But I've gone back to Scheme for a few ridiculous reasons.1. TCO. Using `recur` in Clojure just breaks my thought process.
2. Difficulty in getting down to the metal when needed. Using JNI is painful. In Scheme, when needed, the FFI usually handles plain old C. Much easier in my opinion.
3. Community. Rich is a really smart guy and has made great contributions, but he doesn't suffer fools lightly and I am a fool. Great for a scientist, not so much for a ""benevelent dictator for life"" of a programming language.
4. Pragmatism over correctness. There was a long running conflict about some set operations that did not return correct results. To my mind, there is no argumen"	clartaq	12.64982	-7.8921175	comment	3.0	16.0	1620311937	-11.139344
27076021	Got a couple of questions - what's t	Got a couple of questions - what's that IDE like, and how's Racket compared to Clojure?I'm a newb to the paradigm, but fiding it useful to understand Javascript better.Thanks.	barrenko	12.68394	-7.853317	comment	3.0	10.0	1620396381	-11.067453
27092051	> I can't memorize all thousands of 	> I can't memorize all thousands of functions to manipulate lists and hashs in clojure (get-in, map-vals, conj, dissoc, select-keys, sorted-map-by, do you know what all those do?) which do a lot, I felt clojure was dense, the opposite of little cognitive loadIn fact you need to memorize 10-20 functions to be productive in Clojure. Many of them are common across the other FP languages and some FP libraries for imperative languages and most of them cover common patterns for  vector/map manipulation. Yes, the names could be confusing at first but there is good reasoning and logic behind them so it’s easy to learn.> because in fact I love how productive I am with ElmThis is interesting because according to Real World App benchmarks Elm implementation has ~4x more lines of code then Clojurescri	achikin	12.627444	-7.885037	comment	3.0	11.0	1620520065	-11.154748
27178848	Thanks a lot for responding.This is 	"Thanks a lot for responding.This is a pretty good example of feedback provided by language novices. You have almost no experience with the language, complained about an aspect of it (line count), and then said you wouldn't use it again, unless you would (as you defined in your closing parens).I'm not trying to diminish your feedback at all. You like what you like, don't what you don't like, etc. Nobody is forcing otherwise. It's just an interesting pattern that you can see with parallels in almost any language. Much like when novice Clojurists say ""I wouldn't use Clojure because of all the parens"" - there are things that, for most novice+ users, just kind of end up not mattering a ton. The things inexperienced users think are a big deal (in your example, line count) usually end up not bein"	void_mint	12.638789	-7.8885746	comment	3.0	11.0	1621212760	-11.123222
27279450	As Clojure programmer since Clojure 	As Clojure programmer since Clojure 1.1 I am so impressed with ClojureScript. I never had much use for ClojureScript but I always follow what going on. swannodette is the peak language maintenancer and helped push the initial idea further then I thought possible.I remember the original talk by Rick and so much work was left. Congrats to the team.P.S: Is there a real good ClojureScript library to work with maps and map data? Or a demo of how to do that kind of thing?	nickik	12.654547	-7.8625917	comment	3.0	13.0	1621962580	-11.158599
27285835	> Clojure doesn't provide built-in f	"> Clojure doesn't provide built-in function for exponential operationIt does actually:    (Math/pow 2 3)
    ;;=> 8"	didibus	12.624749	-7.891377	comment	3.0	21.0	1621999087	-11.148353
27385896	Ask HN: Have you had trouble recruit	Ask HN: Have you had trouble recruiting Clojure developers?	jonwalch	12.655814	-7.9004874	story	3.0	14.0	1622747043	-11.173319
27386106	I've found I typically reach for clo	I've found I typically reach for clojure when i need to do something on the jvm and want a better java than java.	cliftonk	12.634594	-7.880622	comment	3.0	22.0	1622748139	-11.17389
27386194	Interesting take since Clojure and J	Interesting take since Clojure and Java are two very different languages. And unlike for example Kotlin, Clojure does not try to be a better Java than Java. But true though Clojure leverages the power of the jvm.	lukashrb	12.63854	-7.887521	comment	3.0	11.0	1622748612	-11.163628
27388178	Seconded. I work in a clojure codeba	"Seconded. I work in a clojure codebase that were trying to get out of. There's just dead libraries everywhere and stuff that maintained by one person that gets no updates at all. That or we just end up making functional ""wrappers"" around Java libraries and at that point we might as well just write straight Java.Also yea everyone wants to be so damn smart having macros within macros within macros that no one knows what the original intent of the code is anymore.The repl based development I find also breeds a really bad mentality of forgoing building a deployment process and instead people just repl in and make a bunch of changes and prod rarely matches whats checked into github."	coneill	12.649441	-7.892906	comment	3.0	12.0	1622758852	-11.120952
33434363	Doesn't include Clojure in GitHub re	"Doesn't include Clojure in GitHub repo count.""Functional programming also requires that data be immutable"" 
Not true"	mmargerum	12.64519	-7.90035	comment	3.0	10.0	1667390750	-11.085345
33568188	The Vujic post describes repl-driven	"The Vujic post describes repl-driven development as ""[evaluating] variables, code-blocks, functions, or an entire module [to] get instant feedback, just by hitting a key combination in your favorite code editor.""Speaking from the perspective of long experience with Lisp and Smalltalk environments, I agree with fogus here: this is a misconcpetion--or at least an impoverished version of repl-driven development. The existence of a repl does not constitute the repl-driven programming that fogus is talking about, nor that I was talking about in the blog post he references.In its full form, repl-driven development means communicating directly with the live dynamic environment of your running program, which contains, in addition to the code you're developing, systematic support for inspecting, co"	mikelevins	12.609911	-7.830828	comment	3.0	10.0	1668209296	-10.991059
33577933	counterexamples: python ruby perl cl	counterexamples: python ruby perl clojure C C++	jes5199	12.640111	-7.885492	comment	3.0	10.0	1668293183	-11.150559
33601918	Clojure is more than just a Lisp for	Clojure is more than just a Lisp for the JVM – it is a Lisp for the JVM with a big focus on immutable data structures – whereas traditionally most Lisps put mutability first instead. There are other Java-based Lisps, such as Armed Bear Common Lisp (ABCL), which are more traditionally Lisp-like in this regard. I think Hy is more of a traditional Lisp, since it shares Python's native focus on mutable data rather than trying to foreground immutability.	skissane	12.650711	-7.8845143	comment	3.0	12.0	1668463528	-11.100409
33721730	Biff tutorial: build a chat app with	Biff tutorial: build a chat app with Clojure	jacobobryant	12.65653	-7.9000974	story	3.0	81.0	1669223124	-11.170683
33752260	One thing that's really underappreci	"One thing that's really underappreciated in my opinion is the ability to use the REPL as a general tool for interacting with the system. A lot of devops tasks can be done very conveniently from the REPL.For example, you can start a Babashka nREPL by running bb --nrepl-server and connect an Clojure editor to it. Then you can do a lot of fun stuff from there. For example, if you have osquery installed, then you can start querying your system for all kinds of stuff, get data back in EDN and manipulate it using standard Clojure functions:    (require '[clojure.java.shell :refer [sh]]
             '[cheshire.core :as json])

    (defn osquery [query]
      (let [{:keys [exit out err]} (sh ""osqueryi"" ""--json"" query)]
        (if (zero? exit)
          (json/decode out true)
          (throw (Exc"	yogthos	12.647106	-7.8925886	comment	3.0	14.0	1669467434	-11.207859
33761877	Babashka Clojure nREPL as a system i	Babashka Clojure nREPL as a system interface	Borkdude	12.649262	-7.901445	story	3.0	115.0	1669544558	-11.181093
33767865	You want to try temporal programming	You want to try temporal programming? Try clojure: immutable values, immutable & persistent data structures, software transactional memory.You need a data base with full history (transaction time), try datomic. Additionally if you need full history AND domain time (bi-temporal) included in your data base, try or xtdb.	muhaaa	12.590676	-7.845871	comment	3.0	10.0	1669589596	-11.149992
33829661	FWIW, I tried ClojureDart a little w	"FWIW, I tried ClojureDart a little while back, had a good time, but thought to myself, ""I'll be back when they have a REPL working."" At that time you guys were saying things in the Slack like, ""We already have a working prototype behind closed doors, it just needs polish. We'll be ready to release it soon."" It was very exciting.That was... six months ago. :) So... I guess I'll keep waiting."	cfiggers	12.653386	-7.898737	comment	3.0	13.0	1669984150	-11.201974
33850948	Interestingly enough clojure (probab	Interestingly enough clojure (probably the most widely-used lisp in the real world) uses “first” and “rest”.	umanwizard	12.646413	-7.88159	comment	3.0	14.0	1670132290	-10.9878645
33912783	The positivity in the comments here 	The positivity in the comments here makes me want to learn Clojure. Apparently it makes you happy.	__MatrixMan__	12.654428	-7.904308	comment	3.0	19.0	1670530855	-11.171632
33937487	I've had a look at threading/piping 	I've had a look at threading/piping operators in a few languages (list below). I'd say that Racket has the best one I've used. I love that you can specify a '_' for the hole which the result from the previous operation will fill. Julia's threading macro is surprisingly brittle, only letting you chain single-argument functions unless you want to use anonymous functions with one bound variable and the rest free.+ Haskell :: https://www.schoolofhaskell.com/user/Gabriel439/Pipes%20tuto...+ Racket :: https://docs.racket-lang.org/threading/index.html+ Clojure :: https://clojure.org/guides/threading_macros+ Julia :: https://syl1.gitbook.	joeman1000	12.507058	-7.8225684	comment	3.0	10.0	1670710568	13.60666
33962868	I preach about using the REPL non-st	I preach about using the REPL non-stop to my coworkers and we don't use Clojure. The problem with REPL-driven development is that you need to invest in your setup - so you have to believe it's worth it. Not even the Clojure REPL works out of the box: you need to make sure your definitions are reload-friendly, Emacs/Calva have to be connected for you to eval stuff with commands, use comment blocks as scratchpad, etc - it's a bunch of little conventions you need to buy into.That being said, the setup cost is paid pretty quickly. Developers underestimate how much time they waste reloading stuff into place. Updated a function - woops, have to clear the variables I setup and run intermediate steps all over again. Even if you think 'yeah but I just write tests and those run the whole flow' using	jrvarela56	12.6179905	-7.855675	comment	3.0	24.0	1670891895	-11.119761
33963301	Clojure has so much boilerplate to g	Clojure has so much boilerplate to get started though. It is a shame that it requires so many incantations when it makes fun of Java's verbosity.I have moved to Common Lisp and it is much simpler and saner, while having the same REPL driven development.	ilrwbwrkhv	12.640395	-7.882743	comment	3.0	10.0	1670894417	-11.115603
22809517	I find it the opposite. Lisp is much	I find it the opposite. Lisp is much easier to write than, say Go. I think the problem is if you're used to the complexity of writing a Spring Boot app (Java) this simplicity of writing in Clojure will confuse you: you think it can't be that simple when in fact it is.I used to freak out when I'd find the library in Clojure I wanted to use but it had no documentation. Eventually I just started looking at the implementation and I'd see it's like the entire library is 35 lines of code! Or like 102 lines of code! You don't need documentation for something that small.I've never seen this before in other languages. If you think it's too complicated, you might just be overthinking it.	nickbauman	12.626105	-7.858505	comment	3.0	13.0	1586313195	-11.032235
22810743	I have nothing against Clojure, but 	"I have nothing against Clojure, but I agree with Donald Knuth who said: ""Programs are meant to be read by humans and only incidentally for computers to execute."" [1].I could be wrong, but I don't find Clojure to be ""simple"" for humans to read (or write). Here is an example from the blog post:  So let’s write a simple one. Let’s write the factorial function.
  (defn fac [x] (if (= x 1) 1 (* x (fac (dec x)))))

Note the ""simple one"" here. I don't know for others, but this is not simple for me as a human to read, understand and reason about. For instance:  if (= x 1)

As a human, I read this like ""if equals x one"", which does not translate to my natural language where I would say ""if x equals one"". So I need an additional mental effort to do the translation. This is not the case in other lang"	benas	12.64821	-7.897285	comment	3.0	20.0	1586330475	-11.136029
22816917	> Their reasoning is along the lines	> Their reasoning is along the lines ofNow I'm sure that many feel like that, but I don't think it's the majority, but I also don't know.Here are some more arguments against types (don't necessarily agree with all of them myself, but for reference in the future when you want to write from the perspective of someone who feels more productive without types):- There are other, more flexible ways to solve the same problems you solve with typing, the clojure.spec way is one of them- You lose flexibility when suddenly everything is locked to each other by name. Even if Account and Person both has a first and last name fields, you can't use both of them if the function is expecting a Account and only use the first and last name. Then you need to add an interface, name it something, then make Acco	diggan	12.511612	-7.840365	comment	3.0	12.0	1586378843	-11.128189
17904791	I think it’s perfectly possible to h	I think it’s perfectly possible to have a career in Clojure in London. But, of course, I couldn’t advise anyone to move to the U.K. until the final state of Brexit is known.	moomin	12.662325	-7.893932	comment	3.0	12.0	1536007704	-11.155676
17946503	I really like and use Clojure profes	I really like and use Clojure professionally, but I have become wary of the extraordinary time I spend dealing with runtime issues because of the dynamic typing. I hope the future of core.typed is bright. I know it is being very seriously worked on. It can't come soon enough for me. Nowadays, I prefer to write in any statically typed language even if it is more line counts, just for my own sanity.	hellofunk	12.543045	-7.8524837	comment	3.0	16.0	1536509347	-11.149509
18005457	Rich Hickey on Datomic Ions [video]	Rich Hickey on Datomic Ions [video]	alpeware	12.709227	-7.866121	story	3.0	147.0	1537188961	-11.220161
19096432	This was an interesting tidbit as we	This was an interesting tidbit as well from another analysis [1]:This year’s survey also included a question about how long people had been programming professionally. 1 in 10 Clojure users have over 20+ years of developing experience; 49% had over 10+ years of experience. In comparison, only 42% of JVM developers have that much programming experience.Clojure having a higher than average percentage of experienced developers directly contributes to the quality of the language and the ecosystem around it.[1] https://jaxenter.com/clojure-2019-java-8-functional-155236.h...	yogthos	12.658056	-7.903422	comment	3.0	14.0	1549470080	-11.1768265
19096575	The repeated message from the author	The repeated message from the authors is that clojure.core docstrings are not gonna improve.If you think it's an easy problem to solve, please point out a single resource (library, website) which is 100% high-quality, comprehensive, up-to-date, IDE-integrated, and noncontroversial. Where is it? Why haven't we all adopted it?The facts are: we have good-enough docs, nREPL, a massive corpus of beginner material (books, videos) and real-time support from enthusiasts on Slack.If you ain't clojuring, it's because you don't want to!	vemv	12.651136	-7.9040084	comment	3.0	19.0	1549470855	-11.174277
19097464	Tempting to interpret this as the la	"Tempting to interpret this as the last major issue in Clojure use (error messages) being resolved with the introduction of spec. Consensus on concerns seem to be dissolving away from runtime issues to softer community management issues (""documentation"", which is very context specific, and ""startup time"" which is important but precisely not an issue while running Clojure).I do suspect that the survey is under-weighting how much beginners must struggle to navigate setting up CLASSPATH. If you don't come to Clojure from Java then the toolchain is a bit intimidating with whatever a Maven is, followed by a process of trying to follow what both Java and Clojure tools are doing. This is one area Clojure compares very poorly with, eg, C (similarly awful setup process, but usually all the burden is"	roenxi	12.653436	-7.901495	comment	3.0	22.0	1549474694	4.304408
19098269	The trend of programming languages i	The trend of programming languages is to move toward static typing. Not as an afterthought, with gradual typing or retrofitted years later into an unwilling compiler, but languages designed from day one with static typing, parametric polymorphism, and type inference.Clojure's life time was limited from day one because it's simply going against the trend.	hota_mazi	12.498851	-7.8385987	comment	3.0	36.0	1549478784	-11.142318
19098531	I would dearly love to use Clojure m	I would dearly love to use Clojure more professionally but the problem in every country I've worked has always been the talent pool; I struggle to hire because Clojure devs are comparatively much harder to find. Clojure is a wonderful language and I was firmly on the hype-train back in 2011 or so but I'm not convinced it has much of a future outside its current niche. I would be very happy to be proven wrong though!I had a similar epiphany to you in that coming from a Python background, Clojure radically changed how I thought about and approached problems. Rich Hickey's work is fantastic and I'm very happy to have spent time in that particular corner of the tech world.	0xADEADBEE	12.654975	-7.901459	comment	3.0	11.0	1549480008	-11.173428
19099375	Just a clarification, Clojure copyri	Just a clarification, Clojure copyrights etc are owned by Rich Hickey, not Cognitect. Cognitect pays for all of the core development team salary, infrastructure, etc.docstrings - we apply many docstring fixes in every release.NIH - are we literally never supposed to try to make anything new? Doesn't this non-argument apply to literally the creation of every language, library, and tool? This is silly. clj has different (quite clear) goals than Lein or Boot and both doesn't do things they do (like builds) and does things they do not (like git deps).We have been accepting PRs for docs on the site for 3 years. Who cares how long it took before we started doing that if we're doing it now? Wouldn't it be more productive to praise for what you like than crap on how someone used to do something yo	puredanger	12.6592	-7.9034157	comment	3.0	12.0	1549484144	-11.215575
19099998	I'm glad you're still earning income	"I'm glad you're still earning income from it.  It was my favorite of the JVM alt-languages, but it just seemed to have died around 2015 with all the others.I say ""died"" but I know that people still write in Scala and Groovy, but how many new projects are you seeing in those languages?At one point I set out to find work doing Clojure, but not much turned up in my locale.  I did one professional project at a former company and only got the green light for using Clojure because it was basically a throw-away in a couple years when a new business process was coming in anyways.Good luck to you, but it's not a niche I would want to be in.  You have to mold yourself to the market, not the other way around (usually)."	ataturk	12.657556	-7.894945	comment	3.0	11.0	1549487515	-11.131657
19247814	It’s also worth noting that almost n	It’s also worth noting that almost nobody uses agents or STM (except for some highly specific use cases, but I’ve never seen them in years), and core.async is a library, not a part of Clojure (which is a good thing, because it promotes choice and keeps the language small).	stingraycharles	12.621961	-7.884614	comment	3.0	17.0	1551118120	-11.182318
15778969	Honest question: is immutability com	Honest question: is immutability complicated in Clojure because it's hard, or because it's running in a virtual machine with no meaningful support for it?The Erlang VM has immutability deeply baked in, and it just works(™).	macintux	12.438888	-7.753995	comment	3.0	15.0	1511659619	-11.106052
15832689	And if you don't mind the learning c	And if you don't mind the learning curve (which will make you a better thinker!), I would addElixir - PhoenixI wish there was a complete Clojure - ???	blunte	12.65608	-7.8980565	comment	3.0	10.0	1512233106	-11.206321
15881890	Leiningen has been incredibly painle	"Leiningen has been incredibly painless:    $ brew install leiningen
    $ lein repl

That's literally all it took."	_sdegutis	12.63592	-7.8722253	comment	3.0	17.0	1512765965	4.3241467
15881893	Associative data structures (maps / 	Associative data structures (maps / dicts) are super first-class in Clojure, in a way that they aren't in other Lisp-1's (at least from what I remember of dabbling in Racket).  There's a literal syntax for them.  Keywords are functions that you can call with a map as an argument.  You can destructure them in `let` bindings.  And so on.In my opinion, this turns out to be a pretty major win.  Code is still data, it's just that this data is a mix of lists, vectors, and maps, and now you can type associative data structures into your code as easily as you can lists.  Hash tables in vanilla Common Lisp are a nightmare (there is a nice library that at least gives a Clojure-y initialization option via Reader macro), and a glance at the Racket documentation suggests the story there is probably not	neutronicus	12.545584	-7.8241973	comment	3.0	12.0	1512765968	-11.093696
15882327	Because lein is bloated, breaks cons	Because lein is bloated, breaks constantly, and is absolutely overkill if all you want is a REPL and some deps from Maven.	cljuser	12.637049	-7.8464203	comment	3.0	12.0	1512769498	12.862012
15881873	Well, for the first time since the l	Well, for the first time since the langauge was created you can now do `brew install clojure`, and then `clj` on the commandline and get a repl. I would have loved something that painless when I was learning Clojure.	_halgari	12.6541605	-7.903656	comment	3.0	21.0	1512765836	-11.181873
15882115	>Can anyone sell me on why I should 	>Can anyone sell me on why I should use clojure over say, any of the other nice Lisp-1s, given that I don't care about java.It's the same question I make myself, since after learning Clojure here I am, still using Common Lisp happily ever after.Well, if you think that data should be immutable by default,if you really need readymade syntax sugar for hash table and the likes,if you don't have any need for object oriented programming, not even once a year, and if you particularly don't feel any appeal for what is by far the most advanced OOP system out there (CLOS),if you love the Java ecosystem and need to be reminded of the J2SE libraries by using them directly all the time to do things other languages have built inside their own stdlib (but Clojure does not),if you don't feel wrong knowing	flavio81	12.644557	-7.8875914	comment	3.0	15.0	1512767854	-11.122966
15882183	If you need to force yourself, or if	If you need to force yourself, or if you need extra special motivation to use Clojure .. most likely you will never use itYou might spend sometime learning it out of curiosity, but you will never use itThe languages I used, are ones I had to use, either because they were the only option, or clearly the best option for my solution (C#, VB.Net, Powershell, SQL)Clojure will never be your only option, and .. it being the best option is highly subjectiveI tried to like Clojure, because of all the blogs and talks, and the reputation of it being a smart language for smart people (I obviously, wanted to belong to this group, and still do) .. but for my work, and use cases (Business Intelligence), it will never be the best option, or the only optionThe same list that include Clojure, for me also in	systems	12.6383915	-7.8967395	comment	3.0	13.0	1512768377	-11.151835
15919872	> Prepare for 1.0 next releaseSo thi	> Prepare for 1.0 next releaseSo this will soon be a stable API?  Great work.  The documentation is extensive.I am personally a big fan of toolz[0], which is clojure inspired.  This object method chaining Scala inspired approach is different, and interesting.It might be fun to make sort of comparison matrix of the difference in approach between this library, toolz, and the venerable fn[1] which also has a Scala influence (and apparently already implements the '_' lambda form).[0] http://toolz.readthedocs.io/en/latest/[1] https://github.com/kachayev/fn.py	merlincorey	12.36378	-7.735226	comment	3.0	22.0	1513224414	11.931649
15976006	Look to clojure if you want a lisp o	Look to clojure if you want a lisp on Android	dmead	12.65801	-7.8862863	comment	3.0	14.0	1513824621	-11.07667
15978609	Devcards aims to provide a visual RE	Devcards aims to provide a visual REPL experience for ClojureScript	tosh	12.656332	-7.889274	story	3.0	59.0	1513863318	-11.176056
15982422	JVM is slow as heck to start, but an	JVM is slow as heck to start, but an awesome runtim. In an ideal world I'll never have to restart my application or my repl, but in the real world I do it all the time. It's much faster than node.js/V8 when executing heavy tasks.One reason I might be interested in running clojurescript on node.js is because most web technologies nowadays are written for node.js/javascript first and ported as an afterthought. GraphQL servers on Clojure/Java, for example, are like 3rd class citizens compared to node.js. Google provides nice wrappers to their APIs as long as you're not using clojure. I end up writing things in-house a lot more often than I would with node where I just npm install the package I want and I get something that is maintained by the official author.	krisdol	12.604531	-7.767664	comment	3.0	12.0	1513887599	-11.158632
16867497	I saw David adding commands that Win	I saw David adding commands that Windows users need in the docs. Personally I don't like treating Windows users like how I treated Linux/macOS users. You chose Windows, you chose the hard way, you have to figure it out on you own.Post your question to http://clojureverse.org/ see if others can help.	jiyinyiyong	12.654756	-7.8992057	comment	3.0	20.0	1524060540	-11.156217
16867657	I haven't found a place that explain	I haven't found a place that explains the big picture and how everything fits together. Is there a good resource to learn clojurescript for someone who's never done web programming and without having to learn JS?I'm learning Clojure now (coming from years of C++) and I love it. There is a bit of black magic (lein/cider make cmake look like a shell script) but CJS is a bit daunting b/c it has so many layers. CJS on Lumo on React on JS on the DOM ... I don't actually know what any of those words mean :P	geokon	12.664681	-7.886077	comment	3.0	17.0	1524061811	-11.1649
17050336	The size of your code is the number 	The size of your code is the number one predictor of bugs. The more code you have, the more bugs you probably have. Smaller code bases have less bugs. Verbosity means more code.This is why very terse dynamic languages like Clojure often have relatively low bug counts despite a lack of static checks.Some interesting reading on this topic:https://cacm.acm.org/magazines/2017/10/221326-a-large-scale-...	jb1991	12.554769	-7.8065815	comment	3.0	10.0	1526068073	-11.052263
17144315	I'm reminded of the Hacker News post	I'm reminded of the Hacker News post that introduced me to React from David Nolen back in 2013, where he first introduced ClojureScript's take on React, Om:http://swannodette.github.io/2013/12/17/the-future-of-javasc...Interested to take this for a spin.	davedx	12.68644	-7.7026224	comment	3.0	11.0	1527172321	-11.173849
17144866	How's Clojurescript interop story? w	How's Clojurescript interop story? what always holds me from using these compile to JS langs is the fear that the gains you get from using a better/nicer language are completely destroyed by all the interop churn.	Scarbutt	12.648975	-7.8729486	comment	3.0	13.0	1527175359	-11.160038
21091658	I thought I wouldn't live to see the	I thought I wouldn't live to see the day for Clojure related link to be the top link on HN. I had to reload 5 times.Clojure's cool, I am glad I got to work with it professionally. I did go back to Javascript, but it made me a better developer. It strikes a nice balance between being a pure functional language and being practical.	TickMark	12.653867	-7.891199	comment	3.0	60.0	1569590674	-11.17497
21091924	External factors. Clojure didn't off	External factors. Clojure didn't offer a great variety of jobs, especially remote. There was a decent number of jobs for onsite positions, but that's the trade I wasn't willing to make.The language itself is great. The ecosystem is fine, you can find most libraries and if you can't you can at time use the JAVA versions. This was at times a pain because Java client libraries for certain services were out of date.Solving real-life business problems was tricky but ultimately fun and satisfying. As the resulting code is usually very elegant and succinct.I really loved the interactive programming aspect of it. It was really easy to go from a repl experiment to the actual implementation.	TickMark	12.656498	-7.898438	comment	3.0	13.0	1569592125	-11.171371
21153964	Honestly this is the area I'm most e	"Honestly this is the area I'm most excited about.  SRS is just one facet---correct choice of input media, datatypes, and mental models are a big deal here.I'm a math undergrad.  And one thing that drives me crazy is how mich rewriting I do.  What I want is a semi-tangible expression tree that I can manipulate and ""snapshot"" (to show my work) into Latex.  The Latex rendering was easy, but figuring out what ""core tree manipulation ux actions"" are is another thing.Similarly--am I the only one tired of typing?  I'd kill for a gait analyzer or a haptic glove that let me program while walking through the park.Some of this stuff sounds farfetched, but looking at emacs, or chorded stenotype machines, or paredit, really drives it home that we could be doing so, so much better, with very little new "	invalidOrTaken	12.564767	-7.7676764	comment	3.0	12.0	1570151562	-11.071966
22836586	One of the things I never understood	"One of the things I never understood about the hype around these Clojure GPU libraries is that there is a lot of marketing jumbo about how high-level it all is. Even the book for these libraries has the words ""no C++!"" half a dozen times on its ordering page [0].However, these are just high-level libraries and you cannot write the GPU shaders in Clojure. You still must use C or C++ for that (depending on if you are going the CL or Cuda route), and your C/C++ code is embedded or called from the Clojure side. This is no different than using another high-level language like Python -- I mean it's focusing on a rather misleading and irrelevant detail. You can use Clojure or Python (or many other languages) to call OpenCL or Cuda shaders, or you can just use the libraries that call them for you."	hellofunk	12.646682	-7.90661	comment	3.0	16.0	1586547520	7.862127
22842653	The dig at JS developers is complete	The dig at JS developers is completely uncalled-for.I'm a JS developer and I admire the way Clojure has seemed to skip both the hype and disillusionment phases and jump straight to the productivity plateau.	_bxg1	12.653659	-7.8942184	comment	3.0	14.0	1586624342	-11.146754
22852395	"Hasura [https://hasura.io]
Graphql A"	"Hasura [https://hasura.io]
Graphql API and Subscription for any Postgres DBKeycloak [https://www.keycloak.org]
OpenID Auth ServernREPL + Cider [https://github.com/clojure-emacs/cider]
Clojure's Network Repl and Emacs integration for live coding ClojureCompany Mode [https://company-mode.github.io]
Emacs autocomplete mode"	shivekkhurana	12.671562	-7.8576064	comment	3.0	15.0	1586742570	-11.215078
22914659	Go with clojure, it's by far the mos	"Go with clojure, it's by far the most mind altering Lisp because of it's extremely nice immutable datatypes.Common lisp by comparison, feels arcane, outdated and non lispy.
You have to learn non composable macro syntaxes, and it's often way too low level and concerned about memory and imperative code and OOP.Scheme is nice in terms of self contained purity, but then again not as nice to use and not as mind altering as clojure.Clojure is basically a lisp build around immutable datastructures, common lisp is a lisp build around metaprogramming, and scheme is a lisp build around lambdas."	j-pb	12.628849	-7.8684874	comment	3.0	38.0	1587289091	-11.065569
22915475	The origins of lisp are that of a ma	The origins of lisp are that of a mathematical tool. Clojure is much closer to math with its referential transparency, immutable datatypes, deep proper object equality, and data first philosophy, than common lisp with its systems programming, lisp machine, need for speed approach.	j-pb	12.660894	-7.886842	comment	3.0	20.0	1587299583	-11.07795
22976078	I've been really thinking about usin	I've been really thinking about using a functional language that complies to JS to start to learn more FP concepts and paradigms. I'm trying to decide if ClojureScript or ReasonML is better for me. Anyone have experience with both?	rhlsthrm	12.5872345	-7.77371	comment	3.0	14.0	1587795518	-11.098392
22976567	To the entire ClojureScript team: th	"To the entire ClojureScript team: thank you so much for all the great work that you are putting into ClojureScript!Without ClojureScript and Clojure, I would not have been able to build and maintain my SaaS app as a solo founder. The incidental complexity would have crushed me. Using a single language to write code, with model (domain) code effortlessly and fluidly shared or moved between ""server-side"" and ""client-side"" is a game-changer.While I don't care that much about NPM, I am extremely happy with the progress that ClojureScript is making. Thank you!"	jwr	12.654176	-7.8802104	comment	3.0	25.0	1587802518	-11.164679
22977007	I like reading these kind of stories	I like reading these kind of stories.I'm trying to learn more about Clojure / CLJS for web development specifically, but there are so many different tools to pick from and as a beginner it can be hard to know where to start.And then I'm also reading about Phoenix (Elixir) and how that's better for web dev.If you don't mind - can you tell a bit more about your Clojure story, when you started using it and your setup?Or maybe you have a blog, where you wrote about this already?I'm not an experienced programmer, hence the naive questions.	uxcolumbo	12.658054	-7.898115	comment	3.0	18.0	1587808746	-11.1872835
22977209	I'm building my startup in phoenix.F	I'm building my startup in phoenix.First of all I wanna say that Clojure is a fantastic language and if the dials on my particular needs were different, I would have gone with Clojure and am considering clojurescript for a subproject paired with an elixir backend.When I started the project, realtime over WebSockets were a huge consideration. Additionally, we weren't doing anything revolutionary from a computer science perspective. Phoenix came in with a clear story for all the work I wanted to accomplish.There were well accepted and documented libraries for doing authentication and a really nice library for accessing the database.The language has few gotchas and is relatively easy to learn. I have no doubt I could take a good js or python developer and have them be proficient within 2-3 we	cultofmetatron	12.615693	-7.8165565	comment	3.0	11.0	1587811858	-11.160773
23048195	The major question is how Janet comp	The major question is how Janet compares with clojurescript.  A quick look it seems at least it is easier to setup. Anyone know how Janet cf with clojurescript.	ngcc_hk	12.638849	-7.866565	comment	3.0	10.0	1588382096	-11.102517
23056858	There is a good talk here, a series 	"There is a good talk here, a series of talks. Clojure and Rich and the thinking of the entire Cognitect team (Fogus included, of course) have been so influential- intellectually- and many of its and his and their tenets have become mainstream, even dogma. That being concerned about ""immutability"" is a practice these days is at least partly due to Rich. Can you imagine programming without immutability?But a big part of Clojure's story has not just been in the ideas, but also in the details of the design and implementation. From the performance guarantees of the persistent data structure implementation, to the idioms around parameter ordering, both of which I was appreciating yet again earlier today- aside from the ideas, there are ergonomics that only make themselves known through use, like"	jonahbenton	12.539916	-7.8337502	comment	3.0	21.0	1588480015	-11.135171
23058892	I have been long enough on HN to hav	I have been long enough on HN to have seen that pattern with CoffeeScript, Clojure, Scala, Ruby, Go, Elixir,....Now excuse me while I get back to selling shovels.	pjmlp	12.559186	-7.8189135	comment	3.0	16.0	1588512972	-11.15264
23077751	Looks really nice, I'll be sure to t	Looks really nice, I'll be sure to try it out!For people interested in this, there's also a recent project https://github.com/overtone/overtone which looks similar, using Clojure though (which seems to deem itself better to live programming).	cube2222	12.656554	-7.9041247	comment	3.0	11.0	1588666978	-11.189675
23165690	1 - Download a JVM and make it avail	1 - Download a JVM and make it available on the PATH2 - Dowload clojure.jar3 - Start command.com or PowerShell4 - cd into clojure installation directory5 - java -jar clojure.jar	pjmlp	12.654005	-7.8960533	comment	3.0	16.0	1589368501	-11.172731
23166144	On the VM front, I love the JVM, but	On the VM front, I love the JVM, but a vast majority of languages gaining popularity are generating static binaries. GraalVM may help close the gap here.OO is overrated but most apps have some state and I found the entity-component systems solid but not still unwieldy.Clojure has really great concurrency primitives; all the semantics I could want built right in. Except my concurrency often occurs in the persistence layer, and unless I'm also writing that layer, Clojure can't help me. Persistent/immutable data structures are amazing.The delimiters IMO are a vast improvement over most other lisps (especially for creating specific data types).Clojure's startup time is pretty brutal for a lot of things I'd like to use it for, and no amount of REPL-driven development can make Clojure appropriat	blandflakes	12.627159	-7.877026	comment	3.0	12.0	1589372761	-11.145715
23234060	I delived a service in 2019 that was	I delived a service in 2019 that was written 100% written in clojure. ReactNative app + SPA Web app + Server all sharing the same code.The developer experience was great. I get subsecond hot-reload on all plataforms (app emulator/app on-device/web/server).The same UI components was shared between ReactNative and ReactDOM. All App issues are reproducible in Web, then I fix in web and I'm sure that App is working.Even SSR was possible, with some tweaks.	souenzzo	12.685319	-7.7889752	comment	3.0	12.0	1589891182	-11.184134
28039511	Now you have Clojure which runs on t	Now you have Clojure which runs on the JVM and interops nicely	dimitar	12.6432	-7.8913302	comment	3.0	12.0	1627924405	-11.179117
28041219	Not who you are responding to, but t	Not who you are responding to, but the common idea that static types are all win and no cost has become very popular these days, but isn't true, it's just that the benefits of static typing are immediately apparent and obvious, but their costs are more diffuse and less obvious. I thought this was a pretty good write up on the subject that gets at a few of the benefits https://lispcast.com/clojure-and-types/Just to name some of the costs of static types briefly:* they are very blunt -- they will forbid many perfectly valid programs just on the basis that you haven't fit your program into the type system's view of how to encode invariants. So in a static typing language you are always to greater or lesser extent modifying your code away from how you could have naturally expressed the functio	uDontKnowMe	12.484783	-7.8380365	comment	3.0	16.0	1627931136	-11.14599
28058433	> if you haven't coded in a language	> if you haven't coded in a language like OCaml, Haskell, ML etcSame argument could be made the other way, if you haven't used Smalltalk, Clojure (and other languages that are strongly dynamic), you shouldn't discount them.	capableweb	12.544225	-7.832208	comment	3.0	48.0	1628063685	9.294471
28109128	When I started focusing on Scheme as	When I started focusing on Scheme as an elegant Lisp for a rapid R&D platform (Web, AI, programming languages, etc.) ~20 years ago, Kawa was one of the implementations on which I tested my libraries.I'd been using Java previously for research prototypes, Java was getting popular, and Kawa's property of running on the JVM seemed potentially practically very useful or critical, and I wanted it in my pocket.I ended up moving primarily to PLT Scheme (aka Racket), but I would (and still do) always tell people about keeping some of the special Scheme implementations as backups.  Kawa for JVM, Gambit for large numbers of threads and other properties, Chicken for its C compilation approach and significant community.I think the JVM aspect was one of the keys to Clojure achieving more popularity tha	neilv	12.671357	-7.8518596	comment	3.0	16.0	1628448712	-10.904297
28223802	Speaking as someone who liked Elm fo	"Speaking as someone who liked Elm for a while, then abandoned it, I will say that the biggest problem with the language is absolutely its leadership. Development moves at an absolutely glacial pace and basically takes place with no transparency at all. I would argue that it's more like a ""source available"" project than an ""open source"" one since the core dev team is so exclusionary. Most planning takes place inside Evan's head, leaving others to just speculate as to what's going to happen to the language.On top of this, the community is run like a dictatorship. Dissent is silenced and banned, and faux positivity is spread far and wide. I got sick of it and was banned from the Elm subreddit after I expressed my frustration. That's pretty much when I gave up on the language, years ago,  on v"	superdisk	13.009293	-7.693678	comment	3.0	22.0	1629305131	-12.761416
28255638	It's dead easy to get started. If yo	"It's dead easy to get started. If you want to spend an hour playing with a ""lisp"" you're only a small download away. Clojure could learn a thing of two from this..It's also not dogmatic. You can use mutable and immutable versions of the same data structure.Docs are concise: https://janet-lang.org/docs/index.htmlFull API is here: https://janet-lang.org/api/index.html[edit] I fully agree that ""getting started"" on Clojure is easier than used to be. Anyway I still think there is room for improvement."	galfarragem	12.653339	-7.895637	comment	3.0	16.0	1629539489	-11.139794
28399009	Did you leverage the repl much in yo	Did you leverage the repl much in your process?I hear a lot about “repl-driven” development with Clojure and CL, but anytime I get experimental with it I find myself neck-deep in editor configuration, or simply wrestling with emacs keybindings.	garren	12.632933	-7.8757286	comment	3.0	16.0	1630628090	-11.119052
28405210	I have long had the ambition to be t	I have long had the ambition to be the N:th guy to try Clojure on C++. For similar reasons. I have a pretty good idea how to do it, already got HAMT and some macroexpanded code to work. But then you remember how even ClojureCLR struggled at times, and that you'd be lightyears behind that, not to speak of CLJ/CLJS, and alone. Maybe one day? :)	vnorilo	12.653244	-7.898162	comment	3.0	33.0	1630681732	-11.160313
28467150	Ahh you mean Elm, by any chance?I fe	"Ahh you mean Elm, by any chance?I feel Elm's growth has been stunted because the creator is actively hostile with whoever disagrees with him. I remember the infamous ""leaving elm"" post which was handled so poorly by Elm's author.If they had handled it well, elm would have definitely seen a large uptick in adoption"	rk06	13.016805	-7.697231	comment	3.0	12.0	1631171676	-12.768574
28577928	My hack to improve at a new programm	"My hack to improve at a new programming language is to read its grammar. We instinctively try to learn programming languages the same way as we would a natural language, bottom up. But unlike natural languages, programming languages have complete grammars that can be read in a session. This will prime you with the right questions to ask (""WTF is an XYZ?"").Doesn't work for Clojure though :)"	zarzavat	12.653841	-7.8966002	comment	3.0	10.0	1631987056	-11.122459
28579164	I learned that using the collection 	"I learned that using the collection functions on strings in Clojure is much less performant... But it doesn’t have to be my PR. It can be anybody’s.""This reveals a fundamental problem in coding. Best practices for performant code shouldn't require ad hoc digging into PR's, and as long as it does then we'll have code that is buggy & slow(er than necessary).Learning from others, in any field, will always be a valuable source of improvement, but it just doesn't seem that, in software dev, it results in laying down solid incremental increases in general knowledge that makes its way back into the education of future devs or current devs in a language new to them:If this was structural engineering, you'd have to have taken a ""materials"" course and learn all about different types of materials, th"	ineedasername	12.636898	-7.8912783	comment	3.0	12.0	1631998057	-11.142772
28586667	1 -I just do some Clojure programmin	1 -I just do some Clojure programming, and I'm not deep into JVM things - but why does Android not even make a mention? Isn't it the most widely used JVM platform..?2 -> This does come with some restrictions and caveats; for example, it's not as straightforward to use Reflection in your Java code.Is GraalVM going to push Reflections out of Java/JVM?I guess my angle is I'd like to use the JVM to make (desktop) apps. Last I did, using cljfx/JavaFX reflections were a huge sore point. Ever dependency would drag in the whole kitchen sink - and reflections are an ugly wart that prevent unused classes/namespaces from being pruned.I know technically there is Proguard.. but it's clunky and ugly I've never gotten it to work with Clojure. Graal native looked like a sort of light at the end of the tun	geokon	12.593738	-7.8127694	comment	3.0	13.0	1632076051	-11.168164
28604878	The article makes the interesting cl	"The article makes the interesting claim that Clojure,  Elixir and similar languages are good for ""glue"" but doesn't make any effort to develop the argument.For a long-time we've heard the opinion that complex systems are best written in a combination of a ""systems"" language (say C++ or Java) and a ""scripting"" language (say Tcl, Lua or Clojure.)  That's how video games are written,  for instance.Clojure and Elixir have the particular angle of being suitable for concurrency,  which more conventional scripting languages (e.g. Python, Ruby, PHP, ...) fall down at thanks to the various global interpreter locks."	PaulHoule	12.648839	-7.885881	comment	3.0	15.0	1632231283	-11.145901
28654787	If you like Janet, you'd probably li	If you like Janet, you'd probably like Clojure a lot as well.If you want to take on web apps, backend services, machine learning and data-science, desktop GUI applications, mobile applications  and/or distributed computing use cases, it could be a good choice where Janet lacks the chops, but Clojure offer a very similar feel while enabling those use cases.For scripting, CLI, and embedding with a C interface, Janet rocks.	didibus	12.631022	-7.8547745	comment	3.0	21.0	1632591142	-11.066286
27865654	I recently found there was a clojure	"I recently found there was a clojure implementation for .NET and also one for the BEAM Virtual Machine. Has anyone used the latter? Regards[1] https://github.com/clojure/clojure-clr
[2] https://github.com/clojerl/clojerl"	Aboh33	12.653812	-7.8893805	comment	3.0	10.0	1626528803	-11.146507
27878518	I remember running into nil a lot wh	"I remember running into nil a lot when trying to use Clojure. My immediate sensibility was very ""yuck"". It allows for nice chaining of APIs but it seems to really just mess up the notion of optionality so much that I'm curious about how often it's a bug generator.I understand that the sort of spaghetti-code from constant nil checking would be painful, but I can also imagine a lot of hidden bugs when it comes to dealing with things like user-provided data. Would love to hear the experience from Lispers who also have experience with ""null""-y issues in other languages."	rtpg	12.40883	-7.811998	comment	3.0	18.0	1626660236	-11.12507
27878726	I've got professional experience wit	"I've got professional experience with null in Java, C#, and C++, as well as Clojure. From my experience ""nil"" in Clojure is the least ""issue creating"" of the bunch.Generally when ""nil"" is an issue in Clojure, it's actually from the Java side, where Java doesn't ""do the right thing"" for ""nil"" and just throws a ""null pointer exception"" instead.In Clojure it's mostly a problem when it hides that you just aren't getting something because of a bug, as opposed to because it truly isn't there.The most common one for me being map lookups:    (get m :fooo)
    ;> nil

Now everything after will ""work"", because everything handles ""nil"" input and generally does ""the right thing"", like treat it as false, or returns nil if given nil, or treats it as identity, etc. But you actually just messed up the key"	didibus	12.410835	-7.83544	comment	3.0	13.0	1626662457	-11.10653
27899437	What pain points are those?  Last I 	What pain points are those?  Last I checked, doing cljs on Clojure Tools wasn't even possible.  If that's still the case, then that's not a valid comparison (complex vs impossible).Also, that's the master version of project.clj, which is a superset of all possible features lein supports.  Nobody's project.clj file looks like that, though I suspect you know this.  Should we compare that complexity to a monster build.clj and this master deps.edn:https://github.com/seancorfield/dot-clojure/blob/master/deps...Lein is also a singular tool vs. a murky interaction between a suite of tools (tools.deps with deps.edn, Clojure CLI, and tools.build).	bm3719	12.643959	-7.900992	comment	3.0	13.0	1626815692	-10.989771
27900169	After using it with Datomic Cloud, d	After using it with Datomic Cloud, do you prefer it also for local projects?  Is there something that happened with Datomic Cloud configuration that made it “click” for you elsewhere?  Did you just have to use it there and that experience informed your preferences?Data > functions > macros is a core concept of Clojure.  Does that come into play here?These are prompts from a curious outsider’s perspective.	filoeleven	12.672971	-7.8786764	comment	3.0	17.0	1626820347	-11.242524
12103381	Whenever I get back into Clojure and	Whenever I get back into Clojure and use type hinting, I usually forget that Clojure doesn't allow ints, only longs. Kind of a strange choice given the JVM supports signed variants of the common word lengths. But then I read articles like this.I'm a pretty high-level language user (read: I don't do C, et al), so when I read stuff like this it always makes me cringe and be happy Hickey decided to keep it simple. 64 bits, everywhere! (God save us when things go to 128)	gleenn	12.563621	-7.8434978	comment	3.0	22.0	1468612144	-11.142429
12113585	Clojure has a pattern matching libra	Clojure has a pattern matching library https://github.com/clojure/core.match. And I think clojure is the most widely used Lisp dialect now.	youjiuzhifeng	12.578106	-7.796871	comment	3.0	10.0	1468825530	-11.0917425
12158371	I am a fan of clojure.  I'm interest	I am a fan of clojure.  I'm interested in LFE, but I've been focussing on learning Haskell lately, and don't want to switch gears yet.The big thing that I miss in clojure are the data structures, and the ease of use of those data structures.  Specifically vectors and maps.  These exist all over the place, but no where (in my experience) are they as pain-free as clojure.That combined with their immutability (yet easy to transform) is a really significant win for productivity.As I've looked for other languages to learn, those sorts of easy to use and highly productive datastructures has been a top criteria.Haskell has them, but I wouldn't put them on the easy to use list yet.  However I'm still learning, and it might just come down to familiarity.Chicken Scheme has them as an egg, but the sy	DigitalJack	12.617557	-7.87015	comment	3.0	14.0	1469452115	-11.157715
12230980	Braced myself before reading this, b	Braced myself before reading this, but what a pleasant surprise!> infinite number of closing parenthesesNowadays, you can express it with finite parentheses using -> macros popularized by Clojure.	calibraxis	12.600889	-7.842795	comment	3.0	10.0	1470389405	-10.964863
12231553	I like Clojure because it's a Lisp 1	"I like Clojure because it's a Lisp 1 and the novelty of having MVCC implemented in my language.With respect to the Lisp 1/2 debate, I hate how this:    (defun foo (g y)
        (g y))
    (foo #'- 10) ; error

Is an error in Common Lisp. Instead, you have to:    (defun foo (g y)
        (funcall g y))
    (foo #'- 10) ; works

That's just so inelegant IMO. Scheme does the ""right"" thing and lets you do:    (define (foo g y) (g y))
    (foo - 10) ; works

but lacks a de facto build tool and package management system. (I also really like Scheme's macro system, but not everyone agrees). Clojure solves the build tool and package management system, does the ""right"" thing with higher order functions, and offers seamless Java(Script) interop, which is why it has enjoyed more ""mainstream"" success t"	madmax96	12.647094	-7.876064	comment	3.0	15.0	1470398431	-11.044856
12364567	Why use this over Clojure if I'm int	Why use this over Clojure if I'm into Java?	edem	12.639738	-7.89761	comment	3.0	22.0	1472192477	-11.1824665
12425532	I founded and help maintain a very l	I founded and help maintain a very large Clojure codebase and to be honest, I am sick to death of not having a real type system to help me.Sure, we can test the crap out of our code watching for npe's. We can lint like crazy. We can write large integration tests to better understand the larger picture better. But ultimately nothing is as pervasive as the compiler relentlessly asking you to be clear.What's more, the benefits of a language like OCaml (where Tagged unions, GADTs, direct modeling of errors via an Either composition, etc. rule the day) on your code leads you to a really good place when the codebase is sufficiently large.Giving up s-expressions and monads is indeed a sad thing. I'd miss it.	KirinDave	12.544926	-7.8647623	comment	3.0	16.0	1473009904	-11.1473875
12471303	As a clojure fan, I agree about cons	As a clojure fan, I agree about conses.  It's rare to use something like that.Personally I'm happy equality doesn't work like common lisp.  See here for a post explaining equality in CL: http://eli.thegreenplace.net/2004/08/08/equality-in-lispIt's old and I don't use common lisp, so please correct me or the post if needed.I've tried to get into lisp numerous times.  Clojure was the one that clicked for me.  I can't say if that's because of clojure or because it was just the right time for me after N times trying to get lisp.Every now and then I poke at a scheme or CL.  Scheme seems do-able for me, particularly Chicken Scheme, but I everytime I try CL, I come across what seems like too many functions to do what it seems like one function should do.  Whenever I see something like SETQ, etc.,	DigitalJack	12.65313	-7.8892627	comment	3.0	14.0	1473549045	-11.110188
12490443	Move fast and don't break things. Ru	Move fast and don't break things. Running a startup on Elm	note89	13.014189	-7.693751	story	3.0	10.0	1473787841	-0.2407648
12500727	If you just want to get shit done, C	If you just want to get shit done, Clojure is fine (though any other Lisp would arguably be better than Clojure).If you want to get shit done, and make sure the types are correct, and make sure all side effects are properly managed and accounted for, that's Haskell's niche.	bitwize	12.550724	-7.8597965	comment	3.0	27.0	1473883240	-11.133464
12501066	Not the GP, but for quick things I p	Not the GP, but for quick things I prefer CL because:* TIMTOWTDI. Doing everything  with map/reduce/filter is great, but sometimes it's more direct to just use the LOOP macro. Immutability is great, but sometimes it's way faster to just SETF something (and not have to worry about atoms).* Batteries (more) included. IME, I find myself needing to use third-party libraries sooner with Clojure than with CL. Also, QuickLisp is arguably faster to get rolling with than Leiningen (I've found it easier to get the new library into my existing lisp image). And CL tends to have clusters of functions that do similar-but-different things, whereas Clojure puts the cognitive burden on you to do things right (example off the top of my head: CL has REMOVE, REMOVE-IF, and REMOVE-IF-NOT, Clojure has ????? (li	tsm	12.657112	-7.8949594	comment	3.0	13.0	1473886018	-11.082998
12514299	I've recently joined a team writing 	I've recently joined a team writing primarily in Clojure, whose proponents often tout repl-driven programming as a unique benefit to the language.In a statically typed language (the stronger the better), aided by a good IDE, I don't need to be constantly executing my code against data during development; My editor is constantly validating my code, and when it stops complaining, my code will work. And months later when I or someone else uses that code in another part of the system, they won't need to execute that code to see how it behaves, as the types themselves provide documentation and as-you-code feedback.	kbanman	12.600628	-7.8754077	comment	3.0	19.0	1474036824	-11.124648
12908395	I don't think the response was as si	"I don't think the response was as simple as ""No, you can't have that because I don't want to"". Reading the discussion about removal of this feature on Github there seems to be a few more points made that the author alludes to: 
https://github.com/elm-lang/elm-compiler/issues/985Also, It's worth noting that Elm does have a BDFL. Evan makes the call and, as I'm sure a lot of python folks would agree, that setup means that the language is going to remain consistent, clean and well defined. This might be frustrating, but is part of keeping a strong design philosophy that directs the language. In that context, is it really a valid criticism?Evan actually addresses this issue directly by talking about the different communities with different aims. He says that having these different communities "	benjaminjosephw	13.008135	-7.692172	comment	3.0	11.0	1478683019	-12.761438
12919083	The startup time is of course very l	"The startup time is of course very low, so that's good.I think you're underselling the tool for beginners like myself - it's not just a ClojureScript REPL, it's actually an executable which can run node.js scripts written in 
clojurescript.For example, here's the typical node http server example:
https://gist.github.com/anonymous/c14b2b57184c650d9f3ff0a9e1...You can run it with lumo test.cljs"	delegate	12.654165	-7.883612	comment	3.0	15.0	1478771743	-11.174838
12919123	That's not true. One of the main obj	That's not true. One of the main objectives of Clojure was to be a hosted language. Not just 'language hosted on JVM'. So idea to make it work on top of Erlang VM is perfectly valid and consistent with original design assumptions.	aaimnr	12.638605	-7.8666086	comment	3.0	11.0	1478772392	-3.041742
13007992	That's because your code assumes tho	"That's because your code assumes those convenience functions exist while the parent's code writes out the anonymous functions.The direct translation of yours' to Clojure would be:    (filter valid-person? (map init-person names))

Meanwhile, the direct Haskell translation of the parent comment is:    filter (\p -> isValid p) (map (\n -> Person n) names)"	Scriptor	12.586366	-7.872986	comment	3.0	12.0	1479754267	-11.04179
13026011	I wish they would stop making change	I wish they would stop making changes just for the shake of change. E.g. Up until 0.17 most code examples where using the prime ' character.With 0.18, Evan decided that using prime is bad taste, so he decided to break any code that uses it.Sure, it is not a big change, but it means they are not respecting user's time and it is a sign of things to come.Sorry for the rant.Edit: I hope my reply doesn't get misunderstood. I love Elm and use it in all my side projects. I think it made wonders for introducing new people to the ML world.Edit2: Sorry, didn't meant to make so much fuss about it. It is indeed a small thing.	kinkdr	13.013004	-7.701245	comment	3.0	31.0	1479937371	-12.736813
13066920	Show HN: js.spec, a JavaScript imple	Show HN: js.spec, a JavaScript implementation of clojure.spec	prayerslayer	12.653273	-7.900831	story	3.0	96.0	1480460274	-11.188347
13110650	Rich Hickey: Books that influenced C	Rich Hickey: Books that influenced Clojure, in no particular order	tosh	12.653816	-7.9083595	story	3.0	42.0	1480978756	-11.165887
13116732	It makes a completely self-hosted Cl	It makes a completely self-hosted ClojureScript compiler possible.	yegortimoshenko	12.652353	-7.894646	comment	3.0	12.0	1481047264	-11.16448
13117897	"So ""Closure"" is a real comp sci word"	"So ""Closure"" is a real comp sci word used to describe variable scope lifetimes in languages includes JavaScript and others. So when google named their project, they basically took a word from JavaScript/CompSci that starts with the same letter as ""Compiler"" (plus other similar sounds). I don't think there's much more to it than that.""Clojure"" is a programming language again based on the regular word ""closure"" but with some twists: The ""j"" is a tip of the hat to Java and the JVM where clojure is designed to run. This also has the nice property that the ""zh"" sound of the ""s"" in closure is also used with ""j"" sometimes (I think due to French). Thirdly I believe the ""CL"" letters of clojure are a tip to Common Lisp.I'm not familiar with ""Clozure CL"" but the history is here: http://ccl.clozure.co"	focusaurus	12.653162	-7.8925066	comment	3.0	12.0	1481055374	-11.134985
13152250	I'm a designer and not a coder, so I	"I'm a designer and not a coder, so I feel obliged to provide my comments with salt added up front.That being said, JSX vs. wrapping HTML in if-statements seems like the same kind of trouble to me. I've done a few simple prototypes in Clojure/Script, so my reasoning is heavily influenced by the fact that I know very little about other languages, and only have moderate amount of knowledge about Clojure.The solution I've encountered in Clojure is to represent the entire page as a data structure. Conditionals and transformations are applied directly to this data structure, which is then sent as-is into the rendering pipeline (which commonly seems to be React). The HTML is never really written by hand, it's just a final ""coat of paint"" on top of the data.To me, this seems far easier to wrap my "	fnordsensei	12.656378	-7.8432555	comment	3.0	16.0	1481480066	-11.184363
13152373	Can you tell me what clojure librari	Can you tell me what clojure libraries/frameworks work the way you describe? I'm learning clojure and would like to build some toy web apps because I've never done webdev before.	mark_edward	12.6514	-7.886068	comment	3.0	11.0	1481481362	-11.158829
13183556	Transducers and Spec are two great e	Transducers and Spec are two great examples of what Clojure's community is best at. There's a practicality of purpose and single mindedness of philosophy at play in the language's evolution here. Making simple easy.To my mind though, Clojure brought clarity to the JVM on issues of concurrency, state, mutability, object orientation and persistence and for that I will always love it.	grabcocque	12.651254	-7.8942657	comment	3.0	16.0	1481796218	-11.155773
13183661	Clojure may be revolutionary, but th	Clojure may be revolutionary, but the fact that it can't be compiled to run on other runtime systems (e.g. Go) is a bit of a disappointment.	amelius	12.649851	-7.9057975	comment	3.0	27.0	1481798152	-11.168585
13199716	Could you explain what you think is 	Could you explain what you think is wrong with Clojure? Maybe it's because I've spent far more time using it than CL, but I see Clojure as having a very consistent, well designed core. It's very opinionated in it's design, but it's a practical and pragmatic one. I don't see what's unlispish about it.	anoctopus	12.643737	-7.895543	comment	3.0	15.0	1481958929	-11.154386
13201658	>> - much simpler languageGiven that	>> - much simpler languageGiven that it all compiles down to JS before execution, I'm not sure I agree. With Java, you're going to bytecode operations which (imo) allows for a simpler language than compiled to.>> - core.async channels/ no callback hell, easier to read async codeI agree, callback hell sucks. I'm not sure that core.async is a huge win over promises, but this is an area that JS is quite horrible.>>  - persistent data structures>> - great sequence abstractionI'm not sure I see the benefits of clj's sequence abstraction over js. You get destructuring and sequence comprehension in es6, although clj's recur/callstack fix is quite nice.>> - live code reloading - vibrant community - improved tooling -I'm pretty sure all of these are better in JS than CLJs.>> macros - transitMacros 	drawnwren	12.640804	-7.869844	comment	3.0	11.0	1481998077	-11.109415
13201934	...Can't the Clojure people just imp	...Can't the Clojure people just implement a native code compiler for mobile stuff? I mean, come on, CL/Scheme have been doing that for years, and they weren't constrained by the JVM, forcing a more optimized design.	qwertyuiop924	12.646447	-7.8776865	comment	3.0	16.0	1482001834	-11.174716
13216160	How mature is the Clojure library fo	How mature is the Clojure library for Unity being shown here?	throwaway7645	12.657128	-7.900819	comment	3.0	10.0	1482192184	-11.141407
13283413	TCO is possible in JVM but not in Ja	TCO is possible in JVM but not in Java. Clojure is just Java library and share all Java problems like TCO, Class sizes or inline limits.I no longer believe in transpiration or hosted languages. Proper language have LLVM backend. Look at Rust, Swift, Crystal, this is future.	Chyzwar	12.6166525	-7.878239	comment	3.0	19.0	1483089337	-11.151416
13283213	Just to add a bit of context, this a	Just to add a bit of context, this article was written more than six years ago: http://thecleancoder.blogspot.fr/2010/08/why-clojure.html	hotBacteria	12.647899	-7.904899	comment	3.0	10.0	1483085376	-11.155857
13284555	I always use something like clj-stac	I always use something like clj-stacktrace[1] to pretty print error messages and I've never had any issues figuring out what the problem was.Most of the time you're working from the REPL inside your editor anyways so the iteration loop is much, much better than any other language's. Even without clj-stacktrace I'd still prefer Clojure development to anything else.Rebooting a program and losing state is always worse than error messages taking a bit longer to understand at first.[1]: https://github.com/mmcgrana/clj-stacktrace	jeremiep	12.644543	-7.8988957	comment	3.0	13.0	1483108905	-11.1908045
13284654	We had a majority of codebase in clo	We had a majority of codebase in clojure back in 2011, but we found that that presented us with major roadblocks hiring new team members. Even some experienced people had hard time getting into and learning curve was non-trivial. So we dropped it. Prbly not a good idea to build a big company with not so popular prog language [1].1. http://www.tiobe.com/tiobe-index/	dominotw	12.659257	-7.902493	comment	3.0	23.0	1483110111	-11.131417
13284689	My team has been using Clojure for t	My team has been using Clojure for the past 6 years, and we have the opposite experience. Most new developers we've hired haven't used Clojure before, but they were able to become productive doing useful work within weeks. The fact that we're using Clojure tends to be a positive factor for attracting candidates as well. A number of candidates we've interviewed mentioned that Clojure was the reason they applied for the job. They heard about the language and they were interested in trying to work with it professionally. In addition, we hired contractors and co-op students to work with our team, and they were able to pickup Clojure as well.At this point I would actually use Clojure as a filter. I'm rather suspicious of any developer who wouldn't be able to learn Clojure.	yogthos	12.658005	-7.8994656	comment	3.0	12.0	1483110655	-11.188371
13340579	I'm not sure I believe what you're s	I'm not sure I believe what you're saying is true. I'm a full time Clojure dev and let me tell you, if I give a damn about performance I avoid a lot of the cool parts of the language.And it gets even more severe with Scala.As Ruby should demonstrate, languages succeed because the community wants them. Not because they have specific performance characteristics.	KirinDave	12.60157	-7.870866	comment	3.0	12.0	1483739441	11.91857
13341207	This was a good book.  It would have	This was a good book.  It would have been better if he had a more critical perspective of the language.  As much as I love Rich Hickey and Clojure, the language does have pitfalls and rough edges, and this book was a little too starry-eyed to tackle them head-on like Crockford's book on JavaScript.	jstewartmobile	12.655287	-7.8984017	comment	3.0	12.0	1483744623	-11.195402
13349041	> as long as you put the right type 	> as long as you put the right type hints everywhere.I'm a novice Clojure programmer and haven't previously heard of this. Can you please elaborate?	krat0sprakhar	12.616279	-7.8861957	comment	3.0	11.0	1483867983	-11.156062
13368253	i hate the output of elm-format, tho	i hate the output of elm-format, though :( it's very wasteful of vertical space.	zem	13.010178	-7.6948185	comment	3.0	12.0	1484077571	-12.764164
13378274	If they had any marketing sense, the	If they had any marketing sense, they would start by telling me why it's better than Clojure.  I'm sorry to offend the Scala guys, but if you want to be the best JVM language, you need to improve on Clojure.	blunte	12.58293	-7.84451	comment	3.0	29.0	1484175777	11.896881
13378495	We are talking about the JVM.  And a	We are talking about the JVM.  And as such, the existing competitors are Java, Scala, and Clojure.  Scala had promise, but many significant users discovered warts on large projects.  And on top of that, Lisp is not only sexy (rationally or irrationally), but Clojure has a lot of intellectual momentum.  Further, we have Clojurescript for nodejs.  It is the one to beat.So if someone is going to sell me on a better JVM language, they need to at least give me a pro/con list vs Clojure.  While HN might disagree, the market (people who work in companies that live for revenue, not VC) will agree in my interest for that comparison.	blunte	12.622597	-7.850698	comment	3.0	13.0	1484177662	-11.091422
13422391	First I've heard of Red. Does it imp	First I've heard of Red. Does it implement 'readable' [1] or is it a [parallel school of thought] (can't think of right phrase here but you get what I mean)?Also has anyone tried to create a 'readable' [1] flavour of Clojure yet? If not, why is that, do lispers consider all the parens to really not be a barrier?[1] http://readable.sourceforge.net/	allover	12.641466	-7.879062	comment	3.0	13.0	1484694601	-11.1232815
13431351	> I’m not even going to consider a s	"> I’m not even going to consider a system valid without managing IO in some way. So yes, all flavors of Lisp are off the table as well.We're talking functional in the context of JavaScript, I think ClojureScript deserves more of an explanation on why it doesn't even qualify. That is, if you're trying to hold to the ""neutral as possible"" thing in the beginning."	sk1pper	12.651161	-7.876348	comment	3.0	11.0	1484780900	-11.053241
13442793	Surprised that a thread about CSP in	"Surprised that a thread about CSP in Lisp doesn't mention Clojure's core.async. CSP in Clojure is implemented as just another library and it's rock solid. While I don't claim to understand the implementation in detail, it's one of the more interesting and high leverage uses of macros I've seen in Clojure. It makes concurrent programming a breeze in Clojurescript as well, despite JS being single-threaded.As someone who programs in both Clojure and Go there's absolutely nothing I miss from CSP in Go, and I would much rather do concurrent programming in Clojure.Rationale: http://clojure.com/blog/2013/06/28/clojure-core-async-channe...Code: https://github.com/clojure/core.async/blob/master/examples/w...Presentations: <a href=""https://github.com/clojure/core.async#presentation"	oskarth	12.557787	-7.8638196	comment	3.0	14.0	1484908502	9.427824
13451524	I am familiar with the concept of Cl	I am familiar with the concept of Clojure's reply but I am always wondering how one gets code out of it eventually.	cygned	12.642121	-7.897118	comment	3.0	12.0	1485025812	-11.165159
13452045	I love the JVM repl experience from 	I love the JVM repl experience from Cursive and emacs. But I've never come close to it from ClojureScript for browser development. Can you describe your repl capabilities and dump some links? (I am looking for a real repl experience like on JVM where the IDE is hooked into the repl and forms can be sent across individually and the app can be built up piecemeal without restarts. If this isn't what I want, tell me what I want. Figwheel doesn't seem to be it.)	dustingetz	12.648594	-7.8752294	comment	3.0	10.0	1485031566	-11.121112
13505461	Checkout clojure.spec - you might fi	Checkout clojure.spec - you might find it very useful. The problem with types is that they are only a static/at rest description of your data. For example, it's a String or it's a Date.But does that String contain @ character (checking for email)? Is this Date in the future or in the past (validating a credit card form)? Types say nothing about that. I'm not saying that types have zero utility, but in the vast majority of my use cases compile-time type checking doesn't go very far.	raspasov	12.518458	-7.8634605	comment	3.0	10.0	1485591385	-0.29647514
13541351	Why a REPL? I don't get it. I don't 	Why a REPL? I don't get it. I don't get it in Clojure. I don't get it in Python. I just make a JUnit with a little test method. Then I have the full power of the IDE: debugger, code follower, block editing. Most of that is missing in every REPL.	virmundi	12.601847	-7.8355446	comment	3.0	12.0	1485962534	-10.961814
21192254	I'd love to see more focus on non-JV	I'd love to see more focus on non-JVM impls other than JS -- .Net Core 3.x specifically. (ClojureCLR is pretty much dead, right?)	thelazydogsback	12.634094	-7.8815866	comment	3.0	15.0	1570542582	-11.155822
21194144	so no Java Function to clojure Funct	so no Java Function to clojure Function automating mapping ? do people use macros to make it nicer ?	agumonkey	12.609339	-7.8785887	comment	3.0	11.0	1570552855	-11.08906
21228378	Heh, escript isn't so bad once you g	Heh, escript isn't so bad once you get used to it.Clojure would be a great language for small-ish scripts if it weren't the dog-slow startup times, and has excellent concurrency support.I hear that GraalVM might fix that but I sadly haven't had a chance to play with that yet.	tombert	12.652101	-7.8897834	comment	3.0	15.0	1570827335	-11.169066
21231970	"I don't think ""Lisps are just genera"	"I don't think ""Lisps are just generally slower and use more resources"" is true.According to ""TechEmpower Web Framework Benchmarks"" (which might not be perfect but at least give some indication), Clojure is one of the fastest language (in terms of handling responses per second) for building a JSON API with. Take a look at https://metosin.github.io/reitit/performance.html"	capableweb	12.6521845	-7.863379	comment	3.0	13.0	1570876119	-11.086964
21312294	The comment is a reference to an ema	The comment is a reference to an email client of the same name. A comment like this appears without fail on every HN post regarding Elm.	jamil7	13.014326	-7.6941185	comment	3.0	11.0	1571666367	-3.3892632
21564353	a) Common lisp was already in undead	"a) Common lisp was already in undead state when Javascript became big. Semi-dead languages as a rule have worse tooling for ""new"" stuff.b) Clojure didn't really fully succeed, there were annoying differences between Clojure and Clojurescript last time I looked. There are compilers for incomplete subsets of CL to JS as well, although presumably much worse ones.c) There's some stuff in Common Lisp that's quite hard to do efficiently on top of most existing language runtimes. For example resumable exceptions and lua/CL-style optional multiple return values. In assembler or without concern for efficiency the last one is trivial, otherwise, not so much.d) Clojurescript could bootstrap existing fancy JVM platform stuff (closure compiler) to do quite a lot of heavy lifting."	patrec	12.656788	-7.8855042	comment	3.0	10.0	1574085852	-11.053498
39120907	"I'd say so, but for many, it's ""dead"	"I'd say so, but for many, it's ""dead on arrival"" for a variety of reasons: Java-centric, unabashedly dynamically typed (favoring instead a slightly more eccentric way of enforcing contracts), etc. Unfortunately, a lot of Scheme and Common Lisp people don't like Clojure a whole lot because it gave up on a variety of things that group has treasured."	reikonomusha	12.653033	-7.9008794	comment	3.0	24.0	1706121111	-11.157518
39127581	> I had trouble finding benchmarks f	> I had trouble finding benchmarks for Clojure vs. Common Lisp, but Clojure is basically just Java at runtime, so this[^3] will do.If only it were that simple ! Clojure has no provision for compile time type checks, unlike Common Lisp running in SBCL. On the other hand Common Lisp running on JVM (see Armed Bear Common Lisp) could theoretically achieve those results because, but if we are including calls to host systems then Embedable CL could better it since it runs on top of C. The optimized Java in the benchmarks you quote in fact looks more like C or Cpp code. Im not informed enough to make a judgement if idiomatic Java even looks like that. Idiomatic SBCL (as opposed to just idiomatic Common Lisp) code does look like the versions achieving best results, because people often use SBCL fo	medo-bear	12.6446085	-7.8835654	comment	3.0	16.0	1706173014	-11.143641
39141799	My question with Babashka is always:	"My question with Babashka is always: why? Why force Clojure into something it is not? Why force some interpreter through the heavy GraalVM machinery to have a binary interpreter for a language that wasn't meant for this? Just because ""the syntax feels similar""? Might as well just use Scheme for such tasks, and invest the resources into other Clojure projects - Clojure has a need for that.Nonetheless it is an impressive achievement. Just one that I deem, like GraalVM's native compilation itself, an unnecessary one."	zilti	12.652501	-7.883403	comment	3.0	10.0	1706271247	-11.195394
39183214	after decades of programming, lisp h	after decades of programming, lisp has always been that thing that intrigues me endlessly, but I haven't had a chance to actually wield it myself. but so many people whose opinions I respect love lisps, and not just for a little while. Clojure especially. Other ideas like datomic and xtdb are also high on my list of things I need to experience. I think im going to have to make an intentional effort to find a lisp job next time.	netcraft	12.678081	-7.8484864	comment	3.0	44.0	1706565141	-10.932415
39184351	It does preclude it, but clojure fou	It does preclude it, but clojure found an arguably elegant solution to it, using recur[1] instead. As a plus, in addition to achieving the same result as tail-call elimination, it does check that the call is indeed in tail position, and also works together with loop[2].For me, it made me not miss tail-call elimination at all.[1] https://clojuredocs.org/clojure.core/recur[2] https://clojuredocs.org/clojure.core/loop	jordibc	12.399807	-7.751753	comment	3.0	18.0	1706571857	8.931101
18132426	This is my experience with Clojure s	This is my experience with Clojure stack traces ~60-75% of the time. Perhaps it is a symptom of functional programming? A lot of function passing and anonymous functions make it difficult to generate a meaningful stack trace.	kickopotomus	12.649747	-7.9045477	comment	3.0	14.0	1538586986	5.776542
18160858	> All of a sudden you can stop worry	"> All of a sudden you can stop worrying about ""what am I getting in this function""I think what you're saying is something like ""this function guarantees that the thing I get here conforms to this shape"" and I do like that.  Something I don't see a lot of people express is just the simple ""I know what the shape of this thing is by looking at the signature"".  Whenever I find myself reading other people's Clojure code, it feels like I end up spending more time figuring out  what is being passed into a function.  I have to look around to find the origin of a value.  I wanted to tear my hair out the first time I tried reading Ring's source code to figure out how it worked.  With F#'s Suave, I can tell what each function gets and what can be done to it--it's self documenting.  In Clojure, as the"	yawn	12.647881	-7.9009924	comment	3.0	10.0	1538924255	4.7539167
18162934	> I can’t really imagine myself work	> I can’t really imagine myself working on a million line projectAny project of this size is too big and is better off being broken up.You need tests no matter what kind of typing you are using.The best thing about Clojure is that it is immutable by default.  Start writing pure functions that transform you data step by step until you send it on its way with a side effect. I don’t miss types much at all - immutable maps lists, sets and pure functions get the job done and it is fun to program.Static typing fans hardly ever acknowledge how difficult the types make it to read the code. Too much focus on that one time when someone made a typo and there was no unit test.This has been argued infintum, nobody is changing their mind. WTF am I doing here?	sankyo	12.554296	-7.859386	comment	3.0	12.0	1538951053	-11.140896
18193181	As one of those few who also worked 	As one of those few who also worked in CL commercially in this century, I disagree. The amount of rope is fine. There's just a big library and documentation problem. You can find a library for anything these days, but quite often it's only half-done, and you need to write the other half yourself.The way I see it, all the power and flexibility of CL is what keeps it alive; any other language would have died off with so little people working on the libraries. I used to not mind this that much, but recently I also started working on Clojure code, and the difference is like night and day.	TeMPOraL	12.594973	-7.80624	comment	3.0	17.0	1539263354	-11.053843
18234088	Joker: Clojure-like language on GoLa	Joker: Clojure-like language on GoLang that's really fast	asimjalis	12.619747	-7.904747	story	3.0	25.0	1539731536	-11.165075
29701907	> Whew. This is why a twenty-first c	"> Whew. This is why a twenty-first century language, like Racket, uses archaic, un-helpful fifty year old terms. While Matthew Flatt and team could have changed these terms, they were keeping with a long tradition.To be fair, Racket and LISP do have the procedures `first` and `last` for accessing lists, but also keeps `car` and `cdr` for accessing either pairs or lists. Clojure did away with `car` and `cdr`, but it also did away with the ability to make plain pairs from `cons`.Racket:  > (first (cons 1 '())) # w list
  1 
  > (car (cons 1 '())) # w list 
  1
  > (first (cons 1 2) # w pair
  ERROR
  > (car (cons 1 2)) # w pair
  1

Clojure:  > (first (cons 1 '())) # w list
  1
  > (cons 1 2) # pairs not allowed
  ERROR

https://docs.racket-lang.org/reference/pairs.html"	adamddev1	12.59226	-7.837167	comment	3.0	12.0	1640607744	-10.787589
29777432	So Clojure programs are data structu	So Clojure programs are data structures, and you can pass a structure to a macro to rewrite it into something the compiler can evaluate. In this way you can extend the language. You can build your own DSL that solves your particular problem in an organic way that grows as you go along.If I understand that correctly I don't get it, because I would still have to write the macro, which in C# I would write as a function that I call in my source code, which doesn't grow the syntax of C#, but grows the program to a DSL that solves my problem, albeit not as nicely as in a REPL.Maybe this is all about the REPL and I don't use them or see any appeal in them. I like to write my text, look at it, and hit run. You write a REPL line and it disappears.I'll keep learning. I'm sure the light bulb will go 	mwattsun	12.63991	-7.888536	comment	3.0	16.0	1641185249	-11.116538
29929309	Thumbs Down for Clojure	Thumbs Down for Clojure	labrador	12.661019	-7.909077	story	3.0	3.0	1642122427	-11.142555
29965979	The LISP version can be more readabl	"The LISP version can be more readable with (e.g. Clojure’s) threading macros:    (-> 1
        (- t)
        (* a)
        (+ (* t b)))

Obviously use more or less whitespace to taste."	thom	12.645777	-7.8516207	comment	3.0	15.0	1642423469	-10.927276
29999312	Having used Clojure for a while now,	Having used Clojure for a while now, I will say having 90% of things be a primitive, map, or vector goes a long way in and of itself. A lot of types concocted in a more conventional language just don't need to exist, IMO, and they create so much baggage around themselves.	preordained	12.613105	-7.8821025	comment	3.0	14.0	1642623063	-11.141345
30038525	Jeopardy Heatmap Written in Elm	Jeopardy Heatmap Written in Elm	msszczep2	13.014095	-7.6968875	story	3.0	24.0	1642871299	-12.750592
30246973	We are currently implementing Tornad	We are currently implementing Tornado on a Clojure + Graal install. Even with our partial, non-optimised version, we are seeing a speed-up greater than an order of magnitude. I presently estimate an infrastructure savings of nearly 70% versus our current Azure spend. I will post a postmortem once completed if it would be of interest.	atdrummond	12.589066	-7.8387423	comment	3.0	12.0	1644251200	-11.186706
18253362	What I find most remarkable about th	What I find most remarkable about the comments here is how quickly programmers try to jump to code (I'm not passing judgment, just making an observation). The goal of this post is to present a simple yet useful specification tool. Sure, a decision table implemented in Clojure would likely be more readable than one implemented in assembly, but figuring out what the decisions should be would be far, far more costly and significant (in all interesting cases) than implementing, or reading, either. Sometimes a specification is not even implemented in a single program, but in some distributed system, with no direct representation in code, and sometimes a specification specifies the environment the system interacts with, and is not even implemented by a computer at all. Coding is important, but s	pron	12.641066	-7.9043655	comment	3.0	19.0	1539907116	-11.183725
18345341	Would be interested to hear their ex	Would be interested to hear their experiences with Clojure at Netflix for the 5 years that have followed since then.Did they keep writing more Clojure? If so, how much of their code is now in Clojure compared to Java? How much more did they rewrite from Java to Clojure? Do they use Clojure rather than Java for new code?What other languages do they use? Python? Erlang? Rust? How much, in terms of functionality, is written in each language they use? How many lines of code do they have in each language? To what extent did they find existing libraries for the different languages usable for what they are doing?Among the things that seemed great with Clojure in 2013, did they find that some of these were not so great after all once the codebase grew? Any other problems?	codetrotter	12.666453	-7.9120917	comment	3.0	58.0	1540991586	-11.180948
18345399	to talk about something new, you nee	"to talk about something new, you need to have something new to talk abouti dont think that scala or clojure have lost momentum
i think both clojure and scala, stopped adding new features that are worthy of blogging aboutyou cant just add feature, just to keep people talking about youclojure, is what it is, a nice language, a very smart leader (rick hickey), and a nice vibrant community (check #clojure on twitter)the most talked about language nowadays is actually c++, and i think this mainly because they suddenly decided to have a very ambitious roadmap, and keep adding features, so there is always something new to talk aboutdoes this make c++ better than clojure, well, i dont think they are even comparable, but it just make c++ more talked about than clojure"	systems	12.6283455	-7.883769	comment	3.0	10.0	1540992087	-11.232157
18345971	You can't refactor Clojure without f	You can't refactor Clojure without fear like in Haskell. It is actually possible in Haskell now to defer type errors to runtime, but I haven't heard of a practice of using that, even to aid in refactoring.See this comment: https://news.ycombinator.com/item?id=18345672	gregwebs	12.524345	-7.860527	comment	3.0	36.0	1540996189	-11.219927
18346025	I use Clojure in the large, and the 	I use Clojure in the large, and the lack of static typing isn't something I miss. FWIW, spec allows you make similar guarantees if you use it (technically more, since you can express more than HM type systems).I think the static/dynamic divide speaks to deep divisions in programmer personalities, but if you're open to suggestion, I would put it like this: As Haskell/OCaML are to static langs like Java, Clojure is to dynamic langs like Python/Javascript.Clojure has a deep vein of pragmatic simplicity throughout its core libraries and community that I think does more for taming large-scale development than static typing does, but that just my $.02.	KingMob	12.486099	-7.83822	comment	3.0	22.0	1540996661	-11.137243
18346043	I am very glad you asked!I wrote and	I am very glad you asked!I wrote and deployed (to production) some Clojure code at Netflix just yesterday. Among other things at Netflix the Mantis Query Language (MQL an SQL for streaming data) which ferries around approximately 2 trillion events every day for operational analysis (SPS alerting, quality of experience metrics, debugging production, etc) is written entirely in Clojure.This runs in nearly every critical service, ~3000 ASGs and easily > 100k servers and Clojure allows us to also compile it for our NodeJS services as well.	diab0lic	12.657087	-7.898882	comment	3.0	41.0	1540996775	-11.186027
18346181	amazed to see there are people who f	amazed to see there are people who findmyObject.myMethod(x, y, z);easier to read than(my-function x y z)- that's 2 delimiters in Clojure vs 6 in your C-style language	vbuwivbiu	12.618893	-7.8791966	comment	3.0	15.0	1540997747	-11.134653
18345851	I love Lisp, so I thought Clojure wo	"I love Lisp, so I thought Clojure would be a great productivity booster.  And it is, if you are a one-man or one-woman shop.  But try to build a team around a Clojure project and it's another story.  The language basically begs you to make ""magic"" happen with domain-specific constructs.  That might make you feel powerful as a programmer, but it's also a nightmare for new team members to get up to speed on.And then, as others have mentioned, it's hard to find Lisp programmers.  Most programmers are turned off by the syntax and/or immutability. I happened to take a Lisp class as an undergrad, but I would otherwise probably be in the same boat."	TheMagicHorsey	12.658294	-7.864293	comment	3.0	11.0	1540995369	-10.982627
18346649	Hey, sorry I saw that and typed a qu	Hey, sorry I saw that and typed a quick response just as I woke up. I'm not usually at a computer so early in the day. I'll address these now that I'm in front of a machine. :)> Did they keep writing more Clojure?Yes but it has never been the primary language at Netflix.> How much more did they rewrite from Java to Clojure?Very little, if any was rewritten from Java.> If so, how much of their code is now in Clojure compared to Java?A very small amount given that it isn't the primary language and Clojure code bases tend to be much smaller than Java.> Do they use Clojure rather than Java for new code?This is a personal choice each engineer makes when they write new code. Those who like Clojure might reach for it more often. Clojure is also easy to use within the environment at Netflix since 	diab0lic	12.651548	-7.8999667	comment	3.0	17.0	1541000604	-11.178071
18348089	>Clojure code bases tend to be much 	>Clojure code bases tend to be much smaller than Java.What are the reasons for this? FP language vs. OOP? Less boilerplate (again maybe due to FP)? Higher-level abstractions in the language or libraries?I have seen that F# code (another FP language, although I've read F# is more from the ML family via OCaml, vs. Clojure being from the Lisp family) can be significantly shorter than equivalent C# code, for example, as shown in some comparisons on the fsharpforfunandprofit.com site.Interested to know.	vram22	12.646121	-7.895909	comment	3.0	11.0	1541010092	-11.173752
18348509	To clarify, the reason I prefer node	To clarify, the reason I prefer nodejs (for web apps) over clojure these days is the vast amount of libs and documentation for almost all your needs. Clojure has the java ecosystem, but it was very tedious (more cognitive load) investing lots of time doing interop instead of just focusing on the problem at hand. Interop is both a feature and a curse.Of course, as a language I find Clojure superior in almost every way compared to JS.	Scarbutt	12.655822	-7.876707	comment	3.0	14.0	1541013486	-11.155194
18359162	"No, it's not. Try `(+ 1 ""1"")` in clo"	"No, it's not. Try `(+ 1 ""1"")` in clojure and clojurescript. In clojure, it produces a runtime exception. In clojurescript it silently errs, resulting in a ""11"".The compiler correctly infers and warns of the problem, but that is of no use if your inputs change types on you. In the case of the service I'm referring to, an external service started serving up json strings for large numbers, whereas it had previously been json numbers. Since there was no exception produced, it silently corrupted data for a couple weeks before it was caught."	darksaints	12.637473	-7.8967934	comment	3.0	10.0	1541112492	-11.161521
18504774	I really wish clojure would adopt a 	I really wish clojure would adopt a heredoc syntax to make embed language snippets and docstrings nicer.	Hupriene	12.647454	-7.8964925	comment	3.0	10.0	1542824430	-11.132453
18538323	I kind of wish people complaining ab	I kind of wish people complaining about Clojure's development process (and of other open source projects) would just create a fork and implement their own ideas.This way, everyone could benefit from the experimentation and likely some of their ideas would get rolled into the root project once they have proven themselves.	drcode	12.675169	-7.9163766	comment	3.0	13.0	1543280015	-11.165636
18538444	I haven't used Clojure much but what	"I haven't used Clojure much but what I hear is mostly great. And I love this rant, its always refreshing when people speak their minds.But.... Rich is pushing things a little too far I believe.On the front page of the Clojure web site, under the section 'Rationale"", his very first 6 words are:> ""Customers and stakeholders have substantial investments [...]""Those words do not sit well with (from the rant):> ""[..] you are not thereby entitled to anything at all. You are not entitled to contribute. You are not entitled to features. You are not entitled to the attention of others. You are not entitled to having value attached to your complaints. You are not entitled to this explanation.""I get it, Rich is making a point, and its a fair and unarguable one - if he indeed has no loyalty or feeling"	abraae	12.654369	-7.901365	comment	3.0	13.0	1543281093	-11.186463
18542080	> I am genuinely curious why you, or	> I am genuinely curious why you, or anyone else, would think he is right.Because Rich has the rights to do what he wants with his time and money. (Like everybody else.) It is completely within his rights to establish his own governance and contribution model for his version of Clojure. At the very least, I don't see an argument why it's NOT within his rights to do so.Of course, there are several corollaries. The first is that nobody is forced to use or contribute to Clojure. The second is that, given that Clojure is Free Software, it's possible for someone else to pick up the baton, make a fork, and run it their own way. (egcs and XEmacs both come to mind as examples where someone did this and it wound up improving the original.... so there _is_ precedent.)I wouldn't feel terribly bad if 	mschaef	12.708236	-7.916936	comment	3.0	10.0	1543325239	-11.202316
18549989	Clojure(Script) is neither a Scheme 	"Clojure(Script) is neither a Scheme nor an implementation of Common Lisp but is a LISP dialect. LISP dialect languages are simply a group of lisp-like language not just implementations of Common Lisp. 
https://en.m.wikipedia.org/wiki/List_of_Lisp-family_programm..."	gcornut	12.66298	-7.8831553	comment	3.0	10.0	1543392807	-11.035407
18565484	I still fail to see how methods are 	"I still fail to see how methods are not data in the general sense, but while trying to answer my own question, it seems that ""data"" in clojure means roughly ""Either an atomic type[1] or a collection""1: an ""atom"" in clojure is not what it is in traditional lisp lingo; is there a name in clojure for type that is roughly the union of: symbol, number, character, boolean ?  perhaps ""primitive""?"	aidenn0	12.60913	-7.8788548	comment	3.0	10.0	1543537114	-11.110193
18591082	"""Clojure is a functional programming"	"""Clojure is a functional programming language, that runs on JVM""...which means that the party is over: anything that I cannot permanently compile into straight machine code and generate a binary executable will have a double performance penalty: once to process the bytecode, and once to just-in-time compile it. Why would anyone in their right might settle for that? Please wait - compiling the planet... that's insane. It's far better to stick with one of ANSI common Lisps and get incremental, instantaneous compilation to straight machine code for any expression which evaluates."	Annatar	12.650751	-7.8954325	comment	3.0	12.0	1543859997	-11.1475115
18613942	And it isn't only Javascript that ma	And it isn't only Javascript that manages to have a single tool for this. Clojure has a single tool. Java has a single tool. Rust has a single tool.This is a solved problem across a variety of popular and mainstream programming languages. I don't mean to suggest that the problem isn't complicated, but this isn't a problem that doesn't have a wealth of previously written solutions to look at for inspiration.	gizmo385	12.65314	-7.87249	comment	3.0	15.0	1544053452	-11.175041
18626647	I see a fifth column growing here.Th	"I see a fifth column growing here.The core problem (sort of created here) is about how lispy Clojure should be. Unlike most programming languages, Lisp code isn't meant to be fully statically analyzable. This affect indentation as well, because the ""full picture"" of syntax is only available at runtime.Consider a macro invocation:  (foo bar
       (some args)
       (some other code))

vs.:  (foo bar (some args)
    (some other code))

Which indentation style is the correct one? That depends on what ""foo"" is. If it's a function, then the first one. If it's just a regular macro, it's still the first one. But for some particular macros - like defun in elisp/CL, the valid syle is the second one. You can't, in general[0], know that until runtime. That's why the Lisps usually give you tools for "	TeMPOraL	12.641526	-7.88216	comment	3.0	14.0	1544180472	-10.980389
18651139	Rich Hickey brought joy and aestheti	Rich Hickey brought joy and aesthetics back to software development.	patkai	12.634459	-7.898728	comment	3.0	18.0	1544475699	5.5732636
18669733	I’m surprised Reagent’s ratoms weren	I’m surprised Reagent’s ratoms weren’t an inspiration. They give you a lot of Hooks functionality largely through Clojure’s native atom.	city41	12.710343	-7.785065	comment	3.0	10.0	1544673133	-11.180708
18703533	The deification of Rich Hickey in th	The deification of Rich Hickey in this thread is amusing. No doubt he's a great developer and language designer, but dogfooding your own language is not exactly novel.	trevor-e	12.6461115	-7.891596	comment	3.0	10.0	1545092467	-11.145497
18743509	The sad thing is that Rich Hickey ha	The sad thing is that Rich Hickey had some very good videos when Clojure was a new thing back in 2008–2009.  Unfortunately, I've disagreed vehemently with most of his talks since then.  In this case, it's completely illogical that a function `Maybe a -> b` should be callable as if it were a function `a -> b`.  Do you want to know how I know?  Because it would be just as illogical to allow a function `Vec a -> b` to be called as `a -> b`.  And Rich must agree because Clojure itself does not support that!I've learned that videos of his talks are just not worth my time.	gnuvince	12.636801	-7.9209924	comment	3.0	19.0	1545525251	-11.167209
18775230	> Interactive REPL based workflow (t	> Interactive REPL based workflow (think of programming in Clojure like playing a difficult video game based on trial and error with emulator save states vs without).What?I'm not sure I understand what that's even trying to say?Is it trying to say, think of programming as playing a difficult computer game, and using a REPL like having save states?...because it sounds like you are saying programming in Clojure is like playing a difficult video game based on trial and error, which is a really rubbish endorsement.> To touch on the video game analogy - imagine playing one of the old Mega Man games, Dark Souls, or Battletoads. Now, imagine that instead of getting feedback (a death) that results in a hard restart at the beginning, you instead just get taken back one action / event that caused an	shadowmint	12.625049	-7.8717666	comment	3.0	12.0	1545979677	-11.136867
18784672	"I would rephrase the title: ""It runs"	"I would rephrase the title: ""It runs on the user's platform or it is wrong.""The example discussed throughout the article is Clujure vs. ClojureScript.The author takes issue with the difference in compile time (6.5 seconds vs. 78 seconds, respectively).But this really is an apples/oranges comparison. If the user expects to run the program in their browser, then any solution that doesn't deliver that experience is wrong. End of story.If the user can't be bothered to figure out how to install your native or byte code binary, then your solution is wrong. Find a way to give the user what they expect or stop trying to write software for a living.Here's a common programmer dilemma:You are familiar with development system X. However, your users demand that your software run on platform Y. Platform"	apo	12.641505	-7.8516507	comment	3.0	13.0	1546104839	7.0701294
18817031	On that topic Haskell is soooooooooo	On that topic Haskell is soooooooooo much more readable than clojure to me	johnwyles	12.470931	-7.8563623	comment	3.0	15.0	1546536918	10.462114
18834470	I am not sure how this would work in	I am not sure how this would work in a production database but the problem of concurrent reads and writes are pretty well solved in Clojure. https://clojure.org/reference/refsI was also wondering if the Datomic approach is better.	StreamBright	12.630325	-7.877542	comment	3.0	12.0	1546724676	-11.195414
18841420	There are alot of interesting points	There are alot of interesting points of view in that thread, unfortunately they're all from people who've spent very little time with Clojure.The biggest innovation I think, its putting Clojure on the JVM allowing for tight host integrations. This has been my way of introducing Clojure in a number of places it wouldn't otherwise have been able to go.In terms of writing better code, the performant immutable datastructures yield more power than I can sum up a single comment.	lbj	12.636752	-7.8850703	comment	3.0	25.0	1546817067	-11.173192
18841677	I would go as far as to say that a l	I would go as far as to say that a language with more traditional syntax (for instance Python style) with pervasive immutable data structures would do very well. Few of the benefits Clojure brings to day to day development seem to require a lisp syntax.	reitzensteinm	12.597667	-7.8628907	comment	3.0	18.0	1546820216	-11.133861
18841736	Maybe – s-expressions have a killer 	Maybe – s-expressions have a killer app though, which is that they are so simple that the level of effort to port Clojure to other platforms (ClojureScript, Clojure CLR, etc) is within reach of one person. I am irrationally bullish on Clojure, but this is the key to the bet – platform reach has network effects which I believe may outweigh in longrun the resistance to alien syntax. My Clojure codebase (http://www.hyperfiddle.net/) runs on JVM, node, browsers, lambdas, and inside Datomic cluster as stored procedure. Same code! Same library artifact! Simultaneously targeting all these different platforms!	dustingetz	12.660806	-7.9018664	comment	3.0	13.0	1546820868	-11.180622
18842012	But afaik most immutable,  persisten	But afaik most immutable,  persistent data structure libraries in other lisps either (1) had poor performance or (2) were developed after clojure and borrowed from clojure.	drcode	12.628804	-7.88452	comment	3.0	27.0	1546824197	-11.07878
18842694	Strictly speaking: yes. But whether 	Strictly speaking: yes. But whether conses (aka pairs), lists, or other derivative structures support pervasive FP in a language is probably most influenced by whether conses are mutable or not.In Common Lisp, they are. In Scheme, they are not.Mutable conses are useful because at least because values can be accumulated in a list from the end by retaining and mutating the tail.However, the presence of mutable conses detracts from a language's ability to support FP, since it must be done by convention and with much copying.I see Clojure's innovation in this area not in the fact that its lists are immutable (Scheme did this already) but in the fact that its lists are immutable and there's never a need to mutate the tail, because lazy sequences are supported throughout the language. The icing 	wooby	12.644786	-7.888832	comment	3.0	10.0	1546833865	-11.082846
18842902	I think I am qualified to answer thi	I think I am qualified to answer this: I wrote reasonably complex systems in Common Lisp before I gradually moved to Clojure several years ago. I have written several fairly large apps and systems in Clojure and Clojurescript (this includes https://partsbox.io/ as my current project and apps like an e-commerce search engine processing hundreds of requests per second for many years).I used to think Common Lisp was a fantastic language, but I always tried to keep an open mind remembering the Blub paradox. Then I started working with Clojure and after the initial friction (some things were just plain annoying in the beginning) things clicked for me. It was, quite simply, a much better language.The major improvements over Common Lisp for me were: 1) immutable data structures: these days I can'	jwr	12.660867	-7.8817115	comment	3.0	11.0	1546837342	-11.0187435
18843543	>> “I think the most innovative part	>> “I think the most innovative part of Clojure is the fact that it's actually used”Popularity is not “innovative”.	bad_user	12.6573	-7.9032717	comment	3.0	14.0	1546847695	-11.234356
18872914	> In a comment below the main post t	> In a comment below the main post they say that the app they wrote is approximately 45,000 lines of code over 170 Elm files.One thing I've found a bit weird about the Elm community is how common it is to highlight or even brag about the size of the codebases.One of the reasons I have come to particularly enjoy Clojurescript on the front-end is because of how much code I don't have to write. I once ported an Elm app to Clojurescript and it was only one-third the line count for the same functionality, and generally a smoother experience.I think some developers just love building up these huge, complex worlds and living inside them, and then telling others how big those worlds are.	hellofunk	12.87827	-7.7069087	comment	3.0	36.0	1547117198	-12.630606
17254568	Man, am I ever a dummy! I look at th	Man, am I ever a dummy! I look at the diagram on that page and it might as well be Egyptian hieroglyphs to me. I'd have to study that thing one long time to even understand what problem Ions is solving. I'm sure it's a real problem with an interesting solution, but geez the modern Cloud world has really gotten quite complex.I feel particularly silly because I've been writing Clojure professionally for many years.	jb1991	12.668432	-7.897009	comment	3.0	28.0	1528365653	-11.153694
17254920	>Ions let you develop applications f	">Ions let you develop applications for the cloud by deploying your code to a running Datomic clusterI could be totally off base here as I have no real experience with clojure, but this intro sentence threw me off right away.>Ions let you develop applications for the cloud by deploying your code to a running Datomic clusterWhat is an ion? What is a ""datomic cluster""? Are these terms just new jargon for what is essentially a deployment system? If they're a clojure thing then ok, but a quick search makes me think they're not. I understand software and I understand deployment. I read the rest of the page and I feel like I would have to problem understanding what this really is if they cut down on the jargon."	EpicEng	12.674753	-7.867847	comment	3.0	21.0	1528371649	9.675441
17254988	Datomic is an immutable database, wr	"Datomic is an immutable database, written in Clojure. It's pretty cool, you should check it out.The company behind Datomic (Cognitect, which also develops the Clojure language) recently started offering the database as a cloud service. This was something Datomic users had wanted for a long time, but one problem with the new service was that one of Datomic's primary features, i.e. having the database reside in memory with your application, was missing.Ions is a new service that addresses this problem by allowing you to deploy your app to the same VMs that are hosting Datomic in the cloud (a ""datomic cluster""). It's basically PaaS for Datomic-backed applications.I'm a longtime Clojure user and I had some trouble understanding all this as well, so I agree that could do a better job with prese"	paradigmshiv	12.682093	-7.868323	comment	3.0	18.0	1528372508	9.674655
17255136	> We are already using Clojure and I	"> We are already using Clojure and I would love to introduce Datomic as well but being a commercial database makes it pretty difficult.I don't see why paying for Datomic would be a problem, but if the license is as crazy as it used to be, that's a bit scary.For example, the license at least used to forbid even saying ""Datomic"" aloud in public.Publishing benchmarks was also forbidden, which is a big red flag. If Datomic performs well, wouldn't Cognitect want lots of benchmarks out there? If it doesn't, they wouldn't!> I must say I often found the setup needlessly complicated. [..] No official way to set up of the whole stack with Docker or Kubernetes for example.You don't find Kubernetes needlessly complicated? Do you actually need Docker or Kubernetes?"	alter_eco123	12.674112	-7.882265	comment	3.0	18.0	1528374324	-11.205371
17356475	The problem with Ruby isn't static t	"The problem with Ruby isn't static typing per se, it is the terrible handling of `nil`. Ruby either has to make nil more evaluatable, or assure unexpected nils never come with options. For instance calling `each` on `nil` should have the effect of calling it on an empty enumerable like Clojure does would make it more evaluatable and stop the dreaded ""No method found each on nilclass"".I've been programming in Ruby for 10 years and I have to say after writing Clojure for a bit I really enjoy the fact that nil behaves as an empty value, and is enumerable. It is not the purest CS interpretation of nil but it makes it way easier. If someone is really concerned to check to see if something is nil there is still .nil?When have you had errors like Oh this is String [][]{} vs Int[][]{}? That kind o"	specialp	12.441235	-7.7578945	comment	3.0	11.0	1529509719	12.372758
17364381	The independence WebAssembly brings 	The independence WebAssembly brings it that you'll still be able to use JavaScript whether or not you are using a compiler targeting WASM and giving everybody else the liberty of that choice. What's also great, is that even if you stick to your guns, you'll be able to use libraries written in other languages targeting WebAssembly.And finally, to appease your OO concerns, in fact... I became progressively annoyed by the state of the web as it seemed to make heavy adoption of OO patterns (thinking angular). The ML family of programming languages has offered a much better software development experience in typed programming languages since the 1970s. There are already several compilers for those languages targeting JavaScript which are only waiting to target WASM. (WebSharper for F# & C#, ocs	davidgrenier	12.636806	-7.791604	comment	3.0	12.0	1529583362	-11.030504
17415732	Fellow Clojurians, I present to you,	Fellow Clojurians, I present to you, Ghostwheel.It makes the writing, reading, refactoring, testing, instrumentation and stubbing of function specs easy; introduces a concise syntax for inline fspec definitions; helps keep track of side effects; and makes general debugging almost fun, with full evaluation tracing of function I/O, local bindings and all threading macros.It's Alpha software and the Clojure port, while essentially functional, still needs some love to achieve full feature parity with ClojureScript – most prominently missing at the moment is the tracing functionality.To steal a quote from Nathan Marz' Specter in a blatant attempt at a so far likely undeserved comparison to its indispensability, I like to think of Ghostwheel as clojure.spec's missing piece. It has become quite e	gnl	12.645062	-7.905054	comment	3.0	14.0	1530182864	-11.091365
17431264	That's quite a judgement call to mak	That's quite a judgement call to make based on the utility of error messages. I can't remember the last time I was blocked based on a Clojure error message anyway. Errors are less frequent and usually pretty obvious.I think you're wrong to say core devs don't understand modern programming, but you'd probably be right to say that they didn't prioritize making it approachable and stooping to the lowest common denominator. And it's not just Clojure, but datomic, core.async, spec -- all solving real problems in modern large scale programming with elegance.Watch Rich's 'Effective Programs' talk [1] and lmk if you still feel that he's out of touch with modern large scale programming. I think he's pretty in tune.[1] https://www.youtube.com/watch?v=2V1FtfBDsLU	rboyd	12.655156	-7.90731	comment	3.0	19.0	1530374154	-11.199419
17431974	Going to have to disagree with you t	Going to have to disagree with you there—if for no other reason than the tooling around Java is much more robust and available than for Clojure. I’m thinking static analysis, IDE support, fuzzers, linters, etc.Clojure has potential, but the lack of good feedback when things go wrong makes it _very_ hostile to users of the language, especially when first trying to pick it up.	d4mi3n	12.641782	-7.8903413	comment	3.0	11.0	1530382711	-11.170902
17437418	Is it just me or is Clojure(script) 	Is it just me or is Clojure(script) becoming more and more syntax-heavy with each passing year?	cutler	12.655527	-7.899434	comment	3.0	12.0	1530477484	-11.121473
17439975	You seem right. Every metric I can c	You seem right. Every metric I can check says it is going downhill. Too bad, I used to go to the Clojure meetups in my area, I even had a talk about Clojure + Emacs.	edem	12.654867	-7.907655	comment	3.0	39.0	1530518244	-11.156046
17440103	Many reasons. S-expressions would be	Many reasons. S-expressions would be the least of my worries. Java is dying, not on the whole, but certainly in mindset of people who are picking new languages. It’s integration with OSs, which Clojure depends on, is arcane by today standards. Second, it’s tightly controlled by one person, and they happen to hate types. Similar to CoffeeScript, couple years after the language inception people figure out that they miss types. Adding them back in is super tough.And third, abstractions have costs. There is no wide-spread popular LISP, and people should really ask themselves why. We have lots of code generation, and depend on it more and more. But it’s “simple” (or “primitive”). It’s usually one step. You can read the input, and you can read the output.I’m starting to get a sense that macros a	xixixao	12.64085	-7.8528666	comment	3.0	32.0	1530520130	-11.115967
17441387	I think there is a lot of exciting s	I think there is a lot of exciting stuff happening in Racket and Clojure around contract systems right now with things like Racket Contracts and Clojure Spec. This approach provides an appealing alternative to static typing because it focuses on semantic correctness while static typing focuses primarily on self consistency.In my view the former is much more valuable because ultimately we want to know that the code is doing what was intended, and static typing doesn't appear to be an effective tool for encoding intent.	yogthos	12.5284195	-7.85375	comment	3.0	69.0	1530537858	-11.118805
17536059	Clojure’s maps, sets, and vectors ar	Clojure’s maps, sets, and vectors are all functions.	prospero	12.572367	-7.8558073	comment	3.0	12.0	1531674609	-11.126489
17576663	Long JVM startup time is a big reaso	Long JVM startup time is a big reason why I went with Elixir instead of Clojure when I decided to move off Ruby to do webdev. (Another reason was easily triggering nasty Java stacktraces.)My Elixir test suites fire up instantly and finish in seconds (if that) and this fast-as-possible feedback loop is extremely important to stay productive, IMHO.	pmarreck	12.618611	-7.8556323	comment	3.0	15.0	1532105348	3.6492114
17646064	Common Lisp has the advantage of bei	Common Lisp has the advantage of being much more stable in terms of language changes. You can pretty much take CL code from the last two decades and run it. It's also got a better native compilation story.I like Clojure for bringing maps and vectors into first class language constructs with simple syntax and the fact that it runs on the JVM means I have access to the entire Java ecosystem of libraries and tools.	justinhj	12.672618	-7.8671594	comment	3.0	23.0	1532970658	-10.906826
17675052	In my opinion one of the primary cha	In my opinion one of the primary characteristics of Clojure is the implementation of the collection types.  Without that it's not going to be an implementation of Clojure to me.	kencausey	12.614955	-7.8836966	comment	3.0	12.0	1533240751	-11.127343
17725397	I'd be interested in clojure if I di	I'd be interested in clojure if I didn't have to use third party tools to set it up on windows, or if the process was documented so I don't have to.	tudelo	12.654317	-7.898888	comment	3.0	15.0	1533830724	-11.175883
17785131	Last time I tried ClojureScript, I f	Last time I tried ClojureScript, I found the interop with web APIs and vanilla js libraries to be horribly lacking, and development was abysmally slow as a result.I loved Clojure when I used it, but ClojureScript was a nightmare.The only saving grace was shadow-cljs, which made it bearable to work with.  I eventually dropped it in favor of Elm mostly for the static typing, but also for the tooling, which is leaps and bounds better.	holtalanm	12.643161	-7.8567805	comment	3.0	10.0	1534534115	-11.10202
17812554	I've found the opposite, all the mom	I've found the opposite, all the momentum seems to be with Reason - I don't hear of many new people picking up Elm.A release with smaller bundle is an amazing technical achievement but doesn't really address the underlying language and ecosystem issues.	hazza1	13.0103245	-7.6913447	comment	3.0	13.0	1534877263	-12.754169
17843160	It is interesting that the message l	"It is interesting that the message locking the post seems to portray engaging with people with opposing views about design decisions as taking time away from working on Elm, instead of being itself a form of working on Elm!Maybe Elm needs some sort of ""Please do not use this language in production"" sign, and no ""Community"" link at the top of the home page. There's nothing wrong with a group of folks making a language for themselves / their employers, perhaps putting it on GitHub because why not, but not having a home page at all and making it clear that this isn't a stable language for others to use and they will put much more emphasis on the feedback from their own experiences than from others'. There's definitely nothing wrong with them doing that until they get to a 1.0 they're happy wi"	geofft	13.007814	-7.6919103	comment	3.0	23.0	1535239807	-12.760087
17845469	Are you paying to use Elm? What's st	Are you paying to use Elm? What's stopping you from sticking to 0.18? What's stopping you from building your own 0.19 IDE support?	yakshaving_jgt	13.012993	-7.694386	comment	3.0	17.0	1535283741	-12.757547
17847480	> The only posts allowed on /r/elm a	> The only posts allowed on /r/elm are those praising Elm.The Reddit thread you linked shows many posts that are critical of Elm, so this can't be the explanation.As others have noted, you can see what was deleted using this link:https://snew.github.io/r/elm/comments/9a0hc6/elm_019_broke_u...Removed posts included both praise and criticism. What they have in common is that they broke other rules, e.g. personal attacks.	rtfeldman	13.01238	-7.6949196	comment	3.0	19.0	1535312481	-12.760935
16304437	I'm interested in Reason/Buckle, com	I'm interested in Reason/Buckle, coming myself from the ClojureScript.The seemingly tinier minified compilation size would be a huge plus. But what are the actual sizes emitted for large scale projects (arguably the ones that matter most for static typing)? Anyone could share real-world experiences?For reference: I know of cases where 60K lines of clojurescript (arguably equivalent to 150K lines JS) compile down to 5MB under advanced optimization mode.(in case that scares you: well it's an actually large app. We should do route-based code splitting soon - easy/robust with clojurescript apparently)	vemv	12.605181	-7.7466464	comment	3.0	11.0	1517773068	-10.842814
16332617	I'm a big fan (and user) of Clojure.	I'm a big fan (and user) of Clojure.However, I feel 150$/h is quite a bit for something that was done for free previously.Taking the 3 months of figwheel, we're talking no less than 60 days * 1.2k/d = 72k$.It's probably just a (slightly above?) average consulting salary in the US/Western Europe but everywhere else  that's really a lot. Heck, even some friends of mine working as developers in Germany or France don't earn that in a year, even after adjusting for taxes and social security.Being a (Clojure) consultant myself, I know the mathematics and I charge the same order of magnitude but I don't go around telling people this because I feel that might have negative consequences. (Most of my friends don't read HN, hence the contradiction in the last sentence)	dmichulke	12.6657505	-7.909828	comment	3.0	10.0	1518103535	-11.180439
16332072	Wow this is such a great idea for fu	Wow this is such a great idea for funding. But I wonder if this would work with other language communities because the Clojure community, from my understanding, tends to concentrate around the same tools.Anyone know of any other language communities with similar foundations?	RubenSandwich	12.652567	-7.8947306	comment	3.0	11.0	1518098623	-11.150946
16354456	I use Scala daily and have never use	I use Scala daily and have never used Clojure - what creates the steep learning curve?  Scala also has a lot of features between “Beginner” and “Advanced” which can really add to the learning curve (Implicits being a good example).	alextheparrot	12.530574	-7.8346252	comment	3.0	14.0	1518379493	11.948673
16354384	This is awesome. Clojure has had sim	This is awesome. Clojure has had similar frameworks for a while, but Clojure has a fairly steep learning curve. Really excited to try this in Scala. Wonder if this will be a new trend away from the totally separate webapp + rest API model...	rusbus	12.631872	-7.8734393	comment	3.0	27.0	1518378714	-11.161857
16408844	I've done two successful startups wi	I've done two successful startups with lisp variants in my career, and continue to do clojure development at Cisco.  The advantages of using lisps are real, if you stay focused on the problem domain and stay close to the customer -- you have great agility and flexibility.  Woe to those who are tool jockeys and get too infatuated with their tools and code base, because there is a lot of rope to hang yourself and your teammates with.The first was a Common Lisp web app for resource management, that was recently sold.  Not a giant payout, but over it's entire life, starting in 2000, it paid peoples mortgages and put kids thru schools.The second was a clojure based malware analysis engine, which we sold to Cisco about 3.5 years ago.  That was a more conventional startup exit.  We have scaled th	cbrozefsky	12.6747265	-7.874095	comment	3.0	23.0	1518989573	-11.121644
16413674	Everytime I use clojure for some new	Everytime I use clojure for some new project because I think it will help, I end up spending too much time on tooling and setup, and in the end change it to something easier to setup, which strangely that's javascript sometimes. I want to go work in a team where they have it ready for me and I can learn the tooling on the way, without needing to do that up front..	pvinis	12.655027	-7.897569	comment	3.0	12.0	1519056630	-11.162419
36671895	I'm going to be the Smug Lisp Weenie	I'm going to be the Smug Lisp Weenie here (I wonder who gets the reference), and comment on this:> One of my favourite things about creating sparklines like this is that I can create the SVGs entirely on the backend. I don’t need to worry about using a JavaScript charting library, or sending the “points” data to the frontend. The browser requests an SVG. The server returns it. Simple!Me, I don't care where I create the SVGs. Most of my Clojure code is shared between backend and frontend (compiled and running on the JVM in the backend and compiled to JavaScript in the frontend). So I can generate SVGs wherever, it doesn't matter, the code is only written once. Or rather, it might matter, because my website uses server-side rendering, so the same thing must be generated on both sides.I'll se	jwr	12.655008	-7.8603635	comment	3.0	13.0	1689018200	-11.197343
36740567	The decision to make Clojure JVM bas	The decision to make Clojure JVM based and so slow to startup has slowed it's adoption to a much more significant level than anyone in the Clojure community is willing to accept.	kasajian	12.6301155	-7.8739667	comment	3.0	10.0	1689452296	-11.172821
36889454	Not the OP but would somebody be abl	"Not the OP but would somebody be able to summarize HOW are the lisp REPLs different then to me?  
I've written limited amount of clojure and common lisp just to play around and I don't recall any difference between Clojure REPL and the REPL I get for say Kotlin inside IntelliJ idea.Maybe the ability to send expression from the IDE into the REPL with one keybind but I cannot say it's not possible with the Kotlin one right now because that's not what I use it for."	bbbobbb	12.582095	-7.7957506	comment	3.0	18.0	1690437298	-10.838244
24608157	In the Clojure world we use clj-kond	"In the Clojure world we use clj-kondo, maps, and spec to solve these problemsWe get editor time feedback of mistakes with optional type hints + light inferance via clj-kondo and a data modelling system that we can export out as database schema, JSON schema etcAnd dynamic enough constraint system to express something like all human names must be ""Tony"" only on TuesdaysThe same constraint that can be shared server side and client side without writing it twice without learning more syntaxAdditionally check what the expected inputs for a function are by checking the function specs I think guardrails pro will make this more ergonomic when releasedAnd finally ask the constraint system to generate valid examples of the constraints great for mocking dataI don't miss type systems but I also underst"	slifin	12.609379	-7.885911	comment	3.0	11.0	1601226587	-11.249459
24716516	Clojure and F# are my two favourite 	Clojure and F# are my two favourite languages and I have similar experience. It is much faster to develop F# code because I can rely on the type system to help me handle all the edge cases, pass in the right things and avoid nulls.	StreamBright	12.5275955	-7.8240952	comment	3.0	23.0	1602139449	-11.143349
24731430	(comment) doesn't completely ignore 	(comment) doesn't completely ignore the body, which is weird for something that is supposed to be a comment https://clojuredocs.org/clojure.core/comment; and ;; pretty usage is same as Common Lisp. #_ is replaced with #+nil in Common Lisp which is just a reader macro. ;;; is usually reserved for prose, and of course there's #| commenthere |# which is just another reader macro, and is suitable for code examples, where you can probably still eval it in your text editor.	fmakunbound	12.622557	-7.878472	comment	3.0	10.0	1602260417	-11.128212
24733402	As one not knowledgeable about Cloju	"As one not knowledgeable about Clojure, and to play devil's advocate: one of the handy parts about `//` is that you can violate the language rules.  E.g. I've fairly often had cases where I want to temporarily remove a check, to see if something behaves as I expect:  //if (some logic) {
    do something
  //} else {
  //  something else
  //}

Or in other cases collapse two if/else blocks together, or stuff like that.  It's not as common as commenting out a logical unit, definitely, but it's far from uncommon.How would you achieve that in Clojure?  Seems like you'd need to copy/paste, like this?  #_(if (cond) thing other_thing)
  thing"	Groxx	12.581471	-7.8697867	comment	3.0	11.0	1602271096	-11.156892
38814294	Clojure effectively is Java, they sh	Clojure effectively is Java, they share the same ecosystem. The only differences are the syntax, which is really just cosmetic (being much terser than classic Java is nice) and Clojure being highly opinionated about semantic style (ie, you should be coding in the style of a very specific expert developer named Rich Hickey).	roenxi	12.634042	-7.8885493	comment	3.0	17.0	1703934278	-11.142701
31880837	It's not impossible to type check he	It's not impossible to type check heterogeneous maps at compile time, but most static type systems don't support this. I think you'd certainly see much more friction trying to program like this in C# than you would in Clojure.	weavejester	12.338141	-7.7776155	comment	3.0	18.0	1656214370	2.001836
32022318	Clojure is a dialect of Lisp accordi	Clojure is a dialect of Lisp according to its website.	sigzero	12.658674	-7.8846025	comment	3.0	10.0	1657247030	-11.072328
32092999	This is very nonambitious, but I’d l	This is very nonambitious, but I’d love to see a Clojure with less LISP. That is - something like JS syntax but with immutable by default types and const only bindings. Macros would be great too, even if they require a different compilation mode. Top it off with great standard library that has _all_ the collection operations you’ll ever need (e.g. partition-all and dedupe in Clojure). nREPL support or the like is a hard requirement.Spending the last 6 years writing Clojure has been great. That said, the parens don’t add positively to the experience. They feel like semicolons in C - “the compiler is too dumb to understand this so I have to help it.”	NightMKoder	12.594599	-7.8518414	comment	3.0	10.0	1657783292	-11.129466
32283041	I really wanted to use Clojure but e	"I really wanted to use Clojure but even with this modern tooling it feels a bit ""Java""-ish."	ilrwbwrkhv	12.646177	-7.8865547	comment	3.0	18.0	1659139301	-11.170631
32284807	Clojure libraries are good but you h	Clojure libraries are good but you have Java and JS interop for mundane, everyday libraries. Is there anything wrong with interop?I think most Clojure libraries rightfully focus on things that either only possible or needed in Clojure. Things like core async, typed clojure are not even possible to implement in other languages as libraries.When thinking of examples: the cognitect/aws-api is amazing in it's ease and fun, yet AWS Java SDK is also easy to use from clojure. I prefer the former, but there isn't anything wrong with the latter.	dimitar	12.649657	-7.8958435	comment	3.0	12.0	1659162906	-11.1293545
32288512	And clojure is actually in a better 	And clojure is actually in a better position than other niche languages because _at least_ you have the option of calling the boring and maintained java library to ship _something_ (it might be something non lispy, maybe a bit less efficient and maintainable but at least you solved the business issue.)Try doing that in some other languages were your underlying platform has even less libraries than a JVM...	phtrivier	12.640789	-7.879454	comment	3.0	14.0	1659201699	-11.167551
32288880	That's surprising. I listed the inte	That's surprising. I listed the interop caveats here because sometimes it feels like a bandage intended to bridge some gap until Clojure matures.But if Alex said that, then maybe it's not. ¯\_(ツ)_/¯	janetacarr	12.66716	-7.91374	comment	3.0	25.0	1659204179	-11.180635
32288937	Clojure libraries target microservic	Clojure libraries target microservices with a precision that no other language ecosystem has.  In essence, Clojure web services developers rail against Rails and other bloated, unnecessarily complected (https://www.infoq.com/presentations/Simple-Made-Easy/) frameworks of the 90s.  As a Clojurist I too rail against Rails.  I don't think that expansive model fits the problem space. I have had painful experiences in the past maintaining Rails projects wondering why they didn't know of DRY. If there is a essence within Rails that you feel could be distilled into a lean Clojure model, build it out in a library and share it.	waffletower	12.647479	-7.8901024	comment	3.0	10.0	1659204530	-11.17381
32288956	“Idiomatic Clojure code calls Java l	“Idiomatic Clojure code calls Java libraries directly and doesn’t try to wrap everything under the sun to look like Lisp… Where Java isn’t broken, Clojure doesn’t fix it.”	mark_l_watson	12.649391	-7.895658	comment	3.0	13.0	1659204606	-11.135699
32290273	> When revisiting old projects I hav	"> When revisiting old projects I have seen countless of Clojure dependencies having died in the meantime. I have replaced utility libraries with more recent utility libraries sometimes several times. Very annoying.Yes, the ""best in class"" libraries change every few years in Clojure's universe, but they always bring huge improvements that require completely new APIs.For instance:https://github.com/plumatic/schema -> https://github.com/metosin/mallihttps://github.com/juxt/bidi -> https://github.com/metosin/reitithttps://github.com/bhauman/lein-figwheel -> <a href=""https://github.com/thheller/shadow-cljs"" rel=""nofoll"	krn	12.657049	-7.895599	comment	3.0	15.0	1659214834	-11.175087
32289849	Something like Phoenix? Elixir is a 	Something like Phoenix? Elixir is a newer language, with a lot of similarities to Clojure. Phoenix even made the most loved web framework in the Stack Overflow 2022 survey.Why did they converge on something so, apparently, great, in such a low amount of time? And why is this so hard for Clojure?Not taking sides or trying to be negative, just honestly curious what the driving factor is.	suprfnk	12.660521	-7.856708	comment	3.0	41.0	1659211836	12.858549
32291516	I believe what you see with multiple	"I believe what you see with multiple web frameworks may more often be the misguided attempt of Clojure newbies to reimplement what they already know instead of kind of stepping back and understanding what they actually already have available via Clojure.I can't find the reference anymore but I think Stu Holloway once said something along the lines of there is a tendency of new devs picking up Clojure to try and rewrite Rails.  And that it was a mistake.The real concern you express about Clojure having ""missing or rotting"" libraries is harder to quantify.  I will say that has this has not been my experience at all.  I actually find that I write one-off programs very frequently with Clojure - to call web services (REST or SOAP), serve a http-friendly API via liberator, and other similar work"	clusterhacks	12.6526375	-7.8898826	comment	3.0	11.0	1659224665	-11.178709
32293800	In Clojure, this data is represented	In Clojure, this data is represented by open maps instead.Is Clojure unique here? seems this is the norm for Javascript applications too, that are done mostly with a FP style, instead of open clojure maps you have open JS objects. Most JS SDKs and libraries I have work with is just passing JS objects between them and your code.	ithrow	12.66663	-7.906695	comment	3.0	15.0	1659250584	-11.164371
32353223	It's not a javascript compiler as Cl	It's not a javascript compiler as Clojure is a hosted language.	smcn	12.650667	-7.8806653	comment	3.0	12.0	1659687814	-11.179041
32494866	Love this. As a Lisper I’m always in	Love this. As a Lisper I’m always intrigued by Clojure but as someone with no knowLedge of or desire to learn to JVM I stayed away since I figured eventually I’d hit JVM questions/issues I frankly didn’t feel like dealing with.Is it really 100 percent compatible with Clojure or is that just aspirational.Also, is it the case that lots of libraries/workflows outside the core language in Clojure assume Java integration?  I always thought a big Clojure selling point was the awesomeness of Lisp while having full access to the libraries of Java.	jshaqaw	12.655481	-7.8964353	comment	3.0	11.0	1660736204	-11.151843
32498969	The only reason Clojure is viable fo	The only reason Clojure is viable for production use is because it relies on the really good JVM GCs. How will Jank try to solve the the GC problem?	ithrow	12.652079	-7.9105864	comment	3.0	13.0	1660756046	4.5670547
32501981	That begs the question: if Clojure i	"That begs the question: if Clojure is so inefficient, that a program written in it needs  10 MB of some ""cached heap"" just to start as fast as a C program, and it does a lot of unnecessary work at startup, why use Clojure and this Jank (great name lol) in the first place? We have Rust, after all. I mean, creating an optimizing native compiler for any language is not an easy task, there must be some seriously powerful stuff in Clojure to warrant such an undertaking. Or just madness."	burjui	12.640951	-7.893152	comment	3.0	10.0	1660771913	-11.154818
22020043	Ask HN: What Lisp-like language fits	Ask HN: What Lisp-like language fits my needs?	capableweb	12.650172	-7.902671	story	3.0	4.0	1578753003	-11.089506
22087760	Why not Clojurescript? It has access	Why not Clojurescript? It has access to the whole JS ecosystem.	bgorman	12.6467905	-7.844139	comment	3.0	11.0	1579386368	-11.13282
22137681	> I think you may also see Clojure o	> I think you may also see Clojure overtake Scala for the same reason. The simplicity of Clojure may in the long run overtake Scala although Scala benefits a lot from similarity to Java at a superficial level.Correct me if I'm wrong, but didn't Scala overtake Clojure some years ago as the second most popular language on the JVM (second to Java ofc). From my point of view it rarely happens that these trends reverse.Scala has the advantage that it allows OOP or Functional Programming, which Clojure does not.But I do get your point about simplicity. I tried 3 times to learn functional programming by learning Haskell and it never clicked. Then I learned Clojure and who would have thought, functional programming is actually not as hard as Haskell makes it out to be.	Random_ernest	12.421405	-7.767288	comment	3.0	11.0	1579870527	11.913303
22141181	A couple of things to point out for 	"A couple of things to point out for new Clojure readers.The 'def' form should not be used inside of 'defn'. Local bindings should use 'let'.When using the STM, 'ref-set' should not be used most of the time.(def names (ref []))(defn add-name [name]
  (dosync
    (alter names conj name)))The 'alter' function will call 'conj' and the return value will be the new value of 'names'."	nickik	12.628651	-7.894277	comment	3.0	11.0	1579891394	-11.203671
22142321	I'm not familiar with Clojure, but y	I'm not familiar with Clojure, but you can hit conflicts in the Git world, though, which seem to be what the parent is concerned about. Two of us could be creating some new data based on the last data we had, at time T, and then the other person submits theirs at time T+5, and I submit mine at time T+10. In that case, my change hasn't taken theirs into account.	majormajor	12.644209	-7.9038386	comment	3.0	20.0	1579899002	-11.186487
22173615	I believe I'm missing something here	"I believe I'm missing something here or my day was too long, but in Clojure this can be squeezed in 13 lines and 435 characters keeping things fairly readable (for Clojure & Lisp developers ;)).    (defn wc [^String file]
      (with-open [rdr (clojure.java.io/reader file)]
        (apply (partial printf ""%d %d %d\n"")
               (reduce
                (fn [[nl nw nb] ^String ln]
                  (let [words (count (.split ln ""[ ]+""))
                        bytes (alength (.getBytes ln ""UTF-8""))]
                    [(inc nl) (+ nw words) (+ nb bytes)]))
                [0 0 0]
                (line-seq rdr)))))
    
    (defn -main [& args]
      (wc (first args)))


I haven't tested how fast it is, but startup time can be optimized by compiling it with GraalVM."	dig1	12.629942	-7.8820524	comment	3.0	14.0	1580242666	-11.18719
22190646	My default Clojure REPL in IdeaJ wit	"My default Clojure REPL in IdeaJ with Cursive has colour coding, hints from the docs etc. If I type     (set/union a b)

it will auto add the set namespac, it has history etc. Supports paredit.It will also do some autocomplete, although this seems flakey."	LandR	12.638452	-7.896283	comment	3.0	17.0	1580384010	-11.146845
22193919	What languages do you usually use? R	What languages do you usually use? REPLs for languages like python and nodejs are never as integrated and well working as REPLs for lisp languages like Clojure. Probably the structure of the code that lisp almost forces you to have, makes the REPL experience much easier. Especially in Clojure where most functions are side-effect free which means you can run them out-of-context, as long as you've defined the vars it's using since before.	capableweb	12.616893	-7.8623137	comment	3.0	21.0	1580409325	-11.090947
32629634	I am and forever will be a fan of th	I am and forever will be a fan of the scheme (and now clojure) convention of saying foo->bar to say foo to bar. I just think that's swell.	uncletaco	12.645859	-7.890897	comment	3.0	14.0	1661704077	-11.120636
32635457	Can you show one large-ish GUI softw	Can you show one large-ish GUI software written in Clojure? Something like, idk, Blender, DaVinci Resolve, Unreal Engine...	jcelerier	12.649222	-7.892263	comment	3.0	13.0	1661756705	-11.146139
39553938	In my case, it was a regex supplied 	In my case, it was a regex supplied by the user. Elm 0.18 had no support for constructing a regex at run-time. So I made a package that wraps native RegExp. When 0.19 was released, I couldn't upgrade because of those 5 lines.  The regex package eventually got regex.fromstring(). So I could've upgraded. But at the time I was bumping against limits accessing Intl and I really hated the prospect of begging some maintainer for access to a browser api.Elm was the most fun I ever had developing a browser app. Then they decided I shouldn't be allowed to develop a ShootMyFoot module, and it stopped being fun overnight.	lolc	13.010648	-7.6926746	comment	3.0	13.0	1709235285	-12.753964
39554278	> Having the system in Clojure offer	> Having the system in Clojure offers a number of advantages. It is not necessary to obtain or prepare a MIT/GNU Scheme executable to execute: only a Java runtime is required.I still wonder if that is the easiest way to go about it. Isn't it possible to compile Scheme to WASM, for example?	amelius	12.647947	-7.889312	comment	3.0	11.0	1709236901	-11.177761
32684439	Clojure Is a Better Lisp	Clojure Is a Better Lisp	behnamoh	12.659858	-7.8872666	story	3.0	2.0	1662072835	-11.061986
32713433	I’m a long time lisper. Learned Hask	I’m a long time lisper. Learned Haskell ... a couple of times now. It’s interesting and in some cases fun and elegant. But I just kept coming back to Lisp for actual work. Lisp just seems to be at the sweet spot between functional, extensible, and work-a-day, and the parens just make the refactoring experience so fluid that it’s like a drug. (Edit: I want to learn clojure, which should be easy from Lisp. I’ve avoided it bcs the JVM makes me nauseous. But I’m told by my cj-loving ex-lisp hacker friends that you don’t need the JVM. So maybe I’ll try again.)	abrax3141	12.549914	-7.7961617	comment	3.0	10.0	1662301761	-10.75896
32836023	I know nothing about the Java ecosys	I know nothing about the Java ecosystem. Isn't Clojure supposed to be compatible with the JVM and everything that runs of top of it?	sph	12.6459055	-7.889732	comment	3.0	10.0	1663157321	-11.169763
32848366	Ask HN: Where do all Clojure devs wo	Ask HN: Where do all Clojure devs work?	thisiswrongggg	12.660749	-7.898368	story	3.0	6.0	1663226914	-11.167993
16607363	This is the same as recur in Clojure	This is the same as recur in Clojure. It's not general TCO, though, which is much more powerful.I do think it's a shame that Python doesn't have general TCO. It's said to be unpythonic because it means there will be two ways to do things. But some things are so easily expressed as a recursion but require considerable thought to be turned into a loop.	cup-of-tea	12.471619	-7.7815137	comment	3.0	11.0	1521300460	-11.058767
16615398	> That's why I like Clojure's philos	> That's why I like Clojure's philosophy of a few data structures and many functions operating on them.Which in practice means that a few data structures that are not perfect for solving a specific problem are forced (with repeated hammer blows) to bend to the problem. Like the old style LISP AList's used as a map. Probably the worst possible structure for representing a map. But yeah it kinda works as long as you don't have much data.	mbrodersen	12.577691	-7.86254	comment	3.0	10.0	1521419971	-11.14144
16629306	I’ve tried Clojure a little bit and 	I’ve tried Clojure a little bit and it seems like a nice language but I’m not convinced by the lack of types. Why wouldn’t you want types? How often can you reuse a function intended for ‘ints’ with some other type? The way I see it types provide important information to anyone reading the code after it was written as well as to the compiler making it possible to catch bugs early and generate more efficient machine code.	rbjorklin	12.52182	-7.8595695	comment	3.0	25.0	1521559250	-11.1507015
16797285	Took me a while to realize this wasn	Took me a while to realize this wasn't about the Elm email client https://en.wikipedia.org/wiki/Elm_(email_client)	Patrick_Devine	13.007688	-7.694045	comment	3.0	14.0	1523310465	-12.778373
19329849	You can live that dream in clojure l	You can live that dream in clojure land! Clojurescript on the front end, Clojure on the backend, and datalog/honeysql for the database if you'd like. And it is awesome! After using a stack like this I'm spoiled for the slog that is developing in separate languages for each of those things.I think that dream is possible with OS usecases as well, it's just that nobody has made it work yet. And I can't think of a better way to eventually get there than to build it slowly out of free and open source software. It might take a while, but since people have the ability to adapt the software to their needs when it is free, I'm confident with time that it will serve those needs.	robto	12.661355	-7.878106	comment	3.0	15.0	1551978976	-11.148448
19347592	Rust, ClojureScript, Clojure, Racket	Rust, ClojureScript, Clojure, Racket, Elixir, Elm, Reason, OCaml, Haskell	tosh	12.455241	-7.8083124	comment	3.0	11.0	1552155952	-11.130614
19369329	There's a slight bias here: static s	There's a slight bias here: static structures don't help discovering.I actually spend way more time finding out what java objects can do than clojure. The only reason java programmers don't feel this is because someone wrote code to check/suggest what they just wrote. Try writing java without an IDE.ps: and I'd add that simple set of immutable structures plus functional idioms filters a lot of ambiguity from programming too. The other day I had to read java sax attribute API. It was not obvious and a complete waste of time all that for a list of pairs.	agumonkey	12.627637	-7.8858037	comment	3.0	17.0	1552405685	-11.140869
19437487	My limited understanding is that hig	My limited understanding is that high end Unity devs code their stuff not to make garbage. Unity has a very nice system for profiling that sort of thing.Also, CLR has F#, which I like much better than Scala (and, no type erasure in CLR), Clojure which is ... just like Clojure on JVM, and C#, which as a Java dev since 1.1 I have come to prefer as a language even as I remain JVM ecosystem preferring on the server side. JVM has ABCL, a neat Common Lisp, and now Graal/Truffle which is super interesting. If not for Clojure though (and maybe Kotlin) I would probably give up on the JVM. Oracle does not help. Just my opinion.	SomeHacker44	12.606413	-7.8629565	comment	3.0	11.0	1553040007	-11.148258
19440834	Yeah mentioning clojure in a thread 	"Yeah mentioning clojure in a thread where he's active is a surefire way to get downvoted.
That guy hates everything not CL..."	j-pb	12.658886	-7.9076653	comment	3.0	13.0	1553079394	-11.156232
19448716	Ask HN: Anyone want to work on a Clo	Ask HN: Anyone want to work on a Clojure project to learn?	elamje	12.655561	-7.8987365	story	3.0	12.0	1553133720	-11.145161
19469149	Clojure Socket Prepl Cookbook	Clojure Socket Prepl Cookbook	bsg75	12.647077	-7.9217863	story	3.0	83.0	1553317729	-11.122197
19479033	This is just blaming people for usin	This is just blaming people for using Clojure's features though. If deep JVM integration wasn't a selling point, you'd use a vastly more mature Lisp, right?	thom	12.634726	-7.8683577	comment	3.0	12.0	1553464890	-11.182245
19479577	Clojure lets you leverage the entire	Clojure lets you leverage the entire Java library ecosystem, which is flippin' huge -- bigger, even, than Python's.	bitwize	12.644947	-7.891135	comment	3.0	10.0	1553474480	-11.126313
19480652	I really don't understand this point	I really don't understand this point about just using Java libraries in Clojure. Why not just use Java? Wouldn't the experience of writing Clojure that fits the Java library's model be horrible?	john2x	12.649793	-7.898396	comment	3.0	10.0	1553495177	-11.171489
19480731	For someone familiar with HTML/XML, 	For someone familiar with HTML/XML, so any developer in the last 30 years, yes it is. Your point being?I like the ideas behind clojure, I really do. I even wrote a non-trivial personal project with it. However, coming back to that code after two months was basically like the plot of Memento. I ended up rewriting it in JavaScript instead.	doteka	12.652127	-7.8848724	comment	3.0	12.0	1553496845	-11.176021
19482378	Clojurists Together: $3000 USD/month	Clojurists Together: $3000 USD/month grants for Clojure open source projects	dragandj	12.659503	-7.901747	story	3.0	149.0	1553522018	-11.164345
19615737	I get to do Clojure about ~60% of th	I get to do Clojure about ~60% of the time at work now, and it never ceases to amaze me how much easier it is to deal with concurrency than in vanilla Java.Futures and Promises and core.async don't allow you to totally avoid planning out your project (I've been bitten slightly by core.async's `go` blocks behaving differently than Go's goroutines), but they are a godsend compared to dealing with manual mutexes and semaphores.I still need to play with manifold; I hear that it helps deal with the IO-heavy stuff that core.async chokes on.	tombert	12.480938	-7.8405757	comment	3.0	46.0	1554824359	9.339437
19664692	Deep Learning in Clojure from Scratc	Deep Learning in Clojure from Scratch to GPU: Learning a Regression	dragandj	12.632211	-7.8941307	story	3.0	120.0	1555329692	-11.203032
19672991	The table of content of the series i	The table of content of the series is at:https://dragan.rocks/articles/19/Deep-Learning-in-Clojure-Fr...If you want to be notified about the book, please subscribe to the newsletter at the bottom of the page.	dragandj	12.657781	-7.908803	comment	3.0	10.0	1555417313	-11.181513
19676341	Mathematica is a great tool. But in 	Mathematica is a great tool. But in my case, there are two huge pain points which limit my use of Mathematica:1. Horrible REPL experience. Yes, the notebook interface can display graphics, cool. But I would take Emacs with paredit over it any day. After structurally manipulating Clojure code in Emacs with paredit, using the Mathematica interface is like a throwback to the 70s. You mean I need to balance and match my parentheses myself?! Seriously? Debugging larger expressions is like stabbing yourself in the eye with a dull spoon.2. Badly designed data structures, specifically maps (also known as hashes or associative arrays). This is the most universal data structure, that can be used for almost anything, storing mappings from keys to values. Using maps in Mathematica is awkward and feels	jwr	12.606885	-7.8430943	comment	3.0	11.0	1555441408	-10.991894
19679342	"> nobody's done a ""Commonwealth of C"	"> nobody's done a ""Commonwealth of Clojure""Higginbotham, Daniel. Clojure for the Brave and True.https://www.braveclojure.com/"	bsg75	12.658339	-7.911953	comment	3.0	13.0	1555469387	-11.195837
19715906	Nice to see some lisp lovers in the 	Nice to see some lisp lovers in the frontend world. How does clojure handle types though, how would you argue with a typescripter for clojure rather than typescript ?	globuous	12.61175	-7.878996	comment	3.0	10.0	1555899738	-11.141929
19728145	I think it's the other way around: C	I think it's the other way around: Clojure gained more exposure than past Lisps because it runs on the JVM.But it's still definitely niche and hardly used anywhere.	hota_mazi	12.663126	-7.8882837	comment	3.0	27.0	1556024491	-11.099296
19728447	>Groovy, Scala and Clojure were the 	>Groovy, Scala and Clojure were the early contenders that people were exploring and Clojure seems to have won.I love Clojure and hope it gains more mindshare, but I don't think this is accurate. Scala currently enjoys quite a lot more industry use than Clojure does, for instance there are currently roughly 15x as many postings mentioning Scala as there are Clojure (source: Linkedin.ca).	joshlemer	12.646232	-7.8901043	comment	3.0	10.0	1556026939	-11.159108
19876638	Polyglot Ruby is invoked from Clojur	Polyglot Ruby is invoked from Clojurescript which transpiles to JS which runs on GraalJS implementation running on GraalVM extension to the JVM?this is both impressive and terrifying.	keymone	12.568767	-7.7150154	comment	3.0	16.0	1557485490	-11.131114
19917414	Permitting arbitrary annotations is 	Permitting arbitrary annotations is a rather nice feature that, besides static analysis, opens the door for expressive runtime pre/postcondition checking functionality like the Clojure spec library[1]. Does Python have something similar?[1] https://clojure.org/guides/spec	Sharlin	12.606897	-7.880709	comment	3.0	11.0	1557909021	-11.155178
19953820	I've done way more Clojure than any 	"I've done way more Clojure than any other Lisp, and I'm now transitioning to Racket. Primarily, because I want to get away from the JVM. One thing about Clojure that is not easy to put into words, and that I miss, is just how ""smooth"" working on it is. The Clojurisms, as they come to be known, are very well thought out, and the whole language fits together like a perfect puzzle, or at least in my experience. To come back to the JVM thing, I find that Clojure is applicable only serverside, where you can have the slow starting hundreds-of-megabytes JVM running non-stop, or in the browser, through ClojureScript, and it's really perfect for those environments. Though as I shifted more towards non-server environments, and I need to use FFIs, Racket is the right blend of expression and performan"	dmos62	12.660978	-7.860305	comment	3.0	10.0	1558280534	-11.088541
33018281	Clojure is not dead, the core langua	Clojure is not dead, the core language is still very strong,  but the dev experience has been degrading IME. This is due to a lack of heavy corporate backing and investment, probably by choice. Taking a PL to the mainstream is very expensive.You cannot compare Clojure and Rust in any way as they're completely different design philosophies.	pyb	12.627424	-7.8918233	comment	3.0	26.0	1664444563	-11.174389
33018763	I am learning Clojure right now and 	"I am learning Clojure right now and I can relate to the feeling of not wanting to put time and effort into it if there is no marketable value in return.  One thing that is motivating me is I read an article about how niche languages can be lucrative.  (I want to say that article was here on HN but too lazy right now to search for it).  The other thing that is motivating me is that this type of programming and thinking is completely different to mainstream PLs.  It is a fun and challenging exercise and my hope is that it will benefit me in ""normal"" PL like everyone says it will.I do have a vague (unrealistic??) idea of maybe getting a PT job using Clojure after studying for a year or so.  PT because my FT job has amazing benefits and career potential.  We will see.  As of right now I am jus"	fm2606	12.651593	-7.894042	comment	3.0	10.0	1664448362	11.087016
33018862	Here is the Google Trends Comparison	Here is the Google Trends Comparison of Clojure, F#, Rust and Scala.https://trends.google.com/trends/explore?geo=IN&q=%2Fm%2F03y...Rust is 4-5 times more popular in searches that Clojure and F#. Interestingly Scala is around 3 times more popular than Rust in searches.	pritambarhate	12.50839	-7.846543	comment	3.0	12.0	1664449255	-11.150156
33019940	I mean compared to a few years ago. 	"I mean compared to a few years ago. I tried setting up a new project after 1 or 2 years away from the ecosystem, and struggled a lot : all existing templates to set up new projects (esp. with CLJ/CLJS combined) had bitrotten and were not usable out of the box ; emacs integration no longer working out of the box, etc.I think it's a ""death by a 1000 cuts""/""broken windows"" that is may be happening when the ecosystem lacks funding to take care of the boring maintenancey stuff. If I remember well, this is a conscious choice by Rich Hickey, a choice that one should respect, but will prevent Clojure from ever getting to the next level IMO."	pyb	12.653432	-7.8965425	comment	3.0	20.0	1664456277	-11.169946
33020524	Yeah, Clojure is not great for CLIs,	Yeah, Clojure is not great for CLIs, but pretty much every other use case it excels at. For CLIs, there is always Babashka (https://babashka.org/) which works good enough.For local development, you usually just compile+eval one function at a time as you change them, and those happens under 1ms, not enough to even notice (unless you develop with a remote REPL, but then network is to blame)For server usage, you usually compile once in CI and put the resulting binary/JAR on the server. A few seconds for startup matters less in those cases.The drama of slow Clojure startup is wildly overblown, because basically for no other use case than writing CLIs, does the startup time matter so much it becomes a problem.	capableweb	12.650684	-7.8856044	comment	3.0	27.0	1664459108	-11.167895
33020217	Clojure is a wonderful language, but	"Clojure is a wonderful language, but not so wonderful that I can tolerate its slow startup and compile times. I think lots of developers think the same way. Imo any language nit facilitating fast startup and compile is stillborn. Imo the same goes for any language requiring you to setup a ""project"" or something to get started."	bjourne	12.6389	-7.886574	comment	3.0	30.0	1664457585	-11.157672
33022423	I moved away from Clojure to Common 	I moved away from Clojure to Common Lisp. The Clojure culture doesn't take seriously developer experience, good documentation, easy getting started pages etc. Plus you have to deal with the JVM and slow compile cycles.Compared to that Steel Bank Common Lisp is rock solid and just works. Even the libraries and documentation are fewer but better.I did learn a lot from watching Rich Hickey's talks so there's that.	ilrwbwrkhv	12.658882	-7.8783603	comment	3.0	10.0	1664466834	-11.020309
33055745	I have used Clojure on and off for p	I have used Clojure on and off for probably 7 years. But when I tried to distribute my program which was a CLI tool, it proved incredibly painful. Clojure startup time is really bad over a second in the best case and it gets worse the more libraries you include. This is not a problem if you are writing a web application, but it's terrible for command line applications. The community seems thoroughly disinterested in solving this problem except with graalvm's native-image. I've done that route and believe me it's so painful.Common Lisp has everything Clojure has. It feels like Rich Hickie took everything that he liked about Common Lisp and put it into Clojure.  Many of the functions in Clojure were basically copied from Common Lisp: if-let, conj(oin), disj(oin) are some examples of core Clo	djha-skin	12.654154	-7.8822527	comment	3.0	15.0	1664717611	-11.0110235
24799675	A simple group-by-and-agg speed comp	A simple group-by-and-agg speed comparison inc. Clojure, Pandas, R and Julia	akhong	12.540829	-7.7706456	story	3.0	4.0	1602847531	-11.149463
24931432	I wrote a Rust / tree-sitter program	I wrote a Rust / tree-sitter program to detect reify usage in Clojure code a while ago: https://github.com/borkdude/analyze-reify (partially for learning Rust but also performance is really nice). I wanted to extend this to more advanced patterns and do it in Clojure itself, because that's what I'm most productive with.The reason I wanted to know more about this specific pattern is to answer the question if it's relevant enough for scripting. If so, I should probably support that in my Clojure interpreter (https://github.com/borkdude/sci) which is used in babashka (https://github.com/borkdude/babashka), a fast starting scripting environment for Clojure.After seeing Grape (https://github.com/bfontaine/grape) I connected the dots and figured I 	Borkdude	12.599996	-7.906486	comment	3.0	11.0	1603984676	-11.149603
24943481	I don’t know. I worked in Clojure fo	I don’t know. I worked in Clojure for several years, and very seldom hit the REPL. I spent most of my exploration time in tests. In TypeScript, I split most of my exploration time between types and tests. Occasionally I hit the Node REPL, or the Chrome console. But doing speculative work in an editor, with all its features, has always felt a lot more productive to me. Maybe that’s why I ended up drifting away from Clojure anyway.	eyelidlessness	12.6372595	-7.8752627	comment	3.0	12.0	1604073075	-11.124343
25029474	I think JavaScript/Clojurescript is 	I think JavaScript/Clojurescript is the exception because they control the runtime and JIT: whether or not you buy their explanation, I think the reason they state is that this is to enable sandboxing. This is at least plausible to me: to have effective sandboxing, you need to restrict the APIs that a device can call, which means blocking the ability to generate and run arbitrary machine code on-device.	fiddlerwoaroof	12.637324	-7.833115	comment	3.0	12.0	1604872683	-11.084079
25048057	As someone who uses .NET daily, but 	As someone who uses .NET daily, but loves Clojure and other functional programming paradigms - Records seem like a very compelling feature. Immutable data structures without any hassle to set up. Simply write “record” where you would normally write “class” and boom, you are working with immutable objects. This is one step closer to one the best features of Clojure IMO -everything is immutable.Additionally, there seems to be another new way to accomplish this. Normally class properties are accessed via get; and set;Now we have the ability to use get; and init; which effectively makes the object immutable/read only after initialization. The syntax is just a little cleaner and more obvious to the reader how the property should be used.C# has really been adding some great features the past few	elamje	12.584955	-7.854048	comment	3.0	24.0	1605027269	-11.148807
25094091	I've only recently started to pay at	I've only recently started to pay attention to Elm after hearing some good things about it so this article was timely for me. I've also dealt repeatedly with the example the author uses, a wizard or multistep form, so I was definitely interested to see how it played out.And I was nodding my head in rhythm with the author until he got to the section on lenses. He writes:That’s 14 lines of code to update one single field. Not only is this single example somewhat confusing to follow, you also need to imagine how this update function will look when taking into account the five or so other fields just in the address record! This is — quite frankly — pretty terrible. The trick here is not to stare out of the window and contemplate rewriting everything in ClojureScript. Instead, the thing to do i	klenwell	12.434596	-7.7588773	comment	3.0	12.0	1605376789	-11.113186
25307181	I wonder how elm and clojurescript a	I wonder how elm and clojurescript are doing?	Scuds	12.910302	-7.6933203	comment	3.0	14.0	1607112922	-12.703304
25343431	Massive problem? That's news to me. 	Massive problem? That's news to me. But what do I know, I've only been writing Lisp for more than a decade.On the other hand, the Clojure kids seem to reinvent programming badly while maligning other Lisps (see blog post), so maybe they do have a massive problem with trivial things like indentation.	bluefox	12.6531925	-7.889332	comment	3.0	24.0	1607419782	-11.06166
25343710	I would call the fixed indentation j	"I would call the fixed indentation just plain wrong in the examples. No lisp-aware editor will indent it like that. They specify a couple core forms that have a body, which is indented ""semantically"" and the rest is treated like functions where new lines are indented to the first argument.Outside (apparently) clojurespace there has never been any bigger disagreement whatsoever regarding this.The article mentions this. But why was there ever a discussion? The hoards of non-lispers going to clojure?"	bjoli	12.646417	-7.884195	comment	3.0	10.0	1607423640	-10.976433
25343787	I think the Clojure people tend to p	I think the Clojure people tend to produce unreadable mess, which tells me the design of their language is down in the gutter.  Common Lisp is a language with a lot of warts, sure, but typical Common Lisp code is way, way, way more tasteful than typical Clojure code.We like our multiparadigmness, thank you very much.  That includes being able to mutate things.  We also like that the language is stable, and that means no changes to the spec, and that means it won't cover everything.  That's OK, because our spec covers more than enough.  We have less stable libraries and implementation-specific interfaces to cover the rest.  We are still pretty conservative with those, too.Clojure doesn't have a spec at all (it has documentation for the single implementation; it seems to have another impleme	bluefox	12.647826	-7.889998	comment	3.0	16.0	1607424626	-11.132634
25375576	Tangentially:I recently decided to g	Tangentially:I recently decided to give Pharo a try. I'm still pretty early on in it, but, so far, I've really been having fun. If you look at it the right way, Smalltalk can almost be seen as more Clojure than Clojure. It's even more dynamic, and the live programming environment gives even tighter, more integrated feedback loops than REPL-driven development. Smalltalkers aren't exaggerating when they say you can literally program from inside the debugger.A lot of familiar programming idioms from Clojure (and other functional languages) are present in Smalltalk, and have been for years. And, while objects in Smalltalk are nearly as dynamic as maps in Clojure, the fact that they're discrete, named entities makes it a lot easier to inspect and grok someone else's code.It's not all perfect, o	mumblemumble	12.558882	-7.7576413	comment	3.0	14.0	1607618984	-11.021015
25375911	This will probably earn me lots of n	This will probably earn me lots of negative points, but I used Java for eight years and after much initial enthusiasm came to despise it. It was the least productive language I have ever used. I have twice tried to learn Clojure and each time I have to install the JVM, I simply quit, despite being intrigued by Clojure itself. Sigh.	talkingtab	12.644119	-7.8876433	comment	3.0	16.0	1607620752	-11.181123
25376497	I suppose the argument would be that	I suppose the argument would be that only developers with a modicum of interest in their craft will gravitate towards niche languages such as Clojure. But you are correct that doing so doesn't necessarily mean they are good.However, I don't think it follows that great developers work on hard problems. Why can't you be a great developer working on CRUD apps and occasionally finding ways to do them better?	bambataa	12.640497	-7.874401	comment	3.0	20.0	1607623721	-11.16233
25376922	It's interesting to see so many peop	It's interesting to see so many people complain that it's hard to hire Clojure engineers, when I've had the exact opposite problem...trying to find a Clojure shop to join. They are few and far between, and the few that are hiring say that they will take folks that are new to Clojure, but then are baffled when you don't know how to idiomatically solve whiteboard problems.Clojure remedies all of my problems with previously used languages (Basic, C, Java, ObjC, Javascript, Python), in that it allows me to remove boilerplate and create layers of abstraction that are appropriate for problem solving.  It's also a fairly opinionated language, preferring functional programming methods that work with how I like to solve problems.  This is refreshing, as it feels like I can bypass all of the style w	nanomonkey	12.6395235	-7.881786	comment	3.0	18.0	1607625972	-11.140528
25379362	> Well I don't know how accurate thi	> Well I don't know how accurate this is, but in 2019 Stackoverflow survey, Clojure practitioners averaged the highest pay of any languages.Well I didn't believe it, but wow: https://insights.stackoverflow.com/survey/2019#top-paying-te...I'm not sure if I should conclude that I'm incredibly ignorant of the engineering market, or that Stack Overflow's survey is not representative.It makes me suspicious that Clojure is shown as the most highly paid language at $90k. Basically any non-new grad developer in a high cost of living area earns more than that, regardless of the language. I'm also suspicious that only 1.4% of survey respondents use Clojure, which may show a bit of a base rate fallacy here.What would be the explanatory thesis for Clojure programmers being the most highly paid? None o	fractionalhare	12.653675	-7.9000072	comment	3.0	10.0	1607637779	-11.179616
25380454	Compared to other languages, I've fo	"Compared to other languages, I've found Clojure makes it much easier to iteratively turn an idea into code.Say you're writing a pure function...You start with just data and a sense of how the output might look. Let's say I have APIs providing me with a user record and a list of transactions, and I want to get that person's balance...Maybe you start with some canned data        (let [person {:name            ""Matt""
                      :id              12345
                      :current_balance 100.10}
              txns   [{:person_id 12345 :amt 10}
                      {:person_id 44444 :amt 0.5}
                      {:person_id 55555 :amt 10}
                      {:person_id 12345 :amt 11}
                      {:person_id 12345 :amt -5}
                      {:person_id 66666 :amt"	mbil	12.632197	-7.8937035	comment	3.0	16.0	1607644516	-11.157076
25497486	While I definitely agree Rust is a m	While I definitely agree Rust is a much faster language than Clojure, I would be interested to see benchmarks on your code that show just how much faster your Rust code was on the same data.I also noticed that you mentioned avoiding lazy sequences is not idiomatic in Clojure. I disagree with this since using transducers is still idiomatic. I wonder if you could've noticed some speed improvements moving your filters/maps to transducers. Though I doubt this would get you to Rust speeds anyway, it might just be fast enough.	chrisulloa	12.610517	-7.89579	comment	3.0	36.0	1608573697	-11.152669
25497763	A bit sad there was no profiling don	A bit sad there was no profiling done, or at least the article doesn't mention it. Maybe optimizing Clojure wouldn't have been that hard, could have been only a few places needed tweeking. In any case, Rust is obviously targeting high performance in a way Clojure isn't. Rust is faster than Java, and Clojure can only ever match Java in performance, not exceed it. But still, it's not clear if the author tried to optimize the Clojure version or not?	didibus	12.6198845	-7.894086	comment	3.0	15.0	1608575223	-11.143989
25501955	That's a very common scenario  for C	That's a very common scenario  for Clojure users to go through and it's one of the reason it has so many abandoned/unfinished libraries (although 7 years was a lot). After they have gather all the insights they can from Clojure and its ecosystem (which is a worthy endeavor IMO), they go back to their big ecosystem mainstream programming language because of all the benefits you get from it even if that programming language is worse. It also doesn't help Clojure the fact that JS 2020 is way better than JS in 2010 and that you can easily bring all your Clojure insights/concepts to JS.	ithrow	12.650663	-7.8801146	comment	3.0	11.0	1608601522	-11.162207
25623163	The JVM interop is a huge positive f	The JVM interop is a huge positive for Clojure, in my opinion.Being able to consume any JVM library makes Clojure usable in many more professional settings than Haskell.	cdmckay	12.638753	-7.8849826	comment	3.0	24.0	1609694617	-11.1824465
25623317	Yeah, that makes sense. If the kille	"Yeah, that makes sense. If the killer app is JVM interop, nothing but JVM based languages should even be on the table. The ""why Clojure?"" question just becomes ""because Clojure is the best language on the JVM,"" which is not too interesting of a topic IMO.Haskell has decent interop with C/C++ languages, but certainly nobody uses haskell because of that."	johnday	12.618013	-7.870825	comment	3.0	19.0	1609695669	-11.167204
25623974	I've only dabbled with GHCI. I've us	"I've only dabbled with GHCI. I've used it as a standalone REPL for trying out small things, the same way I'd use a Python or Javascript REPL. I haven't used the REPL /the/ developer interface to the program. In Clojure, I would (1) start a REPL server, (2) connect to it from my editor, and (3) send expressions to it. I didn't develop Haskell that way, though I think it was possible with Intero[1].Within the Clojure community, there's a perception that the Clojure REPL is one of its strongest selling points[2].Are you using the REPL actively when developing?Edit: really curious about the ""-- >>> expression "" syntax! I might have to give Haskell another go.Edit 2: Example of this interaction in practice with VSCode[3][1]: https://github.com/chrisdone/intero#readme
[2]: https://clojure.org/gu"	teodorlu	12.592969	-7.8646784	comment	3.0	10.0	1609699799	-11.084995
25624187	I don't see a future for Scala. Sinc	I don't see a future for Scala. Since Java got lambdas and var, enough of the pain is gone that Scala ends up adding its own pain. And now there's Kotlin if you really want to avoid boilerplate and not deal with sbt.Clojure is actually designed as a functional language and not as multi-paradigm as Scala.	dehrmann	12.406922	-7.735552	comment	3.0	19.0	1609701173	11.924583
25624015	> The entire syntax for Clojure fits	> The entire syntax for Clojure fits in a single line.But some of us absolutely don't like this syntax. The small bits of Java in the article are very readable in comparison.	p0nce	12.64289	-7.89493	comment	3.0	12.0	1609700036	-11.147267
25657181	My impression is that Clojure has fo	My impression is that Clojure has found a niche, for better and worse.Back when I looked into it, I loved the lispyness but the JVM underneath it never quite 'clicked' and there was something about the ecosystem/community that wasn't so much bad as much as it left me ambivalent.Then I looked into Elixir and it just 'clicked'. From what I understand, its creator, Jose Valim, took a /ton/ of inspiration from Clojure.I still watch Rich Hickey's talks and when I have more time, I really want to take a deeper dive into Clojure, so I by no means want to reflect negatively on my experience with it so far. Just an anecdote.	mercer	12.6577215	-7.9016433	comment	3.0	10.0	1609936912	-11.147791
25691064	"This reads a bit like ""why you shoul"	"This reads a bit like ""why you shouldn't use clojure"" to me. I'd expect to leave some performance on the table when writing idiomatic code in a dynamic language with immutable datatypes, but a function that's already specialized to arrays, as the name indicates, taking 3 orders of magnitude too much time? 1-10 microseconds to say ""get me the length of this java array, and BTW this is a java array""? What on earth is going on there?Edit: So I just ran the author's (alength (long-array 5)) (with the indirection to foil type inference) and got 10µs mean execution time in criterium. By contrast here's some roughly equivalent python:   In [5]: a = array.array('l', [5])                                                                                                                                 "	patrec	12.643005	-7.897569	comment	3.0	16.0	1610143114	-11.143712
25699771	The line which sprung out most to me	"The line which sprung out most to me was the one claiming that ""Clojure took the world by storm"". This is simply not the case. JavaScript has taken the world by storm, as has Python. Ruby, PHP and others have taken the world by storm before and are slowly fading. Clojure has never taken the world by storm and (IMO) never will. Neither will Haskell btw.To me, Clojure is very much on the same level as Haskell: an extremely niche programming language with a small (sub-1% in TIOBE) but dedicated following that is unlikely to grow much beyond what it already is.Rest of the article: meh. It presupposes a lot of what it thinks Haskell should aspire to without investigating whether those things are actually what it is aspiring to be."	WJW	12.601906	-7.8969274	comment	3.0	16.0	1610194954	10.47685
25699816	Can you use it to write code that wi	"Can you use it to write code that will be used (compiled) both server-side and client-side?Because these days this is my bar for a language that is ""nice for building web applications"". I've gotten so much mileage out of Clojure+ClojureScript just because of this, it's not even funny."	jwr	12.653713	-7.8819237	comment	3.0	12.0	1610195363	-11.172025
25699918	> Look at Clojure. Weird parentheses	> Look at Clojure. Weird parentheses, and yet it took the world by stormAm I on another planet ? I'd rate clojure slightly above haskell in terms of market share. Is my radar broken ?	agumonkey	12.61181	-7.9015384	comment	3.0	15.0	1610196327	10.488073
35729502	>used Clojure fulltime for five year	>used Clojure fulltime for five years.How did that work out for you?  Usually following a hype cycle, there is a negative hype cycle i.e. Mongo is webscale, then Mongo is a buggy mess.Clojure seemed to just fade away. Did it turn out well or are there interesting pitfalls that make it not as great as advertised?	stonemetal12	12.657673	-7.9029446	comment	3.0	14.0	1682608969	-11.16332
35740940	This sounds awful to google for, I g	"This sounds awful to google for, I guess if you do ""Clojure Morse"" it might work. The other nitpick is, if you're ever introducing a new language, regardless of context, throw some code samples, like a simple applicable ""hello world"" at a minimum.And because someone has to...""Can I look at your Morse code?"""	giancarlostoro	12.61255	-7.8458223	comment	3.0	14.0	1682687898	-11.06735
28831300	How are mentioned three inferior to 	How are mentioned three inferior to Clojure and Clojurescript? What if you need performance or a bit less of maximalism in the community... Or even a community at all and libraries and support?	Keyframe	12.648072	-7.8923	comment	3.0	11.0	1633976816	-11.162407
28853192	I'm making an editor, Freja, which i	I'm making an editor, Freja, which is like a tiny Emacs with graphical support. Makes it fun to create gui apps and games. :)Ultima Underworld inspired game I'm making for a game jam: https://youtu.be/1fWsV83P-S8Demo of pixel editor: https://www.youtube.com/watch?v=KOBi805nxNcFreja: https://github.com/Saikyun/freja---My experience has overall been very nice. I come from Clojure, and comparing to that:- so nice and small! Clojure is great but has a lot of baggage from JVM, for good and bad- very easy to get started interoping with C. You need to manually wrap libraries, but I think it's pretty easy. As a benefit, you are able to throw exceptions from C that can be catched from Janet. The C support is what sells me on Janet over Clojure- repl:ing works well, but you can get tripped up by ear	saikyun	12.6461115	-7.8909388	comment	3.0	14.0	1634137959	-11.127552
28898604	Neat! Surprised to see so many resul	Neat! Surprised to see so many results for Clojure. The mobile UX is pretty hellish, though. I’ll have to check it out again on desktop.	tytrdev	12.656358	-7.8974657	comment	3.0	13.0	1634495483	-11.189283
28909475	What makes CL/Clojure really work is	What makes CL/Clojure really work is that your editor (emacs usually, but there’s other options now) connects to the live program and has access to the entire runtime environment. So, you can do a lot of the things other languages need static types for via introspection (e.g. autocomplete: CL just asks the running program what functions are available that matches the current pattern and returns a list).Secondly, since I’ve learned statically typed languages, I already have a mental model for how they make you structure your code, except dynamically typed languages make patterns easy that would require something like dependent types to check (see how complicated Typescript is, because it has to be able to model JS idioms). My experience is that a lot of the value of static types isn’t in th	fiddlerwoaroof	12.533157	-7.863071	comment	3.0	12.0	1634582101	-11.13179
34266998	Tail call optimization can get you t	Tail call optimization can get you that, too. If you've written Scheme and/or gone through SICP you might be familiar with this: you write a recursive function, with the recursive function call as the last thing the function does ('tail-recursion'), and the compiler/runtime is able to optimize those recursive calls out rather than consuming one stack frame of space per call ('tail call optimization'). Clojure has loop/recur at least partially because it doesn't support tail-call optimization.See https://en.wikipedia.org/wiki/Tail_call for more. Or SICP might be a good resource. https://sarabander.github.io/sicp/html/1_002e2.xhtml	wging	12.438797	-7.779272	comment	3.0	19.0	1672954455	-11.092796
23419023	A great quote from the introduction,	A great quote from the introduction, on why Rich took a sabbatical to work on Clojure:...to give myself the opportunity to work on whatever I found interesting, without regard to outcome, commercial viability or the opinions of others. One might say these are prerequisites for working on Lisps or functional languages.	adamkl	12.645633	-7.8977356	comment	3.0	19.0	1591289932	-11.139679
23419624	Same here: having gone from C++ to J	Same here: having gone from C++ to JS+Python and back to Golang/Rust, I just can't imagine life without types.However, of all the not-static-typed language ecosystems I see, Clojurists seem to miss types the least. I have dabbled with the language and I know about `spec` but I don't quite seem to grasp why even shops using Clojure without spec don't seem to miss types much either.Perhaps people more experienced with Clojure can shed light on this?	hannofcart	12.546993	-7.8688254	comment	3.0	12.0	1591293152	-11.151701
23419855	An idle wonder: one non-criticism of	"An idle wonder: one non-criticism of Clojure (and lisps in general) is ""the parens.""   Anyone who's used Clojure finds that a) this is totally handled by the editor, and b) the parens are actually an advantage, because all language structures are the same, which means the same hotkeys, etc, can be used universally.Now the reason I mention this is:  I ""hate"" static types.  But then again, the only place I've actually used them was when writing Java in plugin-less Vim in college ten years ago.Am I the outsider who just got a bad taste because I was lacking proper editor/IDE support?"	invalidOrTaken	12.653484	-7.893466	comment	3.0	10.0	1591294296	-11.102479
23419961	Prior to Clojure I feel that I didn'	"Prior to Clojure I feel that I didn't really know how to do things well.In the context of the domain I have the most experience with, web applications, I'd summarize the bulk of programming as defining data, data transformations and shoving data through APIs. Once you get the hang of it, Clojure makes it trivial to transform datastructures from A to B. This has enormously expanded the kinds of problems I can solve.When Rich says
""It was impossible to
avoid the sinking feeling that I had been “doing it wrong” by using C++/Java/C# my whole career.""I feel somehow that this is the case for the majority of people but they don't realize it yet because their experience is the most popular trendy language or framework. I've seen many examples of libraries in different languages having enormous amo"	Naomarik	12.59973	-7.8385277	comment	3.0	144.0	1591294921	-11.113418
23420134	> Python does the same thing but wit	> Python does the same thing but with CDon't think that's really accurate.You don't have to use C with Python, and there's no VM to worry about. CPython* just happens to be the most popular implementation.Clojure (by and large)* requires the whole Java infrastructure, and that is a nonstarter for many.	airstrike	12.632387	-7.8774385	comment	3.0	10.0	1591295787	-11.175534
23424208	I fell in love with Clojure and fell	I fell in love with Clojure and fell out of it. It is a great language. Lisps have this inherent elegance to them especially in data transformation pipelines.That said I found its performance still a bit on the wanting side particularly if you avoid type hints. For many tasks the performance is probably acceptable but the backend work I tend to do makes the abstract style get in the way of trying to figure out performance issues.Also I'm coming around to the imperative style more and more. Sometimes a for loop is all that's needed and makes for a more understandable code than all those hipster maps and folds.	abraxas	12.619561	-7.877741	comment	3.0	19.0	1591321824	-11.122105
23425396	I also found that Clojure is full of	I also found that Clojure is full of weird edge behavior. Sets are unsafe, and might change the type on you. Seq leaks like a sieve, so there are all kinds of places where you have to map seq, and type hinting is the worst. The moment you type hint a Protocol, all kinds of weird shit starts to happen, including the need to import the type hinted classes in the consumer (except Java.util.*), even if you don’t reference it. Oh, and if you type hint protocols wrong, it doesn’t error, but your performance remains bad.At least it did in 2017. I haven’t used it since then.	ashtonkem	12.6233015	-7.8880877	comment	3.0	11.0	1591335459	-11.153185
23512075	Then don't come near the Clojure com	Then don't come near the Clojure community either, that's the most cultist one I have encountered.	Scarbutt	12.6581135	-7.9091907	comment	3.0	12.0	1592077188	-11.156139
23580317	Interesting.  Lisp is hard not becau	"Interesting.  Lisp is hard not because of the language. I read the source code and unlike python etc it is straightforward.but the setup is hard.  Clojure setup is still a bit hard. But at least package management is 
Easy. Asdf ...The most difficult issue is it is more or less pure.  Whilst the c external interface seems easier. But it is not designed from ground up as one of the language in a system. JavaScript sort of work with HTML and CSS and not dealing with this.  You do have canvas. But not for simple terminal io like this.Somehow it is kind of lost on space experience. Great language and great ecosystem. Just out there, alone and for their own kind.But nice to read. Still find it hard to read python after writing. Even there is only one way to do so."	ngcc_hk	12.657498	-7.862755	comment	3.0	10.0	1592612397	-11.044771
23637862	I'm also wondering the same thing, a	I'm also wondering the same thing, after the whole Elm meltdown I've been looking for something similar to learn on the side.	jamil7	13.013023	-7.6939564	comment	3.0	12.0	1593070445	-12.764596
23638545	Did someone say concise? Here is a C	"Did someone say concise? Here is a ClojureScript + Reagent example for whoever is interested in that:  (defn Counter [{:keys [label counterType onClick]
                  :or {onClick (fn [])}}]
    (let [count (r/atom 0)]
      [:button
        {:onClick #(do (swap! count (condp = counterType
                                      :increment inc
                                      :decrement dec))
                       (onClick))}
        (str label "": "" @count)])))"	diggan	12.628289	-7.7540717	comment	3.0	15.0	1593076537	8.623126
23698223	Oof that XR bug was a rough one to r	Oof that XR bug was a rough one to run into. If you're a small startup trying to move fast with CLJS, these kinds of impedance mismatches between GCC/CLJS/browser versions can be both hard to track down and a time killer to fix.I really like CLJS, when it works it really feels like you have superpowers - immutable data structures and higher order functions being idiomatic in Clojure makes Reagent more ergonomic than React in vanilla JS.Additionally the Clojure philosophy of embracing the host makes interop feel quite ergonomic when you do need to duck down into JS.That said, I wouldn't say that the CLJS->JS compilation is watertight (especially with advanced compilation turned on) and in any non-trivial project you will run into issues as outlined in this blog post. Once you are familiar w	djtango	12.651501	-7.8822036	comment	3.0	10.0	1593583136	-11.152651
19973599	Not only would I not call Clojure a 	"Not only would I not call Clojure a ""proper lisp"" but since it doesn't run any Lisp code and lacks fundamental Lisp data structures (e.g conses), I wouldn't even call it a Lisp."	armitron	12.667335	-7.8877873	comment	3.0	24.0	1558465186	-11.055154
20036915	This book is my attempt to make Cloj	"This book is my attempt to make Clojure more accessible for newcomers.
The book teaches at a digestible pace the syntax and the main concepts of the language, in particular data immutability which is at the core of the language.This is part of a ""Get Programming"" series by Manning, which means that the reader is guided from concrete to abstract until the ideas are fully integrated.This book takes a pragmatic down to earth approach:- Lots of code snippets in each Lesson- Several exercises at the end of each Lesson- A Capstone Project at the end of each UnitThe book is in MEAP (Manning Early Access Program) stage which means that for now only the digital version is available and 5 out of 16 Units are published. (When a new Unit is published, the reader gets notified.)Hopefully you'd find int"	viebel	12.653556	-7.902154	comment	3.0	16.0	1559104985	-11.169457
20074357	Java is statically typed. Clojure is	Java is statically typed. Clojure is not. To me, this is the biggest difference and the reason to choose Java.	ian1321	12.604855	-7.8833756	comment	3.0	13.0	1559466652	-11.193699
20074388	These Talebian references got me thi	"These Talebian references got me thinking. Couldn't you argue that it shows a certain arrogance and non-results oriented ""falling in love with ideals and tools"" detachment from reality to use Clojure instead of good ol' Java?"	Shmebulock	12.653608	-7.90592	comment	3.0	16.0	1559467426	-11.1866455
20110559	To be fair I haven't really used it,	"To be fair I haven't really used it, only read the core of the guide, so I may be mistaken.But I've done a bit of Clojure, and I've done a bit of Immutable.js, and particularly when you have a deeply-structured piece of data, ""mutating"" something a few levels down gets really ugly. Now, maybe something about Haskell Enlightenment obviates this case entirely in a way I'm not seeing. But I also remember Haskell seemingly forcing you to push all your imperative code up to the surface layer of your otherwise pure program, which sounds great unless you need to do really meaningful things that are by nature imperative."	_bxg1	12.385386	-7.766687	comment	3.0	14.0	1559782227	7.515526
20245728	PSA: please use clojure.edn/read-str	"PSA: please use clojure.edn/read-string instead of read-string. The latter can execute code when it parses the string (try running `(read-string ""#=(println \""oops\"")"")`."	hk__2	12.646595	-7.9010468	comment	3.0	14.0	1561146267	10.856256
20281224	> most programmers even at Google an	> most programmers even at Google and Amazon would not even be able to either read or write such codeHello, I am at Amazon. I spend a decent portion of my time working with an in-house Clojure library (not entirely dissimilar to Haskell) which handles some mission critical business logic my team owns.It terrifies me. I hate it.For every hour I spend working with it, I spend another hour trying to convince everyone we need to rewrite it in Java, immediately, or replace it with a different library. None of us have a clue how it works. We can't debug it. The guy who wrote it quit three years ago.I mean, it works. It works very well. But the day it doesn't work, we're not going to have a clue why that is. And then we're in real trouble.	mabbo	12.704676	-7.9330983	comment	3.0	14.0	1561514366	-11.161691
20281296	You could use those hours currently 	You could use those hours currently spent lobbying for a rewrite to, you know, learn clojure.	rfrey	12.653718	-7.902119	comment	3.0	11.0	1561515235	-11.207922
20305135	"I suspect by ""ideas from Datomic"" yo"	"I suspect by ""ideas from Datomic"" you are referring to ideas predating Datomic (and Clojure) that are used and possibly refined in Datomic."	eternalban	12.684259	-7.8759537	comment	3.0	11.0	1561734912	-11.243625
13692677	Why is `reject!` even a separate, an	Why is `reject!` even a separate, and different implementation than `select!`? Perf reasons?Haskell's Data.List doesn't seem to even have a remove/reject. Clojure's remove is simply a complement of filter.	sriharis	12.444279	-7.8054986	comment	3.0	12.0	1487643074	-11.159453
13761898	The Clojure Error Message Catalog: c	The Clojure Error Message Catalog: common error messages and their meanings	kimi	12.645539	-7.9080563	story	3.0	90.0	1488352285	-11.19985
13772387	When I was learning Clojure a year a	When I was learning Clojure a year ago, I spent quite some time Googling the cryptic error messages. An overview like this would have been useful. But I never really understood why Clojure couldn't give better error-messages by itself.	defenestration	12.649694	-7.9109073	comment	3.0	10.0	1488441034	-11.147189
13786997	Show HN: Online Clojure REPL	Show HN: Online Clojure REPL	amasad	12.650275	-7.8968444	story	3.0	46.0	1488577578	-11.190829
13869276	All these faults seem to me to be th	All these faults seem to me to be the result of inadequate use of types. So Go/Clojure are precisely the wrong response; the way forward is decent type systems (i.e. ML-family languages) and replacing stringly-typed unix pipes with something more structured.	lmm	12.5907345	-7.877186	comment	3.0	10.0	1489510858	-11.16554
13981617	Do you prefer it over Clojure? If ye	Do you prefer it over Clojure? If yes why? I'm a bit versed with Clojure but sometimes I feel that it is not a true lisp.	edem	12.651935	-7.888907	comment	3.0	12.0	1490741751	-11.0895
13982014	I have used both in production setti	"I have used both in production setting and can say that the tooling for most CL implementations is just plain light years ahead of Clojure, and there is no sign of it really improving.For Clojure the interactive debugging experience is just plain dreadful and for a dynamic language this is pants on head crazy imo. For me a dynamic language has to have a good interactive debugging experience because you have foregone the support of a static compilation and instead wish to reason about your program at runtime. But with the JVM stack traces and lack of interactive debugger Clojure just does not support you in this regard. And as a side note the lack of an identity print is annoying as well e.g. (+ (print 4) (print 4)) ""4"" ""4"" 8 (yes, it's easy to add...)Clojure's decision to use persistent da"	Guthur	12.644577	-7.890492	comment	3.0	24.0	1490745242	-11.0888815
30802205	But Clojure is not a Lisp.  It is Li	But Clojure is not a Lisp.  It is Lisp-adjacent, a bit, but it is really not the same language.	eadmund	12.660606	-7.885706	comment	3.0	16.0	1648216540	-11.061114
30927494	He wrote a blog post about it https:	He wrote a blog post about it https://swlkr.com/posts/clojure-isnt-for-me/TLDR: He hated the Java part of Clojure	muhgarvey	12.648789	-7.9009066	comment	3.0	13.0	1649209390	-11.180835
34615730	I like Racket's way of handling them	"I like Racket's way of handling them, to a degree. Each of {}, [], and () are interchangeable, and the use of [] is mostly down to convention. For example, it is often used in let bindings:    (define x
      (let ([a 1]
            [b 2])
          (+ a b)))

By to a degree, I would actually prefer if the convention was enforced."	bmitc	12.552958	-7.766229	comment	3.0	14.0	1675277968	5.8156514
34621763	The convention is enforced in Clojur	The convention is enforced in Clojure. [] for bindings, {} for maps.	gsinclair	12.549055	-7.8409534	comment	3.0	11.0	1675309488	9.730442
34707760	I'm going to suggest Clojure. It is 	I'm going to suggest Clojure. It is a very opinionated language made a person who was about to quit professional programming because of an explosion of complexity (both accidental and incidental).Check out the talks by Rich Hickey to see if you have the same sentiment or perhaps this paper: https://download.clojure.org/papers/clojure-hopl-iv-final.pd...The community of the language largely follows this philosophy, the ecosystem is very stable and there is little churn. The most common implementation is on the JVM making the language very portable.The headaches historically were with getting your environment setup, but there are amazing tutorials and good tooling or VSCode, IDEA, Emacs and vim.	dimitar	12.5600815	-7.806724	comment	3.0	11.0	1675863303	-11.07
34761426	The most enjoyable programming exper	The most enjoyable programming experience I've ever had, hands-down, was writing Clojure in LightTable, an IDE that allowed line-by-line inspection/execution, which sounds like what you're talking about.The project looks like it died unfortunately, but I think they did end up adding Python support before that happened. Might be worth checking out.	nmfisher	12.64946	-7.8907046	comment	3.0	11.0	1676194486	-11.155363
34775306	I like Clojure, but unfortunately fo	I like Clojure, but unfortunately for web development, there isn't a great stack and for data science/ML/AI (which is a great fit for clojure), python dominates the market. What is the niche for Clojure, or why should keep using it in 2023?P.S: I like it a lot, but either I do golang or ror for web dev, or python/pytorch for data sciences/AI stuff, C# for game development. I don't think i can get more productive with Clojure in any scenario, that I'm exposed too, what I'm missing?	pelasaco	12.644578	-7.886564	comment	3.0	25.0	1676304447	-11.147295
34775481	It is actually a great choice for un	It is actually a great choice for unopinionated server-side web development.Frontend development is simply awesome in ClojureScript.  Give me Reagent + Shadow CLJS over plain React (or React Native) any day.	ARandomerDude	12.6744585	-7.8332644	comment	3.0	20.0	1676305116	-11.1647625
34775729	In Clojure ORMs aren't really that p	In Clojure ORMs aren't really that popular considering most Clojurists just use the built in datatypes (e.g. maps) to represent data. There are no classes as such (unless you use Java interop). If you need a query builder the honeysql library is really nice.	snorremd	12.662245	-7.871077	comment	3.0	13.0	1676305990	-11.211861
34776440	I love Clojure (and have touted such	"I love Clojure (and have touted such in past comments), but it suffers from a glaring problem: every library is half done and/or abandoned. What happens is you end up modifying an existing library to fit your particular problem space. I needed a web framework. None of them just did things in a ""simple way"". I ended up branching an existing one and have altered it (very heavily) to fit what I need. It's now my go-to for all new projects.The issue with us Lispers is that we love the language more than we do the tooling. Tooling be damned! So we all end up re-inventing the wheel for the 1000th time. We will never gain wide spread adoption, as such.With Ruby, I have Rails. With Python: Django. With Clojure...well good luck. Every framework does one thing beautifully correct and about 10 things"	distantaidenn	12.647296	-7.8871775	comment	3.0	12.0	1676308245	-11.150436
34776912	Stage5: All other languages and thei	Stage5: All other languages and their syntax now looks ugly and wrong. I'm mean for heavens sake put the parens on the outside ! We are not heathens.Lol only half joking. It really did surprise me how can something I hated some much in the beginning of learning Clojure (all the parens) has now become one of the things I most adore about the language (all the parens)	rawoke083600	12.652474	-7.894122	comment	3.0	15.0	1676309618	-11.095396
34777075	Clojure is really good at self-selec	Clojure is really good at self-selecting for people that really care about innovation in programming languages.  The other jobs in a tech company care about innovation in their domain.  They rarely align.So for every weird, cool innovation you see, the productivity is immediately lost because people equally care about how you deal with state on app startup, or routing, or database interaction.  And since none of those other things move the needle much in how you compete in your business domain, competitors who are not concerned wind up eclipsing you.  While you're arguing integrant vs. mount, people are just running dotnet new and bikeshedding over things closer to the business domain.PMs/EMs/QAs/etc. may not have technical knowledge, but they smell something off about programmers arguing 	gemstones	12.658093	-7.9020123	comment	3.0	10.0	1676310102	-11.176432
34777498	Lets say that someone wants to impro	Lets say that someone wants to improve on Clojure and make a better functional, immutable LISP! What should they start with ? Some things I miss is type support (for easy refactoring, auto documentation and performance), (small) native compilation, support for mobile platforms and their UI's, first-class web-assembly support, real structs and misc things like performant implementations for `first`, `last` and other clojure functions, light-weight concurrency like Go, data-flow analysis and pipelines, etc.An example of clojure performance issues covered here: https://tech.redplanetlabs.com/2020/09/02/clojure-faster/All that stuff above should be fixed at the language/stdlib level.But what is your take on what needs fixing ? What would have been your solution for the N data-structures/ M alg	lenkite	12.612076	-7.855353	comment	3.0	22.0	1676311470	-11.096445
34777822	I have the feeling that after Nubank	I have the feeling that after Nubank bought Cognitech, Clojure has gone to stagnation. I mean, i feel that promoting and improving Clojure is no longer a priority. And another think that stinks me everytime Cognitech talks about Clojure they have to bring to the table Datomic. They tried to push Datomic on my company long time ago when they do some consultancy job at my company. You can skip all the talk, because is all about how good Clojure is and that is. No any eta about future features, improvements and fix problems of current Clojure users.Lot of open source contributors have leave the community, because there is any plan on Clojure. I guess that Rick Hickey is happy with Clojure as it is now, and this is the way is going to stay. And still no Java 8 support for CompletableFuture, la	logistark	12.660383	-7.8959517	comment	3.0	13.0	1676312707	-11.184323
34779657	"""Superb"" is not the word for deps.ed"	"""Superb"" is not the word for deps.edn documentation. It is certainly documented but the gap between most Clojure documentation and the deps.edn documentation page is big. I suspect Rich wrote most of it but left the deps.edn page to someone else.The deps pages have a knack for includng pages of waffle that doesn't help to solve the current problem.If a newbie is trying to debug    {:deps
     {ring/ring-devel {:mvn/version ""1.9.6""}}
     {ring/ring-core {:mvn/version ""1.9.6""}}}
=> Error building classpath. Error reading edn. Map literal must contain an even number of formsThey have to notice that while they got 80% of their maps right, the file itself if a map with 3 forms. This is compounded by the fact that there are no examples of a multi-dependency project in the getting started page! "	roenxi	12.652731	-7.898289	comment	3.0	17.0	1676319104	4.470433
34811657	I’ll note this article could have be	I’ll note this article could have been written ten years ago without changing a word. If you’ve already made your mind up about Clojure, there’s very little going on that’s going to move that needle.	moomin	12.65465	-7.9058456	comment	3.0	15.0	1676499975	-11.177095
34863448	Yeah, for Emacs users I'm sure Cloju	Yeah, for Emacs users I'm sure Clojure is great. For the other 99% of us who use VS Code or IntelliJ or something else entirely, it really isn't. Though IntelliJ + Cursive I'd say is probably the best, it still pales in comparison to say Rust or TypeScript support in editors.	askonomm	12.644684	-7.872001	comment	3.0	15.0	1676852784	-11.07526
34949921	Clojure(script) always seems to me t	Clojure(script) always seems to me to be this hotbed of interesting ideas in programming. I.e. you'll see something wild like this start here then eventually the concepts make their way out into regular JavaScript.I'm almost starting to regret not picking Clojurescript for my app	Rodeoclash	12.658272	-7.8916645	comment	3.0	42.0	1677448423	-11.157338
34950387	No I genuinely don't like clojure be	No I genuinely don't like clojure because I just finished my first clojure class, it was also my first functional language and it was online and i am bad at learning online so thats why.	Funnyduck99	12.653448	-7.90229	comment	3.0	13.0	1677451051	-11.155267
25442210	I'm aware of this. How do you achiev	I'm aware of this. How do you achieve setters if the state you close over is immutable? Isn't that the default in Clojure, since it seems to aim for immutability by default?	phoe-krk	12.514831	-7.8172245	comment	3.0	16.0	1608125177	-11.093318
25446655	>Is there a good argument against Cl	">Is there a good argument against Clojure in this case?I use Common Lisp and my main argument will be that Clojure isn't an ""interactive programming"" language like Common Lisp, Smalltalk (and Pharo, Squeak, Scratch) are. And, for me, this is removing one of the main, core advantages of Lisp.Dispensing with the interactive programming features is, IMO, a step backwards in the state-of-the-art. Common Lisp ADDED all the improvements in the state of the art: Interactive programming from Smalltalk, lexical scoping from Scheme, various high performance/low level features from StarLisp and ZetaLisp, a very powerful OOP system, etc. And then, thanks to it being highly extensive, almost any feature can be added to it.Clojure features like threading macros, immutable seqences, software transactiona"	flavio81	12.656265	-7.86258	comment	3.0	15.0	1608144611	-11.080958
36989303	> “Readable” is mostly a matter of “	> “Readable” is mostly a matter of “fits the grooves already worn in my brain”; to me, the Elixir there nonstandard-macro-based-syntax-and-all, is vastly more readable than the Clojure.I'll admit to being able to read Lisp syntax without choking on the parens, but I don't even use Clojure (or any other dialect that uses special syntax for the different collection types) and I think it's way more readable and malleable (you can literally do whatever you want that makes sense to this data and it'll work, meaning you're free to write whatever middleware you want that takes and produces the expected data).I've used Elixir since 2015 so I have no problem actually reading the syntax at all; I just think it's factually much worse than the Clojure example because it's basically just a bunch of mac	59nadir	12.647496	-7.878083	comment	3.0	14.0	1691085236	12.894315
37002942	So you had to switch to C++ because 	So you had to switch to C++ because Clojure / Java wasn't performant enough?	uxcolumbo	12.593783	-7.8427534	comment	3.0	13.0	1691169552	-11.176826
37032198	The main issue is that Clojure compi	The main issue is that Clojure compiler doesn't really optimize lazy sequences right ?  Most language compilers do this. Rust lazy iterators for example many times exhibit faster performance than for-lops.And clojure also doesn't give an error/warning when lazy sequences aren't finalized.	lenkite	12.630356	-7.893774	comment	3.0	11.0	1691400359	-11.165178
37044760	Sheldon's site was hugely influentia	Sheldon's site was hugely influential back in the day. Maybe even more so than the Park blue book.You could find answers you didn't know to questions you didn't know to ask for hours and hours. And then some tangent about French derailleurs, besides.I still have tools color-coded Sheldon's way.	kemitchell	12.628394	-7.8063087	comment	3.0	67.0	1691471574	-11.087311
37160495	FlowStorm: Omniscient time travel de	FlowStorm: Omniscient time travel debugging for Clojure	jpmonettas	12.676035	-7.936793	story	3.0	25.0	1692275012	8.887125
37320415	Serious question, and I apologize fo	Serious question, and I apologize for the strong language: why should I give a shit about the language a service I consume is written in? Why does it matter it’s in Clojure? I am professionally a Clojure dev so it’s cool to see something written in Clojure like this, but why should I care about that?This is one of the things I really dislike about the community. Yes, Clojure is a powerful language, and I really enjoy working with it, but I often feel that the community has some kind of imposter syndrome that drives the need to tell others and justify the use of the language in some project, and it’s weird.	yladiz	12.654052	-7.9047265	comment	3.0	11.0	1693394971	-11.142111
29018487	Is there something special about CL 	Is there something special about CL as compared to other Lisp dialects? Why not choose something like Clojure, or LFE (Lisp-Flavored Erlang) with better async/library support? Then you skip over the community aspect entirely by piggybacking off the JVM or Erlang communities.(Another alternative would be Elixir, which is basically Erlang wrapped in a nicely-formatted version of Lisp. I.e. Elixir is to Erlang what Clojure is to Java.)I'm sure the answer comes down to something like, the author was more familiar with Node.JS so it would be a very quick rewrite. But I feel like there are a lot more Lisp-like language choices for backend APIs before you jump to Javascript.	japhib	12.658846	-7.8638263	comment	3.0	12.0	1635365410	-11.092586
29090974	In many ways I feel like Clojure is 	In many ways I feel like Clojure is a better Lisp than Lisp itself. Syntactic niceties like support for vectors/maps/sets are, once you've gotten used to them, hard to do without. And although it's orthogonal to the syntax, I also appreciate its focus on immutability. I just with there was a Lisp like it that didn't run on the JVM.	staplung	12.655567	-7.8858824	comment	3.0	22.0	1635912035	-11.04907
29091049	This isn’t really a thing, though: C	This isn’t really a thing, though: Common Lisp has built-in literal syntax for n-dimensional arrays and structs and libraries like fset provide literal syntax for Clojure-style immutable data structures.	fiddlerwoaroof	12.612878	-7.874624	comment	3.0	13.0	1635913057	-11.026965
29091143	> I just with there was a Lisp like 	"> I just with there was a Lisp like it that didn't run on the JVM.There are a few, with varying degrees of distance from the JVM and varying degrees of similarity to Clojure.- There's ClojureScript, which is Clojure transpiled to JavaScript.   - See also Lumo (<https://github.com/anmonteiro/lumo>) and Planck (<https://planck-repl.org/guide-all.html>)

- There's Babashka (https://github.com/babashka/babashka), which is a natively-compiled Clojure interpreter, implemented with the Small Clojure Interpreter (https://github.com/babashka/sci) and GraalVM for native compilation.- There's Joker (https://github.com/candid82/joker) with a similar mission to Babashka, but commonly used as a linter.- There's ClojureCLR (<a href=""https://groups.google.com/g/"	naruhodo	12.64811	-7.880967	comment	3.0	16.0	1635914154	-11.103997
29092449	I've been messing with Clojure/Cloju	I've been messing with Clojure/ClojureScript for a few years having previously had zero Lisp experience. Overall, I think Clojure does a good job of being both practical and lispy. It's a language that is for building real things.I've been focusing on ClojureScript (https://clojurescript.org/) as you get the benefit of interoperating with the Javascript ecosystem. The fact that there's a strong community around both Javascript hosted and Java hosted gives a wealth of library options.Overall, the tooling has been getting a lot closer to the sort of experience that contemporary developers expect. The Calva plugins integration with Visual Studio (https://calva.io/) makes it easy to get started - you can even run it online with gitpod (https://github.com/PEZ/rich4clojure).That just leaves lear	slgeorge	12.670039	-7.88174	comment	3.0	20.0	1635930721	-11.166292
29113493	I was referring to Clojure's immutab	I was referring to Clojure's immutable data structures, not immutability in general. My nodejs apps are just transformations pipelines of pure functions with postgres being my global mutable state. Clojure doesn't offer me anything here that I can't easily do with JS/node.Sure Clojure is a better language but not better enough to justify the additional abstraction layer IMO.	romero-jk	12.55165	-7.8247733	comment	3.0	16.0	1636066849	-11.170741
29293544	I'm torn between Clojure (totally n0	I'm torn between Clojure (totally n00b) or Elixir (mostly to force myself to use it rather than defaulting to Python)	BeFlatXIII	12.620292	-7.794378	comment	3.0	17.0	1637460270	12.878647
29388365	mutability is a data structuring vir	"mutability is a data structuring virtualization but i'd just as much suspect the runtime virtualization.that the bundle used to be 570kB isnt an immutability issue. itcs that clojurescript drags in a whole clojure runtime, a new virtualization layer atop the js runtime. that, to me, is the most likely suspect.that said, for sure, short tbeow away high gc allocation patterns are generally not good. at work there's a lot of ""functional"" patterns, nary a for loop in sight. this endless .map() .filter() usage causes near exactly similar issues, with shortived objects. it seems ultra sad & silly to me. waste after waste. but i also think we have much more deeply rooted problems."	rektide	12.671922	-7.9189343	comment	3.0	17.0	1638240831	-11.155621
29388897	What a boring takeaway from this. Be	"What a boring takeaway from this. Beyond the fact that the immutable data structures proposed by Clojure/script tend to perform very well in a lot of ""normal"" cases (and in a lot of normal web-app workflows your stuff is immutable, like ""query then display the result from an API""), at least to me it feels like asciinema is a very good example of a case where you have  tougher-than-average performance requirements.Not to say that we shouldn't have ""everything be performant"" but drawing a bunch of stuff to screens is _the classic_ performance question. Whereas most ""business apps"" people here work on to a day-to-day have different performance issues.Rewriting your CRUD frontend in Rust isn't going to make your DB queries faster"	rtpg	12.6222105	-7.8949122	comment	3.0	21.0	1638245916	-11.137788
29389094	> ClojureScript is not that easy to 	> ClojureScript is not that easy to integrate with the JS ecosystem. I know, there’s been a lot of improvements done in this space over the years, and I’m sure someone will immediately point me to relevant docs, but it’s still the extra mile you need to go when compared to regular JS codebaseThis always kills me. Clojure(script) is one of the neatest languages I've ever used, but it is just such a pain to work with. I spent hours getting NPM imports working in a project, when it ought to take seconds. It really makes it hard to recommend, even though the language itself is amazing.	ajaxexact	12.65077	-7.852703	comment	3.0	20.0	1638247986	-11.147423
29507168	> how on earth am I going to convinc	> how on earth am I going to convince my corpo overlords that this language belongs anywhere near a production system?This is part of the rationale behind Clojure, being able to lean on established platforms (Java and later JS): https://clojure.org/about/rationaleWith that said, though, that parsing function doesn't seem all that complicated?	simongray	12.651626	-7.920819	comment	3.0	13.0	1639119212	-11.188727
29507079	I find it fascinating that the autho	I find it fascinating that the author was forced to learn CL because there were no jobs in Haskell. I believe him, but as a Clojure developer, I find it very hard to find a lot of jobs in any functional language, especially lisps. They exist, but I just don't see a lot of good ones. Someone tell me I'm crazy.	gleenn	12.560345	-7.8541555	comment	3.0	31.0	1639118505	-11.151684
36043527	I loved Elm as soon as I had a runni	I loved Elm as soon as I had a running app that I could refactor and be (reasonably) sure it would work once the compiler was satisfied.However, I don't like the way the project is run. It's one Benevolent Dictator that has a particular vision for Elm and he's not really sharing with the community. For context, the latest Elm version (0.19.1) was released in October 2019. It kind of feels like a nice tree house left to the elements because the person grew out of interest, but kept a lock on the door.	cranium	13.010374	-7.695417	comment	3.0	30.0	1684846392	-12.813792
36082988	That is why I like Hiccup/ Clojure s	That is why I like Hiccup/ Clojure so much: https://github.com/weavejester/hiccup It is very natural to produce something resembling a document in pure Clojure data structures and then just convert it to valid HTML. I think, Reagent has some hiccup extensions that are nice like writing the class or id with a . or # notation right in the keyword describing the tag. So there probably still is some space to improve the ergonomics and probably performance. Concatenating strings still wins performance wise by a lot.	kaliszad	12.645065	-7.855433	comment	3.0	14.0	1685102645	-11.11434
36125079	I'm reading this book right now. It'	I'm reading this book right now. It's really great so far!I've been working a lot with Trees in Clojure, and have been hitting serious limitations of my understanding.I also found this YouTube video from a Clojure conference that reviews some different strategies for tree traversal in Clojure: https://youtu.be/YgvJqWiyMRYI thought that learning a Functional Lisp would make it really easy to traverse trees, since that is that the language is doing to actually execute its code.Turns out all the stuff I want to do is simply hard.Functional data structures are really awesome though, it just seems to take a bit of up front investment.	aeonik	12.517024	-7.8211484	comment	3.0	15.0	1685455866	-11.127491
36157297	Perhaps I'm being pedantic, but `if`	Perhaps I'm being pedantic, but `if` and many other control-flow constructs are implemented as macros in Clojure. So you probably use macros a lot!	maxfurman	12.567744	-7.859802	comment	3.0	10.0	1685653464	-11.149431
36195171	> I’ve seen people saying that but n	> I’ve seen people saying that but never with an argument as to why. What do they mean?I don't know but if I had to guess, it's because lisp is list processing language, and Clojure doesn't really support lists (I mean, it's possible to make some, but there are none out of the box); instead it has a variety of trees that mimic the runtime performance of lists, arrays, hashes, etc.	nordsieck	12.637567	-7.885073	comment	3.0	14.0	1685967184	-10.861233
36250859	And yet, Clojure, the most used Lisp	And yet, Clojure, the most used Lisp today, decided to use brackets instead of parentheses for parameter lists, breaking with 50 years of Lisp tradition. How dare they??But I'm sure you know better than them.	hota_mazi	12.631516	-7.8748083	comment	3.0	13.0	1686267249	-10.9651785
36275545	So elm is abandoned or there's more 	So elm is abandoned or there's more to this story?	vbezhenar	13.01276	-7.6950655	comment	3.0	17.0	1686433971	-12.76022
36440278	Om is definitely not the place to st	Om is definitely not the place to start Clojure web development. I'm not sure it's even maintained. Kit and Fulcro are full-stack frameworks but if it's just SPA then re-frame is best option.	cutler	12.656332	-7.8821993	comment	3.0	10.0	1687474238	-11.165995
36442907	No programming language is a product	No programming language is a product design tool, what a ludicrous title.I think there are more blog posts about Clojure than software written in Clojure that people use.	JSavageOne	12.644995	-7.8925285	comment	3.0	11.0	1687495715	-11.16595
36446518	I've been trying really hard to get 	I've been trying really hard to get into Clojure as a full stack dev, but this has been my experience as well. Building a simple crud app has been a nightmare. I find that:- The debugger sucks- There are other tools for debugging like Portal and Flowstorm, but they involve already knowing what the problem was so you can instrument the function and call it with the same arguments- Java stack traces make the above very hard to do.- You're a second class citizen if you don't use emacs. Half of Clojure devs are using the EMACS according to a community survey. Calva, the VSCode extension, does lots of automatic setup to make the REPL work, and when it doesn't work, you have no way to fix it. I have to restart the REPL a lot, which I'm told is the opposite experience I should be having. It took 	Capricorn2481	12.646146	-7.891406	comment	3.0	13.0	1687526692	-11.118762
36520178	the problem with clojure is you have	"the problem with clojure is you have to learn java (or at least some java)
same issue i see with F#, you still need to have at least some basic knowledge of C#unfortunately running on JVM actually really means running on Java
same for .net it mean running on C#i dont mind learning two languages, its expected from most developers to know more than one, but context switching in a single function between two language is not fun"	systems	12.556149	-7.8324375	comment	3.0	23.0	1688045777	-11.0996275
26103879	Clojure still sounds like research g	Clojure still sounds like research group to me.	brainzap	12.652305	-7.9010673	comment	3.0	16.0	1613062417	-11.169983
26358344	Huge Clojure fan here, been using it	Huge Clojure fan here, been using it professionally for 9 years.This is a good article, highlighting a couple of the warts, which I think is a missing element for most people who like a language.I completely agree with the nil punning observation.  One of the issues pointed out in the article that resonated most with me is functions in the standard library  usually (but not always) nil pun.  You get used to nil, so when the standard library does throw a runtime exception, you're surprised.  For example:(:foo nil) => nil(int nil) => exceptionOverall great article.	ARandomerDude	12.562329	-7.9018292	comment	3.0	10.0	1614960385	-11.143747
26359025	> The underlying design of Clojure's	> The underlying design of Clojure's data structures must be different. It needs to efficiently support functional updates; you don't want to fully copy a hash table or vector whenever you add a new entry.I've actually been curious about this myself.  No one seems to scream that functional languages are slow, so I'm curious what's going on under the hood.  Like the author, I would presume they don't fully copy the hash table every time I add an entry.Is Clojure smart enough to know that the previous hash map is now out of scope and can be GCed, so it just mutates the hash map in place under the hood?  In the tiny amount of Clojure I've written, that seems possible.  On the other hand, it makes performance much harder to reason about since mutating a variable that stays in scope after the m	curryst	12.62348	-7.8876476	comment	3.0	12.0	1614963355	-11.156357
26359203	Anecdotally, I've been using Clojure	Anecdotally, I've been using Clojure professionally for about seven years and only very rarely need to interop with Java. Of course it depends on what you're trying to accomplish. On the other hand, interop with JS from ClojureScript is very common; shadow-cljs has made that experience more inviting.	elwell	12.6452465	-7.8867927	comment	3.0	11.0	1614964367	-11.16542
26359387	SICMUtils co-author here, if anyone 	SICMUtils co-author here, if anyone has any questions on the Clojure port.One beautiful thing about a Clojure computer algebra system is that it can run completely in the browser. This includes automatic differentiation, numerical integration, all of the hardcore Lagrangian and Hamiltonian mechanics work, differential geometry... it is startling stuff.For example, here's a(n interactive!) derivation of Kepler's Third Law in the browser (thanks to Nextjournal's lovely integration), if anyone wants to play: https://nextjournal.com/try/sicm/ex-1-11Many more exercises live here: https://nextjournal.com/sicm/	sritchie	12.649481	-7.9014163	comment	3.0	13.0	1614965220	-11.186392
26361083	If Clojure offered a direct compile-	If Clojure offered a direct compile-to-native option for any platform (desktop/mobile/WASM) with no JVM in between, I suspect it would explode in popularity.	lenkite	12.644775	-7.8868747	comment	3.0	17.0	1614972998	-11.164314
26475698	In a practical working environment i	In a practical working environment it creates more problems than it solves.It's an optimization that effectively turns non-working code into working code, in ways that aren't always obvious or predictable and possibly in different ways across different compilers/interpreters.I'd rather the code blow up in my face immediately than spend time wondering why it gets optimized on engine X and not on engine Y, or why seemingly trivial code changes cause the function to have drastically different runtime behavior.Clojure did this right. No TCO, loop/recur construct instead.As a side note at the cost of being snarky, it's also probably a good thing that developers who get overexcited about recursion are being encouraged to use proper functional idioms instead of abusing it.	qsort	12.477151	-7.804198	comment	3.0	23.0	1615897048	8.944013
31179780	Janet [1] is a clean, modern LISP.Cl	Janet [1] is a clean, modern LISP.Clojure is also an option, but of course that comes with a heavy JVM burden.[1 ]https://janet-lang.org	the_duke	12.647137	-7.866115	comment	3.0	14.0	1651066950	-11.028276
31203330	As the co-creator here I'd like to a	As the co-creator here I'd like to add that Joyride is taking the very first baby steps here. We hope a lot of people want to try it and provide feedback to inform our next steps.NB: The video has a target audience of people who know Clojure and its strengths. Especially how the REPL is used. I hope HN will see beyond the parens. =) It should make some sense anyway. Especially if you have some Emacs scripting experience, because that is where most of the inspiration to Joyride comes from.	cospaia	12.668063	-7.908592	comment	3.0	18.0	1651226523	-11.194764
31250267	I watched the video from your articl	I watched the video from your article: https://youtu.be/CNFr7zIfyeMAnd as someone who programs in Clojure, I feel the interactivity is the same. Maybe I'm missing a detail of what he's doing though?The part you don't have in Clojure (without using a library), is the restart options, but he didn't seem to ever use them, seems he just looked at the error message, and went back to fix the code and re-evaluate his test again, and that would be exactly the interactive flow I would follow in Clojure.Am I missing something?	didibus	12.645	-7.9010096	comment	3.0	12.0	1651595472	-11.185826
31279153	Used Clojure for ~4 years, doing REP	Used Clojure for ~4 years, doing REPL-driven development in Emacs. Have used Ruby and Java since. Maybe it's a rosy retrospection, but in terms of program production I think that was the most productive I've ever been. Falling into a flow state was much easier. Translating complex ideas into code was much easier. Building constructs up piece by piece felt natural and smooth. Sometimes I worry I'll never work in a LISP again.	mbil	12.601602	-7.8228545	comment	3.0	10.0	1651790301	-11.036255
31588108	I'm not a fan of books like that bec	I'm not a fan of books like that because it doesn't teach you real-world usage. You can't be thrown into a standard clojure project repo after reading that book.	olah_1	12.65331	-7.9004683	comment	3.0	14.0	1654117554	-11.166687
31656126	I don't really care about startup ti	"I don't really care about startup time personally but the linked page mentions ""very low memory usage"" which is quite a contrast with Clojure which seems to use insane amounts of memory for simple things."	jpe90	12.593829	-7.7977843	comment	3.0	12.0	1654617148	5.782155
31666286	Scheje: A little Scheme implementati	Scheje: A little Scheme implementation on top of Clojure	slim	12.637871	-7.9021826	story	3.0	102.0	1654691377	-11.204546
31668055	No, we ignore Elm because it has a b	No, we ignore Elm because it has a bus-factor of one.	GiorgioG	13.01365	-7.6959944	comment	3.0	10.0	1654699244	-12.769659
14007305	mainly because the CLs aren't clojur	mainly because the CLs aren't clojure i.e. AFAIK don't use persistent data structures, and don't focus on robust concurrency primitives, don't have STM, etc...But if there is a CL out there that does all that I'd give it a try tonight :)	jfaucett	12.618067	-7.888561	comment	3.0	10.0	1490988602	-11.168222
14007934	This experience is extremely common.	This experience is extremely common. I have lost track of the number of people who have formed a negative opinion of Clojure because they were forced to pick up the pieces of a half-baked project written by someone who wasn't familiar with Clojure or its idioms.It should go without saying that this should not actually reflect poorly on Clojure as a language.	venantius	12.652741	-7.9058304	comment	3.0	29.0	1490992580	-11.138007
14009530	I want to echo comments here by shar	"I want to echo comments here by sharing that my professional experience with Clojure has been dismal. It's definitely unfortunate because Clojure itself is a wonderful language.To give you a better idea: no use of component or similar, no ability to run the app 100% in a repl. A junior engineer prematurely split a monolith out into microservices that weren't truly isolated in their function (they shared the same underlying db and a handful of ""libraries"" that were not libraries) -- a true fucking productivity nightmare. Shipping a small fix would oftentimes involve version bumping and deploying 3 separate jar's before you could even QA it. You NEED to use your repl and reloading tools when doing Clojure. You can't rely on your test suite, jenkins, or suffer through JVM restarts every few m"	whalesalad	12.648514	-7.8905096	comment	3.0	14.0	1491005611	-11.182939
14009628	My team is responsible for building 	My team is responsible for building small services on top of existing databases (or other API) and we found real success with Clojure. It took a little while to learn, but after you understood the basics it was damn simple to dig into a deeply nested JSON response to get at only the data you needed.We have since moved away from it because of the inertia required to get past the curly fingernail stigma. But even with Go/Python we haven't been able to get the same velocity compared to Clojure services.	johnbellone	12.643958	-7.886925	comment	3.0	11.0	1491007104	-11.1430435
14227169	While I understand this kind of guid	While I understand this kind of guide (showing how things are done in one language/ecosystem vs another), is there such a thing as a Clojurist that would have benefited from it?I'm not asking whether there are Clojurists. Of course there are.I'm asking whether there are people that primarily and only know Clojure, and thus would benefit from a translation guide between Clojure and Rust, instead of say between C or Java or Python or Ruby etc and Rust.I'd think that anybody who uses Clojure was already familiar and/or proficient in some other language before, much more major than Clojure.	coldtea	12.655656	-7.899752	comment	3.0	10.0	1493481823	-11.1709
14254475	Uncomplicate: Number crunching in Cl	Uncomplicate: Number crunching in Clojure	tosh	12.621331	-7.8910084	story	3.0	87.0	1493807663	-11.161201
14364326	"The ""ew gross weird"" reaction to Sca"	"The ""ew gross weird"" reaction to Scala and Clojure is tremendously disappointing (especially coming from someone whose thesis is basically ""give this new language a chance"")"	pje	12.4506645	-7.787451	comment	3.0	33.0	1495072430	11.960677
14415979	Clojure's most important lesson	Clojure's most important lesson	tosh	12.655303	-7.907279	story	3.0	45.0	1495699601	-11.175122
14419551	clojure's killer app, datomic, is cl	clojure's killer app, datomic, is closed sourcein my opinion, this is a key reason, why clojure is not thrivingi can't think of any (problem) domain, where clojure have a framework or library, than is significantly better than most other frameworks or librariesif you are not number 1 at anything, it is hard to thrive	systems	12.66559	-7.9018836	comment	3.0	15.0	1495740982	-11.1802025
14419760	I use Datomic everyday. While it's c	I use Datomic everyday. While it's certainly a stunning piece of technology and you could pry it from my cold dead hands, I don't think it has that much bearing on the growth of the Clojure community.	swannodette	12.677946	-7.8586984	comment	3.0	12.0	1495742778	-11.193117
14420038	I feel that Rich Hickey alone makes 	I feel that Rich Hickey alone makes the Clojure community very healthy, friendly and warm. The JVM is solid, reliable and battle proven, is it not?	eriknstr	12.656131	-7.9089375	comment	3.0	10.0	1495745192	-11.156032
14421642	I really hope this isn't true, Cloju	"I really hope this isn't true, Clojure is my favorite programming language. I feel that it spoiled me. Builds are easy, code is elegant and easy to parse, functional programming combined with immutable data structures is beautiful. It also is great for ""full-stack"" devs in that there is little context switching between server and client.I think the ""killer app"" that Clojure needs is that it should be compilable into C/C++ with the same great interop it has with Java. It would be amazing to be able to utilize all those libraries, all those frameworks, all that code... in a Clojure REPL!"	j_m_b	12.645344	-7.890995	comment	3.0	11.0	1495765290	-11.168107
14429382	Author here and I'm surprise to see 	"Author here and I'm surprise to see this here. I haven't maintained this elm version. I've created a rust version[0]
and it's practical usage incorporated into markdown[1].
A MacOS app can be downloaded [2]. 
Pay what you want so I can improve the app in the future.[0] https://github.com/ivanceras/svgbobrus[1] https://ivanceras.github.io/spongedown[2] https://sellfy.com/p/SsQS/"	ivanceras	12.977833	-7.6938324	comment	3.0	10.0	1495873685	-12.759707
14444066	After being Clojure-only for a long 	After being Clojure-only for a long time, I decided to write the front end to my last project in Elm, just to see what the fuzz was about.While I miss code-is-data very much, there is no turning back from the type system and how there are no unpure functions. It is just so mind-blowingly easy to catch almost every bug I would usually write.I'm afraid this is the point where I should try Haskell, and be unsatisfied for the rest of my professional life.	yjgyhj	12.609487	-7.817474	comment	3.0	16.0	1496137774	-11.256682
14445782	Same thing with scala or clojure. If	Same thing with scala or clojure. If the object is mutable setters and other methods can still mutate it	AzzieElbab	12.4936905	-7.8047004	comment	3.0	14.0	1496156064	-11.131108
14498223	This is nice, but I wish he showed i	This is nice, but I wish he showed it in mathematical syntax too. I don't understand some of the calculations because I don't know much about Clojure. Or Linear Algebra.	deft	12.642775	-7.902369	comment	3.0	10.0	1496764805	-11.157907
14508674	Possibly stupid question:At the top 	Possibly stupid question:At the top of the article, we see `(reduce + (map inc (filter even? s)))` -- here, `reduce` is a two-place predicate, taking a function and a collection.Later, `reduce` is taking a function, a 'base case' [], and a collection -- it's a three-place predicate, more in line with a signature for `fold` than what I'm used to seeing for `reduce`.Is this a clojure specific overload thing? I'm not at all an expert in FP or anything so it might be fairly standard.	WaxProlix	12.552691	-7.8612294	comment	3.0	12.0	1496859769	-11.142793
14663047	why would one do that instead of usi	why would one do that instead of using clojure?	nikofeyn	12.644606	-7.89652	comment	3.0	13.0	1498742448	-11.150364
20383256	> I think Clojure is uniquely positi	> I think Clojure is uniquely positioned here in its ability to fuse these JS<->JVM technologies using a single languageWhy? Aren't there a lot of other languages that do the same? What is different about Clojure? Genuinely interested!	chrisjc	12.646866	-7.886774	comment	3.0	13.0	1562597798	-11.13281
20429304	This is interesting. I've tried Cloj	"This is interesting. I've tried Clojure, and heard about the idea of avoiding mutable data and using pure functions plenty of times, but imperative/OOP have still always made the most sense to me. When reading this though, something clicked because I've encountered the problem of getting a stable state to read/write without blocking other operations, and dealt with it in C++ in a similar way to Clojure without realizing it at the time.I have this little lightly-tested library: https://github.com/tne-lab/rw-synchronizer. I'm not using it much currently but have played with it a lot while building extensions to Open Ephys. The idea being that as a reader, you get a ""snapshot"" of the last thing that was written, but it's really just one of several copies, and subsequent writes can happen on t"	etbebl	12.585977	-7.861394	comment	3.0	20.0	1563040915	-11.17974
20430623	I recall he was big into SBCL, but m	I recall he was big into SBCL, but most IT organizations wanted all code to run on the JVM or CLR. So he had to make a Lisp to run on the JVM and Armed Bear Common Lisp apparently wasn't exactly what he wanted.I want to learn Clojure, but there are definitely some road blocks. I don't have the time for Emacs, it'd be a pain to get a Cursive license (although the cost is extremely reasonable I'd have to do paperwork at work), and I don't know the JVM or Java well.	6thaccount2	12.663844	-7.882142	comment	3.0	12.0	1563058040	-11.081703
20507784	one thing I haven't found a solution	"one thing I haven't found a solution for is how to make Lisp/Clojure play nice with version control and diffsyou take something like this    (defpackage my-package 
      (:use :cl) 
      (:import-from :alexandria 
                    :with-gensyms 
                    :curry))

and you want to add an item to the list.. so you need to change the :curry)) line to be :curry and then add a new item. anyone have a workaround?Of course if you had a lisp with no parans then you'd never have this problem to start with...    defpackage my-package 
      :use :cl
      :import-from :alexandria 
                   :with-gensyms 
                   :curry
                   :new-thingy

""Indentation is two lines per form""Emacs seems to always do one space for Elisp and Clojure and two spaces for 'le"	geokon	12.657423	-7.885353	comment	3.0	13.0	1563897725	-11.072995
20549513	Try Clojure. My advise and what wow'	Try Clojure. My advise and what wow'ed me the most: install Leinengen the package manager for Clojure and try a hello world web app tutorial that follows Leinengen. Lein will download and install Clojure for you and pull in all the dependencies. Idk any package manager that bootstraps itself like this. All you need is the Lein JAR and obv a JRE installed and you are good to do anything.Also having done both Clojure and Enterprise Java. I can tell you its not married to Java. Theres plenty of Clojure specific libraries you can use.Also try out Nightcode. Its coded in Clojure and is very straight forward. Just hold CTRL and it will show you all available commands.	giancarlostoro	12.632505	-7.870606	comment	3.0	12.0	1564343983	-11.142779
20582199	I earn money for working in Clojure.	I earn money for working in Clojure. And I feel it provide a huge advantage.I do Haskell in my spare time too. Once you’re used to FP, going back to imperative languages feel like a terrible regression.	yogsototh	12.441113	-7.8254046	comment	3.0	11.0	1564649572	-11.161495
20605997	If Hy could resolve its problems wit	If Hy could resolve its problems with let being moved to contrib and attracted enough manpower to reach 1.0 I think it could attract significant mindshare. Hy fills in the missing piece for devs who want to go all-in with modern Lisp supported by an established ecosystem, ie. front-end/Clojurescript/NPM, scripting/Hy/PyPi and back-end/Clojure/JVM.	cutler	12.649757	-7.887794	comment	3.0	23.0	1564920633	-11.16326
20646482	I've also came upon Clojure after in	I've also came upon Clojure after investing much time in Lua/Love2d, but my takeaways are different from yours.I enjoyed Lua's simplicity, portability and execution speed. It shares much of JS strengths, with fewer quirks. I was productive after a weekend of reading Programming in Lua book.Clojure took some more time because I had to unlearn some habits. It's for the best, I think. It's not just about homoiconicity and REPL. In Clojure it's hard to do the wrong thing, compared to JS or Lua. The language makes it easy to isolate a small piece of functionality, develop and test it, and then and put it together into coherent whole. Clojure may be harder to learn, but the cognitive load is smaller and it scales better for large projects.Persistent data structures are also huge step forward. Th	jmiskovic	12.644629	-7.89014	comment	3.0	10.0	1565285036	-11.079513
20657195	> You will never code lisp in your j	> You will never code lisp in your job. Promised.I believed this too, but then Clojure happened. It's not my ideal Lisp, but I can get paid to write it at a mainstream company.	User23	12.66407	-7.879066	comment	3.0	13.0	1565376238	-11.049238
20776586	Can anyone give a pro/cons analysis 	Can anyone give a pro/cons analysis of a ML variant versus of a Lisp variant. Let's say F# versus Clojure?One of the general arguments in Lisp vs the world is that lisp is more concise. F# is really concise. It has datastructures as intrinsic part of the language syntax (just like Clojure, i.e in F# [|,,,|] is an array and in Clojure [...] is a vector, so more or less the same thing). Furthermore, the type inferences concierges the developer through the regular bureaucracy involved with strong type systems so effortlessly that you seldom notice it ... unless your code does not compile, in which case it's wrong somewhere and you need to fix it (which you needed to do anyway).Ok, so for the sake of the argument, let's say the syntax is equally light for F# and Clojure, and their support for 	fsloth	12.507764	-7.8117394	comment	3.0	25.0	1566561730	-10.875354
20787234	Prevalent use of these macros in clo	"Prevalent use of these macros in clojure code is admission to the following facts,1. Lisp code is hard to read.2. Lisp based languages do not have ""small syntax""."	dominotw	12.636065	-7.8671765	comment	3.0	11.0	1566656131	-10.988936
20788880	> by far the best programming langua	> by far the best programming language I've ever usedWould love to hear why? What is that make Clojure such a good experience for you?	noncoml	12.625265	-7.8769436	comment	3.0	32.0	1566671917	-11.125486
20789359	My previous startup (CircleCI) was w	"My previous startup (CircleCI) was written in Clojure, my current one (Darklang) is written in OCaml. I decided not to use Clojure again because it's not statically typed, and my number one frustration when I coded in the CircleCI codebase was that it was very very hard to know what shape a value had, and whether it could be null.OCaml certainly has a lot of flaws, and is not nearly as ""nice"" a language as clojure, but the productivity of static typing (in the statically typed functional language sense, not the C++/Java sense) is huge. Knowing you can do a big refactor and the type system has your back is massive.We sponsored core.typed to add types to Clojure, but there were flaws at the time (they have have been fixed since), and we didn't end up sticking with it.So Clojure I wouldn't us"	pbiggar	12.525189	-7.8563437	comment	3.0	13.0	1566676741	-11.177636
20823900	I did not realize common lisp was st	I did not realize common lisp was still in use and was therefore planning on learning Clojure instead. Which is better to learn then?	jammygit	12.669728	-7.876529	comment	3.0	12.0	1567025883	-10.979772
20841114	I've starting building my personal b	I've starting building my personal backends in Clojure and I am amazed at how easy and fast it is to get things going. The difference is even more remarkable for frontend code. I get my program into a state that displays some unfinished component and iterate until it's done. ZERO reloading is a huge time saver.Now if I could only get my React Native programs running with Clojurescript...	wry_discontent	12.6659975	-7.83505	comment	3.0	10.0	1567189267	-11.148086
20846295	Clojure: live repl into running code	Clojure: live repl into running codeScala:Clojure: Explore the problem you are facing with quick prototyping in the repl and see the blind spots, the unknowns, the shape of data received from flaky integrations. Mold and shape your functions as the problem becomes clearer.Scala: Best it can do is write unit tests and the debugger to look at what exactly is happening, devise a bunch of classes to handle them, rinse repeat and of course wait hours for recompiles. Refactor when new unknowns surface and curse at the fucking compiler not knowing what type it should be inferring.Clojure programmers are done before Scala has a test environment up.	serpix	12.569481	-7.870715	comment	3.0	14.0	1567260022	-11.165137
20846419	Clojure/Lisp is super nice until you	Clojure/Lisp is super nice until you have a bunch of transformations to make then you've to keep everything in mind without having a named reference in front of you (unless you omit the threading operators and abuse the let statement). It becomes exhausting after a while and makes you question if you are working for the machine or the machine is working for you.Yes, it's more succinct and elegant but is it worth it?	itwy	12.646974	-7.884308	comment	3.0	13.0	1567261250	-11.131911
20847253	My favorite thing about Clojure:You 	My favorite thing about Clojure:You compose libraries, instead of totally buy into framework A or B. Some people prefer the opposite.However, Composition works in Clojure because everyone is using the staples: functions, maps and seqs. Pretty much everything in the language can work as one (or all!) of them.While I also like static types, this is my argument for a well designed dynanic language like Clojure or its Lisp relatives: stuff just snaps together like magic lego bricks.	vnorilo	12.62182	-7.8839693	comment	3.0	28.0	1567268613	-11.165644
20847630	Really though, Clojure web apps are 	Really though, Clojure web apps are at the php-no-framework level security days, not joking.The most used HTML templater(hiccup) doesn't do any secure output escaping, bad password/session management, auth*, sql injection, bad encryption methods, its all there.	Scarbutt	12.653254	-7.8882236	comment	3.0	14.0	1567272670	-11.158738
20847956	I tried to learn (get to know) Cloju	I tried to learn (get to know) Clojure by writing a library for cacheing (memoizing) function calls. I thought it would be a simple exercise, but it turned out to be not so easy at all, with lots of special cases.	amelius	12.640992	-7.900269	comment	3.0	11.0	1567275759	-11.168261
20859922	Not very exposed to Lisp style langu	"Not very exposed to Lisp style languages. So take this as you will.But the actual clojure code looks weird? I get that its a different way of writing from the C like syntax, just that fro a quick glance it doesn't look very pleasant to read due to the how messy the brackets everywhere nature is.I also feel like reasoning about CRUD problems is easier in a non functional way, but again no real experience with functional languages to say for sure.EDIT: To illustrate with an example:
In C# I can write LINQ using the lambda syntax for queries, however sometimes its useful to be able to break down complex queries into parts, step through with a debugger to follow the logic, don't see how the functional style of Lisp aids in doing any of that (at least not when writing it idiomatically)."	boarnoah	12.639092	-7.880687	comment	3.0	10.0	1567440363	-11.077609
20878055	Can I ask why?I came from low level 	"Can I ask why?I came from low level language background but my ""fun programming"" went from Lisps to MLs and now I have difficulties going back to Lisps for projects. Always wanted to like Clojure but never had a need for JVM in anything I worked on."	jecxjo	12.650029	-7.8670173	comment	3.0	11.0	1567610786	-11.027066
20878379	ClojureScript is beautiful! If only 	ClojureScript is beautiful! If only it had types :)	a0	12.651733	-7.888724	comment	3.0	12.0	1567612323	-11.158125
20903828	Noria: UI Reconciliation Library for	Noria: UI Reconciliation Library for Clojure, Kotlin and Rust	tosh	12.53737	-7.9278417	story	3.0	25.0	1567865244	-11.161146
20940795	I'm struggling with the same problem	"I'm struggling with the same problem: I'm a Lisp programmer who's writing a commercial game, in my case a Unity engine game, which requires C#.I've opted for a less elegant, but technically simple strategy: I'm writing all the build tools/content tools in Clojurescript, and then writing only the core game engine in raw C#.Next, I'm using http://bridge.net to cross-compile the game engine into javascript, which I can then link to from clojurescript so that all unit tests and 90% of all QA testing can be done via clojurescript tooling, without any C# in sight.This allows me to deploy a commercial game in ""native"" C# without any performance penalty, but with as few lines of C# as humanly possible."	drcode	12.649017	-7.8794413	comment	3.0	11.0	1568213525	-11.150699
20950156	One of the most striking difference 	One of the most striking difference between Clojure and Haskell:In Haskell Immutability is an Abstraction, not Implementation. Clojure data structures and INTEGER & FLOAT object wrappers are expensive. Haskell build toolchain produces much-optimized code which preserves the functionality at high level and reasonable performant mutating code at a low level.	truth_seeker	12.452279	-7.860222	comment	3.0	10.0	1568286959	10.464005
20950382	Some observations:* Parallelism in C	Some observations:* Parallelism in Clojure is cheapParallelism is Clojure is not cheap if you are using ordinary threads, due all machinery necessary to setup and start OS thread (the same applies to Java/C(++)). If you are using core.async, you will get cheap green threads.However, parallelism in Clojure is extremely easy, especially switching between non-parallel and parallel implementations (map -> pmap or using reducers).* (Lack of) Libraries and LimitationsThis is common misconception between Clojure novices or someone wanting to start with Clojure. Clojure embraces Java and, using Clojure primitives, you can easily make your Java code functional and safe. Lack of ML libraries in pure Clojure just means that wrapping TensorFlow java code will require couple of more Clojure functions.F	dig1	12.644818	-7.8917546	comment	3.0	15.0	1568289200	-11.175816
20985366	That's interesting. How does Elm sta	"That's interesting. How does Elm statically know if the logic of your app is correct?  Since I don't know Elm I'll use some pseudocode:  if condition
    pourCoffee()
  else
    pourTea()

Is Elm able to determine that this condition is flipped the wrong way?"	Touche	13.010103	-7.693983	comment	3.0	17.0	1568649374	-12.759857
20988332	"Clojure ""Hello, world"" compiled with"	"Clojure ""Hello, world"" compiled with Graal running in Docker wasn't that bad: https://gist.github.com/cellularmitosis/66e024439cdefbc43375..."	cellularmitosis	12.644533	-7.881153	comment	3.0	13.0	1568666312	-11.176465
23801522	That Clojure is keyword heavy is tru	That Clojure is keyword heavy is true, but it's so important to note that objects are essentially never checked for reference equality in Clojure, even when e.g. looking up keys in a hash map (see demo).With this is mind, you could stop interning keywords and damn near every Clojure program would continue to work just fine - but with a noticeable slowdown.Or, more sensibly and to bring it back to the theme of the thread, for adding a second non-interning Keyword type which can safely be generated while deserializing user input in a long running process, that you can use interchangeably with standard keywords, but will be garbage collected away with the reset of the deserialized data when you're done.You do pay a hefty penalty here because you're hiding everything behind interfaces and abst	reitzensteinm	12.626333	-7.8902984	comment	3.0	18.0	1594469336	-11.172505
23904943	> Clojure's license makes it a compl	> Clojure's license makes it a complete non starter for me, sorry. Live free or die.Can someone ELI5 this? Why is Clojure's license problematic?	Santosh83	12.664085	-7.9061656	comment	3.0	29.0	1595315797	-11.174397
23920964	It really isn't. I'm almost tempted 	It really isn't. I'm almost tempted to say it's the opposite though that would be overstating the case.It's a format that still bears excessive decoration (what's the purpose of quotes around field names? what are all those commas for?) yet it's  limited in the types of data structures that it's able to express (natively). I'm not particularly fond of Clojure specifically but a format like EDN would have been superior in just about every way.	abraxas	12.630446	-7.884096	comment	3.0	28.0	1595448091	-11.111222
23927144	Clojure has many free IDEs. Many peo	Clojure has many free IDEs. Many people currently use Emacs w/CIDER, Atom w/Chlorine, Visual Studio w/Calva, Vim w/Fireplace, etc. For that matter, Cursive also has a free non-commercial edition.	puredanger	12.665513	-7.8573365	comment	3.0	14.0	1595510935	-10.957302
23927299	I've found CIDER superior to Cursive	"I've found CIDER superior to Cursive for Clojurescript, specifically.  I use a combination of IntelliJ (with the emacs keybindings) and emacs depending on which language I'm working with.  Most of my projects involve two or more languages, so I'll usually have both editors open all day :)As an aside, I'm starting to become a fan of Kotlin for backends (with some Clojure sprinkled in where it offers a big advantage), and Clojurescript (re-frame) for the frontend (because it offers a big win over javascript there).  I've taken a step back from full Clojure for everything, being that I have to work with others who aren't as in to ""alternative"" languages as I am.Datomic is something I probably won't mess with until (and if) it becomes open source."	jcadam	12.653136	-7.888489	comment	3.0	11.0	1595511988	-11.102389
23927493	Are there any technical posts from N	Are there any technical posts from Nubank on how they manage such a large Clojure codebase (I guess it must be Clojure's largest user in the industry).I'm looking for things like how to refactor safely in the absence of static typing, for example. Do they make use of spec?I'm a big fan of static typing, but when using a dynamic language with immutable values and pattern matching, like Erlang, I don't miss it that much. Maybe with Clojure is the same?	andrenth	12.544408	-7.8662167	comment	3.0	17.0	1595513254	-11.143484
23927918	(for anyone who doesn't get it, Rich	(for anyone who doesn't get it, Rich funded Clojure development via his retirement savings from 2005 until he ran out in 2009 https://dl.acm.org/doi/pdf/10.1145/3386321)	keeganpoppen	12.657771	-7.907405	comment	3.0	12.0	1595515804	-11.166163
23928523	Not sure we have any talks about tha	Not sure we have any talks about that specifically, but what I can say is that on the Clojure codebases:- We rely heavily on testing (unit tests, property-based/generative and integration)- We adopt a micro-services architecture, so most codebases are small enough that refactoring is easy, or sometimes we just replace the service altogether- We leverage Schema (https://github.com/plumatic/schema) and/or clojure.spec (https://clojure.org/guides/spec) to annotate functions and data schemas, but it's opt-in- We have static checking of data schemas across boundaries (e.g. checking data producers did not break consumers over HTTP or Kafka), which is where we found the most value (replaced complicated end-to-end tests)	hcarvalhoalves	12.62605	-7.8888497	comment	3.0	14.0	1595518991	-11.18308
23932814	I am about to (next two or three mon	I am about to (next two or three months) launch a company/product that is heavily built on Clojure(script) too and I was actually thinking about this exact thing just this week! There are a number of libraries that I rely on that I would love to give back to, both as a thanks for the work so far, and to fund future development. I'm not in a position to do so yet, but its something I very strongly hope to do in the not-too-distant future, if things go generally well.	dkersten	12.66137	-7.89928	comment	3.0	12.0	1595541348	-11.166819
23941592	I would be surprised if Datomic's co	I would be surprised if Datomic's core code was written in Clojure rather than Java (and these days Java's performance can get you pretty far in implementing a database, see e.g. Cassandra).Most highly performance-sensitive code in the Clojure ecosystem is a Clojure wrapper around a Java core.But yes as I said elsewhere, it would be great if Cognitect allowed people to post benchmark results.	dwohnitmok	12.67124	-7.8823495	comment	3.0	12.0	1595608968	-11.226183
23992912	Clojure is strongly typed. I think y	Clojure is strongly typed. I think you mean statically typed.They're orthogonal concerns. C is statically and weakly typed. Clojure is dynamically and strongly typed. PHP is dynamically and weakly typed. Haskell is statically and strongly typed. Java, as the most design-by-committe language ever, manages to be a mix of all four.	mumblemumble	12.573949	-7.8834085	comment	3.0	14.0	1596067404	-11.144457
24031670	This is interesting to read having w	"This is interesting to read having worked with Clojure, but never Haskell or CL. I expected the Haskell examples to look alien and the CL to look familiar, but the idiomatic Clojure solutions to the examples are almost identical to the Haskell solutions. E.g.    take 5 . filter (not . p) . drop 3

becomes    (->> s (drop 3) (filter (complement p)) (take 5)) ; for some sequence s

I think it is also true of Clojure that it strives to have many small functions with a high degree of composability."	jetrink	12.531152	-7.8645816	comment	3.0	33.0	1596401727	-11.1443615
24081610	Why Clojure? I honestly never heard 	Why Clojure? I honestly never heard of anyone using Clojure as data tools.I use Python and Scala. I use Python for mostly small tasks. When I hit large data, I normally use Spark on EMR (PySpark or Scala).	aynyc	12.650942	-7.895794	comment	3.0	11.0	1596807285	-11.12844
24092027	Show HN: Portal – A new data browser	Show HN: Portal – A new data browser for Clojure to navigate through your data	djblue	12.6523075	-7.8954988	story	3.0	12.0	1596898372	-11.178136
24188153	But do they implement the same progr	But do they implement the same programming paradigm, or is there any fundamental differencesFor example, C# and Java implement the same paradigm , they are different, many argue which provide a better set of feature, but I would not call the differences fundamentalC#, F#, implement completely different paradigmsF# and Clojure, same paradigm, but have fundamental differences, F# being static and come from the ML family , Clojure dynamic and come from the Lisp familySo APL to J, is more like what to what, C# to Java, or F# to Clojure ??	systems	12.492898	-7.7875247	comment	3.0	10.0	1597677997	-11.087067
24332405	There's the core team, which is extr	"There's the core team, which is extremely unfriendly to any kind of user-driven development of the language.The whole reason Elm has been stuck in a niche when it had _huge_ hype around 2015 and everyone was sure it would be the ""next big thing"" on the front-end is that the developers have tried to keep full control of the language and keep shooting down proposals by users. It's either their way or the highway."	pcstl	13.005063	-7.6910067	comment	3.0	13.0	1598887606	-12.759958
24355822	I've been looking again at Clojure r	"I've been looking again at Clojure recently, and it seems to have that feature of lisps that their language feature-set seems to just settle over time; unlike Javascript and even Python, it's pretty much the same as it was a few years ago. Instead, it's implementations like Babashka that are providing most of the innovation.I think this is a good thing! Though I do worry a bit that Clojure can look more moribund than it is. I see a lot of people exploring the language for the first time saying ""this tutorial is from 2013, is it still valid?"". The answer is mostly yes, but with some changes in tooling that can be dispiriting for beginners, and may make them think the whole ecosystem has gone rusty."	dannyobrien	12.663234	-7.8930883	comment	3.0	11.0	1599069227	-11.110038
24364489	To me Reagent is the ultimate answer	To me Reagent is the ultimate answer to the markup/code mix. A single language, ClojureScript. Nothing is done in strings except text. I absolutely love it, but haven't been able to use on a production project yet.[0] https://github.com/reagent-project/reagent#examples	kgwxd	12.644447	-7.8607173	comment	3.0	11.0	1599143843	-11.1039915
33081789	Question for Clojure's pros: as a de	Question for Clojure's pros: as a designer I started programming javascript for a long time, now I can do my own APIs on Node easily, would it be hard to do APIs in Clojure? Can you recommend me a video course for learn it?	meerita	12.660788	-7.898089	comment	4.0	14.0	1664897440	-11.165731
33083190	I kind of agree with you. I used to 	"I kind of agree with you. I used to work with Common Lisp in a Desktop App (Nyxt browser). I had some fun playing with Racket. And I love Emacs. So, I am already into the Lisp idea. But, I was kind of disappointed with Clojure which is new in my life and has been used in my current job. Maybe you have a backend bias in your testimony?I have been working with ClojureScript (re-frame and reagent) on front-end stuff and, unfortunately, the REPL does not seem to help me that much on my workflow. I miss the REPL driven development, by the way... The real ""interactive programming"" seems to happen on Chrome Dev Tools + Browser's reactions to Chrome Dev Tools tweaks on the UI + (lastly) changes on the source code via the editor (Emacs in my case).Namespaces as prefix of invocations on the REPL are"	pedrodelfino	12.633343	-7.875271	comment	4.0	13.0	1664902585	-11.153636
33296221	From my brief time trying it out abo	From my brief time trying it out about 3-4 years ago, the major things that needs improvement include:1. Improve startup times.2. Ditch leiningen, its functionality should be included in base clojure.3. Emacs toolchain for Clojure  seems massively complex and have too many parts. Makes it difficult to get it reliably installed/setup.4. Getting it set up on Windows seems obscure, which shouldn't be. Part of the problem is that lein is not distributed with clojure.5. Error messages are cryptic.6. Needs a lisp style debugger. Once an exception occurs we need to get a repl at that point of state.7. Needs provision include Local jars easily without having to set up a maven repo for the same. This is very important for hobbyist work, and for exploratory programming.	billfruit	12.650279	-7.897702	comment	4.0	37.0	1666423128	4.3617363
33296442	deps.edn isn't solving the same prob	"deps.edn isn't solving the same problem as lein. Lein you install it, run ""lein"" and it starts telling you what to do to get a running Clojure project.Deps you install Clojure and ... no hints how to get to a running project.""touch deps.edn""? Still no hints how you get from here to functioning clojure dependencies. It isn't a YAML file. Isn't JSON. No template.Read the reference page (https://clojure.org/reference/deps_and_cli)? We quickly learn that you can execute a function by invoking ""clojure [clj-opt] -X[aliases] [a/fn] [kpath v] kv-map?"". Still not much closer to installing a dependency, a lot of people probably give up here.Oh, there is a guide! Read the guide (https://clojure.org/guides/deps_and_cli). Now we get to our first dependency.Lets add a 2nd one!    {:deps
     {com.githu"	roenxi	12.650068	-7.900757	comment	4.0	15.0	1666426293	4.420722
33467826	Installing Clojure, because of its d	Installing Clojure, because of its dependence on Java and plethora of IDEs, is a major pain in my experience. I have tried several times and usually just give up because I find it difficult to get up and running with a simple project that allows me to write code. I don’t understand the seemingly complicated project systems.It takes literally just a few minutes to download, install, and get going with Racket, Elixir, and F#. It’s the main reason I have not got into Clojure yet, despite trying.	bmitc	12.649807	-7.8955393	comment	4.0	12.0	1667573913	-11.16249
33621490	I’ve had similar experiences with sc	I’ve had similar experiences with scala and clojure professionally. I now actively oppose people attempting to add functional code to projects I work on.…because when they say “more functional” most people mean:I want less code.I want the code to be shorter, because I’m lazy and I want it to be all on one screen.…but that’s actively harmful to almost any code base.You want simple code, not dense complicated code. Dense complicated code is for people who wrote the code, and a few smart talented people. Other people have to work on the code too. They cannot.Actual functional code doesn’t strive for code density, it strives for code purity and algebraic structures.That’s fine. Do that.Dense map reduce reduce flow reduce functions can die in a fire.	wokwokwok	12.39511	-7.7698174	comment	4.0	25.0	1668597880	11.897992
33621939	Asami: A flexible graph store in Clo	Asami: A flexible graph store in Clojure	tosh	12.648951	-7.8864775	story	4.0	126.0	1668601198	-11.200735
33751742	As a user of Common Lisp but not Clo	As a user of Common Lisp but not Clojure, where does Clojure dev environment stand with respect to something like SLIME? What unique features do Clojure dev environments have?	avindroth	12.64561	-7.883596	comment	4.0	15.0	1669461274	-11.087276
33827014	When working with Flutter I did drea	"When working with Flutter I did dream ""It would be pretty amazing to have a Lisp on top of this"" - awesome work you're doing here!Lots of interesting stuff happening in the Clojure space lately.https://github.com/squint-cljsIt's a strange thought, but I wonder if Clojure (or rather, the clojure community) would somehow ""migrate"" from the jvm at this rate."	100phlecs	12.655249	-7.894746	comment	4.0	29.0	1669957443	-11.164706
33889917	This is intriguing, and solves real 	"This is intriguing, and solves real world problems that I have come into writing Clojure. On the other hand, it is complicated, taking up to four arguments. It reminds me of Common Lisp's `loop` macro, able to handle complex and interesting situations, but has its own chapter in ""Common Lisp, the Language"" because it is so complicated. Is it really helping solve the accidental complexity problem at that point? Perhaps. I use the loop macro all the time, so it does bear thinking about.The OP also speaks of decreasing indentation as a goal instead of decreasing cyclomatic complexity. It is true that one tracks with the other, and I'll be the first to say that I too am an 80 character wide masochist, but optimizing code structure around decreasing indentation is dubious at best."	djha-skin	12.646266	-7.879462	comment	4.0	12.0	1670379260	-11.0150385
34053698	I'm an experienced developer and I'm	I'm an experienced developer and I'm getting the feeling that advanced languages are getting less relevant for most applications, since you usually just need a little glue code to glue together mainstream solutions or managed services. I don't need the power of Clojure to connect SQS to Lambda with some extra custom logic.But Clojure does look amazing :)	haolez	12.62375	-7.8799424	comment	4.0	16.0	1671466144	-11.150359
34066833	Why are you calling him Elmo? Isn't 	Why are you calling him Elmo? Isn't that rather juvenile? No matter how you feel about someone I think that respecting them enough to use their name should be the lowest level to which we allow ourselves to sink.	Eisenstein	13.013773	-7.695803	comment	4.0	15.0	1671548731	-12.79522
26587819	I'm still fairly removed from clojur	"I'm still fairly removed from clojure.  Most of what I do read doesn't convince me it is worth it over common lisp.That said, the idea of conj bring an extended cons sounds really nice.  Are there examples where the ""you can change the fundamental data structure and the algo still works"" pans out?I fear this will be a lot like our industry's love of tries.  Mostly impractical and more likely to cause bugs.  :("	taeric	12.652845	-7.8955045	comment	4.0	13.0	1616721566	-11.141512
26588528	Company?!  I'm looking for a good Cl	Company?!  I'm looking for a good Clojure team to join.	nanomonkey	12.656381	-7.8989034	comment	4.0	12.0	1616729992	-11.155352
26637972	Because Clojure is not terribly fash	Because Clojure is not terribly fashionable, I imagine the developer pool is much smaller but the candidates are higher quality, mostly due to self-selecting. I really like the sentiment of empowering individual developers to the max.It's funny, a lot of organizations want to beat the averages whilst engineering in an identical fashion to their competitors. You're not going to consistently get outstanding results if you do the same thing as everyone else.	mattgreenrocks	12.668665	-7.9070554	comment	4.0	15.0	1617127137	-11.177231
26720867	I have been using Clojure as a solo 	I have been using Clojure as a solo developer for about two years now, there is definitely a productivity increase. It always feels like the amount of time required to do the next thing is incrementally decreasing (like Ologn?)While all that is fun, Clojure is still a very enterprise ecosystem, where participants don't share as much elementary code as in Python ecosystem. Participants are also quite experienced, thus I have to sit, read through and make architectural decisions for the entirety of the project. When we add this thinking time into the measurement, the time taken for a Clojure 'project' (not a piece of code) is definitely more than Python or Java (IMO).	demonshreder	12.656207	-7.9032035	comment	4.0	32.0	1617773042	-11.176573
26777874	Interesting how different some of th	Interesting how different some of the approaches are in the same language, never mind different languages. In clojure, the “atom” version is 5 lines (not including data or tests), while the “zipper” version is 47 lines and the “reduce” version is 31 lines	ghufran_syed	12.64958	-7.9012237	comment	4.0	12.0	1618223503	4.557452
26931323	Design, Composition, and Performance	Design, Composition, and Performance – Rich Hickey (2019) [video]	nanna	12.653901	-7.902641	story	4.0	59.0	1619340927	-11.184018
27060675	I loved clojure until working with i	I loved clojure until working with it for a few years, with some of the famous best teams in Europe and America, including Cognitect people, who ill leave unnamed here.I fell out of love when I realised what the language is - a mutable, imperative, blocking IO by default language with lambdas and zero guarantees at compile time. Effects happen at any time, as it is an imperative language. Just like JS with a better syntax but with blocking IO and Java threads.Backends, when more than a handful coders program, turn to runtime checking all the time with spec or schema, and because it’s always up to you to make things async, things often end up depending on a handful of blocking calls. It’s not impossible to write good big programs in clojure, but when working with a group it does not tend to	jeofken	12.619687	-7.8845353	comment	4.0	35.0	1620291370	-11.152974
27062086	You're both wrong. If it was dynamic	"You're both wrong. If it was dynamicism then why are JS, Python, and Ruby so popular? If it's about being functional then why has Scala got more users?Languages are driven by the platform. There is no Clojure platform that people want to use, so no one uses Clojure.If a language isn't bound to it's own platform, it can share a platform and displace other tools like python, go, and rust do with C and C++ (docker is go; docker-compose, dnf is python; etc).Scala has carved out pat of the jvm platform (spark, kafka). Clojure has not.A common onramp is command line tools, but Hello world in Clojure takes 670ms to run. This is a total non-starter.    time clj -M hello.clj
    Hello world
    clj -M hello.clj  1.05s user 0.12s system 175% cpu 0.672 total

Without an on-ramp to take over a platfor"	fnord123	12.506002	-7.801793	comment	4.0	15.0	1620303465	11.92571
27063348	- Clojure without clj-kondo- PHP wit	"- Clojure without clj-kondo- PHP without phpstan/psalm/phanAll bad ideas, modern tooling can detect errors in your code before you finish your code expression, but you do need to go out of your way to setup it upMost people do not
and then complain about types instead of talking about static analysisIf you are ever coding Clojure you should be following this:
https://github.com/clj-kondo/clj-kondo/blob/master/doc/edito..."	slifin	12.628091	-7.8932357	comment	4.0	14.0	1620309786	6.759809
27306496	Seems like a really silly lisp with 	Seems like a really silly lisp with string operators and is incredibly hard to read when not trivial. This will probably be the first and last time I ever ask this question, but why not just use something like clojurescript?	millerm	12.636657	-7.8657413	comment	4.0	19.0	1622140666	-11.006245
27386056	This is what I imagine experienced c	This is what I imagine experienced clojure developers can squeeze out of a language like clojure. I would venture that they can train a junior programmer in a couple of weeks, and make them productive very fast.I guess they could make it work in any language but judging by the description clojure is indeed a great fit, due to the macro capabilities, flexibility and solid runtime via JVM.	mping	12.655333	-7.89795	comment	4.0	58.0	1622747837	-11.158513
27386313	If I want to learn Clojure, where is	If I want to learn Clojure, where is the best place to start?I have a lot of experience with Python/Javascript now, and spent many years in C/C++/Objective C and Java. Also have some Go.	misiti3780	12.660708	-7.894339	comment	4.0	15.0	1622749225	-11.16724
12621899	From JavaScript to ClojureScript: Wh	From JavaScript to ClojureScript: Which Editor to Choose?	roman01la	12.647484	-7.8494444	story	4.0	3.0	1475407898	-11.160115
12637255	Big fan of Rich Hickey.  I found mos	"Big fan of Rich Hickey.  I found most of his talks really great, and applicable beyond the Clojure universe.  My favorites: ""Are we there yet?"" and ""Simple made Easy""."	dudul	12.657633	-7.9058623	comment	4.0	14.0	1475601665	-11.1604805
12716124	Why I Think Elm Is the Future of Fro	Why I Think Elm Is the Future of Front End Development	rgoomar	13.008411	-7.6937094	story	4.0	29.0	1476574391	-12.774054
12789095	Fully agree. We're moving our work c	Fully agree. We're moving our work codebase from Clojure to Java. It's true that Java is boring and old and simple. That's what makes it great! Now we can focus 100% of our efforts on the business logic rules. (Granted, sometimes I wish we were using C# instead. But only sometimes.)	sdegutis	12.658252	-7.895715	comment	4.0	25.0	1477411836	-11.170065
12904156	This is actually why I prefer Emacs.	This is actually why I prefer Emacs. I can literally do all my development work in Emacs, with a full-featured shell (e-shell), directory explorer (dir-ed), REPL and full IDE for Clojure (CIDER). It's pretty great.	_vya7	12.645454	-7.858123	comment	4.0	13.0	1478641016	-11.01636
12950146	Debugging with Elm 0.18	Debugging with Elm 0.18	ronjouch	13.013337	-7.694104	story	4.0	147.0	1479135434	-12.76289
13052495	Heh, I just started doing some searc	Heh, I just started doing some searching on probabilistic programming about an hour ago. Funny how that works.Since it's on subject here - anybody know of any good clojure libraries or resources for probabilistic programming? Anglican definitely looks good, but their intro pages use some kinda strange workflows.	bpchaps	12.631239	-7.8797827	comment	4.0	14.0	1480292075	-11.169896
13056865	I've deployed Datomic on AWS using c	I've deployed Datomic on AWS using cloud formation to spin up two transactors for when one goes down under pressure.Throw out everything you ever thought about databases. It is from here you will learn a completely new way of dealing with data especially in environments where you need an immutable audit trail.I almost feel like Datomic solves what blockchain does (immutability) really well without the drama.Clojure was also another culture shock. I like it personally but the syntax at first was scary (but it's really simple and straightforward).Having said that I'm not 100% sure whether I realized any productivity boost working with clojure. Finding clojure developers is tough & expensive vs Java or .NET or PHP.Datomic has a bit of a learning curve and I still haven't fully crossed over, r	brilliantcode	12.677113	-7.875161	comment	4.0	21.0	1480353886	-11.161559
13095605	Zaphod: Clojure's API for JavaScript	Zaphod: Clojure's API for JavaScript's Data Structures	codecurve	12.644239	-7.883529	story	4.0	68.0	1480772674	-11.161575
13097057	Can I write Clojure that gets compil	"Can I write Clojure that gets compiled to JavaScript with ClojureScript and run that on JVM's JavaScript engine Nashorn?Obviously turning code into JavaScript at least once is a mandatory requirement for fulfilling the ""web"" part of ""web scale"" and running the JavaScript on JVM gives me the ""scale"" part./snark"	bsuh	12.648482	-7.8721232	comment	4.0	12.0	1480792833	-11.173751
13116695	Does anyone know what this means for	Does anyone know what this means for clojurescript?	xntrk	12.649916	-7.903359	comment	4.0	21.0	1481047036	-11.14607
13183416	Huh no. You may have parens but that	Huh no. You may have parens but that's it.It's not not predominantly a functional programming language and has no rich set of immutable, persistent data structures.So, it's no Clojure. But it is young. It may become a clojure but it seems presumptuous at this stage..	grabcocque	12.663535	-7.9029856	comment	4.0	117.0	1481793653	-11.144756
13183510	Calling itself a Clojure is a pretty	Calling itself a Clojure is a pretty bold statement.Clojure is one of the most revolutionary programming languages of the last decade, I can't see how this mini-toy-language packaged as a Go library can be compared to the mighty Clojure with a straight face.	iagooar	12.625881	-7.9061584	comment	4.0	105.0	1481795415	-11.157665
13183752	Clojure can compile to Javascript an	Clojure can compile to Javascript and .NET, so that's 3 major platforms, being among the most portable languages available.That it doesn't compile to Go, that's because Go isn't a good compilation target. Besides being a subpar language that ignored the last 30 years of research at least, it wasn't designed to be a platform for other languages. If you're looking for disappointments, you aren't looking in the right direction ;-)	bad_user	12.625985	-7.906441	comment	4.0	20.0	1481799482	-11.165021
13183821	Clojure is a Lisp but also much more	"Clojure is a Lisp but also much more: Readable persistent vectors, hash maps, and sets.This is kind of oxymoronic - because those things make it less of a lisp. And to be frank, if you don't think    (vector 1 2 3)

is readable, then I don't think you really get lisp.ProtocolsA greenspunning of OO features with a different name because Hickey doesn't get OO (probably never made it through to the bit SICP where you implement objects, or read the ""closures are a poor mans object"" koan).90% of the rest of what you list can be found in in various lisps - often all in the same place (racket, common lisp)."	lacampbell	12.649153	-7.8853946	comment	4.0	54.0	1481800543	-11.040082
13233761	My disillusionment with Clojure and 	My disillusionment with Clojure and Lisps	tosh	12.655708	-7.894433	story	4.0	20.0	1482365520	-11.102983
13283282	I really tried SBCL, but even knowin	I really tried SBCL, but even knowing a little Lisp (own about 6 books I've read most of), I couldn't get past the tooling. SLIME+emacs is powerful, but the tutorials are awful and very lacking. Sadly, Clojure isn't much better here. Racket is pretty good here, but I can't get past the fact that I'm essentially playing with an educational product and not a real industrial language.	throwaway7645	12.6571	-7.879078	comment	4.0	12.0	1483087037	-11.045488
13285324	That wouldn't be possible on the JVM	That wouldn't be possible on the JVM. CL's condition system is unique to CL AFAIK. Even Emacs' cl module doesn't have this condition system. You really need support from the ground up to have it.Clojure is a hosted language, CL isn't. There are loads of tradeoffs from that design decision alone. Saying it feels primitive for that difference only is jumping to conclusions rather quickly! It feels like you're comparing decades of CL experience with days of Clojure experience :)	jeremiep	12.590208	-7.8545103	comment	4.0	22.0	1483116606	-11.133297
13284713	I've used Clojure in a few cases and	I've used Clojure in a few cases and I totally adore the simplicity of its Lisp syntax as opposed to the baroquesque abomination that is Scala. However, lack of strong typing is sorely felt. I 've done a little playground-style OCaml coding and the feeling you get with OCaml is that once your program compiles, it most likely also runs correctly. Is a Lisp language with strong typing for the Java ecosystem too much to ask? Apparently it is or else we would have had it by now.	MarcusBrutus	12.535817	-7.8583193	comment	4.0	36.0	1483110954	-11.157869
13349013	If the author reads this:Can you ela	"If the author reads this:Can you elaborate more on what you mean by ""lackluster performance""? What is the use case? If you're looking for top speed in terms of C/assembly performance - I'd say yes, probably the JVM will get in your way. However, I spent months building a database/key-value store in Clojure and it's quite doable to write very high performance code in Clojure as long as you put the right type hints everywhere. Tools like YourKit can help you identify the bottlenecks in your program. Again, depends on the use case, but Clojure makes it very, very idiomatic to write code that makes full use of a multicore system - something possible in the like of Java, C, et al but definitely not idiomatic at all."	raspasov	12.644101	-7.8878236	comment	4.0	43.0	1483867262	-11.203119
13349036	(not the author)> probably the JVM w	(not the author)> probably the JVM will get in your wayNot so much the JVM, but Clojure and how it uses the JVM (although, as you say, it's possible to get not too far from top JVM performance with Clojure). It's fairly easy to get C performance (and even beat it in concurrent code) for the same amount of effort on the JVM. Currently, the main handicap the JVM has is the lack of arrays-of-structs which may cause lots of cache-misses, and requires less-than-elegant code to overcome. This, thankfully, is being addressed by the addition of value types.	pron	12.631548	-7.888127	comment	4.0	32.0	1483867901	-11.14849
13353289	Same data in Clojure:    [{:appt/sta	"Same data in Clojure:    [{:appt/start #inst ""01-02-2014T9:15:00Z"" :appt/end #inst ""01-02-2014T9:15:00Z"" :appt/description ""See Anderson""}
     {:appt/start #inst ""01-02-2014T10:45:00Z"" :appt/end #inst ""01-02-2014T11:00:00Z"" :appt/description ""See Lundstrom""}
     {:appt/start #inst ""01-02-2014T13:15:00Z"" :appt/end #inst ""01-02-2014T16:00:00Z"" :appt/description ""Attend Y Committee Meeting""}
     ...]


Let's point out some important differences:1) Clojure prefers maps over cons cells. This means that I always know exactly what I'm looking at. I don't have to guess that the second times are the end-times...I know because it' named :appt/end.2) We don't overload data types. Have a date? Use a date type. In the CL example we see symbols and numbers sometimes used for descriptions, sometimes f"	_halgari	12.62701	-7.893771	comment	4.0	15.0	1483924759	-11.144952
13362465	New Functional Language for JVM (Lux	New Functional Language for JVM (Lux) Builds on Haskell, Clojure, ML	lrenn	12.467452	-7.827212	story	4.0	23.0	1484021008	10.718356
13375644	"""Relatively easy to understand even "	"""Relatively easy to understand even if you don't know the language"" <- We have empirically verified this by showing code samples of quicksort side-by-side in Java, Scala, Clojure, and Eta to ~100 programmers who had no experience with functional programming at an exhibition. Eta won, followed closely by Scala (people just love their curly braces!). One person liked Clojure because of ""it looked like English"" and no one liked Java. For this reason, we have posted it on the landing page. We have made no claims that it's the most performant nor that it's the fully correct quicksort (accounting for uniques) - the whole point was to highlight the expressiveness."	rahulmutt	12.539324	-7.837482	comment	4.0	29.0	1484155791	9.281962
13420467	What's the state of development of t	What's the state of development of this? Did somebody use it with Raspberry pi? I want to use this over Clojure(only on pi) because I have read Clojure is slow on Raspberry pi(even 3, not sure how true that is).Also, how fast is this? How does it compare to other lisps(or schemes) in terms of speed? Can someone port the benchmarks to https://benchmarksgame.alioth.debian.org.	abc_lisper	12.649976	-7.892651	comment	4.0	27.0	1484682126	-11.124969
13421329	Alas, this ambitious project appears	Alas, this ambitious project appears to be not currently under active development.My largely uninformed armchair opinion as to why, is that the author is very performance-driven, and in the end it's very difficult to beat the JVM performance-wise. Lesson: if you want high-perf Clojure, you already have it on the JVM.Personally, I think there's room for a simple small native Clojure implementation where performance is not top-priority. Small footprint, quick startup, access to native C libs. Still holding out hope for that one.	branchly2	12.634662	-7.879133	comment	4.0	20.0	1484688103	-11.168388
13487012	> In practice, I've found that proto	"> In practice, I've found that prototyping anything remotely complex without types is so painfulJust to offer a counter-point, I have a Clojure project here with 3k LOC, without using spec/schema. All I have is 700 LOC tests. The tests enforce semantic meaning, along with (some) contracts. I miss types from time to time, but it is no where near as bad as you mention. Against me is the fact is that my app is mostly self-contained, and written all by me. I am fairly certain the project would be atleast 30k LOC if I wrote it in Java.I think value of types only comes into being when there are many people working on a single code base. Repl/tests/integration tests will take one a long way before it reaches its limits.I don't buy the argument that types are useful for large codebases, because
1."	abc_lisper	12.520528	-7.854779	comment	4.0	21.0	1485384489	-11.068704
13503571	Using JavaScript Modules in ClojureS	Using JavaScript Modules in ClojureScript	fnordsensei	12.6601	-7.8837414	story	4.0	55.0	1485558423	-11.165312
13537414	Yep, I live in the EU but I am in Ca	Yep, I live in the EU but I am in Cambodia now and I love three languages the most; Lisp, Forth and APL. So you know what to do to make me cry and have eternal enlightenment...Edit; I use Lisp in the form of Clojure daily as well as Forth for embedded. When writing embedded code, instead of assembly (check my profile, the stuff we use definitely has no room for Node but often not even C) I usually port a Forth if one is not available, at least for testing but usually it is good for production too.	tluyben2	12.633734	-7.7046847	comment	4.0	22.0	1485913456	-10.7112665
27599237	You could argue that Clojurescript e	"You could argue that Clojurescript early adoption of React was one of the reasons for it's rise.  The early work of David Nolan (Om) and Dan Holmsand (Cloact->Reagent) were, at least in my opinion, pretty influential.  Clojure's immutable data structures were (are) a perfect fit.  iirc, the fact that ""shouldComponentUpdate"" could be performant with equality was a huge, easy performance/simplicity win.  I may be way off about that, if so, I apologize."	lrenn	12.649821	-7.8756504	comment	4.0	16.0	1624408280	-11.165185
27782864	A History of Clojure [video]	A History of Clojure [video]	lukashrb	12.653395	-7.9051256	story	4.0	99.0	1625832795	-11.166869
27819812	To give a bit context, Elm main team	To give a bit context, Elm main team has been defensive against forks. They are preventing development of features they don’t think worth to them. It’s not possible to publish packages with low-level access without Elm main team approval. The compiler even has built-in DRM about that. My point is more compilers is exactly what Elm needs to flourish. C has several compilers. Python has even”jython”. That doesn’t make a language community weaker.	lisardman	13.006646	-7.691868	comment	4.0	27.0	1626176883	-12.758359
27866710	Elixir seems to be very approachable	Elixir seems to be very approachable. But some of the strengths of Clojure are unmatched, such as Java/JS interop, isomorphic code for web development, and generally being a Lisp (which includes macros).	dgb23	12.646746	-7.8709173	comment	4.0	14.0	1626537743	-11.139994
27896736	Note to non-Clojurians:Most people j	"Note to non-Clojurians:Most people just use Leiningen and don't mess with this stuff.This post does not paint a good picture of Clojure development tools, but don't get turned off by it.99% of Clojure projects I've worked on just have a declarative project.clj file and building it is as simple as:    $ lein uberjar

I will never understand the core team's acute NIH Syndrome and tendency to fragment the community, but I guess Open Source Is Not About Me."	divs1210	12.656275	-7.897476	comment	4.0	64.0	1626802765	-11.138268
27900576	> RICH HICKEY: I think that, collect	> RICH HICKEY: I think that, collectively, we are infatuated with these two notions of easy. We are just so self-involved in these two aspects; it's hurting us tremendously. Right? All we care about is, can I get this instantly and start running it in five seconds? It could be this giant hairball that you got, but all you care is, can you get it.Simple Made Easy is what attracted me to Clojure, and tools.build, tools.deps, tools.cli are aligned with this mission. Cognitect is doing exactly what they said they would do and have been doing all along.Re-read the talk here: https://github.com/matthiasn/talk-transcripts/blob/master/Hi...(PS, a note to Cognitect comms – maybe start here with your next blog post and see if people react differently!)	dustingetz	12.662183	-7.901307	comment	4.0	16.0	1626824278	-11.178362
12193711	Characteristic examples from the boo	Characteristic examples from the book Doing Bayesian Data Analysis 2nd edition [1] programmed in Clojure and OpenCL to run on the GPU. Much, much faster than Stan or JAGS!The library used (Bayadera) is still pre-release, so much polishing is still needed, so this can be considered a preview. But, it is still very useful, and not more complex for programmers than the mainstream Bayesian tools.[1] https://www.amazon.com/Doing-Bayesian-Data-Analysis-Second/d...	dragandj	12.609226	-7.8478007	comment	4.0	32.0	1469897890	5.9323225
12231146	Clojure is currently the sexy lisp d	"Clojure is currently the sexy lisp du jour.When I first learned Clojure, to me it was the first time programming truly clicked with me. That first time I ever felt that spark of ""oh my god, so that's what programming can be like!"""	hbex5	12.646724	-7.8871884	comment	4.0	37.0	1470392443	-11.142311
12305178	Can you do similar stuff with clojur	Can you do similar stuff with clojure or Scala? Maybe there's a way to avoid the bad parts	wry_discontent	12.600818	-7.8668075	comment	4.0	13.0	1471445905	-11.151029
12321568	"> adopt the idiotic ""-p convention"" "	"> adopt the idiotic ""-p convention"" which doesn't even really exist in Lisp any more.Do you have a better way of signaling to the reader that a function is a predicate? I don't write a ton of Common Lisp, but I do still see quite of a bit of foop when I read Common Lisp. Possible that most of the code I'm reading was written when this was still a thing though...I think the only reason this doesn't exist in Clojure (which is the lisp I used the most) is that ? is a valid identifier. Similarly Scheme includes ? as a valid identifier (at least R5RS as implemented by Chicken)."	emidln	12.6400175	-7.849695	comment	4.0	14.0	1471626557	-11.039167
12390979	Why not just use Clojure?You've got 	Why not just use Clojure?You've got datomic on the server and datascript on the client, transit on the wire, reader conditionals to share code and much more. Plus everything can be modified as its running.When it comes to web frameworks I don't really care about performance as much as I care about managing complexity. Which is why I'm looking at om.next over all the other frameworks.And managing complexity is not something you can benchmark in toy projects - every single framework is virtually the same at such a small scale.	jeremiep	12.647154	-7.866954	comment	4.0	14.0	1472570741	6.552899
12402481	This is one of the few JS compiled l	This is one of the few JS compiled languages that interest me: Some of these languages add a very thin syntactic layer on Javascript  and maybe a type system. If I wanted Javascript, I'd use Javascript, and if I wanted types, I'd use Flow, not a new programming language that's kinda-sorta-not-really JS.That leaves this, Clojurescript, and SPOCK as the only really interesting projects. They all have runtimes that are unpleasantly large (well, Buckle may not), but that's the price of a new language.However, Clojurescript leaves a bad taste in my mouth, and SPOCK stresses javascript implementations in interesting ways. I'm not really a fan of OCaml, but Buckle looks interesting, and more enjoyable/practical than the other two.	qwertyuiop924	12.631364	-7.80932	comment	4.0	21.0	1472690254	-11.098305
12500671	The Clojure code is shorter, but tha	The Clojure code is shorter, but that's almost entirely because it's dynamically typed. And that's not necessarily a benefit, either. Cheshire just takes JSON and turns it into plain old Clojure data (maps, vectors, strings or keywords, etc.) whereas Aeson requires the programmer to manually unroll the whole structure from top to bottom into user-defined types. But by doing so it guarantees that if something is missing or unexpected, the code fails early and fails fast. Plus the static typing enables compile-time checking of all your code which uses it, rather than how Clojure accesses JSON which is so often stringly-typed because that's easiest/shortest/fastest.	sdegutis	12.611582	-7.881616	comment	4.0	15.0	1473882889	-11.16795
35387134	One obvious point I'm missing here, 	"One obvious point I'm missing here, and that I've been missing from Janet discussion in general: why Janet and not Scheme?Gauche for example implements the latest (and IMO greatest) R7RS, its standard library is huge and ""batteries-included"" including a wide array of RFCs to the point of rivaling Python, and has a package manager in the form of Akku. Chicken has a similar story. Racket is arguably more useful ""out of the box"", but its community seems so heavily focused on using it for PL research that it's harder to justify using it for day-to-day programming. And there's Clojure as well, which I know comparatively less about, but is well-loved by its users.Heck, even Common Lisp has a lot going for it, but the Standard and the conventional Lisp dev tools are kind of chaotic and idiosyncra"	nerdponx	12.6671095	-7.86881	comment	4.0	27.0	1680270592	-10.963539
35462784	Try out Clojure libraries via rebel-	Try out Clojure libraries via rebel-readline	todsacerdoti	12.654691	-7.902846	story	4.0	70.0	1680743444	-11.213978
35510587	1. Unlike Python, Clojure actually i	1. Unlike Python, Clojure actually is functional and is optimized for it, with persistent immutable data structures and a huge library for functional transformations. You get faster, more expressive code in Clojure than in Python if you’re doing FP.2. The REPL is not on par. You can run an in-editor REPL and build your entire program in a REPL session. Combined with tap you can visualize your output on the fly.3. Macros are used, not looked down upon. But they are discouraged when not needed. Much of the power and succinctness of the language comes from macros. Boilerplate is a solved problem.There are a lot of subtle and less obvious advantages too, like namespaced keywords, a highly productive and creative niche community, a very composable and simple library ecosystem and a huge emphasi	dgb23	12.647996	-7.8880286	comment	4.0	16.0	1681119144	-11.149432
28036856	> ... and the question regarding cho	> ... and the question regarding choosing Clojure as our main programming language rose over and over againIf I find myself having to repeat myself justifying a certain decision time and time again, it's an indicator that the decision needs to be revised to be something which is a more intuitive fit for the organization.	aliswe	12.648564	-7.9036565	comment	4.0	16.0	1627914041	-11.176429
28109191	So is kawa irrelevant now that cloju	So is kawa irrelevant now that clojure exists ? And why did'n't clojure build on kawa instead of starting from scratch ?	slim	12.652939	-7.9026117	comment	4.0	12.0	1628449116	-11.182137
28186836	You don't need to write boilerplate 	You don't need to write boilerplate code and watch for syntax errors, if you use a programming language that does not encourage boilerplate or have a lot of syntax.When I start a new C# project, first 40 minutes I am mindlessly writing a scaffolding of classes, data structures and helper functions that I will need from the beginning.When I start a new Clojure project, I don't need all that, so I just stare at my blinking cursor thinking about what the program will actually do.	nlitened	12.640988	-7.883309	comment	4.0	14.0	1629011838	-11.094296
28189165	Really I think the mistake there was	Really I think the mistake there was not forking Elm. Maybe the fork wouldn't have been popular long term, but at least they'd ship.	Igelau	13.00944	-7.6934752	comment	4.0	13.0	1629038746	-12.795252
28189940	I think learning functional programm	I think learning functional programming is harder with a statically-typed language as there's so much more to learn which revolves solely around the type system. I would recommend anyone new to FP to try Clojure first. No mon[a|oi]ds necessary. I also think the transition from procedural languages is easier than from OO languages. I was lucky not to be exposed to Java or C++ in the early days of my programming career, opting for Perl instead. When I transitioned to Ruby I also encountered Clojure at the same time and could appreciate the functional/lisp elements in the design of Ruby.	cutler	12.486192	-7.802686	comment	4.0	12.0	1629044108	-11.146277
28223291	Honestly I think the main reason for	Honestly I think the main reason for this perception is that people in the Elm community have gotten increasingly tired of correcting inaccuracies people like to post about Elm on Hacker News.I spent a bunch of time doing that in the past, and eventually stopped because I felt like Sisyphus. The same people would crop up on the next thread repeating the same things anyway. Of course if the claims go unchallenged, it leads to the perception that they're accurate...but that doesn't make engaging with them  any more enjoyable a way to spend one's free time.If you want to check the health of the Elm community, visit Elm Slack and ask in the #beginners channel how people feel about it. It takes about the same amount of time as posting a HN comment, but it gives a very different perspective than	rtfeldman	13.011835	-7.697298	comment	4.0	29.0	1629303012	2.3042104
28346291	This is remarkably similar to the ad	"This is remarkably similar to the advocacy made by lots of C/C++ programmers that the language is more useful because it lets you make mistakes, which is all well and good until someone buffer overflows your server and leaks the personal data of a million people / your cryptocurrency keys / whatever.The opinion of Rust and Haskell is precisely that making mistakes is bad, regardless of your ""provocative"" opinion that it might be good, and that the language should be a https://en.wikipedia.org/wiki/Poka-yoke against certain categories of mistakes that have been found to cost the industry billions of dollars in failure.(What do the Clojure-for-web-services people do? Presumably that doesn't drop web requests to an interactive debugger, or does it? Or is that irrelevant because this is only c"	pjc50	12.621612	-7.9090524	comment	4.0	13.0	1630241531	-11.142268
28473313	> Did I miss something important tha	> Did I miss something important that should be covered?Accessibility. Outside of that everything seems reasonable. But I don't know much about cross-platforms GUI. I expect someone will come and explain that Delphi or something like that already does everything the author wants except for the integration with Clojure.I would add that I'm not sure which value Clojure provides here. Does the REPL adds anything to the live-reload environment? If not, the choice of Clojure seems to be arbitrary.	Zababa	12.653604	-7.89068	comment	4.0	29.0	1631214050	-11.175154
28490894	Ask HN: Why is it so hard to find an	Ask HN: Why is it so hard to find an Elm job	kiraken	13.008426	-7.6934996	story	4.0	3.0	1631357574	-12.774813
28550438	All available with Clojure plus you 	All available with Clojure plus you get the JVM.	cutler	12.642241	-7.8919806	comment	4.0	14.0	1631792341	-11.158621
28585245	Create ad-hoc ClojureScript scripts 	Create ad-hoc ClojureScript scripts on Node.js with nbb	Borkdude	12.6496	-7.8890967	story	4.0	116.0	1632066334	-11.169376
22381316	> But I would take any functional la	"> But I would take any functional language with types over itWhich is what? Scala? Haskell? OCaml? F#? Typed Racket? Idris?I think Clojure really hits the sweet-spot between stupidly boring, ""pragmatic"" PLs and idealistic, novelty, academic ones.Haskell is awesome, but realistically it is really difficult to quickly train someone to the point of them being able to write production-ready Haskell code.Scala has its own warts (besides, Kotlin seems to be slowly eating its pie);OCaml still struggling to get any recognition in the industry, despite all attempts from a few good players.I disagree with the notion that Clojure is not suited for large projects, but I agree that Spec needs to be improved (and it is being actively worked on). And I don't think it is not well thought out. Rich Hickey "	iLemming	12.541714	-7.8620534	comment	4.0	18.0	1582266554	-11.126195
22402320	I looked through examples and I don'	I looked through examples and I don't see what's so revolutionary about it.This is specialized language suited for more or less one task that has nothing specialized for that task which cannot be rolled in Clojure in a day or two.Challenge me, give one example that can't be done as easily with Clojure.	lmilcin	12.60547	-7.8596325	comment	4.0	23.0	1582529933	-11.150866
22459970	I really like Clojure, it's a well d	I really like Clojure, it's a well designed language and one can get quite productive, surprisingly fast.My core criticism that is not really mentioned in the article is the error messages. At the beginning I often felt lost and had no idea where to look if something went wrong.	Random_ernest	12.653529	-7.899484	comment	4.0	12.0	1583103223	-11.199988
22460026	Some of it is libraries and framewor	Some of it is libraries and frameworks. Some of it is the attention Clojure has paid to ergonomics. A lot of Clojure’s libraries seem to have been built by smart people for mediocre programmers (like me!). Elsewhere in lisp land it can feel like smart people wrote libraries for themselves.For me Racket is probably the closest thing to a decent end-to-end modern lisp experience with decent libraries outside Clojure. Gerbil Scheme also looks promising.For me I’m most often writing smallish standalone apps, which I feel are easier to make in Racket than Clojure. But between the two languages, I’d probably take Clojure if I didn’t have the JVM along for the ride. Of course the JVM is also one of Clojure’s biggest strengths. Also, I don’t trust Oracle enough to stop pretending that Graal doesn’	peatmoss	12.653508	-7.875914	comment	4.0	20.0	1583103771	-11.143726
22460192	Last week some nice folks assured me	Last week some nice folks assured me tooling was good in Clojure; and not a total time suck, and so I'm getting ready to take the jump I think... but, one thing I'm still really skeptical about... is embodied in this paragraph:> The way the languages are integrated today, Clojure developers doing full-stack development don’t really have to think about data serialisation/deserialisation. Writing code for frontend and backend differ mostly just in the way that the different implementations access the host platform. The functional aspects of Clojure, especially the immutability and focus on referential transparency, ensure that source code is mostly split into chunks of highly portable code, with the host-interop conveniently put aside in its own sections. You can move code between frontend a	rubyn00bie	12.643184	-7.8908434	comment	4.0	22.0	1583105714	-11.147382
22460626	My personal perspective (after 8 yea	"My personal perspective (after 8 years clojuring, half of that professionally) is that Clojure keeps progressing, with ever better tools and ideas for getting stuff done, optimally. I remain optimistic.At the same time, it still fails at my ""golden test"": can I gather 5 random freelance engineers and get them to ship a project within a few months, wasting almost no billable time?I can (and have) with Ruby, Typescript. People can learn those on the go, being productive on day 3 or so.Clojure is still bit of a journey on itself, involving quite a lot of stuff to learn, and plenty of choices to make.That's not necessarily a bad thing, nor Clojure's ""fault"", but it's a real cost/risk that is still there.I do envision a future where the mainstream is ideologically closer to Clojure, and Clojure"	vemv	12.648983	-7.894409	comment	4.0	17.0	1583110783	-11.160326
22523681	I was talking with a Data Scientist 	"I was talking with a Data Scientist  friend abiut what I love so much about Clojure and it was largely about the REPL. To him it sounded like nothing special - trying expressions in a prompt is hardly new or original and he does all the time in R. Which I thought is actually a really good selling point for Clojure - you get to do the really high-level data manipulation you do in R, Mathematica or even Python in a language that is compiled, good with concurrency, probably embraces your platform of choice and is also used for the frontend.What makes it different for me is two things:
- the functional style mean that many things are much easier to track in a REPL - you don't need to use a stepping debugger to get to the troublesome value of i as often.- Structural editing using parinfer or si"	dimitar	12.62921	-7.8804746	comment	4.0	24.0	1583739907	-11.10222
22548867	Looks like picking Clojure and Datom	Looks like picking Clojure and Datomic has created a great deal of technical debt for them. They started adding Spec everywhere to specify their data because they were having big problems scaling their wild west code base. But now Spec is dead and there's a new Spec2.alpha version.I don't even know how they have manage to scale datomic to that level, the support contract we had for datomic was only really used to report bugs[0] but they have more than 2000 datomic transactors? ouch.[0] Yes, too much bugs and slow, but databases are hard so I guess this was expected for a closed-source niche DB with little users.	Scarbutt	12.679884	-7.8679924	comment	4.0	26.0	1583952015	-11.197154
19099441	Some experienced devs might say the 	Some experienced devs might say the same thing if they've also found a language that just clicks with them as I have.Clojure is a locus of things I really, really like and I have no reason to change despite the recent FUD around it. Namely: Lispiness, dynamic typing, functional programing, immutability, lean pragmatic design, and it runs on the JVM. I haven't seen anything that compares to it in these regards that also has the community support that Clojure has (great projects like Leiningen, Lacinia, and so on).I've tried Haskell but felt I was fighting the compiler due to the static typing (I hate static typing). It also felt like it was designed for eggheads and not people like me just doing a job. Scala feels like it doesn't know what it wants to be when it grows up. Elixir and Erlang 	jakebasile	12.572084	-7.8296394	comment	4.0	25.0	1549484534	-11.07726
19123830	> If you undertake this exercise you	> If you undertake this exercise you will come to know the answer to the question: why has this idea (a vector-based Lisp) not gained more wide-spread adoption?It's gained incredibly widespread adoption. Clojure doesn't use cons cells at all; lists are trees of vectors internally, and vectors and maps enjoy first-class status, even as syntactic elements, right alongside lists. Clojure enjoys far more business interest than Common Lisp or any other Lisp dialect, meaning that non-cons-cell based Lisp has won.Furthermore, the C++ programmers, being performance minded, have learned something the Lisp guys still don't seem to grok: on modern architectures where cache is fast and RAM is slow, the big-O inefficiency of using vectors vs. linked lists is usually more than made up for by the speed g	bitwize	12.638853	-7.876995	comment	4.0	31.0	1549737655	-10.828111
19125321	How would Clojure be a Lisp, given t	How would Clojure be a Lisp, given that it runs zero Lisp code?	lispm	12.653449	-7.885661	comment	4.0	19.0	1549754065	-11.05478
19220285	is there a list of 'data science' li	is there a list of 'data science' libs for clojure somewhere?	Scarbutt	12.65756	-7.9072695	comment	4.0	12.0	1550780959	-11.170286
19279863	The following function is valid in h	The following function is valid in hy and clojure.(defn fact [x] (if (< x 2) 1 (* x (fact (- x 1)))))Yes, hy and clojure don't have access to the same libraries, but then neither do clojure and clojurescript, yet you'd agree that clojurescript is a dialect of clojure, yes?	jhbadger	12.648204	-7.8954787	comment	4.0	13.0	1551442894	-11.147023
19358224	An Interactive Quine in Clojure	An Interactive Quine in Clojure	tosh	12.65399	-7.8979316	story	4.0	47.0	1552305275	-11.190223
19359482	Clojure is a great language on its o	Clojure is a great language on its own, like many articles show. But it feels like a big chore when you are doing business apps. You are between these two worlds, debugging imperative java code/libs and debugging clojure  functional code/libs at the same time.	Scarbutt	12.650432	-7.8932886	comment	4.0	12.0	1552316796	-11.134689
19479819	It's interesting that the very thing	It's interesting that the very things that attracted the author to Clojure was what kept me from moving to it from Python.I enjoyed the syntax. Loved the immutability. However, I wasn't able to understand the structure of program data at a glance even when reading my own code. The reliance on lists and maps everywhere meant that the structure of data was encoded in the code of the functions that created it and sometimes you had to go several functions deep just to understand the bit you wanted.In Python if I'm returning a tuple that's more than 2 or 3 elements long, I know that it's time for, at the very least, a namedtuple because I've had to deal with code in the past that has mysterious 5-tuples etc that just becomes too tiring to deal with.To be clear, big collections in Python aren't 	hetman	12.615656	-7.878044	comment	4.0	33.0	1553479085	-11.173199
19523447	The main issue with using Clojure is	"The main issue with using Clojure is that you are expected to build everything out yourself. A lot of dependencies tend to stop being maintained after a while. Auth systems etc. are half-baked with 10 different implementations on GitHub. The newer shinier ones lack in features while the more featureful ones are from 3 years ago and have not seen a single update since. Now lisp people like to say ""but...but.. backwards compatibility!"" Sure that works for a lot of things but it goes out of the window when you need to prototype something quickly and your intern using Django/Rails has already built a MVP while you are still trying to sort out your dependencies story. Now you can always pull in Java libs, but then you will spend the rest of the week writing a wrapper for a very tiny subset of f"	sansnomme	12.650967	-7.874478	comment	4.0	13.0	1553878873	-11.146539
19728333	Clojure is popular? It's at the bott	"Clojure is popular? It's at the bottom:https://insights.stackoverflow.com/survey/2019#technologyAs much as I love Clojure, it's still a harrowing language for beginners to learn and use. The learning curve is just too high. If you have to learn category theory in other to handle basic programming flows, then there's just something wrong.Elixir, for instance, has many functional primitives, but isn't dogmatic about it. It can ""feel"" like traditional OO-style programming without the cruft."	shay_ker	12.600948	-7.863076	comment	4.0	15.0	1556026057	-11.159217
19728502	I work at Walmart Labs. Clojure is s	I work at Walmart Labs. Clojure is super popular[1] in Walmart Labs. Clojure is fun and importantly it is a very productive language to work with. This gain in productivity comes from less state, thus easy to debug and fix, and functional approach, so the functions do what exactly what they are supposed to and there are no hidden surprises.Less state or immutability means concurrency is easy. Easy concurrency means we can scale[2] applications with ease. I mean ease of development. It takes less work, less mental effort to take something that works for a single thread and make it work in a multithreaded and/or distributed manner over hundreds of thousands of cores. Debugging is easy too. P1 incidents for a microservices written in Clojure takes less time to debug compared to those written 	throwawaywlabs	12.637026	-7.8834157	comment	4.0	22.0	1556027293	-11.162946
19730326	ClojureCLR exists as well, to target	ClojureCLR exists as well, to target the .net CLR VM.It's an official dialect: https://clojure.org/about/clojureclr	didibus	12.650835	-7.8934755	comment	4.0	12.0	1556037820	-11.147717
19875335	ClojureScript: Graal.js REPL Environ	ClojureScript: Graal.js REPL Environment	tosh	12.6508875	-7.880334	story	4.0	137.0	1557466595	-11.188189
19906924	Let me tell you my perspective as a 	Let me tell you my perspective as a Lisp enthusiast and ex-software engineer who now works in academia. I think the problem is that most people who write software in the world (even many professional software engineers) just want to solve their problem and will resist if at all possible having to learn anything difficult (such as S-expression syntax), even if it is promised that their hard work will pay off.The academics I work with, for instance, prefer Python, tolerate Java, do OK with JavaScript, but run for the hills when they see Lisp. When I tell them that ClojureScript not only has semantics with consistency that will elicit sobs of joy, but is also historically the most stable and concise way of targeting JS in the browser, maybe a few of them will be interested, but as soon as I s	lgessler	12.655772	-7.8036337	comment	4.0	18.0	1557810507	-10.883811
15771856	Learning lisp is never in vain. You 	Learning lisp is never in vain. You can almost apply your functional programming paradims learnt in clojure to most of the dynamic languages out there. Plus you will be thinking in the immutable way of doing things.	tejinderss	12.6626215	-7.859871	comment	4.0	13.0	1511543824	-10.847145
15771928	As Evan Czaplicki (creator of Elm) s	As Evan Czaplicki (creator of Elm) said:“If functional programming is so great, why is it still niche? We have a product that can practically eliminate runtime errors, make refactoring much easier, lighten the testing burden, all while being quite delightful to use. What’s the hold up?”- http://www.elmbark.com/2016/03/16/mainstream-elm-user-focuse...I'm just getting into Clojure and enjoy working with it so much that I don't care if there are job opportunities at the end of it to justify the time investment and mind-reboot. It's the first language that I didn't feel like I was fighting, and Parinfer has made all those “weird parentheses“ a joy: https://shaunlebron.github.io/parinfer/That said, there do seem to be more opportunities than last time I looked at Clojure/Scala/Haskell (Function	modernerd	12.592781	-7.7715235	comment	4.0	26.0	1511544696	-11.254269
15778932	I really want to like Carp but I som	"I really want to like Carp but I somehow feel that the Rusty memory model does not fit the Lisp philosophy... all the borrowing story comes from a basis mutability.I wish for something more Clojurish based on immutable data.  Then one can exploit the power of inferred type linearity/affinity to transparently build safe ""transients"" and other cool stuff.  Maybe some day I should write such Lisp myself on top of my C++ immutable data structures [1] :-)[1] https://github.com/arximboldi/immer"	arximboldi	12.619888	-7.869903	comment	4.0	26.0	1511658876	-11.087989
15778952	I've been waiting for a non-Clojure 	I've been waiting for a non-Clojure lisp to make some headway. Immutability is mostly a fad: look at how incredibly complicated Clojure's implementation is. It's not worth sacrificing elegance just to attract the true believers.	sillysaurus3	12.581859	-7.8565316	comment	4.0	21.0	1511659244	-11.127238
15836297	Nightcoders.net – A Cloud IDE for Cl	Nightcoders.net – A Cloud IDE for Clojure	Immortalin	12.650558	-7.8989625	story	4.0	113.0	1512282805	-11.158445
15883095	Rather than most popular, I propose 	"Rather than most popular, I propose using the most useful.That'd be Lumen.http://github.com/sctb/lumenIt's the only lisp that can interface seamlessly with any JS library you want. Just `npm i leftpad && LUMEN_HOST=node lumen` and type `(require 'leftpad)`.  $ npm i leftpad
  $ LUMEN_HOST=node lumen
  > (require 'leftpad)
  function
  > ((require 'leftpad) ""foo"" 5) 
  ""00foo""

Other lisps are nice, but they all try to build their own ecosystems instead of use existing infrastructure. So if you want to do webdev and run into a problem with the library, your only option is to fix it yourself or write your own, since most people don't use lisp for webdev.That brings us to Clojure: the prima facie ""lisp for webdev"". It's a good lisp, but it forces you into non-optional immutability. That's a f"	sillysaurus3	12.652054	-7.8592553	comment	4.0	15.0	1512776529	-11.063525
15982010	I keep looking at ClojureScript, and	"I keep looking at ClojureScript, and decide to try it. And then I get to the ""requires JDK"" and just turn around and walk out the door. It seems like an interesting language, but it would be nice to have it run without that requirement."	v4tab	12.6494665	-7.8881783	comment	4.0	14.0	1513884661	-11.170732
16000683	I write ClojureScriptA good indicato	I write ClojureScriptA good indicator of if a technology is going to explode, is if emerging language users are excited about it, as good ideas tend to trickle down from the more advanced/research-y ecosystems which aren't as constrained by legacy. So for example React was built by a user of OCaml.ClojureScript early adopted React.js through the Om project in 2013 and there is a growing number of competing React adapters, Clojure rewrites etc. I first saw virtual-dom in ClojureScript in 2012 (eight months before React came out).Number of ClojureScript projects with traction that are based on vue? Zero, that I am aware of.	dustingetz	12.654149	-7.8729067	comment	4.0	24.0	1514140881	-11.165132
16180397	Clojure Numerics: Orthogonalization 	Clojure Numerics: Orthogonalization and Least Squares	dragandj	12.644714	-7.9064364	story	4.0	118.0	1516303284	-11.155728
17946193	So... awful and bloated Java code (w	"So... awful and bloated Java code (with javadocs, why?!) compared to short counter-examples from Clojure.
IMHO quite terrible way to compare the two…"	ktosobcy	12.639806	-7.8918114	comment	4.0	24.0	1536505227	-11.183655
17946303	Thankfully Clojure will go nowhere b	Thankfully Clojure will go nowhere beyond a few edge places. I saw a decent sized project written in Clojure script that had to be rewritten once the original authors moved on as new hires struggled to get anything done. Small features took enormous amounts of time.	ronnier	12.655487	-7.8959904	comment	4.0	23.0	1536506530	-11.175283
17946712	Not really. Although Clojure and Clo	"Not really. Although Clojure and Clojurescript are both dynamically typed, Clojure is strongly typed while Clojurescript is weakly typed.Clojure:(+ ""1"" 1)ClassCastException java.lang.String cannot be cast to java.lang.Number  clojure.lang.Numbers.add (Numbers.java:128)Clojurescript:(+ ""1"" 1)""11""They may be close, but that is all the reason for concern. There are a million ways that small semantic differences like this can completely fuck you and leave you in a debugging nightmare. I would rather use javascript, AKA the worst language ever invented, than a language that claims to be cross platform but with semantics that change depending on the platform."	saosebastiao	12.646962	-7.890261	comment	4.0	18.0	1536512127	-11.155587
17960005	Clojure had this same property, and 	"Clojure had this same property, and it seems like a benefit at first: because new ""language features"" aren't tied to releases of the language, anyone can create them and instantly share them with the community for everyone to immediately start using.A great example is destructuring, which someone wrote a macro for, around version 1.2 or so, that got bundled with the language shortly after. You can't do that without changing the language, or being able to extend it with macros.But in practice, having community-written macros means you'll get several versions of the same one, and there often won't be any clear winner since each will have strengths and weaknesses, and at least some authors will be unwilling to merge or add features or change their version, so that you end up with a bunch of a"	sdegutis	12.650955	-7.890704	comment	4.0	12.0	1536676141	-11.146163
17980575	Was thinking the same. Probably it d	Was thinking the same. Probably it doesn't make a particularly good image of Emacs/Lisp users.I happen to tweak Emacs and write Clojure for a living, but thankfully I left the 'meta' trap behind years ago. My blog in on Medium.	vemv	12.662289	-7.878256	comment	4.0	30.0	1536860053	-11.03998
17997735	Ambly: embedded ClojureScript	Ambly: embedded ClojureScript	tosh	12.65976	-7.8944173	story	4.0	73.0	1537082432	-11.170094
18139974	I wonder how performance sensitive t	I wonder how performance sensitive this code has to be? Clojure is a pretty bad choice for numerical work in general since function parameters are usually just Object and this leads to a lot of boxing. You can type hint them as primitives but it's pretty funky internally once you start doing that. If code can offload the numerically intensive bit to either Java or something native (as Neanderthal does) then it's more tractable, or of course if it doesn't actually require very high performance.Still, awesome effort - it looks like a ton of work.	lemming	12.633211	-7.89099	comment	4.0	15.0	1538661895	-11.150345
18160853	I can't say I've personally seen any	"I can't say I've personally seen any evidence of ""mass migrations"" of this sort. However, I can personally say that after 5 years of working with Clojure and with several large Clojure projects under my belt now, I'm starting to realize that I'm losing confidence in using Clojure for large projects and the feeling of how _maintainable_ that project will be in 2-3 years or longer. I think Clojure hits a sweet spot (at least for _me_ personally) for small-to-medium sized projects though, and I don't hesitate to use it in those cases.The thing I've _consistently_ seen with every large Clojure project I've been a part of is that as the project grows, it becomes harder to make sense of the types used across the project. On the last couple of these projects I've been on, Schema was used to annot"	gered	12.641742	-7.899401	comment	4.0	24.0	1538924168	-11.115792
18160987	I got the Clojure bug at some point 	I got the Clojure bug at some point not long ago. Decided I’d write a crawler and some data munging stuff directly in Clojure since it’s all about data processing.Crawlers naturally want to be stacks with pipelines and expressing them as tail recursions over URLs curried into transducers, etc was easy enough conceptually, by difficult in reality because you want crawlers to be stateful. I think in clojure you end up hacking state by just attaching stuff to the outputs of your functions and building of more complicated objects down the line.I discovered that stuff which is cake in SQL or a language with data frame support is often typically hard in Clojure. Eg eg joining data , aggregation, etc. The few clojure libraries for this sort of thing are complicated to use because they have a mech	usgroup	12.633794	-7.88577	comment	4.0	15.0	1538925752	-11.152342
18161085	Every programming environment has do	Every programming environment has down sides and Clojure is no exception but I still think that using Java instead of Clojure is not better because simply you have 3-10x source code to maintain and the number of bugs are correlating with number of source code lines. On the top, I quite often see null pointer exceptions in Java when in theory that should never happen because we are statically typed.	StreamBright	12.64843	-7.8998103	comment	4.0	19.0	1538926804	-11.159416
18193315	Clojure has this advantage of Java I	Clojure has this advantage of Java Interop. So even if you didn't find native Clojure libraries, you can always find Java libraries. And you will find Java libraries for pretty much everything under the Sun. Sure they had to sacrifice a lot for that, but ultimately its worth it.Any language that has to compete and be acceptable to the larger programming community today needs libraries. So it kind of becomes a Chicken/Egg problem.I don't think anything today will ever reach the levels of Java usage. Partly because no company is likely to spend on a new language as much as Sun spent on Java.So you are pretty much well off building on their ecosystem than fight it.Having said that, TCO is the only thing I missed in Clojure compared to CL.	kamaal	12.635882	-7.887719	comment	4.0	15.0	1539264386	-11.160741
18228249	As a dev from non-CS major, I person	As a dev from non-CS major, I personally havn't learnt anything about Lisp but I would like to know. Is Clojure (specifically ClojureScript) a good start to study about it?	kbumsik	12.668733	-7.8801064	comment	4.0	14.0	1539687452	-11.0554495
18268803	A bit unclear from the landing page 	A bit unclear from the landing page if it's an IDE with a REPL or if you can edit the IDE you're running in..Kinda sounds like an object oriented Emacs? Or what the creator of Nightlight is trying to do with Clojure.	geokon	12.646329	-7.896239	comment	4.0	14.0	1540140100	-11.163549
18345336	Is Clojure still a thing? It seems t	Is Clojure still a thing? It seems to have fallen off my radar. Java seems resurgent after 8, even Scala seems to have lost momentum.	rb808	12.610661	-7.8742723	comment	4.0	19.0	1540991545	-11.179739
18346250	I worked in a large company where cl	I worked in a large company where clojure was used. After the original developers moved on from that project (they always move on), it was a giant struggle to get people who could work in the code base. They ended up rewriting it in something more standard. Whatever benifit clojure provided was outweighed by the high cost of maintaining the code base and the inability to find devs who wanted to work on it.That’s my only data point with clojure.	ronnier	12.657619	-7.8974533	comment	4.0	13.0	1540998196	-11.17167
18346070	There are a lot of people who claim 	There are a lot of people who claim they're more productive in Clojure, in spite of or because of its dynamic typing.I'll just throw my anecdatum out here: I found that dynamic typing was a major pain even on my own personal projects. I also never found REPL-driven development to mesh well with my workflow.In Scala, for example, entire classes of error that I just shouldn't be able to make don't exist. Maybe I'm just the kind of person who works better with static typing.Clojure overall is an excellent language with really good features. It just won't get out of my way sometimes.	blandflakes	12.542185	-7.8560467	comment	4.0	23.0	1540996972	-11.127552
18347225	> but as a LISP most people aren't g	"> but as a LISP most people aren't going to be excited about using it.I agree that Clojure has a lot of strong points and that s-expressions
probably put a lot of people off, but as a Lisp programmer, I was very
disappointed in Clojure's debugging/interactive development story (and I've
heard that from a lot of others). It feels more like using a typical scripting
language compared to the traditional Lisp/Smalltalk experience, and even
there, a typical scripting language would at least give useful backtraces. As
it stands, I think a decent number of conventional Lisp programmers would also
worry about large Clojure programs being unmaintainable unless they're
superbly written."	kbp	12.653067	-7.8791847	comment	4.0	19.0	1541004223	-11.062353
18347847	"Just as with the word ""developer"" [1"	"Just as with the word ""developer"" [1], I'm beginning to think that the word ""refactor"" is a dirty word.  Are we even talking about the same activity?  How is it people are alternately claiming that Haskell and Clojure (virtual opposites on the language spectrum) are infinitely superior to each other at the same thing?Wikipedia defines it as ""the process of restructuring existing computer code without changing its external behavior"", which sounds about right, but it's also so completely generic that it could mean almost anything.Claiming that Clojure can't do 'meaningful refactoring' sounds to me about like claiming that Kanji is bad for transcribing Welsh, or that sign language doesn't work well for audiobooks.  They're technically languages but the fundamentals are so different that all t"	ken	12.547271	-7.8810463	comment	4.0	12.0	1541008452	-11.138702
18370281	> I wouldn’t want to use racket for 	> I wouldn’t want to use racket for applications that would have thousands or millions of concurrent users. For programming in the large, clojure wins by a long shot.Can you explain why?Because it's been used more in big prod envs? Or for reason intrinsic to the languages themselves? If the latter, which ones?	dorfsmay	12.677081	-7.843926	comment	4.0	29.0	1541255148	-11.103299
18377209	> and Clojure’s syntax is pretty lim	> and Clojure’s syntax is pretty limitedErm, what? I am confused by the use of the word 'limited' in this context.	outworlder	12.65365	-7.894506	comment	4.0	31.0	1541355292	-11.151869
18426635	Introduction to Clojure (2013)	Introduction to Clojure (2013)	mariuz	12.643874	-7.9022365	story	4.0	108.0	1541948090	-11.172569
18486420	The weirdest part of this survey is 	The weirdest part of this survey is in many categories, the most experienced developers (and by extension, the highest paid) were using a less popular technology. Over 50% of people surveyed had heard of ClojureScript and were not interested, but the developers who used it and liked it had the highest average years of experience and highest average salary. Same goes for Ember and Polymer for frameworks, and Relay for data store. I'm really curious what the reasons for this are.	nepeckman	12.661111	-7.9003434	comment	4.0	12.0	1542636125	-11.216565
18538349	>> Cognitect does not make money fro	>> Cognitect does not make money from Clojure. Period.But it makes its money because it is the company of the creator of Clojure.  AFAIK the company was started after Clojure gained traction.  That means they are well compensated, that's as good as money, IMO.Reading the original post and this, I don't think Rich Hickey is a good citizen of the F/OSS community.  F/OSS is not about cost.  It's about sharing.	gkya	12.6600275	-7.9075556	comment	4.0	13.0	1543280329	-11.185662
18541032	This thread made me look at Clojure 	"This thread made me look at Clojure again (it has been a few years since the last time). Searching for Bayesian inference libraries I came across this: https://github.com/cemerick/raposo""Never, ever, ever give a talk about a library or other code publicly unless it's in a public repo prior to the talk. Period. (Exceptions to this might be things like case studies and such.) Doing otherwise is surely irritating to talk attendees, but it's even more disrespectful towards organizers, as their acceptance of your talk may have been implicitly preconditioned on the attendees being able to benefit from the code/library/project in question.""Is the expectation now that when you talk about something it is necessarily going to be open source? (And from there the expectations grow and grow...)"	kgwgk	12.652769	-7.894157	comment	4.0	22.0	1543313397	-11.187818
18541737	> Though Rich is right, it pains me 	> Though Rich is right, it pains me to read this because it is indicative of some disputes in the clojure community.I am genuinely curious why you, or anyone else, would think he is right. I can see why people would agree or why he wants to do things a certain way, but to be right you have to have arguments backing up what you are saying. I don't see that in this post. Am I missing something?	hoaw	12.648765	-7.9098206	comment	4.0	16.0	1543321548	-11.192232
18564361	The only tools I've found with decen	The only tools I've found with decent support for Python and other languages are all emacs based. Same goes for the Clojure and CL ones, actually. It's no surprise, I suppose, because this style of programming is so natural to an emacs user.But it's difficult with Python as soon as you try to do anything beyond a single module. CL and Clojure have proper packages and namespaces so it works fine. But in Python you're limited to working on the context of a single module. If you modify a module that was imported then you have to restart the REPL because you can't reload modules. It just doesn't work.In CL I would just load the entire system then eval whatever part I want to. From that point I would never not have the current version of the system completely loaded into the running image. Much	black-tea	12.627157	-7.867874	comment	4.0	22.0	1543527934	-11.102241
18564600	Interesting. But one of the points o	Interesting. But one of the points of Clojure is to get away from the object-oriented way so I'm not sure that I'd like Smalltalk.	black-tea	12.577707	-7.7991576	comment	4.0	15.0	1543529406	6.81441
18565454	I need a Clojure job, their technolo	I need a Clojure job, their technology seems like it's from the year 3000 and I'm over here in PHP land banging rocks togetherTheir idiomatic database can travel through time, they focus intently on composition, referential integrity, immutability to the database levelThey have specs which can validate things typically better than types and they composeThey focus on shared protocols which gives them amazing leverage, like the internet works because we all cooperate via the http protocolI've been looking quite closely at datomic recently and that database looks ducking magicNow datafy and nav will give rise to generalised browsers of anything Clojure can touch, conceptually it's kind of like my file system, my SQL browser, my web browser, my profilers, my debuggers and any number of other t	slifin	12.663103	-7.8911448	comment	4.0	16.0	1543536913	-11.195774
18623750	The 80-character limit may have come	"The 80-character limit may have come from punchcards, but it's still important in 2018. It allows me to have three side-by-side columns of code, and I know I'm not alone. Even 100-character limit would break similar setups.Furthermore, I personally find a lot easier to read code that is not too spread horizontally. I do not have extensive experience with Lisp or Clojure, but all languages I've worked with will handle a ""small"" line width of 80 character just fine most of the time.I do recognize this is a matter of personal preference, but please don't dismiss the 80-character limit because it's old. It may be, but it is still relevant.Other than that, I wholeheartedly agree with the post. I started toying around with clojurescript for the past few months, and the one thing I can't wrap my "	napsterbr	12.628772	-7.8614793	comment	4.0	19.0	1544140399	5.7537932
18692910	The question is valid if you intend 	The question is valid if you intend to stick with one paradigm and keep it pure. For any practical purposes, that's useless crap.Nothing wrong with writing the gist of your program written in functional way, keeping things immutable, allowing for orderless execution and lazy evaluation. But because your program interfaces with the real, consequential world it must realise all that computation at the pivot points where there is I/O and it suddenly matters that the lazy evaluation is complete.Have a procedural loop to drive your events and other practical stuff and, from there, launch functional computations to calculate a completely or partially new state for your program. Keep things mostly immutable but do mutation in certain specific locations where it makes sense.Clojure is good at draw	yason	12.612053	-7.878698	comment	4.0	23.0	1544965768	-11.151016
18703537	> I guess I might ask what this stan	"> I guess I might ask what this stance is founded on?Kotlin has Kotlin/Native, so I was hoping there might be a similar initiative for Clojure. But, a few reasons:* Startup time* Ability to deploy/share a binary* The JVM just seems so ""heavy"" to me. It's certainly the only language runtime I know of that runs a persistent helper app, or asks to install an Ask toolbar upon installation.* Bias against Oracle and Java> Also I think recent Java releases have gotten into making self contained binariesTIL, thanks.Edit: edited."	kbd	12.619107	-7.8565755	comment	4.0	18.0	1545092512	-11.141095
18741713	I thought this was one of the notabl	I thought this was one of the notably bad talks this year. The whole premise that a function of Maybe a should be a function of a without an API change is neither intuitive to me nor really justified by Hickey. Different things are different. It's sad to see someone build such a wall around himself when faced by something (type theory) that he doesn't understand.	maxhallinan	12.5449705	-7.8779125	comment	4.0	44.0	1545502244	-11.19606
18841526	I wonder how good clojure is with so	I wonder how good clojure is with soft real-time like graphics rendering/games, or as an embedded script engine.	chii	12.647739	-7.893026	comment	4.0	19.0	1546818174	-11.165319
18842004	As a Lisp dialect it isn't that inno	As a Lisp dialect it isn't that innovative besides a few syntactic improvements [0]. I'd gladly use Common Lisp instead if it could do something like ClojureScript. But by design it'd be hard to pull off.Like a good politician Clojure is pretty unimpressive in of itself, for any given characteristic, someone has a better take. But as a whole it's one of the few sensible choices out there.[0] I feel like they're generally underrated. Adding [] {} and #{} might not seem like much, but when writing DSLs they really do make all the difference.	axelrosen	12.63958	-7.8760633	comment	4.0	21.0	1546824124	-10.991223
18871166	* Obligatory Pine joke here *(I know	* Obligatory Pine joke here *(I know the Elm people don't like jokes about the email client.  Tough; they should have picked a name that wasn't already used.)	patsall	13.014773	-7.6971684	comment	4.0	16.0	1547089294	-12.772862
18871344	In a comment below the main post the	In a comment below the main post they say that the app they wrote is approximately 45,000 lines of code over 170 Elm files.That's one of the largest (and apparently most useful) Elm apps in the wild that I've heard of, and the fact that it exists and they had an overall good experience with it inspires me even more to try to learn and use Elm.	savanaly	13.000779	-7.6923647	comment	4.0	46.0	1547091986	-12.682467
29861508	"You wrote ""There's a fundamental pro"	"You wrote ""There's a fundamental problem with generating a beautifully typeset document for a codebase: it's dead. It can't render inside just about any actual programming environment (editor or IDE) on this planet, and so we can't make changes to it while we work on the codebase.""Sorry, that's not correct. When writing a literate program you should also include a chunk containing a Makefile. Extract the Makefile and let it construct the program.I did this with the whole Clojure programming language. The whole source code for all of Clojure, as well as the test cases, are in the PDF. The sequence (from scratch is):Extract the Makefile from the Latex document.
Run the Makefile. This:  1) extracts the code and tests

  2) compiles the code

  3) runs the tests

  4) recreates the PDF from th"	daly	12.645847	-7.8973317	comment	4.0	21.0	1641717556	-11.155331
30139715	What does the Common Lisp community 	"What does the Common Lisp community think about the adoption of Clojure and ClojureScript by ""knowledge graph"" companies like Roam Research and clones like Obsidian (https://news.ycombinator.com/item?id=28894481) and Athens (https://news.ycombinator.com/item?id=26316793)?May 2020, https://athensresearch.ghost.io/why-you-should-learn-clojure...> Clojure code is incredibly dense. If I have a file with 30 lines of code, it might as well be 1000 lines of java. I’m not exaggerating. The code does a whole lot in a few words and once you’re comfortable with Clojure, man you can whip out a web service really fast ... You will never want to program without a REPL again ... Clojure isn’t just function-oriented in its syntax; it can be object-oriented, and stack-oriented, and array-oriented, and so o"	walterbell	12.647724	-7.8968844	comment	4.0	21.0	1643567503	-11.113139
30173892	Any reason why they haven't moved to	Any reason why they haven't moved to Clojure. For one, Clojure has all the Java libraries at it's disposal.	abc_lisper	12.650621	-7.893037	comment	4.0	16.0	1643777895	-11.202605
30295505	First off I don't think this is quit	"First off I don't think this is quite the way Hickey thinks about the issue (though I suspect he would agree about the working memory part), especially with the comment about etymology /s!(it's a meme in Clojureland that every Hickey presentation and library must contain at least one slide on/mention of etymology) In particular Clojure as a whole embraces an ideology of ""open systems"" vs ""closed systems"" where we start with an infinite sea of ""can""s and then add ""can't""s as needed.But that's immaterial to your main point, which is that adding state into the mix of things makes things hard. Which I agree with, but again to steelman the point, I could turn around and say that values allow for exponentially more possible values as well! When I see a map passed into a Clojure function I have n"	dwohnitmok	12.617166	-7.8821955	comment	4.0	20.0	1644542204	-11.148774
30424390	I started playing around with Clojur	I started playing around with Clojure back in 2014 by implementing a rudimentary polyglot persistent news feed microservice. That microservice used Ring which sits on top of Jetty. I blogged about that implementation at https://glennengstrand.info/software/architecture/oss/clojur... which is my personal blog. Last year, I re-evaluated Clojure with a feature identical microservice. This time, I integrated with Donkey which sits on top of Vert.x and https://glennengstrand.info/software/architecture/microservi... is where I blogged about that implementation.I put each of these implementations in a load test lab where I collect then analyze the performance data for comparison purposes. Those two blogs include the performance results. It is hard for Clojure to compete with other tech stacks, pr	gengstrand	12.6368885	-7.8920627	comment	4.0	18.0	1645508397	-11.2072935
30482161	Not sure if Clojure is considered ni	Not sure if Clojure is considered niche, but anyway I do it because it's the most fun programming language for me.	mateuszf	12.646224	-7.889939	comment	4.0	13.0	1645911080	-11.164762
16411015	Boilerplate can happen at a higher l	"Boilerplate can happen at a higher level than just writing down type names.A good example is ""variadic"" functions. Consider computing the max of three numbers. Clojure's `max` takes any number of arguments, while Haskell has `max` that takes two arguments, or `maximum` that takes a list of arguments; both require some boilerplate to apply if you have exactly three.It's impossible to write down a Haskell function equivalent to Clojure's `apply`. You have to work around its absence, e.g. with awkward folds.Or for a more immediate example, compare Clojure's flexible `map` to Haskell's big 'zip' family: zip1, zip2, zip3, zipWith5..."	millstone	12.431589	-7.837307	comment	4.0	18.0	1519019301	-11.114957
16412333	> More people should get to know clo	> More people should get to know clojure as it's a wonderful language that has almost all concurrency models on this planet.Clojure is great. But Rust is a Must, so I hear, and you will need some Python for ML. And then of course JavaScript if your stuff touches the web, and it all does. And there is Go and Erlang or is that Elixir for systems and transactions. Ruby or PHP for RAD and Java for the large stuff can not be ignored.And before you know it you'll be bad at 25 languages, instead of good in one or two that allow you to do what needs to be done.All these languages are great in the sense that they exist and show what is possible but they make it super hard for a professional programmer with ~8 hours in a productive day to choose which eco system (which is far larger than just the la	jacquesm	12.534147	-7.8316693	comment	4.0	29.0	1519041449	-11.082539
16412577	I just got rejected in a hiring proc	I just got rejected in a hiring process at Nubank (a sexy fintec from Brazil that uses clojure a lot) because I used a database for the take-home code challenge they sent me (writing a REST API). Since I'm a Python developer who knows little about concurrency in clojure and I would not like to use locks, I thought it would be better to delegate these things to the database.Apparently I was supposed to use a global shared collection instead of a proper database because they want to see if I'm able to map/filter/reduce.Recruiting is such a gamble - I have this former colleague that I've introduced to functional programming and he passed with flying colors at Nubank's recruiting hoops. I would not say I'm smarter than him but he would agree that I know more about our trade.	scardine	12.65512	-7.8919215	comment	4.0	20.0	1519045217	-11.192046
16592459	How is Common Lisp for SPA developme	How is Common Lisp for SPA development? I tried to look for anything on either Racket or CL side and pretty much a dead wasteland on that front.I've used re-frame ClojureScript for a few years now but would like to dip my toes in CL, just can't seem to get a head start. Maybe trying CL on the backend first, but even there Clojure dominates..	serpix	12.681764	-7.8666615	comment	4.0	18.0	1521119283	-10.939867
16623167	Respondents:2014 - 13392015 - 244520	Respondents:2014 - 13392015 - 24452016 - 24202017 - 23252018 - 2325Has the uptake of Clojure plateaued?	damagednoob	12.650473	-7.90844	comment	4.0	14.0	1521493569	-11.1742115
16639734	Clojure does not have an alien synta	Clojure does not have an alien syntax.  As with Lisps in general, it has almost no syntax.  (operator param param ...) Done.	blunte	12.643915	-7.8895235	comment	4.0	24.0	1521650059	-11.131764
16696237	Ask HN: Best programming language fo	Ask HN: Best programming language for rapid development?	tinderliker	12.600266	-7.849741	story	4.0	2.0	1522224914	-11.121234
16799188	Serious question:  What's the busine	Serious question:  What's the business value case for not using Elm?	carapace	13.011668	-7.6935763	comment	4.0	14.0	1523338170	-12.767203
16923689	Looking at this as someone who's bee	Looking at this as someone who's been writing a lot of ClojureScript lately, I'm reminded of how nice it is to be writing in a Lisp: if I felt this was the right syntactic construct for a common-enough problem in my codebase, I'd write a macro for it and get on with my life without having to wait for it to trickle through committees, compilers, and browser implementations.	lgessler	12.640245	-7.869293	comment	4.0	19.0	1524676273	-11.075351
17037350	I liked clojure when I dived into it	I liked clojure when I dived into it but lack of static typing is a pain especially once you have got used to the wonderful refactoring and code-intelligence abilities you get by adopting the tools of static typed programming languages like Java/Go/C#/F#. Also performance!	lenkite	12.557041	-7.8412256	comment	4.0	48.0	1525943848	-11.1372
17037839	"I'd say several reasons:
1.) a lot o"	"I'd say several reasons:
1.) a lot of folks have trouble with the abstactness
2.) a lot of folks think C syntax is how all languages should be
3.) the lisp ecosystem is fractured into too many lisps like SBCL, Clojure, Racket, Allegro, Franz, Picolisp, ABCL, Shen...etc, so some confusion amongst those that are new
4.) poor windows support for SBCL...it literally tells you it is experimental if I recall correctly. Setup wasn't straightforward
5.) tooling is complex and emacs is recommended for both SBCL & Clojure, which is arguably more difficult than hitting run in most modern IDEs
6.) multi-core seems to only be in Clojure
7.) lack of decent libraries. There is always someone quick to say that this is false and that they have everything you need, but coming from Python and Perl's CPAN, I "	FractalLP	12.672724	-7.8708715	comment	4.0	41.0	1525950508	-10.923978
17254659	Can someone explain the benefits of 	Can someone explain the benefits of Datomic Ions? What problems is it supposed to solve and how does it compare to existing solutions?Also, what is the story regarding local development? (I also have this concern about AWS Lambda; it seems you can only realistically run code in the actual cloud environment)We are investing heavily in the Clojure-ecosystem (but not yet Datomic). It seems Cognitect is strongly headed into a direction which involves some kind of holistic vision about a new stack, but they don't seem to explicitly communicate this vision anywhere.Edit: I asked the above question also on Clojure Reddit and got an interesting response: https://www.reddit.com/r/Clojure/comments/8p3d5s/datomic_ion...	vincentdm	12.682861	-7.864978	comment	4.0	18.0	1528367297	9.677637
22782458	General Transit Feed Specification a	General Transit Feed Specification and Clojure	simonpure	12.646705	-7.9050384	story	4.0	78.0	1586044012	-2.6841164
22824284	Because every single one of these po	"Because every single one of these posts is ""I like Elm, I don't like Evan('s style of leadership).""All of these leavers could've maintained that fabled community fork they want with the features they want if they all got together."	pd-andy	13.014748	-7.6959887	comment	4.0	14.0	1586450080	-12.769862
22824500	"> That came over to me as ""you are o"	"> That came over to me as ""you are obliged to do a lot more work that I want you to do, on your own time and personal cost, and to stop developing the project according to your own vision or you are a bad person"".I mention this in my top-level comment, but here's Rich Hickey of Clojure responding to similar assertions: https://old.reddit.com/r/Clojure/comments/73yznc/on_whose_au...> Clojure was not originally primarily a community effort, and it isn't primarily one now. That has to be ok. The presumption that everything is or ought to be a community endeavor is severely broken. A true community respects the autonomy of its participants, else it degenerates into a cult of need/want.The people who write these ""I'm leaving X"" posts must know they have disproportional power in such a tiny pond"	hombre_fatal	12.658318	-7.9062486	comment	4.0	15.0	1586451060	-11.173503
22823890	That's what forking entails.It's a b	That's what forking entails.It's a bit like Brexit. You don't get to stay in the club.If there are sufficient people unhappy with Elm but are cohesive enough to push the compiler forward, then why not?	neilwilson	13.006298	-7.691779	comment	4.0	13.0	1586448558	-12.755889
22826914	Original author of the elm-firebase 	Original author of the elm-firebase ( https://github.com/pairshaped/elm-firebase ) here. While I think Elm certainly has some rough patches in both their aggressively PC community and the immaturity of the language (still many breaking changes, not 1.x, etc.), it's not that awful. I was told that elm-firebase was basically a waste, and don't use native modules, so I stopped development. I didn't need to make a big stink, and write a huge blog post on why I'm leaving Elm and how the community is toxic.If the author needs to leave the community, then do it, but no one needs to leave a community with so much drama.	mrozbarry	13.010424	-7.693021	comment	4.0	16.0	1586464459	-12.768979
22975378	Yep. But having this feature only in	Yep. But having this feature only in shadow-cljs doesn't do much for the ecosystem as a whole since non-portable. With this change, many tools, cljsbuild, Figwheel, etc. have the same capabilities. It also opens the door for creating ClojureScript libraries that depend on node_modules and these can again be consumed with any tool.	swannodette	12.657436	-7.889623	comment	4.0	12.0	1587786475	-11.162596
22985687	"""Clojure For The Brave and True"" is "	"""Clojure For The Brave and True"" is also another book who's author explicitly chose their publisher (No Starch) because they could also publish the book for free on their website. Not only is it free but also amazing book, one of the most enjoyable books I've read about programming overall and also made me dive into the Clojure rabbit hole that I'm now lucky to work professionally with during my day job. https://www.braveclojure.com/clojure-for-the-brave-and-true/"	diggan	12.657963	-7.9025197	comment	4.0	15.0	1587891498	-11.149239
23065286	Clojure as a dependency	Clojure as a dependency	nathell	12.647298	-7.9008617	story	4.0	138.0	1588575612	-11.168495
23070384	When working with Clojure teams, I p	"When working with Clojure teams, I personally ran into ""libraries, not frameworks!"". Interesting maxim, but I never found any kind of satisfactory explanation. There was a general deep-seated belief that Clojure was the right solution for every problem, with a similar amount of elaboration."	Kalium	12.657063	-7.8995986	comment	4.0	22.0	1588611218	-11.161602
23165244	The first point clearly didn't pan o	The first point clearly didn't pan out. In reality, applications ended up bundling their own OSes along, so Clojure is stuck with antiquated VM on its ankle for no good reason.	varjag	12.651412	-7.905326	comment	4.0	54.0	1589363925	-11.175108
23233352	Long time ago hygienic macros move m	Long time ago hygienic macros move me to decide to farewell racket.  Common Lisp, clojure or scheme  allow me to program in Lisp when I have some code to do. So I don't look back to racket. /rantEdited: Hygienic macros are powerful but as an user of a computer language and not as a researcher I find them very difficult to grasp compared to Common Lisp macros. And this is only the tip of the iceberg, what is down is that the language is more oriented to researcher than to get things done. Should I work in Northwest University, I would appreciate a lot those complexity and make progress in the field, but that is not my cup of tea now. I don't have problems to program in Haskell or any other language, but I don't buy racket complexity.	iddiid	12.6723385	-7.8423915	comment	4.0	17.0	1589884513	-10.900918
23241053	"Repeat after me: ""JVM is not Java."" "	"Repeat after me: ""JVM is not Java."" Clojure and Kotlin are the perfect proof of that. If you actually look closer, JVM is a pretty cool piece of technology. Too bad that it is doomed to be associated with Java forever."	iLemming	12.588068	-7.821929	comment	4.0	34.0	1589927315	-11.18884
23284360	For Clojure fans, there is [Overtone	For Clojure fans, there is [Overtone](https://overtone.github.io/), which uses the SuperCollider audio engine, but allows you to write more functional code and utilize REPL based development (within emacs!).	nanomonkey	12.655627	-7.8990607	comment	4.0	13.0	1590252189	-11.16302
25568626	CIDER and main author bbatsov are su	CIDER and main author bbatsov are such indispensable figures of Clojure ecosystem.I hope more fancy features keep getting enabled by default or made more discoverable, I always find some hidden gem like image support in REPL buffers when randomly browsing in the docs. (That one has a reasonable reason for being off by default in its current form though)	fulafel	12.651409	-7.8981304	comment	4.0	14.0	1609239187	-11.151276
25623229	How about Clojure vs Scala? Anecdota	How about Clojure vs Scala? Anecdotally speaking, I've seen more Clojure than Scala at my company, both being incredibly niche (I've seen more Groovy than either to be honest).If I want to get more into FP, is there any strong positives/negatives for either? I must say though that after using Racket for a bit, I am a fan of the parens. Makes expressions crystal clear.	BossingAround	12.518878	-7.819587	comment	4.0	28.0	1609695033	11.929627
25628530	When I mentally diff Clojure against	When I mentally diff Clojure against other JVM-based Lisps -- mainly thinking of Kawa and ABCL here, which are dialects of long-established Lisps -- Clojure comes up different enough to be weird, but not sufficiently better than the alternatives for me to put up with the weirdness and choose it over them.It's kind of like when I recently evaluated Visual Studio Code  (for the (1+ n)th time) to use as my default editor. Everybody I know at work uses it, and for a couple years there Hackernews made a collective O-face every time a new version dropped from Microsoft. So it must be good, right? Well, it was different enough from Emacs to force me to get used to an entirely different workflow, but not enough better than Emacs (really, for my purposes, not better at all) to justify making that e	bitwize	12.66064	-7.8909516	comment	4.0	13.0	1609744093	-11.096838
25690426	If you have to use java arrays, coll	If you have to use java arrays, collections, methods and type hinting everywhere while also dismissing/avoiding more than half of the language to meet performance requirements (which is needed regularly in Clojure cause it's so slow), why not just write the thing in Java? Even Javascript will be much faster and your code won't get ugly that fast as in Clojure when you need performance.	ithrow	12.641655	-7.8931513	comment	4.0	12.0	1610139584	-11.165396
25795196	Clojure has come up a lot more frequ	Clojure has come up a lot more frequently on HN than in the past.I'm curious if there is a particular larger project that is using clojure that's driving a lot of this?Or particular JVM application like Kafka?	codemac	12.6524315	-7.8952236	comment	4.0	39.0	1610739160	-11.17655
25842319	> Optional typing - Currently not im	> Optional typing - Currently not implementedJesus H Christ could the whole FP world stop this? You're either going to prioritize static types or you're going to blow them off. Either front-and-center your type system, or stop mentioning how you blew it off. Those of us who want Clojure's syntax and semantics and a decent type system would like to stop being taunted.	eyelidlessness	12.542197	-7.864834	comment	4.0	23.0	1611113763	-11.1680355
25886712	I guess thats what something like cl	I guess thats what something like clojure is supposed to fix? Interop with Java to give you access to that world? Not sure how that plays out in the real world though	vikramkr	12.646896	-7.894227	comment	4.0	19.0	1611440769	-11.184774
25895992	If you want live image reloading sti	If you want live image reloading stick to a Lisp like SBCL rather than Scheme.If you care about startup times or FFI then don't pick Clojure.YMMV between Racket and Guile; I would say Racket is better insofar as the culture of documentation is really very good.In practice, once you learn a Lisp, you can jump between them without too much trouble.	yw3410	12.670492	-7.850223	comment	4.0	13.0	1611522149	13.627347
25925867	It is a very multi-dimensional issue	It is a very multi-dimensional issue. While all these languages belong to the same family, they also take some time to learn, and each has its specific strengths. It is probably very helpful to think about what matters most to you, and pick what matches your needs best for the first language.Here some axes of distinction:1. supported programming styles2. support for concurrency3. performance of generated code and parallelism4. floating-point performance5. level of standardization6. closeness to the system and capability to call into C functions, or functions with C ABI7. suitability for scripting and stand-alone programs8. GUI programming9. Comprehensiveness and beginner-friendliness of documentation10. REPL Programming11. Libraries12. LicensesHere what I know about the languages you name:	jnxx	12.549352	-7.8165474	comment	4.0	16.0	1611738206	-10.950524
25940988	Minimum Viable Clojure Developer	Minimum Viable Clojure Developer	shivekkhurana	12.667876	-7.9119706	story	4.0	37.0	1611836898	-11.172545
26013080	> In our benchmarks, the Clojure ver	> In our benchmarks, the Clojure version underperformed by about 9-13% when comparing peak throughput.The performance difference between Clojure and the pure Java implementations was much smaller than I'd thought. Quite amazing for a dynamically typed language to get so close to Java in performance, to be honest.The ring-clojure performance was much lower than the Java equivalent, but that's expected because de-serialization can be A LOT faster when you use static types for guiding parsing (e.g. cache the string keys and never allocate object keys, maybe small values that are common as well). I wonder if Clojure contracts could be used for the same tricks.	brabel	12.645705	-7.8910623	comment	4.0	13.0	1612355879	-11.16086
26062789	One thing I find fascinating is that	"One thing I find fascinating is that it feels like Common Lisp, Racket and Clojure are talked about a lot, but from the top of my head I would not be able to name everyday software or tools written in any of them.Meanwhile I rarely encounter discussions and talk about Guile while at the same time seeing it ""everywhere"" (Guix, embedded scripting in GDB, Gnucash).This is just my personal feeling though."	2pEXgD0fZ5cF	12.683528	-7.8005085	comment	4.0	13.0	1612779961	-10.514464
26150310	Elm Roadmap	Elm Roadmap	mauroc8	13.01132	-7.6936827	story	4.0	46.0	1613443146	-12.749315
26357654	As a clojure fan, I think this is a 	"As a clojure fan, I think this is a really well balanced and fair assessment of clojure. It's a bit surprising they didn't get into the whole ""hygenic macro"" business, which seems like the most obvious differentiator between the two languages to me. I would argue the macro system in scheme is very complicated (even more so in the extensions found in many scheme implementations) and this somewhat undercuts the minimalism appeal of the scheme language. (Though the scheme macro system is still extremely cool from a computer science standpoint.)Also, the post states that you can't have nested ""tail-call optimized"" loops in clojure, which is only partially correct: Using nested loops is commonly done in Clojure, the only thing you can't do is have the loops call each other mutually-recursively,"	drcode	12.58587	-7.8663154	comment	4.0	27.0	1614957113	-11.125048
26358007	> As a clojure fan, I think this is 	"> As a clojure fan, I think this is a really well balanced and fair assessment of clojure.Thanks for the kind words. I tried to keep my biases out of it as much as possible and tried to avoid making it too ranty. And on the whole, I like Clojure; it's just not really my first choice as far as Lisps go.> It's a bit surprising they didn't get into the whole ""hygenic macro"" business, which seems like the most obvious differentiator between the two languages to me.I debated including a bit about macros, but in the end decided that this would be a bit too in-depth. Clojure uses namespaces in a somewhat clever way to work around the bulk of the hygiene issues you get in CL with defmacro, but the macro system itself is rather uninteresting. I think their custom syntax for gensym is a nice touch, "	sjamaan	12.6481085	-7.884521	comment	4.0	20.0	1614958691	-10.995171
36874797	It doesn't give you good tools for n	It doesn't give you good tools for networking, for writing concurrent or asynchronous code, for graphics, it doesn't give you a good package manager or means of distributing code, its data structures are unwieldy, it takes work to make it performant, etc.The obstacles add up, and the time you spend on these issues by dealing with hopefully supported community libraries or rolling your own is time spent not dealing with the real problem you're trying to solve.Racket and Clojure are better suited for pragmatic use in my opinion/experience.	BaculumMeumEst	12.652024	-7.8839197	comment	4.0	15.0	1690361613	13.620572
36888409	There are plenty of old business sys	There are plenty of old business systems which are critical, can't be removed or turned off, and use LISP, COBOL, etc.  Meanwhile, nothing important uses Clojure or other trendy flash-in-the-pan language.  If you want an interesting project, sure, use Clojure or something.  If you want money, learn COBOL.	10g1k	12.651093	-7.8882623	comment	4.0	15.0	1690427119	-11.119824
37000733	Rich Hickey is retiring from Nubank	Rich Hickey is retiring from Nubank	jayceedenton	12.662063	-7.907719	story	4.0	137.0	1691160113	-11.172367
37001761	I wrote my first trading system in C	I wrote my first trading system in Clojure because a few of the libraries we relied on were in java.It was 2011 and I'd had about 3 years of lisp experience.  I got a bit of side eye from people when I told them I was using a relatively new programming language but the fact that it was based on the JVM, which alot of HFT firms were using helped make the case.We didn't use if for more than a few years before it was retired and rewritten, though that was due to new requirements that included C++ interop.In the end tracking memory usage and allocations got too hard and if you've ever written something that is time sensitive you'll know just how slow memory allocation is, so you could argue I made a poor choice but for the rewrite was easy to reuse the java libraries when we moved to java.The 	chollida1	12.66723	-7.9061112	comment	4.0	23.0	1691164653	-11.1297035
37032528	This article is somewhat puzzling fo	This article is somewhat puzzling for me. On one hand, the OP clearly knows Clojure very well. The disadvantages of laziness are real and well described.On the other hand, though, this sounds like a theoretical/academic article to me. I've been using Clojure for 15 years now, 8 of those developing and maintaining a large complex SaaS app. I've also used Clojure for data science, working with large datasets. The disadvantages described in the article bothered me in the first 2 years or so, and never afterwards.Laziness does not bother me, because I very rarely pass lazy sequences around. The key here is to use transducers: that lets you write composable and reusable transformations that do not care about the kind of sequence they work with. Using transducers also forces you to explicitly re	jwr	12.630852	-7.895877	comment	4.0	13.0	1691403454	-11.179636
37072195	Also relevant, Rich Hickey listed th	Also relevant, Rich Hickey listed the books that inspired him to create Clojure in his own Amazon account: https://www.amazon.com/ideas/amzn1.account.AFAABBRGIVOWVKTHP...Easier to browse list: https://www.goodreads.com/list/show/137472.Rich_Hickey_s_Clo...I find it interesting he includes Mozart/Oz (CTM). It'd be great to see more ideas from that language coming to Clojure.Also Norvig's AIMA. Clojure could be well positioned for neuro-symbolic AI. That's somehow connected to Anglican, discussed in the History of Clojure article.	nextos	12.656064	-7.899141	comment	4.0	15.0	1691644124	-11.177713
37459278	If I understand you correctly, trans	If I understand you correctly, transduces transform something like(map fn1 (map fn2 (map fn3 collection)))into(map (fn [x] (fn1 (fn2 (fn3 x)))) collection); Is that correct?More idiomatic clojure:(map (comp fn1 fn2 fn3) collection)	vaylian	12.487179	-7.8280125	comment	4.0	12.0	1694375194	9.740413
24705000	One thing that stuck with me from a 	One thing that stuck with me from a good Clojure book(1) is that using < is greatly preferable to using >.  Coming from an OO background and reading left-to-right, this made sense to me: list the args from smallest to largest.(< 1 2 3) ;; trueis a lot more intuitive to me than(> 3 2 1) ;; trueeven if one or more of those literals is replaced with an argument.  It’s especially apparent with the two-arg use of the function.  This is one of the few places where I still feel like infix notation has an advantage.This isn’t even a nitpick about the article, just a remark about some cognitive dissonance seeing > used here.(1) Maybe Elements of a Clojure?  Not sure that’s it; it was a book referenced on HN which has a whole chapter on naming things.	filoeleven	12.539863	-7.8255877	comment	4.0	15.0	1602040884	-11.064592
24858482	I think this survey was populated wi	I think this survey was populated without any thought.1. it does not specify to whom this website belongs to, neither what the purpose of this survey is2. in programming languages, there's not even one lisp dialect. In a survey. For Emacs. :p[Edit]: correction for 2, as there's clojure. Thanks anamexis.	_cipher_	12.658352	-7.891419	comment	4.0	16.0	1603377572	-11.067414
24940723	> that still needs to call JS though	> that still needs to call JS though... It's not like they rewrote the renderer in ClojureBut why exactly is that an issue...? Some people also think the JVM is icky so they won't touch Clojure. I don't really care much myself what underlying technology is used, I just like to get things done.> A simpler and easy to grok alternative with minimal dependencies is thing-geomThanks for reminding me of thi.ng. I am both in awe at how prolific he is, while at the same time frustrated with the non-standard org-mode-driven development style.> You just declare what you want drawn and you get back an svg tree which you can either modify further or transform to xml to get an actual .svg format stringProbably worth mentioning that Vega can also give you an SVG.> I even quickly wrote a converter to Jav	simongray	12.6469755	-7.8648496	comment	4.0	15.0	1604052236	-11.232503
24941170	Nice article in general, but seems t	"Nice article in general, but seems to miss the most important point (at least for me) of why Clojure (and similar languages) are way better than anything else today: it's REPL driven development. Definitely more important for me than any of the other ""why we love Clojure"" points.As long as Rust doesn't offer something similar as the REPL driven development Clojure offers, there is zero reason of preferring Rust (for me) over Clojure for the same tasks. Which, because of the last point (""Rust is not homoiconic"") won't happen any time soon.Now, if you need to do embedded system development, Rust might make more sense than Clojure, but it won't replace Clojure for the same tasks today."	diggan	12.614259	-7.8849144	comment	4.0	29.0	1604057759	-11.204493
24941241	Having built remote monitoring and f	Having built remote monitoring and firmware updating systems for high-current LiFePO4 batteries in Rust for low-level STM32 and ESP32 integrations, Clojure for backend and ClojureScript on the frontend - I can corroborate this.The dynamism of Clojure and the memory safety of Rust are a strong combination, especially for streaming EDN data over websockets to Clojure or ClojureScript frontend.However, neither Rust nor Clojure is the end-game. Eventually all languages will IMO adopt memory lifecycle management (lookahead guarantees) and borrow-checking as language features to do runtime optimization.An interesting language in this regard is Carp, a high-performance statically-typed Lisp implemented in Haskell with borrow-checking: https://github.com/carp-lang/CarpIt's a shame they did not opt	pgt	12.587292	-7.9056687	comment	4.0	12.0	1604058618	-11.129739
24951388	Do you use other paradigm / language	Do you use other paradigm / languages ? (clojure comes to mind, but maybe others)	agumonkey	12.648486	-7.872339	comment	4.0	12.0	1604151599	12.745847
25078446	I’ve been thinking about how to pack	I’ve been thinking about how to package macros across a variety of programming languages. Macros are the ability to generate code structures, which are then executed. For example, [“setnull”, “x”] might be compiled to x = null in JavaScript, which is then evaluated. Notice you cannot do this with functions — you can’t access un-evaluated arguments, like the name “x”, or the lexical environment in which it appears (to say nothing of dynamic scope).It’s a hard problem. Clojure has some prior art in this space, but the packaging system relies on creating “their own world” — classes in Clojure aren’t really plain Java classes. Or more specifically, protocols are a completely different thing from what normal Java applications write their programs with.I don’t think building one’s own programmin	sillysaurusx	12.632332	-7.873659	comment	4.0	17.0	1605237692	-11.013766
25320345	I was expecting Clojure vs Common Li	I was expecting Clojure vs Common Lisp. I love scheme but it's not fair to include considering how few libraries there are (I don't even know if there is a package manager).	banjomet	12.673515	-7.876028	comment	4.0	15.0	1607220233	-10.927548
25342652	I don't know enough Clojure to reall	"I don't know enough Clojure to really understand this argument. I am a bit confused by the example. It appears that the only difference between ""semantic"" and ""fixed"" indentation is that the former allows ""hanging indentation"" of the arguments, i.e. aligning everything to match the indentation of the first argument when that was not preceded by a newline but placed immediately after the identifier of the function being called. I don't understand how that has anything to do with macros as it is claimed in the article, but that is probably due to my lack of Clojure knowledge.I think there is an important - but often ignored - argument against ""hanging indentation"", and that is that it makes the indentation of a possibly large number of lines depend on the length of the identifier or expressi"	ulrikrasmussen	12.644452	-7.8836455	comment	4.0	15.0	1607410611	-11.011654
25357423	I found it funny you mention Clojure	I found it funny you mention Clojure since leiningen takes 20 seconds to get to a REPL prompt on a full spec MBP 16 from last year. For all the hype about interactive development, I think Clojure people are deluding themselves if they think that’s reasonable for a dynamic language.	doteka	12.648613	-7.890248	comment	4.0	12.0	1607512304	-11.127683
25374290	I'd love to see clojure take a bigge	I'd love to see clojure take a bigger role in the financial  services sector. The fact that it runs on the JVM, gives it a nice foot in the door.Ideally, it would be great if clojure replaced Python and Scala as the defacto language used to interact with Apache Spark. That's probably not likely, though. It's hard enough to get a lot of folks past spark's weirdness without throwing a lisp into the mix. But it does seem like a functional JVM language that's not Scala would be the optimal way to use spark.	tharne	12.566405	-7.825676	comment	4.0	92.0	1607612247	11.928394
25374916	With Java, your convoluted mess can 	With Java, your convoluted mess can be parsed by IDE and you can figure out what it is doing. Also, most of it looks the same and is Ctrl+c, Ctrl+v of something else.With Clojure the mess is still 100k to millions LOC because the guys did not know how to make worthwhile abstractions, but now it can't be parsed by IDE and you are screwed trying to figure out what happens at runtime.ALso, if you think if there is less code then it is easier to understand, go and read any advanced Common Lisp book (like Let over Lambda) and try to really understand what some of the more advanced macros do, exactly. It is definitely not the same as reading pages upon pages of redundant code.	lmilcin	12.653547	-7.892967	comment	4.0	22.0	1607615232	-11.083081
25375513	Having worked at a company with a la	"Having worked at a company with a large Clojure codebase, I just don't see Clojure growing. It's not well-suited to large projects. The dynamic-ness of it and awkward parts of the language (macros, protocols, ambiguity of laziness, etc) end up inevitably getting used in ways they aren't intended.The idea that you need ""wise programmers"" is a really big problem. People leave, institutional knowledge is lost, and then the code archaeology is just more difficult than it would be where types exist as guard rails.I think Clojure looks favorable in comparison to Java still (though perhaps less so). But with Kotlin and Scala as mature alternatives -- and Clojure without a real niche -- it's not what I would reach for."	keithasaurus	12.619318	-7.872511	comment	4.0	39.0	1607618590	-11.160383
25375786	Maybe a broader version of this poin	"Maybe a broader version of this point: clojure tries to be something suited both for industry use at scale and for hobbyists wanting to do freaky-deaky stuff at the same time, but those are fundamentally incompatible.I say this as someone squarely in the latter category who has exactly the opposite problem from you: I love clojure the language and its features, but all the major libraries seem to be written by refugees from Java working at big companies who have a will to massively overengineer everything.I'm thinking of libraries like mount and such which everyone uses for everything, and which I experience as, like, ""did you want to inject your dependencies in your injected dependencies?  Well first you have to do a quadruple axel inversion of control at the fifth abstraction layer out a"	paultopia	12.6457815	-7.8868127	comment	4.0	18.0	1607620068	-11.1491
25376193	> The downside of Clojure is that yo	> The downside of Clojure is that you need good, wise developers...Is there a language that, for a sufficiently large application, you don't need wise developers? What is it? How?	bird_monster	12.647746	-7.894862	comment	4.0	23.0	1607622015	-11.150961
25377022	I use Clojure because I am not a par	I use Clojure because I am not a particularly wise programmer (I have been fortunate to work with many actually wise programmers).I like to write dumb, obvious code. Most Clojure code is about taking your data, representing it a sequence of maps, and transforming them into different sequences of maps. The maps are open (easy to change over time), immutable (impossible to encounter data races, weird equality semantics, or concurrency issues), dynamic (no pre-definition or ceremony required), concise (thanks to a literal representation that does not even require commas between elements), and have a generic access api (no custom functions/accessors/etc).Because I use the exact same transformation functions on EVERY PROBLEM, there is an enormous amount of reuse of generic operations both withi	puredanger	12.60553	-7.873066	comment	4.0	15.0	1607626484	-11.142531
25377659	are there people who used both cloju	are there people who used both clojure and scala. And decided to use Scala ? if so why ? I'm new to Scala that's why	dzonga	12.466912	-7.7927303	comment	4.0	13.0	1607629484	11.943038
25379284	I've said it before, and I'll say it	"I've said it before, and I'll say it again. I will continue to write Clojure for a living as long as I am able to find a job willing to pay me to do so. I have never encountered a more pleasant environment to do my work. I think Clojure isn't going to ""go away"" any time soon as long as there are other people like me still around.I do think that Clojure shops (like all software shops) need to dial back the torture interviews / homework / tests, but that's really a bigger thing that just Clojure. I think more could be done to market Clojure to the non-believers, but I don't have specific ideas on how that could be done.You can take my parentheses from my cold, unemployed hands."	jakebasile	12.65301	-7.900809	comment	4.0	41.0	1607637409	-11.179262
25381057	How do I know if I’m really trying t	How do I know if I’m really trying the repl/editor cycle?I mess with Clojure with some regularity and each time ultimately back away in a combination of frustration and nerd sniping self awareness as the ratio of editor setup blog reading meta work  to actual work hits infinity.Either I am terrible at finding good setup guides or it’s pearls before swine and I just don’t get the aha moment. I’m starting to think it’s the latter.	fhsm	12.641338	-7.8858237	comment	4.0	13.0	1607648798	-11.1265745
25382279	At a contract job, I had to use ReAg	"At a contract job, I had to use ReAgent, ClojureScript's ""this compiles into ReactJS"" framework.  Wow, what a pain-- all I could think is ""Why don't we just use Reactjs?"".Clojure itself is decent.  But as you mention-- ""n practice everyone expects you to use poorly-maintained clojure-ish libraries to paper over the java/javascript bits, which get out of date quickly.'That is indeed the problem I saw."	aeoleonn	12.673194	-7.805582	comment	4.0	13.0	1607660774	-11.133692
25433817	I am nowhere near their numbers, but	I am nowhere near their numbers, but I run a boostrapped business that would never be possible if it wasn't for Clojure (and specifically ClojureScript). A while ago I decided that I'd be permanently setting aside a percentage of revenue that will go towards sponsoring open-source developers that write and maintain libraries that my project uses. The contributions are very small, but growing steadily.I think what matters mostly is not the contribution size, but the mindset. If every company using open source contributed at least a little, we would have a healthy ecosystem.	jwr	12.662493	-7.9044914	comment	4.0	16.0	1608059546	-11.153502
38790430	Unfortunately you can't treeshake a 	Unfortunately you can't treeshake a language that supports reflections. So it's not like a C++ program where unused parts get dropped.You can manually remove dependencies or.. I think in the Android world you specify what classes can be reflected on and then strip unused code with Proguard (though I could never get it working with Clojure)Would love to be corrected if I got any of it wrong	contrarian1234	12.645671	-7.8959565	comment	4.0	13.0	1703742164	8.4318075
32513830	This is only true for languages that	This is only true for languages that are not taking a long-term vision into account.Run some 8 year old Clojure Github project, should be fine.Try a Common 20 year old Common Lisp project, you shouldn't have an issue.	azeirah	12.649153	-7.897493	comment	4.0	15.0	1660850862	-11.092905
32707330	> “Try different things” is the key,	> “Try different things” is the key, of course.32 year programmer here (started at 19).I cannot “amen” this sentiment enough. But probably not in the way most will read it.Most will interpret this at a macro level: Learn some Smalltalk! Now go learn Lisp! And then Clojure followed by Haskell, throw in some Java or C++ so you know what pain feels like! This is OK, it is good to be somewhat travelled in your journeys as a programmer.But I find that there is a micro application that gets overlooked. You can do a lot of “try new things” right in the stack you’re in without having to bust strange new worlds. Most languages end up with many ways to do things. You can and should take time to explore those. Learn the conventions/idioms, but then push/challenge those.I was afraid of C macros until 	travisgriggs	12.507352	-7.8050375	comment	4.0	22.0	1662246588	-11.019131
32724130	I think I would be better to compare	I think I would be better to compare CL with Clojure rather than Racket...since Clojure has found some usage outside academia	amitprayal	12.671029	-7.840492	comment	4.0	24.0	1662384887	13.616387
32753822	Nice to see the data confirm the gen	Nice to see the data confirm the general consensus (by my measure, at least) regarding the Clojure STM options.Like others, I've been telling Clojure newbies something like: When you need Clojure STM, default to using an atom unless you really know you need to use something else.	bm3719	12.645199	-7.894943	comment	4.0	19.0	1662573181	-11.172024
38151749	this sounds exciting, but I wonder. 	this sounds exciting, but I wonder. How closely linked is Elmish to Elm?In theory Elm is just such a fascinating project... if it was not held back by the people developing it.	DarkNova6	13.011431	-7.6946983	comment	4.0	37.0	1699196880	-12.761389
38314074	For those who don't know:Borkdude is	"For those who don't know:Borkdude is a fairly big name in the Clojure community, most known for developing clj-kondo (static analysis tool used by clojure-lsp) and babashka (a Clojure interpreter built atop GraalVM native image so you can have fast startup times and decent performance writing scripts in Clojure).""Squint"" is a ClojureScript compiler of his that transpiles ClojureScript directly to JS while introducing as little runtime overhead as possible. For instance, the usual PersistantVector, PersistentHashMap, etc. data structures compile straight to ordinary vectors and maps in JS. This means they are technically mutable and have slightly different semantics underneath. The goal of Squint as far as I can tell is to be akin to ParenScript but for Clojure (a subset of the language imp"	koito17	12.647787	-7.8871403	comment	4.0	14.0	1700273208	-11.146377
38540929	It's probably because the author kee	"It's probably because the author keeps getting comments from other developers about his choice of language and he's tired of explaining why.There was a HN submission yesterday about another project of his (also in Clojure) and many of the comments were ""Why is this made in Clojure?"".Unfortunately, a large segment of developers think there is no value in venturing beyond C-style languages.Another dimension in recent years is the static type checking cult, whose adherents must warn everyone else in the cult whenever they spot any kind of dynamically typed programming language, e.g. causing a separate thread about the lack of static type checking in any comment section about a Clojure project."	simongray	12.591441	-7.878343	comment	4.0	17.0	1701843194	-11.1287985
38541337	Situation: There are three competing	Situation: There are three competing Clojure development environments.Three!? Ridiculous! We need to develop one universal Clojure environment that covers everyone's use cases.Situation: There are fourteen competing Clojure development environments.	civilitty	12.653128	-7.8980203	comment	4.0	26.0	1701848164	-11.193856
38541475	As a heavy user of Clojure (my SaaS 	"As a heavy user of Clojure (my SaaS is written in Clojure/ClojureScript) for 10 years or so, I would fully agree with what Kyle wrote. In addition, things that I found very valuable:* most of my domain code is in cljc files, so these get compiled both server-side and client-side and I get a huge boost from that* transducers and transducer pipelines are an under-appreciated feature, I get huge mileage out of them, because of performance, composability and reusability* stability and longevity: Clojure was created by a very experienced system designer and programmer (Rich Hickey) and it shows. Backwards compatibility is hugely important, and I can focus on my application rather than rely on tools that are a moving target. It's not an accident that an average ""Clojure programmer"" (I dislike th"	jwr	12.652795	-7.8993187	comment	4.0	94.0	1701849441	-11.185686
38541555	In short:- being on JVM means Jepsen	In short:- being on JVM means Jepsen can use JDBC drivers to interact with databases- Clojure was designed to facilitate concurrent programming (via software transactional memory and persistent data structures)- Clojure's interactivity allows quick prototyping- Clojure's community has a strong emphasis on backwards compatibility- macros allow a great deal of code reuse- while there are some big drawbacks (niche language, no strong static typing, ...), it isnt an issue in practice since Jepsen is only worked on by 1-3 people at a timeI agree with most of these points, but it seems overly simplistic of an explanation. I really wanted to see what other languages were used for prototyping and why they were deemed insufficient. For instance, Haskell is mentioned but the most treatment it gets i	koito17	12.588311	-7.8134184	comment	4.0	15.0	1701850306	8.132356
38541864	Clojure does many things right and I	Clojure does many things right and I like it for it a lot.One thing that I see slowing down real teams building real web stuff with Clojure is the near-dogmatic desire to compose (dare I say hack) everything together from tons of libraries that each have their own understanding of how things should be.I bet Clojure would be much more popular and nicer to work with if the community would _also_ (i.e. in addition to the current approach) have actively-maintained, batteries-included, generally usable web framework(s). (Is Biff it?)So that there would be alternative path to choose for us who like the language, but are not fans of the build-your-own-monster approach.Disclaimer: I have been spoiled by Ruby on Rails	727564797069706	12.640075	-7.8827605	comment	4.0	13.0	1701854026	-11.152969
14725114	The Re-Frame Guide: Front-End Archit	The Re-Frame Guide: Front-End Architecture in Clojure	kimi	12.652056	-7.892082	story	4.0	156.0	1499515331	-11.17006
14760100	Pretty disappointing article. All th	"Pretty disappointing article. All the arguments are pretty weak. For example, the article argues that FP is necessary going forward because immutable data helps avoid race conditions. However, immutable data does not make a programming language functional. I could just use Rust, which (although it incorporates functional constructs) is still clearly imperative, and avoid race conditions through its particular implementation of immutable data structures.The most upsetting part is when the author brags about how Clojure programs can manipulate itself at run-time, on a website that's literally called ""Clean Coder Blog"". Self-modifying code is a clear opposite of clean code. Also:> Maybe we don’t have to worry about chips with 32,768 cores on them.Author apparently has never written a GPGPU pr"	majewsky	12.525304	-7.82489	comment	4.0	16.0	1499941277	-11.151438
14765424	Got 14/15 because I couldn't tell Em	Got 14/15 because I couldn't tell Emacs Lisp from Clojure. Argh ...	SilasX	12.662454	-7.8949747	comment	4.0	13.0	1499981410	-11.116868
14849472	What frontend stack fits Elixir most	"What frontend stack fits Elixir most symmetrically? Is there a ""ClojureScript"" to Elixir's ""Clojure""?"	fnordsensei	12.638787	-7.8528914	comment	4.0	16.0	1501001959	12.810401
14872551	 The other problem is that no matter	 The other problem is that no matter how many times different people bring up the same recommendations for Elm language features, if those opinions are not shared by Evan, they are seen as trivial and unnecessary.Also, for such a very tiny community, they make it hard to participate in some ways. Many of the github issues are locked for comments unless you are a core contributor. And the mailing list has a lengthy waiting period on the first several new messages sent to it (I've never seen such a tightly moderated list in any language).  You would think they would want to embrace anyone who chooses to spend time with their language, but they don't really give average users much of a voice.	hellofunk	13.009167	-7.692679	comment	4.0	19.0	1501226043	-12.756656
14910639	Using Clojure as the first language 	Using Clojure as the first language is interesting. Being one of the most expressive and efficient (I am not talking about clock cycles here) languages I've used, I think it will set a great mindset for programming.Clojure is declarative, you tell what you want, not how you want it. It uses immutable data structures and functional programming. It teaches you a sane, safe and beautiful way of working on the problems rather than working against/around/because of your language (e.g building OOP design patterns rather than just solving the problem at hand).Some people might disagree, but Clojure is a very hands-on and practical language. There's not much syntax or quirks to learn; just a big standard library of very useful functions for processing and transforming data.	elnygren	12.639484	-7.887366	comment	4.0	28.0	1501682785	-11.149964
14929645	> In the past I also did some other 	> In the past I also did some other work on bringing Clojure Transducers to C++ ...  consider it a much less important effort---without the data-structures the other parts of Clojure feel almost like just sugar.Very few clojure programmers consider Transducers very important even in Clojure. While they're convenient for implementing Clojure's stdlib and they have some nice properties, they're very difficult to work with. It takes a very experienced clojure programmer to use transducers. Heck, I know some famous clojure developers who admit they themselves don't feel confident using them.But the main challenge for  them is that transducers just scream for some basic type validation so that you don't accidentally chain together nonsense. C++ could provide that, and you'd end up with all the 	KirinDave	12.636899	-7.9085546	comment	4.0	17.0	1501862344	-11.166554
15028228	"Neither are making ""big strides"". Th"	"Neither are making ""big strides"". They both are barely able to exist.Eta will never even approach Scala in terms of adoption, and I had only heard about Purescript a few weeks ago reading about Elm.Typescript will dominate functional JS-world (already is, tbh) and Scala is still crushing function JVM-world, and if Dotty ever actually materializes, adoption will get even better. Additionally, Scala-Native and ScalaJS are making progress and could eventually be real players. Not likely to take food away from Haskell or Typescript, but they will certainly maintain larger usage than PS or Eta.edit: I'll concede that Clojure matters a bit in JVM-world, but it's dying quickly."	DeepRote	12.448815	-7.731859	comment	4.0	23.0	1502897252	11.927721
15076294	Ask HN: Does anybody know a company 	Ask HN: Does anybody know a company use Lisp other than Clojure in production	kureikain	12.671416	-7.8762136	story	4.0	4.0	1503435263	-10.967321
15083623	EDIT: this is getting downvotes for 	EDIT: this is getting downvotes for some reason even though it's just addressed to OP.  OP, you could email me at the link on my profile if you didn't want to answer here.  I'm not on the Go team or anything, just curious.---Thanks for your answers!So I know you don't want to rehash what's easy to find elsewhere, but your perspective is different because you wrote a Clojure interpreter.  It's not the same as what I can find from people who just use languages.You just list:>(e.g. no generics, error handling littering my code and obscuring intent, etc).But could you flesh out this litany of complaints, even if it's common? I just want to know your version of that list, without the 'etc'.  It's not going to be the same as other people's - different things will bother you or come to mind for y	logicallee	12.651893	-7.9020295	comment	4.0	17.0	1503511026	-11.183968
15104598	When showing off Clojure the applica	"When showing off Clojure the application is often molded while running by patching it via the repl. But what I don't understand is if you can actually develop real programs like that?
Surely even in Clojure code there are lots of dependencies so you can't just change one place in isolation.
And I also guess that changes done on the repl aren't actually saved for the next time you run your app?
And how do you do testing?How is the actual work flow you use when molding your app?"	jfries	12.649225	-7.891855	comment	4.0	13.0	1503735450	-11.170855
15258816	Because, in Lisp, getting it wrong m	Because, in Lisp, getting it wrong means that you don't know which one was supposed to close which opener.  And which is a vector, which is a list, which is a hasmap, etc.Clojure, in my opinion, did this right.  You don't need very many alternate delimiters to get a lot of bang for the buck and break things up.	bsder	12.649333	-7.8918924	comment	4.0	13.0	1505495432	-11.049169
15460132	Ask HN: Which is better Clojure or E	Ask HN: Which is better Clojure or Elixir?	anildigital	12.642466	-7.7633934	story	4.0	4.0	1507833124	12.884451
15464567	I always enjoy Rich's and Cognitect'	I always enjoy Rich's and Cognitect's increasingly futile attempts to bait and switch the Clojure community into using his expensive proprietary database, Datomic.I love Clojure, it's a beautiful language, but its march has stalled, perhaps even reversed, and I lay the blame of that squarely at the anti-community practices of Cognitect, especially surrounding Datomic.	grabcocque	12.679297	-7.8868027	comment	4.0	24.0	1507892533	-11.194908
15579944	From reading this it seems like cloj	From reading this it seems like clojure transducers are the same thing as linq expressions over IEnumerable. Is there any additional functionality they provide?	BoiledCabbage	12.626614	-7.8834653	comment	4.0	13.0	1509294856	-11.177279
15582105	4Clojure is really fun! Reading just	4Clojure is really fun! Reading just the book by itself got boring for me and I thoroughly enjoyed working through the problems side-by-side! Thanks to everyone who contributed to it.Another thing that I found great for practice was Advent of Code[0]. The exercises are more challenging and most of them lend themselves really well to the conciseness and elegance of Clojure collections. The reddit community[1] is also helpful and even if you can't crack the algorithm, porting someone else's solution to Clojure is a valuable & fun exercise.[0] - https://adventofcode.com/[1] - https://www.reddit.com/r/adventofcode/	krat0sprakhar	12.657708	-7.901815	comment	4.0	13.0	1509319074	-11.183667
15601478	what's the tradeoff of clojurescript	what's the tradeoff of clojurescript over native clojure? wouldn't the java clojure runtime be much faster?	LesZedCB	12.640339	-7.8844543	comment	4.0	23.0	1509546954	-11.159453
15680943	This reminds me of another great art	This reminds me of another great article.http://www.learningclojure.com/2010/09/graphics-like-its-197...The author talks about how its harder to get graphics on the screen without installing prerequisite software than it used to be, and goes on to sing the praises of the ZX Spectrum and its concise and well written manual. He finishes the article with some fun coding experiments writing Clojure code in the spirit of the ZX.	tmountain	12.6436	-7.891009	comment	4.0	21.0	1510496819	-11.138367
17415726	Show HN: Ghostwheel – easy spec, sid	Show HN: Ghostwheel – easy spec, side effect detection and tracing for Clojure	gnl	12.651679	-7.904336	story	4.0	64.0	1530182792	8.826972
17576995	"""So you have no excuses not to build"	"""So you have no excuses not to build your CLI tools in Clojure now.""Except that the toy program is 25MB and takes multiple minutes to compile..."	me_again	12.655722	-7.897916	comment	4.0	32.0	1532107380	-11.152917
17645367	(Mostly talking about SBCL)Mature na	(Mostly talking about SBCL)Mature native code compilation (including runtime assembler), type declarations that lead to optimizations in generated code, SBCL compiler can use declared types for compile-time type checks, read/compiler macros, extremely easy interface to C (JNI is a pain in the ass), multi-paradigm and doesn't prematurely optimize like Clojure (I have no need for STM or immutable data structures in 99% of the things I do), very powerful and flexible debugger, CLOS, more sophisticated interactive development.Clojure is a no-go for me primarily because it's tied to the JVM (or worse, Javascript) and the Java ecosystem but also because it prematurely optimizes with the sort of decisions it has made in the design space (immutability, STM, crippled reader, not Lispy-enough debugg	armitron	12.663515	-7.876323	comment	4.0	25.0	1532966137	-10.971157
17679696	Except for lisps, few languages let 	"Except for lisps, few languages let you name functions/variables using dashes and other symbols but looks like any legal name in Clojure is fair game:    function people-eq?(p1 p2)
      if p1 == p2 then
        println(""Are Equal!"")
      else
        println(""Not Equal!"")
      end
    end

Interesting."	scardine	12.638195	-7.892031	comment	4.0	17.0	1533303448	-11.139445
17708356	I was learning Clojure and OCaml las	"I was learning Clojure and OCaml last week (again) after doing a survey of a handful of functional languages. I still haven't seen a good way to spin up a really simple HTTP server like Sinatra or Express. Ones I did see either had a huge bug, were more verbose, or had no ""getting started"" documentation. The languages themselves are fun though."	devmunchies	12.603702	-7.8314705	comment	4.0	13.0	1533661239	10.938243
17724398	Clojure has been the most stable eco	"Clojure has been the most stable ecosystem I've ever dealt with. Once you get into it it's not uncommon to see libraries that are years old that function perfectly. I'm not even scared to update clojure to the latest alpha builds because things just always work.There's also this to look at on the subject: 
https://lkml.org/lkml/2018/8/3/621Reddit discussion:
https://www.reddit.com/r/linux/comments/95b1hf/linus_torvald..."	Naomarik	12.655799	-7.898645	comment	4.0	30.0	1533824366	-11.199965
17726855	I'm not an expert in Clojure, I've p	I'm not an expert in Clojure, I've played with it a little.  I think it's one of the best designed languages I've ever seen - and I'm a static-type kind of guy :)However, I have the feeling that its popularity has been decreasing over the past few years.  I very rarely see job descriptions mentioning it.  Have people observed the same thing?	dudul	12.652774	-7.900183	comment	4.0	19.0	1533838488	-11.1590395
17773191	Schism: A library of CRDT implementa	Schism: A library of CRDT implementations of Clojure’s core data types	tosh	12.643048	-7.9020457	story	4.0	112.0	1534411480	-11.18299
17847156	> 2) total blocking of genuine and c	"> 2) total blocking of genuine and constructive user feedback, which feels like censorship - or simply a closed-source, proprietary software.For those looking for examples, check out the recent post on /r/elm: https://www.reddit.com/r/elm/comments/9a0hc6/elm_019_broke_u...It was locked and deleted from the front page within hours. There are many many more such posts that have been deleted. The only posts allowed on /r/elm are those praising Elm.They always invite the users to discuss this in the Elm Discourse which is not constructive because threads about the ""forbidden"" topics (Native Code) are either locked or completely deleted within hours."	throwaway237468	13.011545	-7.6930194	comment	4.0	25.0	1535308419	-12.7584715
17856514	Clojure is really your better bet. I	Clojure is really your better bet. It is highly practical with a good community and excellent Java interop. You never have to worry about finding a good library. The syntax is also a bit more easily parsable than CL. If you don't touch the Java interop stuff, it's just as elegant as CL.	cultus	12.624143	-7.866538	comment	4.0	29.0	1535429750	-11.130083
17856541	I've spent a few months learning Clo	I've spent a few months learning Clojure - never gave CL a try. Here are a few thoughts on Clojure:1. Excellent syntax and library support. It is my first Lisp, but I can't how I programmed without macros and persistent data structures.2. I hate the stack traces. I've used both Clojure and Clojurescript (mainly cljs), and the stack traces for errors are nearly indecipherable. To be fair I am using React (not Reagent), but I don't find it too much better with other libraries.3. I hate the build system. It is fractured and there are too many mediocre options. shadow-cljs is the best one I've used, and it works okay not great. I also hate that I can't distribute standalone binaries. I have used pkg, which distributes Node project as binaries, but the binaries are huge (something like 85MB+)4.	typon	12.654563	-7.8873563	comment	4.0	19.0	1535430459	-11.107737
21091044	Don't let the title fool you - 90% o	Don't let the title fool you - 90% of the advice given in this book isn't specific to Clojure, and boy is it good advice.This book contains some of the deepest programming insights I've encountered, to be put on the same level as SICP or the Pragmatic Programmer.The discussions on naming and abstraction are particularly illuminating, exposing some fundamental tradeoffs like synthetic vs natural names, or principled vs adaptable systems of abstractions. Were these notions more widespread, a lot of the pointless rants and debates we hear in programming circles would disappear.I would not recommend this book to beginners - this book is most useful when you are experienced enough that your struggle is to make choices, not to get things to work.	valw	12.667792	-7.9079466	comment	4.0	14.0	1569586793	-11.158852
21092985	Is it growing? It is a difficult met	Is it growing? It is a difficult metric to quantify, but looking at thing like Github, or Reddit, it seems flat or declining. Clojure initially benefited as the preferred Java escape path, but it seems like that has been supplanted by Kotlin.https://github.com/oprogramador/github-languages#most-failin...https://www.benfrederickson.com/ranking-programming-language...	WillPostForFood	12.639625	-7.881427	comment	4.0	25.0	1569597928	-11.178725
21179037	Show HN: Small Clojure Interpreter	Show HN: Small Clojure Interpreter	Borkdude	12.64024	-7.890132	story	4.0	143.0	1570441763	-11.137804
21231715	What looks bad about the ClojureScri	"What looks bad about the ClojureScript example? I'm obviously a bit slow, but I can't see any practical difference between the two.I do prefer the ClojureScript because I don't know how to type ""λ"" and that seems like a usability handicap. Minor complaint I know."	another-one-off	12.648169	-7.892738	comment	4.0	12.0	1570872334	-11.144736
21287847	Unfortunately, a somewhat popular Cl	Unfortunately, a somewhat popular Clojure library for machine learning on GitHub is also called Cortex, because this is going to make discussing machine learning APIs in the context of Clojure that much more confusing.	kevinmershon	12.642511	-7.898878	comment	4.0	14.0	1571361626	-11.158526
21300661	What is the async story for clojure 	What is the async story for clojure if it isn’t core async? How do you make server calls? If you’re still using callbacks, you’re really missing out on the convenience that async/await provides.Also, are you using core.spec or transducers regularly? Do you find them understandable? How has the clojure community responded to react hooks? There’s so much that I’m curious about regarding present-day large clojure codebases, sorry.	bikeshaving	12.619293	-7.884219	comment	4.0	12.0	1571517951	-11.171179
21303298	The Elm Architecture (TEA) animation	The Elm Architecture (TEA) animation	galfarragem	13.010102	-7.691763	story	4.0	75.0	1571567177	-12.753419
21312233	Elm has long been at version 2.5.8. 	Elm has long been at version 2.5.8.  Why they couldn't come up with a name that wasn't already in use I will never understand.	markgall	13.011738	-7.695484	comment	4.0	25.0	1571666011	-12.7982435
21518553	Love the interface and the fact that	Love the interface and the fact that it's written in Clojure but it's worth mentioning Whimsical is $10/month vs. draw.io being free forever, and the Whimsical limited intro version is crippled in some quite annoying ways.	andrei_says_	12.650821	-7.8966928	comment	4.0	14.0	1573595428	-11.169545
21564206	I wonder why Clojurescript succeeded	I wonder why Clojurescript succeeded where Common Lisp hasn’t: compiling a lisp to javascript. Is Common Lisp particularly tricky in some way that Clojure isn’t?	NoahTheDuke	12.662964	-7.873775	comment	4.0	18.0	1574084592	-11.102453
21619983	Author here. The library is a toy pr	Author here. The library is a toy project, it's far from being complete. Many things including macros are missing. Implementation style is derived from ClojureScript's compiler	roman01la	12.658249	-7.8946486	comment	4.0	15.0	1574598241	-11.186736
21704055	For large code bases, most languages	For large code bases, most languages get unmaintainable without an IDE, putting Java at an advantageThat’s an assumption which advantages Java by default. Other languages may be able avoid having a large code base entirely. I recall reading some stories of people rewriting giant Java code bases into very small Clojure programs that were more flexible, maintainable, and scalable.	chongli	12.619984	-7.8626165	comment	4.0	26.0	1575479252	-11.173907
21720051	You don't need to apologize for what	You don't need to apologize for what you get paid to do. Barely anyone gets to work with the software they would use in their free time. That managers let you use some language does justify learning it, but it doesn't make that language better on technical (or aesthetic) merits.PHP is bad. If you're getting paid for it, it's still bad. So what? People also get paid to scrub toilets.Personally, I would rather write Java than Clojure. But I wouldn't quit if I suddenly had to use Clojure.	zelly	12.651829	-7.902493	comment	4.0	12.0	1575620328	-11.165039
39121436	> our planet and the technology we u	"> our planet and the technology we use. By embracing Common Lisp over Clojure and the JVM, we’re not only choosing a powerful programming language but also making a greener choice for the environment.Wait what?! When was the last time programmers chose a language because it was ""green""? What does it even mean for a language to be ""greener"" than the others?"	behnamoh	12.622681	-7.859214	comment	4.0	55.0	1706123666	-11.078044
39184426	Does anyone know how to get a lisp j	Does anyone know how to get a lisp job? Or have any experiences to share? Its been a dream for a while for me, and I think I am possibly ready (at least with common lisp, have started doing more clojure recently though). It just seems so impenetrable to me, I don't even know how to begin to search for it.	beepbooptheory	12.669408	-7.8726845	comment	4.0	14.0	1706572367	-10.896691
32823459	Clojure has massive amounts of ecosy	Clojure has massive amounts of ecosystem and toolchain pain, even though it is a cool language. Most common dev environment for it is a complex emacs tool chain. If you are seeking the simple joys of programming, Clojure is unlikely to be what you want.	billfruit	12.64863	-7.888168	comment	4.0	14.0	1663072457	-11.155206
33021363	Similar experience here. My first Cl	Similar experience here. My first Clojure(script) projects used leiningen, now everything is deps.edn and the clojure CLI. Cool, changes happen. But editor integration, REPL tooling, even which compiler to use, etc are not consistent either. The tooling is changing everywhere and bit rot has claimed almost all of my past projects. The code is still 100% compatible but the build system is just broken. I've given up trying to port any projects over - it's easier to generate scaffolding for a new project in the tool-du-jour and move the actual code into that structure.Since there is no obvious right way, there's little consistency between projects - which means you're likely to follow the wrong path if you follow the wrong README or pick an outdated starter template. This forces developers to	perrygeo	12.65497	-7.8982487	comment	4.0	13.0	1664462478	-11.0767145
31838126	> Clojure remains the highest-paid l	> Clojure remains the highest-paid language to know.Any ideas around why that could be?	Barrera	12.652362	-7.8948107	comment	4.0	17.0	1655915198	-11.136353
31879871	Interesting how Clojure takes the co	Interesting how Clojure takes the complete opposite approach by simply making dicts immutable.https://chasemerick.files.wordpress.com/2011/07/choosingtype...	valbaca	12.600555	-7.8777666	comment	4.0	16.0	1656202773	-11.12444
31886515	I worked at a company where it was u	I worked at a company where it was used. I was on the front-end team, so I didn't really get to understand the perks really well, but overall, it was frustrating how difficult it was for us to work on that codebase. It felt like to even get started I had switch my editor from VS Code to emacs.It was impossible to hire Clojure devs directly. They had to go through this training period.And honestly, it never felt like the choice of language had reduced the number of problems we encountered. That's my personal take though.	shubhamjain	12.653579	-7.8975224	comment	4.0	16.0	1656268072	-11.121672
39452052	Show HN: An IDE with version control	Show HN: An IDE with version control for writers – ButterDocs	michihuber	12.654933	-7.906954	story	4.0	14.0	1708510458	-11.200621
32166482	How does one Lisp without TCO?(Yes, 	How does one Lisp without TCO?(Yes, I know some do without, but usually not without a great reason...for example Clojure needing to maintain JVM calling conventions)	busterarm	12.603141	-7.824558	comment	4.0	16.0	1658328372	-10.489637
32288836	Clojure typically doesn't attract th	"Clojure typically doesn't attract the kind of developers who want to work on ""boring"" thingsSo there is an imbalance thereOn one hand I'm kind of happy there's no one true way in Clojure to do web dev, because as I think Rich said, it's not a solved problemSo if we couple too heavily to one opinion on web dev then it's going to fail us as a community on a big scale and be hard to move away fromSets of libraries are typically easier to swap outIn reality I think most Clojure businesses end up on reagent or and reframe and they are the defacto ways of doing web devFor ""solved"" problems like stripe calls it would be nice if we had more people working on maintaining libraries but as a Clojurian myself I know I wouldn't do that myself so I only have me and people like me to blame"	slifin	12.656062	-7.8987317	comment	4.0	18.0	1659203851	-11.163937
32289179	What would a 'Clojure on Rails' fram	What would a 'Clojure on Rails' framework look like? I think that's the primary reason why such a framework has yet to find traction; there's no single, obvious way to go about it.The efforts made so far in this space have taken many different approaches, because they're all experiments. Explorations of what an idiomatic Clojure web framework might potentially look like. Clojure has been around for over a decade now, and it's fairly mature as a language; but it's ideology is young in comparison to more established paradigms like OOP.To make matters more complex, Rails came to prominence in an era where web applications were mostly of one type: server-side HTML with a sprinkling of JavaScript. Nowadays there tends to be more options, e.g. a web application may consist of a single HTML shim,	weavejester	12.652537	-7.8876467	comment	4.0	63.0	1659206199	-11.164799
32290531	Your observation is simply not true.	"Your observation is simply not true. To the contrary, the consensus of the community seems to be that there's no need for a rails-like framework for Clojure. Most of Clojurians are satisfied with what we have in the Web front, and are not worrying about the lack of ""big Web framework"" at all. I don't know where you got your impression from."	huahaiy	12.653717	-7.8899055	comment	4.0	22.0	1659216650	-11.158562
32322208	The Elixir ecosystem is growing incr	The Elixir ecosystem is growing incredibly well. I am impressed both from an engineering and a product perspective.It shows that they are playing the long game.I think they are achieving what I wished happen to the Clojure ecosystem: productive, well designed, respected and popular. Clojure missed the last step, unfortunately.	xcambar	12.65467	-7.791409	comment	4.0	46.0	1659463430	12.878729
32324245	It seems making a Lisp popular is an	It seems making a Lisp popular is an impossible task.That said, I'm not sure if the data agrees with you. I think Clojure is more popular and widely used at this time. Not sure, but I think from what I remember of the few rankings, and just the fact I don't know an equivalent success story to NuBank for Elixir, I think maybe Clojure is at the moment more popular in practice.But with the amazing learning material Elixir is putting out, maybe it won't last.	didibus	12.66067	-7.890711	comment	4.0	19.0	1659474014	-11.027012
32386276	Why we chose Clojure	Why we chose Clojure	feross	12.6542225	-7.905929	story	4.0	70.0	1659970915	-11.183269
32498139	Everything on the landing page talks	Everything on the landing page talks about jank's goals and aspirations. 100% Clojure compatibility is a big one. The progress page starts with this disclaimer:> jank is under heavy development. It's safest to assume that any feature advertised is partially developed or in the planning stages. There is no sales pitch here; just a lot of work and some big plans. All development happens on Github, so watch the repo there!	Jeaye	12.6553955	-7.9007125	comment	4.0	17.0	1660752316	-11.163218
22035498	Tail recursion? As far as I know, Cl	Tail recursion? As far as I know, Clojure doesn't and cannot have it because JVM doesn't support it.	MadWombat	12.479644	-7.799899	comment	4.0	20.0	1578930872	-11.1730995
22065009	Something I discovered about Clojure	"Something I discovered about Clojure's cond recently.It usually looks likethis:    (cond (< a b) (println ""a < b"")
          (> a b) (println ""a > b"")
          :else   (println ""a = b""))

I thought the :else had to be :else, but it only needs to be truthy, so it can be anything that isn't false or nil (which makes sense as you want it to always execute that form if no others match).So this is just the same:   (cond (< a b) (println ""a < b"")
         (> a b) (println ""a > b"")
         :hotdog (println ""a = b""))

Probably obvious to everyone else but it was a bit of a ""duh, of course!"" moment for me."	LandR	12.553991	-7.84138	comment	4.0	12.0	1579186384	-11.126983
22088572	Not to be pedantic, but since Clojur	Not to be pedantic, but since Clojure is a hosted JVM language (as one of a few platforms it's hosted on) and has full interoperability with Java, by definition it has more libraries than Java as it has all the Java libraries plus all the clojure libraries. So definitely not library support in recent years but maybe back in the days. Performance was an issue early on as well, but that's certainly not the case now. Clojure is extremely performant and outperforms pretty much all the popular interpreted languages easily.	mnm1	12.649672	-7.8931704	comment	4.0	18.0	1579395176	-11.159478
22142011	Once javascript gets immutable types	Once javascript gets immutable types and better handling of objects, the gap between it and clojure will very small for most daily tasks.https://github.com/tc39/proposal-record-tuplehttps://github.com/tc39/proposal-object-iteration	Scarbutt	12.623091	-7.851547	comment	4.0	18.0	1579896954	-11.125599
22247941	Having read through this, I fail to 	Having read through this, I fail to see any benefits over using existing tools like Clojurescript+React. What am I missing?	lbj	12.6629095	-7.816358	comment	4.0	20.0	1580918381	-11.129483
35609481	Is the clojure user experience still	Is the clojure user experience still a JVM stack trace on anything going wrong? As a non-JVM developer that was extremely off-putting.I never quite bought into the atoms/transactions concurrency model, but probably wouldn't have looked so closely at hashed tries if they weren't clojure's choices and those have brought me a lot of joy.	JonChesterfield	12.645096	-7.8875976	comment	4.0	14.0	1681787076	-11.177005
35741524	Are Clojure dev teams outside of Nub	"Are Clojure dev teams outside of Nubank currently using REBL excited about this?As a small project Clojure dev (and admittedly a couple years out of daily Clojure use), these types of projects are hard for me to place in a day-to-day work context. The doc says that Morse is one tool that can ""amplify the power of the programmer during interactive development"".I totally feel like Clojure REPL-based dev is better for me personally - the interactive feedback feels so natural and functional programming matches so well my preferred dev process. But it is more difficult for me to understand where this type of tooling fits in dev workflow. Is Morse an incremental improvement? Does it make more sense in significant Clojure dev shops with many programmers vs just me sitting around with an Emacs rep"	clusterhacks	12.656609	-7.8988705	comment	4.0	14.0	1682691387	-11.166984
35804907	I thought STM was dead. Seems to be 	I thought STM was dead. Seems to be minimal adoption within clojure and all the hardware which tried to do it has been disabled for being broken. What makes it a particularly important example?The C++ plan of attack probably is more syntax though. Maybe parameterise constexpr, constexpr<input_only_io> or similar.	JonChesterfield	12.652066	-7.90262	comment	4.0	12.0	1683133802	-11.162008
35854909	I like lisps syntactically. The only	I like lisps syntactically. The only thing stopping me from using it more frequently is the lack of static typing. I wasn't always a stickler for static typing, but I've spent a lot of time working with Scala and TS and the main advantage for me is ease of refactoring and avoiding NPEs.EDIT: What I'm continuously evaluating for myself is Clojure specifically	leethomas	12.644479	-7.8200555	comment	4.0	20.0	1683488612	-10.61789
36043335	It's a shame Elm was abandoned.Impos	It's a shame Elm was abandoned.Impossible to justify for serious projects at this point.	dzogchen	13.012477	-7.6934395	comment	4.0	29.0	1684844998	-12.760466
36043394	Wait until you want to support an en	"Wait until you want to support an enterprise customer and you need to adapt their requirements in a quick way.Elm is fine for learning, but that's all for me. Serious products for serious customers require more than ""beautiful typings"""	revskill	13.005455	-7.6909904	comment	4.0	13.0	1684845503	-12.76562
36115321	Joker is a small interpreted dialect	Joker is a small interpreted dialect of Clojure written in Go	gstipi	12.625548	-7.905836	story	4.0	69.0	1685376973	-11.160178
36195544	I’m not sure I understand how there 	I’m not sure I understand how there are no lists out of the box in Clojure. What makes the data structures not valid lists? Basic lisp lists are nestable, doesn’t that make them trees? The underlying structure is to support immutability by default but that’s under the hood stuff. Conceptually and, I think more importantly, syntactically they’re list.	kgwxd	12.613617	-7.8668227	comment	4.0	13.0	1685969728	-10.924879
36442348	I started out with Clojure, but rece	I started out with Clojure, but recently have been really enjoying Janet.[0]Janet is a tiny (the entire language, core library, interpreter, assembler, and compiler are all < 1 MB combined), some-batteries-included, embeddable Lisp implemented in C. It borrows a number of Clojure's design sensibilities but isn't married to the JVM. It has super-fast startup times, so it's great for scripting. It has a built-in event loop, so you can do concurrent stuff out of the box. And the accompanying build tool compiles straight to native executables (either statically or dynamically linked) so distribution is a breeze.If you're Clojure-curious but want something lighter-weight with (IMHO) a much more gradual learning curve, Janet is a great pick.[0] https://janet-lang.org	cfiggers	12.633224	-7.8585477	comment	4.0	16.0	1687489907	-11.083227
36442182	My summer promise to myself is to ge	My summer promise to myself is to get into the lisps and do some new stuff. I've been stuck with C, NASM, Python and JS/PHP for quite some time now and I feel like I should branch out. Clojure seems like a good choice but CL seems to be more recommended across sites I've read.I realize this might be slightly OT but, yeah.	omgmajk	12.662465	-7.8805013	comment	4.0	25.0	1687488096	-11.025635
36455727	That was my issue for a long time. I	"That was my issue for a long time. I even talked with their founder several times on twitter back a few years ago. Each time I was greeted with buzzwords, that I knew the meaning of but I think they assumed I didn't.They would claim grand things like having solved the issues with continuations and delimited continuations, distributed process migration and a whole host of other very hard problems that haven't been solved in the past. I would ask their founder: ""right, so you know that delimited continuations have problems with accidental captured scope, they run poorly on the JVM, how did you solve this, have any papers I can read?"", and all I ever got was that Clojure, immutable data, X and Y would fix these issues and you just had to wait and see what they were cooking up.That's when I kn"	_halgari	12.653788	-7.901222	comment	4.0	16.0	1687583032	-11.16864
36519871	"Isn't Clojure the literal ""Lisp for "	"Isn't Clojure the literal ""Lisp for the modern day(a.k.a JVM)""?I hope I don't get kicked out of HN altogether for this comment :)"	theanonymousone	12.670823	-7.910507	comment	4.0	65.0	1688044168	-11.07222
36519993	IMHO Common Lisp is the modern one. 	IMHO Common Lisp is the modern one. Using the JVM is nice for certain uses, and clojure is a fine language, but going bare metal from higher abstractions is some power of Lisp that we should not give up. Same with macros and code generation.Luckily all of them can coexist, so we do not need to choose.	mejutoco	12.651508	-7.872776	comment	4.0	29.0	1688044868	-10.917181
36520105	Unfortunately, IMHO Clojure’s mainta	Unfortunately, IMHO Clojure’s maintainers hold an iron grip on the language and actively limit the growth of an ecosystem around it. See “Open Source is not about you”.It’s too bad, because itself is really terrific.	wildermuthn	12.655775	-7.896972	comment	4.0	18.0	1688045504	-11.170465
28721874	If you're coming from Java, you migh	If you're coming from Java, you might want to look at Clojure. It has immutable datastructures and Java interop.	wedesoft	12.353346	-7.7054367	comment	4.0	12.0	1633112734	-11.119717
23389675	Esprit Board for Exploring ClojureSc	Esprit Board for Exploring ClojureScript on ESP32 Processors	tosh	12.659547	-7.883668	story	4.0	65.0	1591095355	-11.192577
23419245	What is notable about Hickey besides	What is notable about Hickey besides being the creator of Clojure? Not to say that this alone doesn't make him notable, but I also don't really see the gain in an entry that is just a glorified redirect.	ImprobableTruth	12.653815	-7.9051776	comment	4.0	23.0	1591291220	-11.129928
23419516	Yeah, share both common concerns, ce	Yeah, share both common concerns, centering around the JVM (which I love, and have used and studied since it launched, but it is baggage).There have been a number of attempts to build Clojure on top of Go (I worked on one), and another on top of Rust. Both lack the dynamic runtime ergonomics that Clojure leverages. Clojure is also seeing significant performance benefits, both runtime and startup, from the Graalvm, but that also will have limitations.I am wondering about D, which should be sufficiently low level from a systems perspective but may also have sufficient dynamic capabilities.	jonahbenton	12.619901	-7.8792157	comment	4.0	16.0	1591292605	-11.185024
23419634	I was at a talk by Guy Steele where 	I was at a talk by Guy Steele where he mentioned in passing that Clojure was a Lisp which had done everything right. This was all the more impressive to him because Rich Hickey had until then been a relative outsider to the Lisp/Scheme community.	bangonkeyboard	12.655167	-7.9057	comment	4.0	45.0	1591293206	-11.161085
23419722	I have posted about this before but 	I have posted about this before but Clojure does have tooling problems specifically ergonomics.Look at create-react-app. Two commands and a ton of editor integration across intellij, vscode, vim, etc gives you incredible access to a rich ecosystem and plugs together really nicely with sensible defaults.Clojure has some answers in this space but everything feels bolted on and not nearly as polished. A big part of the problem is the size of the community, there just isn't enough hands to build out the infrastructure that other langs enjoy.I still love Clojure and will continue to use it but in order to do so I have to understand that some simpler things will just be more work.	Royalaid	12.65808	-7.89843	comment	4.0	27.0	1591293627	-11.198107
23419087	The fascinating thing to me about Cl	"The fascinating thing to me about Clojure is that it's so vocally a ""practical"" language, and yet is a) a Lisp, and b) purely functional[1]. Usually those two things are associated with language enthusiasts, and not """"""pragmatic"""""" development. In the end it works, clearly, it's just very interesting to see that juxtaposition.I think it says something interesting about the practical value of higher-brow programming concepts, but also about how important the packaging/marketing/ecosystem is to conveying that value and making it accessible to the masses.[1] I know it's technically not 100% functional, but all of its messaging highlights that philosophy as a focal point and advantage."	_bxg1	12.619313	-7.867747	comment	4.0	32.0	1591290279	-11.108284
23445755	I just built a frontend and backend 	I just built a frontend and backend with TS following this same logic. I'm super happy with TS for the frontend, but I regret picking it for the backend and am considering rewriting the backend in Clojure while it's still early.My reasons are:- I don't need to share type definitions between the frontend and backend; the frontend can generate TS type defs using GraphQL introspection regardless of which language the backend is implemented in.- The backend is doing a lot of data manipulation, which TS is not very good at. For example, there's no built-in group-by function, and group keys must be primitives since TS doesn't have value equality for objects or arrays.- Static typing doesn't help much with setting up GraphQL resolvers correctly, and overall feels much less useful than on the fron	peferron	12.638434	-7.882993	comment	4.0	14.0	1591518469	-11.140111
23516687	> If somebody knows other languages/	> If somebody knows other languages/systems that do let me know.Clojure can do this via namespace live reload. ClojureScript is already doing this inside figwheel [1] environment. CommonLisp had this since dawn of time. Kawa [2] can do it, but because it aggressively optimize the code, you need to be careful. Racket can do it as well [3].[1] https://github.com/bhauman/lein-figwheel[2] https://www.gnu.org/software/kawa/[3] https://github.com/tonyg/racket-reloadable/tree/master#readm...EDIT: added Kawa and Racket.	dig1	12.647456	-7.8901644	comment	4.0	25.0	1592132027	1.7566993
23636195	Not sure where the hostility is comi	Not sure where the hostility is coming from. I didn’t read anything disparaging about Haskell in hencq’s comment. He/she just made a factual statement about Clojure’s approach to data types being analogous to Unix/strings when it comes to composition.It comes with the same drawbacks (the lack of static typing is similar to strings with Unix; you have to be aware of the details of the data coming in and out because there is no type system to save you - unlike Haskell), but the benefit is easier composition.	adamkl	12.43335	-7.851806	comment	4.0	16.0	1593051428	10.43651
23793984	The clojure REPL is nice, don't get 	The clojure REPL is nice, don't get me wrong. But I think the reason people rely on it more than in other languages is because of clojure's slow startup time. If you could just make a change and run tests immediately, you'd see much less REPL abuse.	keithasaurus	12.625806	-7.8676167	comment	4.0	13.0	1594402196	-11.117319
23884688	Clojure's take on types is not so mu	Clojure's take on types is not so much that types are bad at micro scale, it's that focusing on proving referential transparency above all else leads to cultural problems at the macro scale. For example, the Datomic Peer API is the most elegant and ergonomic database API I've ever seen. Queries compose as functions under the illusion that the database is a local data structure and this results in a beautiful information model. But if you tried to put IO types on Datomic you find that it spews IO everywhere. And yet it works incredibly well with good enough performance for a wide band of applications! I think you don't find stuff like that in Pure FP ecosystems because those communities coordinate under principles of RT and algebra, and are thus unable to consider a solution space rooted in	dustingetz	12.583522	-7.8718095	comment	4.0	17.0	1595105116	-11.166773
23909532	Yeah, no way that's true if his pyth	Yeah, no way that's true if his python and clojure knowledge are at the same level. That tweet sounds like what you see on r/clojure all the time, a cult.	Scarbutt	12.652151	-7.9033165	comment	4.0	14.0	1595356765	-11.18799
23926662	The bull case here is if Nubank goes	The bull case here is if Nubank goes full Amazon and uses banking as a beachhead to create the next layer up from AWS, which Clojure/Datomic is amazingly perfect for – data all the things	dustingetz	12.661928	-7.890625	comment	4.0	16.0	1595507860	-11.202587
24123905	Clojure is nice for heavy data engin	Clojure is nice for heavy data engineering projects that require robust/stable/mature tech like the JVM. But for a full stack language for a web app it just adds a tons of complexity over just using JS.In Clojurescript interacting with the JS ecosystem is painful cause of its reliance on the closure compiler.In Clojure, is almost the same, most Java libs are over-engineered and horrible to use but you need to reach for them because Clojure lacks an ecosystem.So while Clojure is a better/nicer language than JS, the tradeoffs are not worth it if you want only one language for your webapp (SPA and server).	Scarbutt	12.647945	-7.8836007	comment	4.0	15.0	1597170491	-11.155747
24130349	I found that learning and writing so	"I found that learning and writing some Clojure and Go made me think better about the code I was writing in my main language (python).I enjoyed working through Clojure for the brave and true: https://www.braveclojure.com/clojure-for-the-brave-and-true/and the go tour is probably the best introduction I've ever had to a language:
https://tour.golang.org/welcome/1"	nicwest	12.529167	-7.895036	comment	4.0	14.0	1597227663	10.260566
24224148	Fun seeing that pretty much everyone	"Fun seeing that pretty much everyone else finds that idiom confusing too. Half-serious, over breakfast:    (case [(> n min) (< n max)]
      [true true] n
      [true false] max
      [false true] min)

(Side note: Clojure's `>` and `<` are kind of unreadable to begin with. Turning `if (> n min)` into ""if n is greater than min"" takes some work for me, still, after more than a year.)"	throwawaw	12.548743	-7.844359	comment	4.0	12.0	1597936684	-11.065414
24287422	Oh boy, what the world needs now: an	Oh boy, what the world needs now: another Clojure. How is it going to compete with the raging success of that :D	cpill	12.661208	-7.9058065	comment	4.0	12.0	1598476903	-11.2159395
24380993	Clojure is wholly inadequate to meet	Clojure is wholly inadequate to meeting challenges of the industry today. Not just because it's dynamically typed (which means tooling for it is close to nonexistent and it has terrible performance), but also because its ecosystem is a ghost town.It takes more than just a language to create a productive development environment in 2020, especially one which is so flawed by designed to the point of not even being statically typed.	hota_mazi	12.645473	-7.8998904	comment	4.0	13.0	1599273805	-11.16071
24380660	So it turns out that Clojure is the 	So it turns out that Clojure is the ultimate data-wrangling tool yet there's no chance of earning a living with it. So much for innovation. Technology is a strange industry where conservative Java bondage and a 2-bit browser scripting extension with no stdlib reign supreme.	cutler	12.658697	-7.898243	comment	4.0	22.0	1599269216	-11.187523
20052022	Maybe it's just me, but what I've fo	Maybe it's just me, but what I've found most difficult about clojure isn't the language itself, it's the java ecosystem around it.  I found clojurescript to be much easier to start working with, and I can only assume it's the javascript backend.Did anybody else have a similar experience?	wry_discontent	12.657019	-7.8884277	comment	4.0	12.0	1559229112	-11.163416
20074659	I think it’s noteworthy that whateve	I think it’s noteworthy that whatever the benefits of clojure it didn’t outweigh the adoption issue.It’s quite a mature language so I’m not sure that bodes we’ll for its prospects this late in the game.	usgroup	12.65607	-7.9052277	comment	4.0	17.0	1559472440	-11.166301
20074460	Most CS programs have a course on fu	Most CS programs have a course on functional programming or programming paradigms including functional programming.I don't understand why it would be a challenge to pick up Clojure.	nnnmnten	12.634808	-7.885611	comment	4.0	13.0	1559468691	-11.113088
20220263	That’s very cool. I’ve added Clojerl	That’s very cool. I’ve added Clojerl to my list of alternative languages on the BEAM: https://gist.github.com/macintux/6349828#alternative-languag...Given the extent to which the Erlang VM is optimized for immutable data, network transparency, and message passing, I can see why Clojure on the JVM and CLR would not have had the same success with the actor model as Erlang has.	macintux	12.627635	-7.8465366	comment	4.0	47.0	1560910344	12.853755
20245682	Looks similar to A* to my non-Clojur	Looks similar to A* to my non-Clojure using eye. How has your performance been? If I use a 1000 x 1000 grid in my A* Python implementation I wrote last night it takes forever.[0]https://en.m.wikipedia.org/wiki/A*_search_algorithm	fuzz4lyfe	12.636632	-7.8912973	comment	4.0	13.0	1561145855	8.769933
20266233	Clojure's immutable data structures 	"Clojure's immutable data structures (lists, vectors, maps and sets) are actually not copy on write, they're based on red-black trees such that when you ""mutate"" the  value, a new one is created that shares everything but the mutated part with the original.Clojure is amazing and i can't recommend it enough. I wish more people looked past the unfamiliar syntax and understood why it exists and how it makes you achieve more with simpler code."	keymone	12.575176	-7.862982	comment	4.0	26.0	1561398242	-11.153476
20304759	I'm excited that some of the ideas f	I'm excited that some of the ideas from Datomic are starting to make it into some open source projects. With crux last month and now Eva, there are now multiple options for modern clojure databases.While there are many excellent ideas embedded in Datomic and these projects, for me just being able to persist the same data structures you're using at a repl and query for them with data is a huge win vs having to start translating types and concepts and query strings to and from SQL is a huge win.	CurrentB	12.686174	-7.8548326	comment	4.0	27.0	1561732925	-11.210534
20312897	The lack of a really good open sourc	The lack of a really good open source IDE or IDE plugin is a real road block for a number of people. Pointing folks to Emacs or an Emacs derivative is is not the solution. I know there is a couple of IDE plugins for Clojure and I think it would help if there were similar options for Common Lisp.I know there used to be a plugin for Eclipse (Cusp) but that appears to have died.	0x445442	12.671824	-7.8612294	comment	4.0	33.0	1561819842	-10.579826
20335723	As a counterpoint, I have had a deve	As a counterpoint, I have had a developer who had wrote production ClojureScript tell me it was the worst of all worlds - it doesn't abstract away issues of the DOM and yet you still have to debug what was happening in JS and translate it over to Clojure.Another thing I noticed is that most developers who had to touch Clojure in my org all pretty much didn't like it at all.	Bahamut	12.655506	-7.8889823	comment	4.0	13.0	1562079287	-11.172765
20364377	thanks for the guide! I've sorta bee	thanks for the guide! I've sorta been avoiding dipping my toes into deps.edn. Maybe I missed it, but this doesn't really seem to illustrate any advantage over leinnow you have to hunt down extensions/plugins to do testing and make uberjars, cobble it all together yourself and then hope they remain maintained going forwardwhat's the benefit? you can make wacky nonstandard directory layouts? I feel like I'm missing the motivation or maybe my problems are too simple. that said it does seem like a nice low level tool (ie. maybe lein could be implemented in terms of deps.edn)	geokon	12.599509	-7.812675	comment	4.0	13.0	1562349303	4.4524455
20367368	It's interesting that there's so muc	"It's interesting that there's so much resistance to Clojure given it's modern / being used in production a fair bit.I've had a number of great experiences working on toy projects using Clojure but nevertheless feel resistance to adopt it fully ""because of the JVM"".I've pinned my own resistance down to three things:- Slow startup times. (Most of my use cases are not long running servers.)- Not ""unixy"". (I write programs to run on linux and OSX exclusively and am used to using non-portable APIs maybe?)- I've been lead to believe Java is ""gross"" and ""enterprisy"".Really, of those three reasons only the first one has merit.It kind of sounds silly when I put it this way: When I'm hacking on fun projects, I enjoy using a ""hacker"" language and Clojure doesn't feel like one.One implementation you d"	jpittis	12.645988	-7.894763	comment	4.0	19.0	1562380055	-11.16122
20375568	Did it? People seem to use Clojure a	Did it? People seem to use Clojure a lot, other dialects are popular with hobbyists, and some of the most enduring computer science books of all time use it. How many other languages from the 50s can claim that kind of wide use?Aside from that, as the author points out, ideas from Lisp have made their way into almost every widely-used language today. It's fingerprints are everywhere. That doesn't sound like a failure to me.	caiocaiocaio	12.665226	-7.8875685	comment	4.0	20.0	1562513399	-11.07033
20504384	Forgive me if the answer to this is 	"Forgive me if the answer to this is already widely-known, but at this point is Racket making a play to be a general-purpose, ""batteries included"" Lisp, rather than a stripped down tool for PLT stuff and making languages? It seems like there's room in the market for something like that. A bit like Clojure, but without all of the big design commitments that Clojure makes, like the deep integration with Java and focus on immutability."	a_lieb	12.704685	-7.8455048	comment	4.0	12.0	1563856020	-10.919155
20624352	It's a pity, because he has a few in	"It's a pity, because he has a few interesting projects like:* Rackjure: ""Provide a few Clojure-inspired ideas in Racket. Where Racket and Clojure conflict, prefer Racket."" https://github.com/greghendershott/rackjure I don't use it, but I think it's a nice idea, and it show how Racket can be used for multiple programming ""frontends"".* Travis-Racket ""https://github.com/greghendershott/travis-racket*"" https://github.com/greghendershott/travis-racket Travis don't support Racket directly, so his package is very useful for testing without having to study all the details about the naming and download addresses of each version/variant, I use it all the time."	gus_massa	12.697741	-7.816024	comment	4.0	12.0	1565093065	13.6289215
20648369	A very important caveat: Clojure com	A very important caveat: Clojure compilation is not side-effect free. If you are generating the JVM equivalent of a binary (excluding the assumption of stuff like GraalVM) i.e. a überjar, you are going to have a bad day if your code does stuff like edit configuration files, call a JSON API etc. The code would run during the compilation stage. Something to take note of.	sansnomme	12.647697	-7.890438	comment	4.0	16.0	1565296268	-11.167346
20789103	My team owns a Clojure app, amongst 	My team owns a Clojure app, amongst a lot of other apps - my understanding is the current DRI (who inherited this app once the original one left for another org) doesn't like working in it though, and that has been the experience of other developers who have been recruited to the project over the past two years. Most developers I work with on a day to day basis don't have any interest in learning Clojure, and would rather work with Scala, the JVM language most heavily used within my org.One of my teammates also has production ClojureScript experience, and called it the worst of both worlds (Clojure and JavaScript). The primary problem is it doesn't try to abstract away the DOM, the most typically problematic part of working with JS.Just my own encounter with it so far - I haven't had the e	Bahamut	12.654766	-7.887434	comment	4.0	14.0	1566674231	-11.178968
20789736	"The response to ""but is it slow"" is "	"The response to ""but is it slow"" is pretty disappointingly bad.> No. Clojure is not slow. Oh, look, it’s not C. It’s not assembler. If nanoseconds are your concern than you probably don’t want Clojure in your innermost loops. You also probably don’t want Java, or C#. But 99.9% of the software we write nowadays has no need of nanosecond performance. I’ve built a real time, GUI based, animated space war game using Clojure. I could keep the frame rates up in the high 20s even with hundreds of objects on the screen. Clojure is not slow.If you're going to respond to this question at least provide some comparison maybe.But otherwise that anecdote of ""I could keep the frame rates up in the high 20s even with hundreds of objects on the screen."" absolutely screams extremely slow. High 20s FPS with "	kllrnohj	12.6389265	-7.8929906	comment	4.0	20.0	1566681048	-11.164721
20789907	The biggest thing keeping me from ev	"The biggest thing keeping me from ever seriously learning Clojure is the JVM. Slow startup time means I'd never use Clojure for ""scripts"", and I certainly don't want to have to manage the JVM in production scenarios, so when would I use Clojure? If there was a native version that could produce static binaries like Go/Nim/Rust I'd be much more interested to learn it."	kbd	12.636105	-7.890879	comment	4.0	14.0	1566683263	-11.167464
20798874	Fast Tensors in Clojure – A Sneak Pe	Fast Tensors in Clojure – A Sneak Peek	dragandj	12.640063	-7.9006205	story	4.0	122.0	1566818385	-11.171746
20800725	Asset minification with Elm (2018)	Asset minification with Elm (2018)	lelf	13.011916	-7.6951284	story	4.0	68.0	1566833964	-12.756866
20804242	You don't have the mature bindings t	You don't have the mature bindings to things like TensorFlow or Torch, you don't have good viz libraries, you don't have broad support for the types of analysis scipy allows, and beyond Weka and random stuff like XGBoost having Java bindings, you don't have access to a lot of different models.That said, Clojure is _much_ better than both Python and R for data prep. You can build very nice, fast (parallel) pipelines with transducers etc, and stuff that seems like magic to tidyverse consumers in R is just everyday data transformation in Clojure. And despite the fact that Incanter more or less died, I still think the language would be a great fit for data science if the community was there, and Dragan's work really deserves that sort of attention. The foundations are already far superior to w	thom	12.644417	-7.8882327	comment	4.0	16.0	1566856983	-11.149
20845882	One (stupid?) thing that annoys me a	One (stupid?) thing that annoys me about closure is that native clojure libraries use snake case while java libraries use camel case. You could obviously write a new defn macro to take of all this and make it consistent, but it might have just been a better decision to just make everything camel case, in in Lisp-like fashion.Also I find Clojure a little dogmatic in regards to mutation, more so than even Scheme. I find Racket to be better designed and more elegant, though currently the performance isn’t as good.	mruts	12.644662	-7.863885	comment	4.0	14.0	1567254294	-11.127438
20847503	I love the idea of Clojure.I find th	"I love the idea of Clojure.I find the ecosystem immature and full of ideas about ""libraries, not frameworks"" that leave developers incredibly vulnerable to their own ignorance and second-order ignorance. The number of developers I know - or even know of - that can be trusted to develop a useful and secure web application from the ground up with this kind of tooling approaches zero.Clojure is a cool language. I can only hope the ecosystem soon matures enough to make it one that's suitable for serious use."	Kalium	12.649525	-7.8913074	comment	4.0	21.0	1567271299	-11.173173
13661417	Hickey may be a brilliant software a	Hickey may be a brilliant software architect, but I'm wondering how high he ranks as a business leader. How is his company Datomic doing? Also in the light of the new database service Cloud Spanner just launched by Google.	amelius	12.659101	-7.905433	comment	4.0	12.0	1487264094	-11.161473
13675001	Optimal Emacs Settings for Org-Mode 	Optimal Emacs Settings for Org-Mode for Literate Programming in Clojure	Terretta	12.638745	-7.898039	story	4.0	67.0	1487430384	-11.126579
13882628	This is super interesting. It's also	This is super interesting. It's also interesting to see the converse - who isn't moving anywhere. Go, Elixir, Dart, and Clojure all seem pretty happy!	urs2102	12.656621	-7.8742695	comment	4.0	15.0	1489640101	-11.147065
13979316	Short answer: don't do that, use Clo	Short answer: don't do that, use Clojure instead. It doesn't have any of listed problems.	ConanRus	12.645259	-7.899242	comment	4.0	45.0	1490726104	-11.161115
14006796	For the nested if-let mess, I'd prob	"For the nested if-let mess, I'd probably do something like this:    (let-every [x (foo)     err ""foo failed""
                y (bar x)   err (format ""bar %s failed"" x)
                z (goo x y) err (format ""goo %s %s failed"" x y)]
      (qux x y z)
      (handle-error err))

Where `let-every` is a macro that works like let, but stops short on the first nil/false variable, runs only the next symbol binding expression, and then runs the else-clause.There'd be nothing special about the ""err"" symbol on each line. It's just the next symbol binding, but on the same line as a convenience, and this means it can reference any previously valid symbol bindings.Here's a quick & dirty implementation of that macro. I don't have a Clojure interpreter installed, so I don't know if it works.    (defmacro"	sdegutis	12.415888	-7.8309636	comment	4.0	17.0	1490985849	-11.1830015
14008557	> Why not? If a language's goal is t	"> Why not? If a language's goal is to be practical (as is Clojure's), then it should take practical concerns into consideration. This is something that the Java community definitely gets right.AHAHAHAHAHAHAHAHAHAHAHAHAHA!Java getting practical considerations right.  Oh, I so needed a good laugh.Let's start from the basic:No unsigned type.  Bit/byte manipulation code written in Java is garbage when written by experienced programmers.  When written by inexperienced programmers it's a nightmare.Ever looked at the ""class pyramid"" monstrosities in Java?  That includes the two primary GUI systems.Ever debugged all the stuff coming from the type erasure that you are stuck with doing in Java?And, let's not even gets started on the people who think they can write concurrent code (Hint: if your Java"	bsder	12.617899	-7.8861356	comment	4.0	20.0	1490996379	-11.159148
14419492	Clojure's not dying, but it's also n	Clojure's not dying, but it's also not thriving[1].I think it will continue on as a solid niche language for the foreseeable future, but it's highly unlikely that the language will grow by leaps and bounds barring some must-have innovation in the Clojure language and/or ecosystem that gets the tech world to take it more seriously.There are so many options these days that it's tough to stand out from the crowd. Clojurescript, while interesting, is a dime-a-dozen with Elm, Purescript, Scala.js, Typescript, etc. all on offer, and with static types to boot. Also, Lisp itself is a tough sell, mainstream adoption isn't in the cards without a major paradigm shift.[1] https://trends.google.com/trends/explore?q=%2Fm%2F0_lcrx4,%2...	virtualwhys	12.653807	-7.88033	comment	4.0	56.0	1495740494	-11.12017
14420573	I tried Clojure and literally within	I tried Clojure and literally within the first hour got a super ugly Java stack trace from trying to add two numbers, and that was after already being a bit miffed by JVM startup time (i'm very big on instant unit test feedback). Meh.	pmarreck	12.635014	-7.8830824	comment	4.0	12.0	1495750488	-11.169118
14421467	I hear this a lot from the clojure c	I hear this a lot from the clojure community... but I think it's a missed attempt to pivot off the JVM and have clojure be useful for more people on a more popular platform.Missed?Yes.Pick a thing.Be excellent at it.What is clojurescript excellent at?Its a nice language, with not very nice tooling, that is hard to maintain and significantly different from the existing javascript code base you already have, with poor interop to the existing js ecosystem (it is poor, compared to some other compile to js languages).On the JVM, java sucks, but your choices are limited; what, maybe groovy, kotlin, scale, clojure?Clojure has pride of place as the best dynamic language in that space.For javascript, that crowd of alternatives is so much larger, clojurescript needs to actually be good to stand out 	shadowmint	12.644534	-7.868737	comment	4.0	15.0	1495761879	-11.142655
14442152	You've made my point for me. The ver	"You've made my point for me. The very fact that you must write (function sin), or #'sin, or use funcall is a way that it treats functions differently than normal values. Since it requires some amount of extra though and/or typing, this often seen as a bad thing. Compare Scheme, Clojure, or other lisp-1s where if you want to pass the sin function to someone, you just say sin. That whole outer let vanishes in those languages, and the result is much simpler.And just as we both agree that in Common Lisp passing functions in as arguments is very common, so in Clojure is ""calling"" a vector on a number to index into it, or ""calling"" a symbol to use it as an index into a alist or hash table, etc. Not only do you not have to type anything extra, you can treat all values as callable."	db48x	12.622964	-7.876439	comment	4.0	20.0	1496101921	-11.002447
14445597	Counting Clojure Code	Counting Clojure Code	aaroniba	12.645205	-7.891872	story	4.0	119.0	1496154466	-11.163768
14506012	Reducers, transducers and core.async	Reducers, transducers and core.async in Clojure	ingve	12.638591	-7.891579	story	4.0	163.0	1496840679	-11.170484
14610986	Clojure Newbie Guide (2015)	Clojure Newbie Guide (2015)	sriharis	12.6544485	-7.9085574	story	4.0	134.0	1498122793	-11.178643
14612256	What're you using it for?  I really 	What're you using it for?  I really like the language, but it seems geared to replace Java for heavy enterprise enterprise applications.  A lot of the benefits I hear people talk about sound like they require a large project to be properly noticed.I've used Clojurescript for a couple toy projects, but it seems awkward to me.	wry_discontent	12.648758	-7.882171	comment	4.0	22.0	1498139989	-11.145915
30768939	Glad to see Clojure continuing to im	"Glad to see Clojure continuing to improve. Racket borrows a lot from Clojure^1,2,3 so its success fuels ours as well. With the other post on here about Java 18 including Pattern Matching, I'm glad that good ideas continue to cross pollinate between different languages. Programming is still a young field compared to other professions, and there is still a lot of good things left to discover!1. https://docs.racket-lang.org/collections/index.html
2. https://docs.racket-lang.org/seq/index.html
3. https://docs.racket-lang.org/threading/index.html"	Decabytes	12.643743	-7.836707	comment	4.0	13.0	1647970091	-11.078711
30771488	- ease the onboarding. Every few mon	"- ease the onboarding. Every few months I try to give clojure another shot, and every few months _some_ part of the setup has changed and / or is broken.- compile to small binaries that run fast. I get what the langage gets from the JVM, but those 5,10 seconds I get before _anything_ runs, even after I had everything compiled ?- show me an example of how having 'spec' is going to help me refactor the code that I got wrong the first time, as easily as what a proto-ML-like static type checker does. It's not a question of ""types are bad vs types are good thing"". It's a question of ""this property was called 'name', but now I need it to be 'names', and I really need to know every possible place of my code base that uses it so that I can recursively change all code paths to handle the fact that "	phtrivier	12.58461	-7.877091	comment	4.0	20.0	1647982854	-11.135541
30772849	About the syntax. I tend to prefer S	About the syntax. I tend to prefer Scheme because (, [ and { mean the same thing, whether in Clojure they are different constructs. How do you feel about this minor point?	haolez	12.601292	-7.857867	comment	4.0	14.0	1647990976	5.8398786
30924184	I loved Coast and wrote at least one	I loved Coast and wrote at least one production app with it (and very quickly and pleasantly at that), but it needs to be said that swlkr is the only developer, and he seems to have mostly moved on to Janet (https://janet-lang.org/). Case in point, the last real updates to Coast were 2 years ago, and - unlike other Clojure libraries - not because this project was /finished/.	phyrex	12.654989	-7.889483	comment	4.0	24.0	1649188742	-11.173121
30934767	I wonder how many OpenSCAD wrappers 	I wonder how many OpenSCAD wrappers now exist? I know of scad-clj [0], openpyscad [1], and solidpython [2].I particularly like scad-clj, because of `lein auto generate`. It watches source files, and regenerates the OpenSCAD files automatically, which OpenSCAD then also picks up. Although I'm not well versed in Clojure, and find debugging Clojure tricky, the workflow is just so good.[0] https://github.com/farrellm/scad-clj[1] https://github.com/taxpon/openpyscad[2] https://github.com/SolidCode/SolidPython	guitarbill	12.651842	-7.891135	comment	4.0	25.0	1649264707	-6.1224346
31044413	I think the article should be titled	I think the article should be titled 'JVM isn't for me'.According to the article, the author moved to Janet, because it is Clojure-like without the JVM overhead.	delegate	12.618073	-7.8509593	comment	4.0	18.0	1650049806	-11.157044
31044479	OP doesn't need or want the JVM or J	"OP doesn't need or want the JVM or Java libraries, and he wants to stay in the world of Free software that C and Ruby provide.He analyzed his needs and wants.This is a good example of what ""right tool for the job"" analysis looks like.Though honestly, if OP wasn't in ""java land"" (his phrase), I'm not sure why Clojure was even on his radar.I greatly respect people who reject the hype and just go with the language that fits their needs, even if it isn't hyped like C, Ruby or Python but provide plenty of what you'll need.https://boringtechnology.club/"	valbaca	12.648037	-7.88882	comment	4.0	16.0	1650050089	-11.144899
31094221	This is a really nice combo, I agree	This is a really nice combo, I agree. But… I think it’s safe to say it’ll probably remain niche forever.I wish there were more stacks like Clojure/Script.While I’m wishing, I’d love to have a modern ML with simple tooling, a good stdlib like Go (with a high performance http server baked in), and a good full stack story that doesn’t produce a 1MB “hello world”, and doesn’t require 1K dependencies. Does anyone know what the closest thing to this is these days?	christophilus	12.618873	-7.830205	comment	4.0	12.0	1650443694	7.173869
31214703	(While it seems that the project isn	(While it seems that the project isn’t active) I’m interested not because of the Rust part but because of the more independent part, with plans to implement conditions and restarts [0].I’ve mentioned a few days ago [1] about the lack of a clean and consistent lisp (in the development sense, not in the core-language-is-tiny sense) with a CL-like REPL-driven development workflow: maybe Clojure with conditions and restarts can be part of the picture?(In Common Lisp, restarts and conditions are a major part of the REPL as it allows the REPL to have a mechanism to catch error conditions and allows the user to resume execution appropriately, after the user debugs and fixes errors.)[0]: https://lisper.in/restarts[1]: https://news.ycombinator.com/item?id=31179701	pcr910303	12.549347	-7.88038	comment	4.0	14.0	1651312469	-11.078564
31265696	Not sure if it is still the case, bu	Not sure if it is still the case, but Circle used Clojure/Om [1]... when I heard them say they did that so many years ago, I knew right away it would end up being something nobody wanted to work on.Sure enough, just checked, Om was abandoned [2] and the person blogging about how great everything was is long gone [3]. This is the absolute definition of tech debt.[1] https://circleci.com/blog/how-circleci-processes-4-5-million...[2] https://github.com/omcljs/om[3] https://circleci.com/blog/why-we-use-om-and-why-were-excited...	latchkey	12.656408	-7.9048543	comment	4.0	12.0	1651697456	-11.164576
31282483	I am almost 30 and attempting to lea	I am almost 30 and attempting to learn Clojure was to me like swimming through mud. It is definitely not just you.	danuker	12.654202	-7.8990555	comment	4.0	13.0	1651823188	-11.153947
31319167	I feel like the unsung winner of Pro	I feel like the unsung winner of Project Loom is going to be Clojure. Its already immutable first data structures, it should be relatively straightforward for the Clojure project to expose the benefits of Project Loom to their ecosystem, as a language its designed to fit well its execution model.	no_wizard	12.641355	-7.884492	comment	4.0	21.0	1652127440	-11.152824
31447374	This is a baloney C-biased question.	This is a baloney C-biased question. The real question is why nil is falsey (ALONG with false) in Clojure.To my mind this is an incredibly boneheaded mistake in a modern language.  Common Lisp can be excused as it is old and has an even older ancestry.  nil has been false in common lisp and its ancestors since forever, but this is an accident of history, and nobody claims it to be a good idea, as it is a source of many bugs.  And indeed some lisp functions have to have additional gizmos added to them to work around it.Scheme fixed this with real true and false constants. And then clojure, um, decided to combine the worst of both worlds, by making TWO things be false.	SeanLuke	12.625197	-7.88848	comment	4.0	18.0	1653054691	-11.088757
31526671	Defining basic scalars and giving th	Defining basic scalars and giving them good names is useful.Trying to define models (as Taxi defines them) statically is often a source of hidden  technical debt as models change over time and different teams in different parts of an org can't agree on what a model should contain.I like that the creator of Taxi is already aware of the anti-pattern lurking behind common domain modeling but doesn't take those lessons learned far enough.Case in point: the field names in models themselves should be the actual Types (again, in the nomenclature of Taxi)`firstName: FirstName` is redundant. It is equivalent to an alias.Instead a model should just be a open set of Types (I would probably call them attributes).That's what Clojure Spec gets right from the get go and leads to much more flexible and op	beders	12.616007	-7.8695703	comment	4.0	12.0	1653633693	-11.18197
31666100	Before you commit too much time to l	Before you commit too much time to learning Elm, please understand that Elm has somewhat unique cultural values. The Elm leadership team has a very specific vision for how Elm should be used and actively discourage alternate visions (in particular for JavaScript interop). In addition, it's difficult to know how the language will change or propose changes to the language. There is no public roadmap and GitHub issues (even for bugs) are ignored for years. Here are two examples of where people felt forced to migrate their project to a different language:https://lukeplant.me.uk/blog/posts/why-im-leaving-elm/https://www.listennotes.com/podcasts/reason-town/elm-to-ocam...I'm not saying to avoid Elm. It's a beautiful language that makes UI programming fun. Just don't put 6 months of nights and we	bbkane	12.988566	-7.6968894	comment	4.0	14.0	1654690258	-12.754899
28831299	Is Clojure not considered a true lis	Is Clojure not considered a true lisp?	bgorman	12.653829	-7.88574	comment	4.0	22.0	1633976810	-11.064879
28863576	This was my issue when trying to lea	This was my issue when trying to learn clojure as well	Decabytes	12.651836	-7.902167	comment	4.0	25.0	1634215983	-11.162967
28980043	Whenever we read about new improveme	Whenever we read about new improvement in Java,it is always inevitably followed by concerns for viability of Kotlin or Scala. However these concerns are never applicable for Closure. I am glad I went all in on Clojure.	manishsharan	12.54308	-7.8237486	comment	4.0	29.0	1635096367	-11.186423
29090729	Is clojure the newest popular-langua	Is clojure the newest popular-language-you-can-get-a-job-in? It's initial release was 2007.Rust (2010) (edit Kotlin (2011) perhaps), but point being there aren't many newer: https://en.wikipedia.org/wiki/Timeline_of_programming_langua...That metric is subjective and arbitrary, but it's on my mind because my company is hiring for clojure developers (see my immediate comment history & apologies for the advertisement).And it's on my mind because common lisp and scheme are _old_.One of the nicer things about clojure is relatively frequent mentions of how common lisp did things, then a choice to hew or differ. And common lisp and the lisp family of languages have a long history. I like this as an art-piece of lisp's age: http://kazimirmajorinc.com/Documents/Lisp-code-typography/in...	delish	12.659839	-7.8852463	comment	4.0	16.0	1635909152	-11.010813
29121308	Like all evidence, it is actually ea	Like all evidence, it is actually easy to find both sides.  Notably, I have yet to come across a project in clojure, Haskel, or scala that wasn't abandoned as soon as the major advocate for that language left the group.Sad in the cases where it was a well done project.  Frustrating when it was bursting at the seams.	taeric	12.629908	-7.8860793	comment	4.0	31.0	1636128837	-11.171941
29163800	I've been building a personal projec	I've been building a personal project in both Clojure and Common Lisp to make a DSL for scraping web data, transforming it, and outputting it to a few backend formats.I would say it's been significantly harder to achieve the same functionality in CL than Clojure, but there are major perks to the ecosystem. I was surprised by how much I've valued conditions and restarts, type inference from SBCL, stack traces, and tooling in general.Clojure OTOH feels like it takes much less effort to get up and running, feels more intuitive to write, and has far better documentation.I'm probably going to continue writing my project in both languages in parallel because I love learning and I spend my time poorly. I want to stick with Clojure given that it sees more use these days, but it's hard not to prefe	jpe90	12.652148	-7.858908	comment	4.0	17.0	1636475217	-11.000821
29229088	I've used Python for 15 years and I'	I've used Python for 15 years and I'm far more productive with Clojure. Don't generalize.	lvass	12.621314	-7.864397	comment	4.0	15.0	1636992977	-11.123104
29361467	Show HN: Llr – a Clojure inspired Li	Show HN: Llr – a Clojure inspired Lisp that compiles to R in R	watwatwat123	12.645822	-7.8904495	story	4.0	63.0	1638031833	-11.130801
29483316	Understanding Clojure's Persistent V	Understanding Clojure's Persistent Vectors (2013)	sendilkumarn	12.635095	-7.8961177	story	4.0	64.0	1638961158	-11.158859
34263786	>  actually think it is the quickest	>  actually think it is the quickest and easiest way to get started learning Clojure, to a point.That's great, I was just checking out Clojure a few hours ago and now have it installed. Any other cool blogs and resources the fine folks on here could recommend.	zote	12.673484	-7.9147696	comment	4.0	14.0	1672941649	-11.126585
34266856	Clojure’s loop expression hits this 	Clojure’s loop expression hits this spot for me. It sets a recursion point to which you can jump using any logic inside the body you want, as long as it is from tail position. It’s like a while loop turned into an expression. I haven’t encountered any other way to write iterative expressions whose number of iterations isn’t known at the top (like map and reduce).	pgorczak	12.473049	-7.794033	comment	4.0	28.0	1672953973	-11.16847
34267134	Interestingly, I almost prefer Cloju	Interestingly, I almost prefer Clojure's `recur` semantically. Means you don't have to change the function name twice if you rename it, and it's hard to miss that you're recursing.	amalgamated_inc	12.57598	-7.8608313	comment	4.0	16.0	1672954905	-11.150929
34273539	I wonder what it would take to bring	I wonder what it would take to bring these things to Clojure. Its REPL experience is miles ahead of non-lispy languages but I do feel a pang of grass-is-greener whenever I hear about CL's debugging tooling. Hell, the JVM has a great debugger as well (or so I hear), so why is that difficult to port over?	zrkrlc	12.652368	-7.8957486	comment	4.0	13.0	1673004347	-11.122069
34755980	So, is that a claim you're seriously	"So, is that a claim you're seriously making about Evan?- - - -Not to be arch, but this whole line of discussion is uninteresting to me.  I'm glad to discuss Elm, but I don't want to hear unfounded character assassination of a kid who's only guilty of being willing to say ""no"" to people who want to change his language in ways that he's not into.From my POV Elm stands as a serious challenge to the entire JS ecosystem.  I keep asking, ""What's the business value argument for not using Elm?"" and no one has a good answer."	carapace	13.008685	-7.691974	comment	4.0	18.0	1676147034	-12.764223
34775966	I've started learning Clojure about 	"I've started learning Clojure about a year ago, couldn't say it was easy (the fault might be with me and not Clojure)Clojure has a  lot a faults (just look at some of the comments here) BUT and it's a BIG BUT for me...Clojure is SUPER FUN :)Over the years(15+), I've been coding in PHP (suck it haters), Go, Rust,Java,Python AngularJS+, Svelte and I can honestly say for me, nothing is more fun that coding in Clojure.It's fun testing a function in ""realtime"" by just ""eval"" it on the spot.
I don't even code ""in the REPL"" I just use Calva and eval inline in VSCodeMaybe it's cause it's my new toy but it really does bring back the ""joy of coding"" I've been missing in the other languages.*Learning Clojure became much more easier, once I told myself ""It's Maps All The Way Down :D""  Sure there are s"	rawoke083600	12.632869	-7.8863845	comment	4.0	59.0	1676306810	-11.130298
34784393	Clojure users fighting against stati	Clojure users fighting against static typing are on the wrong side of history. They are fighting a side for all the wrong reasons, and they will lose.There is a reason why all dynamically typed languages today are scrambling to add some form of static typing to their language, but never the other way around.Static typing does everything dynamic typing does, but better, faster, allow automatic refactoring, faster programs, better navigation, better documentation, better maintenance.	hota_mazi	12.496859	-7.8395553	comment	4.0	14.0	1676341540	-11.110972
34812261	I don't use Clojure and I probably n	I don't use Clojure and I probably never will, but I love seeing the way it's been kind of a jailbreak moment for Java programmers trapped in enterprise practices. It was laser-focused to give specifically those people access to a whole lot of highly-productive and pleasant language features, wrapped up in a package that enterprise management could be amenable to. It seems like it succeeded in liberating a bunch of people at their real jobs, which is cool to see	brundolf	12.655603	-7.8997955	comment	4.0	24.0	1676502468	-11.1698
34812742	I've had a couple of jobs doing Cloj	I've had a couple of jobs doing Clojure full-time, the problem is that Java jobs pay better.	jcadam	12.6533785	-7.9208465	comment	4.0	17.0	1676505106	-11.169133
34813121	I actually quitted a job in 2017 bec	I actually quitted a job in 2017 because I was so hyped around my discovery of  clojure in 2016 and wanted to write some piece of code that was gonna parse some JS code and spit out some other JS code. (I quitted cuz I never got the project done and my manager was like hey man it's been 5 months do you have any updates and I'm like hey I've been rewriting the same thing over and over again while hopping between 5 different editors and 3 different build tools and to be honest all I've done is learning emacs for the past month).I don't know if things have improved but back then everything felt either a WIP or obsolete. You wanna use lein to build but apparently that's ancient and you really should be using this other build tool that's not fully integrated with any editor other than emacs and	n-gt	12.652503	-7.8884945	comment	4.0	16.0	1676507115	-11.128562
34816146	> A first element of decision lied i	> A first element of decision lied in the fact that our product used a great number of data structures and business management rules which aim to evolve very frequently and be adapted to new business contexts over time.They seem to have a very good use case for Clojure adoption. The article mentions many of the affordances Clojure gives you for data oriented, information processing problems.But one of the unsung heroes of Clojure is the namespaced keyword:If you’re already working in a FP, data oriented style but in a language that doesn’t have them, I recommend you have a go with Clojure and explore them.It’s such a simple construct that gives you a lot of leverage in terms of semantics, code organization, flexibility and validation.Think of them as having characteristics of uuids, URLs, 	dgb23	12.645844	-7.890523	comment	4.0	14.0	1676534021	-11.1756735
34844970	You mean Python, not Clojure. A numb	You mean Python, not Clojure. A number of key underpinnings, such as (almost) exclusively immutable datastructures are missing from this language.It is more of a Python with a LISP syntax.	haspok	12.632586	-7.895531	comment	4.0	20.0	1676707299	-11.125359
34936878	Symbolic Programming with Clojure [p	Symbolic Programming with Clojure [pdf]	cpp_frog	12.647836	-7.899781	story	4.0	171.0	1677335041	-11.171645
34949971	While I love Clojure, these ideas al	While I love Clojure, these ideas already existed in other languages. For example, Mozart/Oz basically integrates all major paradigms [1].It's a bit of a tragedy it has been mostly abandoned. I wish a Lisp, such as Clojure, emulated Mozart/Oz semantics.[1] https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf	nextos	12.651682	-7.8902187	comment	4.0	18.0	1677448757	-11.162374
16839366	We Really Don't Know How to Compute:	We Really Don't Know How to Compute: Gerry Sussman - https://www.youtube.com/watch?v=O3tVctB_VSUZebras All the Way Down: Bryan Cantrill - https://www.youtube.com/watch?v=fE2KDzZaxvEJonathan Blow on Deep Work: Jonathan Blow - https://www.youtube.com/watch?v=4Ej_3NKA3pkSimple Made Easy: Rich Hickey - https://www.infoq.com/presentations/Simple-Made-EasyEffective Programs - 10 Years of Clojure: Rich Hickey - https://www.youtube.com/watch?v=2V1FtfBDsLU&t=845sThe Last Thing D Needs: Scott Meyers - https://www.youtube.com/watch?v=KAW	nordsieck	12.657546	-7.9064116	comment	5.0	19.0	1523738565	-11.159462
16867373	I've been learning Clojure and Cloju	I've been learning Clojure and ClojureScript in my spare time. I can honestly say that one thing that would make adoption a lot more wide-spread is a better way to include NPM modules in the project.I know that there is a new feature for it, but the documentation was a little cryptic.  Ended up just adding some CLJSJS dependencies to my project and giving up on using the NPM module I _really_ wanted to use.In the end, that could be because i'm just lazy, though.  I'd love to hear what others think on this topic.	holtalanm	12.654259	-7.862102	comment	5.0	23.0	1524059588	-11.177655
16980889	Neat!  How would you differentiate p	Neat!  How would you differentiate picolisp from say, Clojure (which also interoperates well with Java libraries).  When would you use picolisp vs Clojure?	crasch4	12.647285	-7.884918	comment	5.0	18.0	1525293167	-11.167234
17218060	Full-stack Clojure with Clojurescrip	Full-stack Clojure with Clojurescript front-end is about the fastest workflow I’ve ever used. The front-end part in particular with Reagent (a Clojurescript React library) is a very quick workflow compared to all front-end alternatives. There are perhaps more valid options for server, but even still, having the same language in both browser and server is very convenient both for reduction in cognitive dissonance and automatic transfer of language-specific data structures back and forth.Highly recommend.I should add that on both server and in browser your code base will usually be a lot smaller than most other languages, which greatly speeds workflow as well. As an example I once ported an Elm project to Clojurescript and it was a 4x reduction in lines.Using Heroku to just git push the proj	jb1991	12.643022	-7.8438525	comment	5.0	32.0	1528004126	-11.164641
17533878	I have worked on fairly large Common	I have worked on fairly large Common Lisp project (around 500k lines of actively managed code). That was the most pleasant experience in my professional life. The refactoring was easy, introduction of new features was simple and clear. I attribute it partially to language itself and partially to the team culture. We had a lot of tests BTW. After this I had quite bad experience with a Clojure project in a different company, so I am not dogmatic about lisp supremacy anymore. Still, Common Lisp definitely can be extremely successful in production given proper environment.	rusabd	12.673761	-7.8707905	comment	5.0	20.0	1531631151	-10.932035
17675191	Why are there two variations for ~> 	"Why are there two variations for ~> and ~>> ? It looks like it limits you to using only functions that take parameters in the same position.Why not have one position-independent version? Something where you can specify at every level which position you want to use, like this:    (~>>> #""foobar""
          (~> bytes-length)
          (~>> number->string 16)
          (~> string->bytes/utf-8))

But that still only limits you to first and last position. Why not use a positional special form like JavaScript has with __dirname called __var?    (~>>> #""foobar""
          (__var bytes-length)
          (number->string 16 __var)
          (__var string->bytes/utf-8))

This way you can use it no matter what functions you want. But I don't write my code in Racket so maybe this is already a solved prob"	sbjs	12.719576	-7.7668147	comment	5.0	18.0	1533241770	13.660346
17847358	Man I need to do a sudo apt upgrade 	Man I need to do a sudo apt upgrade on my brain: I read the title and thought he was talking about ELM the email client, and was like: yeah, we all stopped using that in the early 90's when zmail showed up.	pq0ak2nnd	13.01188	-7.694871	comment	5.0	17.0	1535310990	-12.796572
19098348	I've said it before and I'll say it 	I've said it before and I'll say it again, the industry can rip Clojure from my cold, dead hands. It's unfortunate that people in this thread seem to down on the language, but the only possible way I would stop using it is if I literally cannot earn income with it. It is by far the most pleasant language I've ever used, I feel at home writing it, and it improves the quality of my work.	jakebasile	12.6432295	-7.898884	comment	5.0	60.0	1549479164	-11.15582
19101976	My question for you would be, why Cl	My question for you would be, why Clojure over, say, Racket? Is it just the JVM?I personally prefer Racket because of the ease with which you can use it to hack on itself. Macros are no stranger to LISPs, but Racket goes beyond by having the entire system around it built to accommodate language design and modification.Want to use dynamic typing? Just use #lang racket. Want to use static type checking? Use #lang typed/racket. Reactive programming is there with #lang frtime. And that's before we even consider things like Scribble.As an aside, I totally agree with you on Elixir. Erlang is wonderful for what it's built for. Elixir's choice to use Ruby syntax, however, ruins Elixir for me -- and it's not because I hate Ruby. I actually like Ruby a fair deal. Instead, it's because using Ruby syn	Gene_Parmesan	12.647352	-7.8500023	comment	5.0	19.0	1549501577	13.57186
19366349	That is exactly how I always feel wh	"That is exactly how I always feel when working in Clojure. Constant ""what is this? What's in it?""You can't just say ""it's a map"". Sure, it's a map, but there's data in there I want so can you at least tell me what keys it's supposed to contain? Sadly the language has nothing to help me make up for the lack of documentation other than inspecting values at runtime inside a half-constructed program and this just doesn't feel very efficient compared to returning a defined data structure with specified properties."	mathw	12.470466	-7.812701	comment	5.0	19.0	1552380172	-11.173608
19478848	I don't have a horse in this race bu	I don't have a horse in this race but I find it interesting that in my career I've seen a lot of bad code but the worst clusterfucks I've met where all in Clojure while the community seems to be chock full of purists and in general people that takes craftmanship seriously at least at face value.¯\_(ツ)_/¯	luckydata	12.655802	-7.9032183	comment	5.0	35.0	1553462469	-11.16822
19565738	Founder here. Excited to announce Re	Founder here. Excited to announce Red Planet Labs today. I'll try my best to answer any questions here.Also want to emphasize that we're a fully distributed company, and we're hiring! If you're a strong Clojure programmer we would love to hear from you (though we're open to non-Clojure folks as well).	nathanmarz	12.659288	-7.9014974	comment	5.0	22.0	1554315206	-11.177839
19715242	After 20 years of traditional JavaSc	After 20 years of traditional JavaScript, I recently got a chance to use ClojureScript on a decent size project, it's the only way I'm ever doing JavaScript from now on. It's a beautiful way to use React, no JSX or HTML strings in site, it's all generated using the same stuff used to write application logic. Yes, there's still a lot of tooling behind it, but I very rarely had to directly deal with any of it, Leiningen does most of the work with package management and builds, and ClojureScript itself takes care of utilizing Google Closure for its dead code elimination and other optimizations, without me having to write a single ugly annotation.	kgwxd	12.657991	-7.8507857	comment	5.0	29.0	1555889892	-11.154289
19729358	I thought that Clojure was losing it	I thought that Clojure was losing its buzz in recent times. Perhaps it is that even though the core language is elegant its ecosystem of leiningen, maven for dependencies, etc, and the whole brittle emacs-cider-nrepl chain is detracting from its core strengths.And poor startup times, and unhelpful error messages (though I hear there has been some improvement in recent versions).	billfruit	12.657122	-7.9044185	comment	5.0	27.0	1556032098	-11.169781
19875162	Ask HN: Books to Learn Clojure Prope	Ask HN: Books to Learn Clojure Properly?	rntksi	12.662058	-7.8925037	story	5.0	20.0	1557464157	-11.1690445
37984387	Debugging compilers in Clojure	Debugging compilers in Clojure	jpmonettas	12.647604	-7.8980803	story	5.0	58.0	1698061960	-11.14997
38271491	I like it, and certainly much more t	"I like it, and certainly much more than java which I just can't. I have trouble committing to clojure fully for larger projects because it's still a bit niche in terms of the size of the community but nice that it interfaces with java, and for smaller one-off things I just use scheme.oh, clojure also is a little bit weird being a sort of grab-bag collection of data structures that it inherits from java and then turns lisp-ish. doesn't make it bad, each thing they add is nice, just feels a little motleyalso, i refuse to call it ""closure"", i pronounce the j"	fsckboy	12.647142	-7.8911185	comment	5.0	16.0	1700005903	-11.120185
33086849	OK but that's a 500k LOC codebase in	OK but that's a 500k LOC codebase in javascript/python that nobody understands, maybe the project doesn't even get thereeverybody hates their language when they have 100k LOC of tech debt from 8 years agoYou're right that Clojure's sequence soup problem is painful at that scale (really any scale) but have you ever debugged Java? It's barely even possible, the project needs to drive $10M+/yr revenue to just not collapse once it reaches 500k+ LOC Java, 500k XML, 300k SQL ...	dustingetz	12.649343	-7.8927	comment	5.0	23.0	1664917417	-11.188719
33089211	As the saying goes, a bad workman al	As the saying goes, a bad workman always blames his tools. You can make a mess in any language, and Clojure is no exception.There are plenty of ways to mitigate the problems the author describes. A few of these things would be having coding standards to ensure that code is written in a way everyone is comfortable with. This also covers things like adding schemas and documentation for maintainability.  Doing pairing and code reviews so that multiple developers are familiar with different parts of the codebase. Having good tests so that you can have confidence that the code does what's intended when you make changes.I'm also not sure what makes Clojure esoteric. It's a clean and well designed language that embodies good principles. It's a niche language, but far from being esoteric. I've bee	yogthos	12.658734	-7.9048166	comment	5.0	27.0	1664929326	-11.171035
33165489	Who among us is still using Elm (oth	Who among us is still using Elm (other than this company)? I thought most would have stopped after the creator's holier-than-thou attitude [0], publicly shaming critics [1], only allowing certain people (read: core contributors) to use language features without monkey patching, and generally acting like only they know how to make a good language so everyone else should just sit down and shut up [2].[0] https://news.ycombinator.com/item?id=22821447[1] https://news.ycombinator.com/item?id=22824899[2] https://news.ycombinator.com/item?id=16510267	cercatrova	13.008755	-7.693634	comment	5.0	26.0	1665506330	-12.758682
33444832	SVGs as Elm Code	SVGs as Elm Code	webwielder2	13.031643	-7.6910024	story	5.0	77.0	1667434407	-12.791904
33460587	Clojure from a Schemer's perspective	Clojure from a Schemer's perspective (2021)	pgayed	12.644031	-7.8976727	story	5.0	168.0	1667525511	-11.166002
33462354	> A quick look at the code implies t	> A quick look at the code implies that various data structures are used under the hood for what looks like one data structure in the language. That's a lot of complexity! I'm not sure that's a tradeoff I'd be happy to make. It makes it harder to reason about performance.I don't think that's true. A persistent array map is a single data structure. It's just a persistent data structure optimized for non-destructive (functional) updates. On a high-level it's not too different from finger trees which may be more famous. When I used to write Clojure, I didn't feel any need to reason about its internals for performance reasons or any other reasons. It simply feels natural.	kccqzy	12.592819	-7.856581	comment	5.0	23.0	1667537523	-11.1606
33465989	Clojure is a nice well thought out l	Clojure is a nice well thought out language, I wish it wasn't on the JVM.	weatherlight	12.644041	-7.891129	comment	5.0	25.0	1667567279	-11.149223
33829913	Are you basically saying that I can 	"Are you basically saying that I can build my front end using clojure?I really want to learn clojure and use flutter for a personal project... are there are any reasons not go down this path? (E.g. the ""official"" implementation of flutter is more secure?, etc.)Thank you for the cool project"	FailMore	12.602636	-7.9557056	comment	5.0	15.0	1669986059	-13.849906
35248260	As a Clojure programmer, I don't car	As a Clojure programmer, I don't care about any of the Java language features or improvements, but I'm super happy that I'm getting a state of the art JVM that is continuously developed, maintained, extended and optimized, over a time scale of decades.This is incredibly useful: having a good VM to run your code in, with good modern garbage collectors, is not an obvious thing (as many other languages have learned).This is not the LTS release, so I won't be switching to it, but I'm looking forward to the next LTS.	jwr	12.505611	-7.72464	comment	5.0	32.0	1679415139	-11.166566
28036496	One thing I don't like about all art	One thing I don't like about all articles on clojure is that basically all of them say: ah, it's just like lisp with lists `(an (example of) (a list))` with vectors `[1 2 3]` thrown in. So easy!But then you get to Clojure proper, and you run into additional syntax that either convention or functions/macros that look like additional syntax.Ok, granted, -> and ->> are easy to reason about (though they look like additional syntax).But then there's entirely ungooglable ^ that I see in code from time to time. Or the convention (?) that call methods on Java code (?) with a `.-`Or atoms defined with @ and dereferenced with *Or the { :key value } structureThere's way more syntax (or things that can be perceived as syntax, especially to beginners) in Clojure than the articles pretend there is.    (	dmitriid	12.629349	-7.8892097	comment	5.0	36.0	1627912300	-11.108586
28036620	Single engineers will pick clojure a	Single engineers will pick clojure at companies , build a project in it, later that engineer will move on, now nobody can maintain this code so it’s rewritten in some normal language. I’ve seen that happen a few times. That code is hard to read and understand. This is why clojure will remain niche.	ronnier	12.65475	-7.9033294	comment	5.0	23.0	1627912856	-11.1840315
28406522	You see, I'd like to write more of m	You see, I'd like to write more of my software in Clojure (or any functionally inclined Lisp). If there was a really good interop story with a non-gc:d native lang I could do more of it.Clojure is a hosted language, so hosting it on C++ (or Rust etc.) would be sweet for me personally. Also, I like compiler projects.	vnorilo	12.651243	-7.8806453	comment	5.0	16.0	1630687599	-11.106927
12586739	I guess I don't understand what the 	I guess I don't understand what the big deal is with tail call optimization.  Could someone give an example where it really shines and clojure's loop/recur just doesn't?If you are looking to put time into a programming language that is interesting in and of itself, I'd suggest Haskell.	DigitalJack	12.4376135	-7.7807717	comment	5.0	31.0	1474935933	-11.10255
12678041	Maybe a Clojure equivalent to NPM's 	"Maybe a Clojure equivalent to NPM's ""devDependencies"" can manage something like this, so that it gets excluded from the final deployment JAR. It's been a while since I'd done Java/JVM development, but the dev-time vs. deploy-time dependencies configuration should be possible, I would think."	tunaoftheland	12.648289	-7.8755846	comment	5.0	17.0	1476116708	-11.162816
12787166	Clojure. Before learning Clojure, I 	Clojure. Before learning Clojure, I didn't even have a career. I just wanted to get into software development.But at the time, all I knew was a bit of Python. And while I could've learned Java, I figured that being yet another Java programmer in the marketplace, but with no experience and a liberal arts degree, was probably going to get me nowhere.So I decided I had to learn something emerging. Something where there was nascent demand but not much supply. I chose Clojure because it looked weird, and all these bright people were talking about how great it is. I invested a couple of months learning it deeply, open-sourcing my side projects, and blogging about it. I also spent that time learning non-programming fundamentals.When I felt I was ready, I started reaching out to people in the comm	votr	12.657573	-7.896641	comment	5.0	32.0	1477397247	-11.131537
13136239	Naga: Datalog-based rules engine in 	Naga: Datalog-based rules engine in Clojure	espeed	12.660699	-7.881148	story	5.0	87.0	1481250800	-11.176268
13137119	"""This turns Clojure into a scripting"	"""This turns Clojure into a scripting language much like Python, Ruby, Perl, or Bash"" would be if you added a sleep(45) to the beginning of every script you wrote with them. All the latency of a compiled language with all the bugs of dynamic one. :)I'm (mostly) kidding...I want to like clojure. I've always had a soft spot in my heart for lisp, and clojure seems to be the best contender for hitting the right balance between the classic ""no syntax at all, just more parens"" and various more modern takes on ""It's lisp, but with our own weird syntax bits layered on."" Unfortunately the JVM'ness of it has shown through so much as to kind of turn me off. (Not least of all the overhead of starting a JVM to do anything.)"	abeyer	12.653458	-7.8864856	comment	5.0	24.0	1481265603	-11.092093
13183585	Clojure is not just a Lisp on the JV	Clojure is not just a Lisp on the JVM. Clojure is a Lisp but also much more: Readable persistent vectors, hash maps, and sets. Protocols, records, and anonymous (reified) instances of protocols/interfaces. Sequences as a common unifying and extensible abstraction for iteration. Transients, transducers, multimethods with ad-hoc and extensible hierarchies. Namespaces and vars with metadata. Atoms, Agents, Refs, and the STM. Reducers and fork-join. AOT compilation to Java bytecode along with dynamic loading of any code. Now clojure.spec and more, and this is just stuff built into the language.	adrianm	12.645514	-7.878758	comment	5.0	62.0	1481796817	-11.045046
13203785	I'm a big fan of Scheme/CL but I fin	I'm a big fan of Scheme/CL but I find development in ClojureScript to be quite frustrating. If anyone has some solutions I'd LOVE to hear them; while es6 is great I'd still prefer a more lispy language.My major gripe is with debugging, when I'm writing es6 it's really easy to set a breakpoint and modify a function half way through execution. Or half finish a program and then play around with completions in the REPL to explore a problem. Sometimes I'll be traversing a complex data structure and I'll write an empty loop with just a breakpoint. I can then run the code and work through things in a concrete state and once I've got things working bringing the code back into my codebase.When I write in any compile-to-js language I always run into the same problem where once I'm in browser I have 	errantspark	12.646134	-7.8656225	comment	5.0	15.0	1482023714	-11.144507
13213918	Proto REPL, a New Clojure Developmen	Proto REPL, a New Clojure Development and Visualization Tool [video]	tosh	12.652243	-7.8981123	story	5.0	129.0	1482173739	-11.170896
13283196	One issue with Clojure is that it co	One issue with Clojure is that it comes with strong opinions (STM, immutable data structures, JVM-Java ecosystem) and thus is not as paradigm-enclosing as other Lisps (e.g. Common Lisp).I'd much rather have SBCL's native code compiler, read/compiler macros, conditions and restarts (that I end up using on pretty much every project) and optionally use libraries for immutability and STM (if and when I need them), than compromise from the get-go and use a language that reduces the set of available options by forcing its specific worldview.If I do need a strong focus on concurrency, I find Erlang (and also Elixir) a much more coherent solution. The cognitive dissonance that comes from having to interact with Java when using Clojure is very damaging and it can't be abstracted away. Just look at 	armitron	12.642252	-7.8830805	comment	5.0	21.0	1483084858	-11.138803
13284449	I tried and really wanted to like Cl	"I tried and really wanted to like Clojure, but I hated the error messages.  I love how it's a lisp, I love how you write programs in it, I love the REPL, it all just feels nice to me.... until I miskey something or make some other error.  Then the compiler seems to hate me personally.""Here's a haystack where the error /might/ be, have fun finding the needle dipshit.""  Maybe I'm just spoiled with Elm, Rust, and Elixir's error messages, but the last time I tried Clojure (more than a year ago) I just hit a wall when I tried to make a toy app, as the Clojure compiler seems to hate me even more than C's compiler does.Has this situation improved?  If so, I'd love to take another stab at it."	twoquestions	12.650869	-7.9081464	comment	5.0	38.0	1483107550	-11.17651
13349795	STM and concurrency...sure those are	"STM and concurrency...sure those are ""aspects"" of Clojure, Clojure's biggest strength is that it's data-centric. The vast majority of the language is focused around manipulating hashmaps, vectors, sequences, etc, and do that in an efficient way. All the concurrency stuff is just icing.So I really have to sit back and shake my head when the author says he's going to be as good as Clojure, then goes off into the weeds with custom syntax, STM and actors. Really? Why actors?This would have been a much better article if it just left Clojure out of the discussion since whenever the author talks about the language he's mostly wrong.And as always, lies, damn lies, and benchmarks: https://benchmarksgame.alioth.debian.org/u64q/compare.php?la... If you're going to use a phrase like ""faster"", at least"	_halgari	12.639909	-7.8922915	comment	5.0	26.0	1483885797	-11.162545
13420738	> If you like Clojure, but are unhap	> If you like Clojure, but are unhappy with the start-up time, or if you want something outside of the JVM ecosystem, then Pixie may be for youYES! :D	spraak	12.649477	-7.9023533	comment	5.0	29.0	1484683988	-11.179036
13451677	Isn't Javascript is the most-used fu	"Isn't Javascript is the most-used functional language that compiles to Javascript?> [Javascript is] a multi-paradigm language, supporting object-oriented, imperative, and functional programming styles https://en.wikipedia.org/wiki/JavaScriptThe author must have a very particular idea what ""functional"" means to include Clojure but not JS. That's fine, though it'd be enlightening if he shared it."	paulddraper	12.589808	-7.773585	comment	5.0	21.0	1485027630	-11.1697035
13543848	Start-up times are still an issue wi	Start-up times are still an issue with Clojure on the JVM. For instance with Android I've found the initialization times to be pretty much a show-stopper for any application development.	vvanders	12.560529	-7.758013	comment	5.0	18.0	1485976096	5.9053636
13592096	I think some of your frustrations mi	I think some of your frustrations might stem from your workflow. You really have to use the REPL to get the most out of Clojure development.For example, you should never change a bunch of code in different files and then try to run it and hope it works. Clojure workflow would be to change a particular function, send it to the REPL, see that it does what you want, then change the next function, and so on.ClojureScript equivalents to GraphQL would be Om Next http://hueypetersen.com/posts/2016/02/13/om-next-from-a-rela... and and Posh with Reagent https://github.com/mpdairy/posh It's the same concept expressed in a Clojure idiomatic way.I would highly recommend using Vim fireplace, Cursive, or Atom to start learning Clojure. Emacs is a very complex editor that takes a lot of time investment t	yogthos	12.648461	-7.888553	comment	5.0	23.0	1486496915	-11.175448
27627764	Clojure. Is a complex language but i	Clojure. Is a complex language but it seems really speeding up your programming when you learn how to use it properly. And the community is really addicted to it.	elias94	12.6482115	-7.8943267	comment	5.0	16.0	1624602881	-11.176114
27700626	What's the story behind clojure.core	"What's the story behind clojure.core/read-string? I have always wondered why it executes code. There are some examples in the docs:
https://clojuredocs.org/clojure.core/read-string"	ollran	12.646644	-7.9055066	comment	5.0	19.0	1625155658	10.97224
27784705	I haven't felt the need for static t	I haven't felt the need for static typing in Clojure at all. I don't understand, why people are so dogmatic about static typing. In my experience and other on the team share it too, static types really haven't (or wouldn't have) prevented any bugs. What is more important are good names for variables/ references/ functions, code that just speaks to you or is at least sufficiently clear, up-to-date and clear documentation with examples and links if needed and efficient testing/ sensible test coverage. If I really need to know the type of something, I can always use (type <something>) or more concrete e.g (string? <something>) if I want to use that information for something. If I don't know, how to use the function, I have to improve the name, the documentation and my understanding of the cod	kaliszad	12.494355	-7.843855	comment	5.0	25.0	1625844662	-11.128428
27784069	Best Programming languages todayF# -	Best Programming languages todayF# - ML + .NetClojure - Java + jvm + lispRust/OCaml - System ProgrammingBoth F# and Clojure give you access to probably the two biggest ecosystems, but they are obviously put them at opposite ends of the programming paradigms spectrum, but this makes learning both less redundantRust and OCaml, are probably what you should use if you want a compiled system languageHonorable mention PureScript, because haskell + Javascript (but F# will take you close and is more practical)	systems	12.370722	-7.7415924	comment	5.0	60.0	1625841292	-11.049179
27867090	Having worked with both to create th	Having worked with both to create the same system (building a game server) I've found Clojure actually sits better with the functional thinking style (1 data structure, 100 functions).While Phoenix was the killer app for Elixir, and Elixir has far superior readability (using the Ruby syntax); there were couple of things that were off-putting and I struggled with them.1. everything is inside a module was an unnecessary distraction2. And then the separation between anonymous and named functions simply were unnecessary3. And that I would have to declare the data / record inside a module (??)Elixir felt like a functional language un-necessarily trying to look like a class based language.I sometimes feel that had Elixir had only supported functions outside of modules... oh that freedom.But some	kopos	12.649114	-7.762937	comment	5.0	29.0	1626541025	12.883418
27897590	I've tried deps several times, but I	"I've tried deps several times, but I keep coming back to leiningen. Can anyone explain the advantage of using deps to me?What I want from a build tool is: manage dependencies, starting a repl, running tests, and building a jar.
Leiningen provides me this: lein repl, lein test, lein uberjar. Simple and exactly what I need, and importantly: i can expect that all leiningen projects use the same commands.Deps can be made to do all these things, and more, but you need to configure it.
Which test runner should I use for tests? Which library should I use to build an uberjar? 
Since it's all configurable, I risk that every deps project gets it's own special snowflake build setup, and I need to spend time avoiding this.Until deps gets a standard way for building and testing, i'm sticking to leining"	synthc	12.630379	-7.84705	comment	5.0	34.0	1626806781	4.4047894
12134971	But the problem is you really do nee	"But the problem is you really do need a ""paredit"" for your editor when developing in Clojure. It's a double whammy for beginners, and a huge one at that. Pretty much every other language ever is perfectly editable in everyone's editor as it exists today."	city41	12.653421	-7.89756	comment	5.0	16.0	1469079536	-11.111506
12158839	As a Clojure fan, I tried using this	"As a Clojure fan, I tried using this, but I got the impression it has learned next to nothing from Clojure, so I ended up going with Elixir instead.Particularly:- No data structure literals (?) - (except e.g., '(1 2 3) for lists)- Manual module exports, instead of just having 2 versions of def- Other small syntactic annoyances, like plain parens everywhere, instead of brackets in some cases like Clojure, and atoms (like keywords in clojure) started with ""'"" rather than "":"""	i_s	12.61511	-7.871965	comment	5.0	22.0	1469456454	-11.127284
12190875	How I wish for a lisp like Clojure w	How I wish for a lisp like Clojure with a type system like Haskell...Hope core.typed will be that!	hkjgkjy	12.485548	-7.825223	comment	5.0	16.0	1469836025	-11.148235
12231333	When I started using Clojure, the fi	When I started using Clojure, the first two weeks were mess. I was trying to fit everything in procedural way of thinking and boy was it a mess. I felt really miserable and maybe that is how it felt when I first started to walk. And then suddenly everything clicked and the world was beautiful.Clojure has a steep learning curve when you start. After about a year and a half there is another much steeper curve and if you cross it, I have heard it feels like you have super powers. I am probably 4/10 on Clojure and 9.5/10 on Java. However I take around 10% of time to get better results with Clojure vs Java.I can try taking a shot at listing why I love Clojure however for me it is as difficult as explaining why I love someone:1. Computers are functional. You give them a massive subroutine and th	timewarrior	12.650051	-7.8961186	comment	5.0	24.0	1470395368	-11.1540985
12361348	Interactive Guide to Tetris in Cloju	Interactive Guide to Tetris in ClojureScript	doppp	12.6511965	-7.88914	story	5.0	39.0	1472150446	-11.166553
22380468	Some people say that their organizat	Some people say that their organization have 100+ people using clojure? Where?	gdsdfe	12.653931	-7.904894	comment	5.0	18.0	1582251950	-11.18547
22380814	It's really unfortunate that the Clo	It's really unfortunate that the Clojurians Slack, being free, lacks good history. So much knowledge is disappearing, or at least becoming inaccessible (I'm sure someone has logs, probably via alternative clients or bots).Hard to move a community though.	lvh	12.659992	-7.9018564	comment	5.0	18.0	1582257131	-11.173386
22382005	>I love working with Clojure and I f	>I love working with Clojure and I find a large benefit in my understanding of the JVM.Reliance on the Java ecosystem has been the biggest issue for me in trying to use Clojure. I love many things about the language, but I have zero experience with Java or the JVM. A number of my attempts at using Clojure for a project have been hindered by my lack of understanding of the underlying runtime and the tools. In a way, it almost feels like Clojure simply isn't for me.On the other hand, I've had much more luck with ClojureScript, which I'll happily use over JS any day, though the build system still occasionally mystifies me.	arc-in-space	12.646289	-7.8859963	comment	5.0	25.0	1582278142	-11.160679
22459518	Thats last few sentences make no sen	Thats last few sentences make no sense. The argument is that uptake is stunted by the JVM's slow startup time, making it unsuitable for commandline utils or desktop apps. However thats easily fixed which was never more hillariously stated than when Rich Hickey did it a decade ago. A blogpost went viral and it was a thunderous critique of Clojure, focused on this single point of slow start up. In the comment section was only 1 reply from Rich:time java -client -jar clojure.jar helloworld.clj> system time 0.0001sThe -client param makes all the difference :)	lbj	12.600247	-7.830182	comment	5.0	22.0	1583098365	5.841263
22460758	The dealbreakers with Clojure for me	"The dealbreakers with Clojure for me are:1. Weirdly irregular syntax.2. Java import statements and Java error backtraces anywhere you want to do real work.3. Inexcusable renaming and name collisions on basic Lisp functions.It's much, much less of a Lisp than Scheme and neither ""but it's properly functional"" nor ""we fixed the tooling now"" make that any less true or the language any more interesting for the use cases of using a Lisp or targeting the JVM with a more expressive language."	yarrel	12.64615	-7.8871794	comment	5.0	15.0	1583112170	-11.130886
22461252	Clojure seems like an odd choice for	Clojure seems like an odd choice for command line tools. I can see why a committed Clojure programmer would want to reuse their existing skills for a slightly mismatching domain. But Rust/Go (even C) would seem like a more obvious choice if you weren't setting off from Clojure as a starting point.	crispinb	12.64674	-7.9016867	comment	5.0	19.0	1583117865	-11.184361
22461690	I think you are omitting the main re	I think you are omitting the main reason why Clojure never succeeded: it's dynamically typed at the core.It's on the wrong side of history in that respect.I know it's trying very hard to catch up to statically typed languages now by retrofitting some type system, but it's too little, too late.Static types are where the current state of the art is, and we're not going back. Clojure missed that train and will never catch it now.	hota_mazi	12.584518	-7.876784	comment	5.0	51.0	1583123621	-11.146119
22523651	REPL is a killer Clojure feature tha	REPL is a killer Clojure feature that nobody (outside the ecosystem) talks about.Probably it's hard to comprehend what developing in a REPL feels like, majorly because no other commercial language has a REPL as powerful as Clojure.I gave a talk[1] explaining the REPL and most people in the audience (including senior Java, C# and Python developers) had never seen something like that before.REPL is the reason why I (and perhaps other Clojure devs) endure the pain around Clojure tooling, demand, supply and ecosystem in general.[1] https://www.youtube.com/watch?v=Bs44qdAX5yo	shivekkhurana	12.625232	-7.8650327	comment	5.0	50.0	1583739563	-11.11747
22523888	I think the major difference between	I think the major difference between the Clojure REPL experience and most other language's REPLs that I've worked with is the fact that Clojure REPLs can connect to a running stateful system (or a situated program as Rich Hickey coined it), and allows you to explore and manipulate the system's state and behavior dynamically at runtime, which makes it an incredibly powerful tool for building and debugging such a system.Most REPLs I've used in other languages are strictly for evaluating individual commands in an isolated, stateless manner.	ss3000	12.624594	-7.865895	comment	5.0	20.0	1583742858	-11.080896
22679361	I've heard so many things about Cloj	I've heard so many things about Clojure. I am a CS student with some experience in the most used languages (JS, java, python). Can someone explain in simple cs terms why Clojure is sooo hyped? What can I do with this language that would be harder with other languages? From what I've gathered it's used in data wrangling and manipulation in general but most data-oriented tools are written in Python.	yagodragon	12.646888	-7.8915186	comment	5.0	17.0	1585086196	-11.148073
22694620	I'm surprised Clojure isn't in the l	I'm surprised Clojure isn't in the list either.Edit: To clarify, Clojure is mostly a dead language that didn't have any innovations by itself, but it did influenced many programmers(the creator is good at marketing). It helped push forward the FP mindset into the users of other mainstream languages(js, python, java).	Scarbutt	12.654501	-7.8949385	comment	5.0	18.0	1585237162	-11.161688
22823074	Arrogant is the most accurate word t	Arrogant is the most accurate word to describe Elm and its leadership. I tried to use Elm in production between 0.14 and 0.18 versions and it was fun and mind expanding experience. I'm truly grateful that I've used it because it introduced a lot of functional stuff to me. But I no longer use it myself or recommend it for any serious work.Breaking changes were negligible in the beginning. But I got fed up with rewriting the app after the 3rd Elm upgrade. I think it's irresponsible to advertise the language to be used in production and break it every fucking year. Speeches about finding the perfect solution are great for academical discussions and toy languages, but you can't just remove the stuff that your community uses without offering any alternative. It all stems from the arrogance and 	scarfacedeb	13.007514	-7.692673	comment	5.0	49.0	1586443849	-12.762449
22842518	> It's not Clojure-deadWhat does thi	> It's not Clojure-deadWhat does this mean? I thought Clojure has a dedicated, if small, user base.	_bxg1	12.646076	-7.898653	comment	5.0	25.0	1586622979	-11.16288
23056939	I think that's focusing on the non-u	I think that's focusing on the non-unique parts of Clojure. Clojure was a product of the 2000s, a generation of interop-focused FP languages (Scala, F#, and Clojure foremost among them) that were deeply influenced by the functional programming languages of the 90s (mainly thinking of Haskell and OCaml here). Immutability and FP are not the new things that Clojure brought to the table. While Clojure transients are a fascinating tool and derived from its implementation of immutable data structures, otherwise its immutable data structures are roughly in the same ballpark as other languages. And parameter ordering is something that I think Rich has walked back occasionally (I remember a talk at some point where he talked about his skepticism of the entire idea of parameter ordering vs just nam	dwohnitmok	12.637091	-7.884212	comment	5.0	21.0	1588481640	-11.139184
23069155	If any of you need motivation to go 	If any of you need motivation to go and learn it! Please do it! You will never regret invest time in clojure.Agree that Clojure is a good language to learn. If you plan to use it beyond educational purposes though, expect to hit many walls when/if you plan to write real world apps with it. The foundations are there but the ecosystem isn't. Someone will mention the Java libraries, but at that point you are not really writing Clojure. Also, be prepared to deal with the cultish obsession of the community. They have very strong opinions but will never elaborate.	Scarbutt	12.65375	-7.8984094	comment	5.0	32.0	1588606047	-11.161388
23165257	What I like in Janet (I'm just a noo	What I like in Janet (I'm just a noob so take this comment with a grain of salt as it will sound superficial):- Easy to get started: one click install, great website and concise docs. No matter what some people say, getting started in Clojure is a nightmare.- Lightweight and fresh. No JVM, no Node.- Freedom and expressivity. Mutable or immutable data structures, ultimately is up to me. It might bite me down the road but for now it feels great.	galfarragem	12.655725	-7.9016137	comment	5.0	77.0	1589364086	-11.156907
23165539	> No matter what some people say, ge	> No matter what some people say, getting started in Clojure is a nightmare.You just need Java installed on your system, then you install clojure (via brew, or sh install) and that's it, you're good to go.I've written a guide to starting with Clojure covering installation to REPL & IDE configuration: https://grison.me/2020/04/04/starting-with-clojure/	flaie	12.658127	-7.9004207	comment	5.0	42.0	1589366723	-11.172872
26638293	Serious question: is Clojure worth g	Serious question: is Clojure worth getting sucked into the complicated/verbose/nested Java ecosystem? I've avoided Clojure to avoid Java. Lately digging Rust...	bionhoward	12.648803	-7.8992724	comment	5.0	15.0	1617128573	-11.165465
26713329	ClojureScript 1.10.844	ClojureScript 1.10.844	tosh	12.653402	-7.902158	story	5.0	178.0	1617724133	-11.174293
26721901	I have no hands-on experience with C	I have no hands-on experience with Clojure but it always appears to me that the language manages to get even complex computations done in relatively little code. This is because Clojure offers powerful abstractions, and this contributes to getting things done rather quickly once you've found the right way of representing data.However, it also makes me wonder if this advantage for writing code might later on turn into a shortcoming for reading, i.e., understanding code - either someone else's or your own code six months later.Complex computations that are highly compressed through the use of powerful abstractions seem to lean towards puzzle solving when you're trying to understand code that you're not already familiar with. Am I wrong?You mention Python and Java at the end of your post, and	kleiba	12.642241	-7.8962555	comment	5.0	23.0	1617784429	-11.138734
26852309	Show HN: Farolero – Common Lisp styl	Show HN: Farolero – Common Lisp style-conditions and restarts for Clojure	suskeyhose	12.651875	-7.893534	story	5.0	150.0	1618752870	-11.1062355
27060507	Both of you miss the most obvious di	"Both of you miss the most obvious difference between Clojure and all mainstream languages: it's a lisp.I've had so many programmers look at code I write and proclaim: ""wow that looks impossible because of the parenthesis"" and that would never touch anything like it because it seems so different.Some people do take the time to learn how it works, but many just have a knee-jerk reaction to it and then forget about the language itself."	capableweb	12.65137	-7.8977423	comment	5.0	40.0	1620289757	-11.113618
27060846	I really like Clojure and I'm glad i	"I really like Clojure and I'm glad it is around, but I'll prefer something with strong types any day.From the article I see a lot f reasons why:> ""Don't break things!"" is part of the culture.If you cannot have compile time guarantees on correctness, the discipline to not break things becomes a key feature. On the other hand, if you have strong correctness guarantees, you may more easily incur some breakage (and thus actually fix things).> Some discipline required [...] with great freedom comes great responsibility.There's always some discipline required, but without a type system discipline become more important.> you often need to find specific places where a function or a piece of data is referenced [which is hard in Clojure] because there are no links established via a type system.Yups."	cies	12.580666	-7.8693213	comment	5.0	22.0	1620292924	-11.150436
27129301	Rust was inspired by Elm, if I’m not	Rust was inspired by Elm, if I’m not much mistaken.	Skinney	12.867827	-7.7267733	comment	5.0	19.0	1620821041	-12.754771
27198303	Honestly, why not just use Clojuresc	Honestly, why not just use Clojurescript if that's where the inspiration came from? With Clojurescript/re-frame you don't have to think about which of the myriad useX inventions apply to your app. Every couple of years React seems to be throwing-out more clutter (hooks, forms) just to get a bit closer to what Clojurescript + re-frame has had for years.	cutler	12.706527	-7.7381806	comment	5.0	30.0	1621359831	-11.185682
27334196	Clojure goes against so many of lisp	"Clojure goes against so many of lisp's timeless philosophies and principles that it can hardly be described as a lisp.When someone says ""lisp is the greatest programming language"" it's these principles that they refer to, most of which Clojure discards so it can play nice with Java and promote very specialized ways of solving problems in order to best fit a particular niche.The best way to discover the essence of lisp is to read SICP and learn Scheme."	creamytaco	12.661935	-7.886453	comment	5.0	15.0	1622390854	-11.05252
27363028	For anyone who finds this topic inte	For anyone who finds this topic interesting, you might be interested in the following resources:http://minikanren.org/The second edition of `The Reasoned Schemer` (MIT Press, 2018):https://mitpress.mit.edu/books/reasoned-schemer-second-editi...The Clojure/conj 2016 talk Greg Rosenblatt and I gave on Barliman:https://www.youtube.com/watch?v=er_lLvkklsk`A Unified Approach to Solving Seven Programming Problems (Functional Pearl)`, William E. Byrd, Michael Ballantyne, Gregory Rosenblatt, Matthew Might (ICFP 2017) (Open Access):https://dl.acm.org/doi/10.1145/3110252and the related talk:https://www.youtube.com/watch?v=o3AHnyEf7IE</a	will_byrd	12.62768	-7.8893275	comment	5.0	26.0	1622591932	-11.1424
27387096	What I heard from colleagues that wo	What I heard from colleagues that work with Clojure is that it is a horrible language where the default way of writing code is an imperative programming style where contexts are passed around and updated. Far from the concepts of functional programming.	AtNightWeCode	12.629716	-7.888937	comment	5.0	37.0	1622753365	-11.153526
14928593	When you say it works across Java/Ja	When you say it works across Java/JavaScript - could you expand? Can I essentially write Clojure that compiles to JavaScript?	hsx	12.6556	-7.878489	comment	5.0	15.0	1501854465	-11.17024
14928673	Clojure is the language where LISP c	"Clojure is the language where LISP clicked for me. Can't recommend it enough, it's got all of it - immutable datastructures, convenient data literals, simple and composable concurrency primitives, very thin interface to host VM.Just put enough effort to get beyond that ""omg parenthesis"" barrier and it will be a delight. It's like that Half-life joke: there are two kinds of people, those that finished Half-life many times and those that never got off the train (which as somebody will probably point out, is a variation on another joke, but you get the idea).totally unaffiliated: https://www.braveclojure.com/clojure-for-the-brave-and-true/"	keymone	12.645942	-7.895203	comment	5.0	47.0	1501855101	-11.168787
14956187	Curious what IDE you have set up to 	Curious what IDE you have set up to do the REPL driven development you mentioned? I'm just starting out in learning Clojure and am finding various options out there with vigorous proponents of each. I am wondering what someone's real-world experience is after 5 years.It's hard sometimes to find the editors/IDEs that might suite one particularly well since the vast community is attached to a given platform.	vturner	12.64513	-7.887616	comment	5.0	18.0	1502186815	-11.125771
15089373	Clojure Concurrency (2008) [video]	Clojure Concurrency (2008) [video]	tosh	12.631924	-7.8957376	story	5.0	76.0	1503576399	-11.170527
15091970	I recently built a side project that	I recently built a side project that utilized core.async. My thoughts on it are that the use of go-style channels combined with immutable data structures makes for a really nice experience when reading and writing code.My main problem was with the frustrating debugging experience: Clojure is so concise that breakpoints can be difficult to place, and macros are almost completely off limits. On top of that, figuring out which part of the code would pick up after blocking on a channel was just tiresome. These are the main reasons I decided not to continue with Clojure personally.	hacker_9	12.532749	-7.868157	comment	5.0	15.0	1503594809	-11.149491
15104568	Agree whole heartedly!That's why my 	Agree whole heartedly!That's why my favorite language is Clojure. That interactivity, instant feedback, seeing the program running as you are tweeking it, its a bliss to use and it creates better more functional software.Imagine playing music as you hear it when trying to come up with a good melody. Now imagine not playing it, but composing it on music sheets instead, and occasionaly playing what you've got every 10 to 30 minutes.Lisp championed interactivity, it invented dynamic programming for that sole purpose. The idea is that you morph a running program into shape, molding it like you would clay.The first thing you do when writing in a Lisp like Clojure is run your program. In most other languages, running your program happens much later, and much less frequently, and it can actually 	didibus	12.627037	-7.848244	comment	5.0	32.0	1503734787	-11.050481
15148333	everybody who feels so strongly abou	"everybody who feels so strongly about separation of code from templates - do you realize that down there it's still just bunch of string concat calls? it's literally what ERB templates in Ruby compile to, and similarly in literally every other template language.rather than focusing on ""omg html in my js"" you should focus on ""omg presentation code in my business logic code"" because that's when you realize where the real boundary is.it's one of the reasons i love clojurescript's hiccup so much - i'm still clearly writing idiomatic clojure code but now the boundary is not some arbitrary ""this file is named .html and this .js"", but actual namespaces/functions, where it's obvious from scope and signature what data my templates depend on."	keymone	12.664854	-7.8623962	comment	5.0	27.0	1504274259	-11.158124
15200220	You can say that something is a floa	"You can say that something is a floating point number (a type) but what if that something must be between zero and one? A type can't tell you that.Typing has its place but the idea that it catches all bugs at compile time certainly isn't true; the cycle of running the app itself, running its tests, is just as important for statically-typed code as dynamically typed.Languages that have a sophisticated contract system* (like Clojure's Clojure.spec library) have a bit of a leg up in my opinion. You can much more precisely explain and control and test for the specifics of all values flowing through your system well beyond merely what type they are.--
* Clojure's devs don't refer to spec as a contract system because it is quite a bit more versatile than that, and some are actually using it for "	hellofunk	12.494496	-7.8454027	comment	5.0	33.0	1504879539	-11.147541
15268563	I tried some quick tests using a ful	"I tried some quick tests using a fully AOT, short-running thing we run in house. Here the cost is the set-up of JVM and loading of Clojure stuff (CentOS 7 Vagrant VM on my Mac).J9:time ./jdk-9+181/bin/java -client -jar l2i-0.1.0-SNAPSHOT-standalone.jarreal	0m1.987s
user	0m3.383s
sys	0m0.161stime ./jdk-9+181/bin/java -server -jar l2i-0.1.0-SNAPSHOT-standalone.jarreal	0m2.949s
user	0m5.452s
sys	0m0.167sOpenJDK 8:[root@localhost ~]# time java -server -jar l2i-0.1.0-SNAPSHOT-standalone.jarreal	0m1.545s
user	0m2.510s
sys	0m0.175stime java -client -jar l2i-0.1.0-SNAPSHOT-standalone.jarreal	0m1.456s
user	0m2.309s
sys	0m0.182s----For whatever it means, this is a repeated execution of 10 runs together for J9:real	0m17.341s
user	0m26.783s
sys	0m1.344sAnd this is the same thing for openjdk version ""1"	kimi	12.631315	-7.884996	comment	5.0	19.0	1505631711	-11.142172
15464773	I submitted this link before I had w	"I submitted this link before I had watched the whole thing. As someone who has only dabbled in Clojure I think there are a lot of interesting ideas in there but found the type-system bashing pretty off-putting.I am now watching his ""Simple Made Easy"" talk [1] after I have heard it recommended on a few functional programming related podcasts. Again really interesting stuff but I encountered another cheap shot at typed functional programming (""You can't use monads for that! Hurr hurr hurr"").Given how well received these talks seem to be by people that enjoy programming with advanced type systems I would have have really expected a more balanced discussion and some acknowledgement of the trade-offs between dynamic and statically typed functional programming.[1]: https://www.infoq.com/presenta"	kasbah	12.393885	-7.813845	comment	5.0	30.0	1507895180	-11.110041
15526165	When I have to write something compu	When I have to write something computationally complex in the language my employer wants me to write it in, I first write it in Clojure because it's easier to think about the problem in that language. Then I translate that.I'm willing to bet that any dev who has learned Clojure does the same thing. If I'm right, that's a huge indictment of what we've been doing for the last 60 years in programming.	nickbauman	12.636527	-7.8921437	comment	5.0	25.0	1508670026	-11.151396
15606986	Compiling ClojureScript Projects Wit	Compiling ClojureScript Projects Without the JVM	ghosthamlet	12.645867	-7.874991	story	5.0	57.0	1509584615	-11.167341
28831384	I feel like Clojure companies should	I feel like Clojure companies should be on here too as it is very much a LISP	stelcodes	12.661374	-7.8874664	comment	5.0	31.0	1633977303	-11.083947
28907742	I’ve done everything from Haskell to	I’ve done everything from Haskell to Java and I still strongly prefer Clojure and Common Lisp-style dynamic types.	fiddlerwoaroof	12.420455	-7.8006387	comment	5.0	40.0	1634576376	-11.137354
28923065	Maybe I'm biased, but I'm often skep	Maybe I'm biased, but I'm often skeptical of the benefits of projects like this that translate a language which normally targets runtime A, into another language that targets a wildly different runtime B (usually JS or WASM)(Disclaimer that I'm not talking about compiling runtime-less languages for different platforms)It just seems like it's going to be a very leaky abstraction, like there will be tons of corner cases where some behavior isn't exactly the same and other behavior isn't quite possible, which will cause libraries and in-house code alike to break in weird ways. I know that ClojureScript, for example, has several caveats relative to Clojure; and most of these translators are not nearly as mainstream (and so don't get nearly as much maintenance attention) as ClojureScript does. 	brundolf	12.647248	-7.8874288	comment	5.0	26.0	1634674109	-11.152035
29202851	> However, working with Clojure and 	> However, working with Clojure and Scheme, I understand the power of repl driven development that is difficult to explain outside the experience of it.The only lisp I've dabbled with was Racket and I found the repl driven development to be a frustrating necessity. I would spend a lot of time trying to figure out the actual type of the thing that I a given function (even a stdlib function) needed, and futzing around in the repl seemed to be the fastest way to do it, but it was still quite slow.It reminded me a lot of my extensive experience with Python where things that are easy in, say, Go, are quite hard. People rave about their repl, but it feels like they're comparing it to a script iteration loop rather than static analysis tooling.That said, I completely buy the argument that Python'	throwaway894345	12.520474	-7.746218	comment	5.0	60.0	1636741840	-10.942571
29217327	I have ~8 months of Clojure experien	I have ~8 months of Clojure experience and ~3 years of F#. Clojure's REPL and feedback loop is bloody marvelous. F# also has a REPL, but it doesn't compare. However I still prefer F#'s type-safety. (I believe) a key part of how Clojure's REPL works is by compiling top level forms into JVM instructions which it puts into global mutable scope. Clojure can run on the CLR, so it seems this should be possible with F# as well. It would be cool if F# could temporarily bypass type-safety to quickly iterate on a module before plugging it back into the rest of an assembly and re-enabling type safety. There's no reason to recompile everything when all I want is to test out a 1 line delta independent of its... uh... dependents.Basically, I want Jupyter-stype notebooks to be my primary dev environment.	dharmaturtle	12.493373	-7.840843	comment	5.0	19.0	1636899857	-11.120617
29453832	He forgot about Clojure after a minu	He forgot about Clojure after a minute or so. Never forget your audience.	copperx	12.65503	-7.9040823	comment	5.0	17.0	1638742094	-11.178001
25499058	I just moved a medium sized codebase	"I just moved a medium sized codebase from clojure transducers to JS, and after having used clojure for 7+ years, and done so professionally, I don't wanna go back, ever. The JS solution is shorter, faster, and easier to understand.
I'm thankfull for the insights into reality and programming clojure has provided, but highly optimised clojure is neither idiomatic nor pretty, you end up with eductions everywhere.
Combine that with reaaaallllyy bad debuggability with all those nested inside out transducer calls (the stack traces have also gotten worse over the years, I don't know why, and a splintered ecosystem (lein, boot, clj-tools)) I'd pick rust and deno/js any day for a greenfield project over clojure. sadly."	j-pb	12.643885	-7.8900747	comment	5.0	26.0	1608581783	-11.163208
25623061	Now I'm somewhat biased, but that co	"Now I'm somewhat biased, but that complete list of advantages also applies to Haskell. [^1]In fact, nearly all of the claims made about Clojure here can be made about haskell more strongly.I've half a mind to do a direct comparison on every point. I'd be interested to hear the author's thoughts on the similarities and differences.[^1] With the obvious exceptions of s-expressions, java/js interop, and ""subjectively good design""."	johnday	12.455845	-7.863532	comment	5.0	45.0	1609693780	10.486553
25623092	Language intricacies aside, is there	Language intricacies aside, is there a reason to use Clojure over Elixir, Erlang? Genuinely curious what JVM has to offer vs BEAM / OTP if you're going to use dynamic languages.	lxtx	12.641686	-7.839651	comment	5.0	17.0	1609694019	12.864981
25626182	Every time Clojure comes up on HN th	Every time Clojure comes up on HN there always seems to be a lot of negativity. I've come to flinch just seeing a mention of the language, which I do still love and have used for a decade, but perhaps this is how everyone feels about their pet language. I think there's a bit of a tension with Clojure, that it's a weird combination of being principled and being pragmatic, which means that there are always languages that on paper beat it out on any given axis. At the same time Clojure people do have a tendency to paper over the cracks quite a lot, at least some of which must be cognitive dissonance.The biggest problem is that it's very hard to picture why, at the end of the day, all the choices that went into Clojure come together into a productive whole for building real-world software. It'	thom	12.650909	-7.895827	comment	5.0	52.0	1609715571	-11.1652565
25796219	At least a dozen big companies are r	"At least a dozen big companies are running on large Clojure codebases: Apple, Cisco, Walmart Labs, Funding Circle, Nubank, Metabase, CircleCI, Grammarly, to name a few. Many smaller companies built their entire businesses using Clojure stack.The days when Clojure was just ""a toy to impress your friends"" are long gone. It's a mature ecosystem for the serious craft.Today it's the most widely used FP language; it has gained popularity and doing better than OCaml, Erlang/Elixir, Elm, Haskell, F#, and even Scala.Clojure is slowly but steadily growing. Without any support from the big players. I think the core Clojure team has fewer people than teams at Facebook and Google for front-end libraries like React and Angular. Podcasts are being recorded, books published, conferences organized.Skeptics"	iLemming	12.65215	-7.8971443	comment	5.0	37.0	1610743729	-11.169628
26006841	Donkey: A Highly-Performant HTTP Sta	Donkey: A Highly-Performant HTTP Stack for Clojure	invisiblerobot	12.648412	-7.897525	story	5.0	123.0	1612300741	-11.185983
26104487	> - don't pretend the JVM and JS hav	"> - don't pretend the JVM and JS have identical runtimes when it comes to concurrency or numerics. Clojure is a language, not a platform abstraction.> - Emit efficient, optimally minifiable javascript code, at the cost of offering something less traditionally lisp-y when it comes to eval, macros, and other forms of code loading. Those are still possible, but some discipline is imposed.This is exactly the kind of thing I'm talking about: Scala.js doesn't need to make these tradeoffs at all! Concurrency works identically (just no parallelism), numerics work identically, macros work identically. The list of pure-Scala things that behave
differently in Scala.js is shockingly short (https://www.scala-js.org/doc/semantics.html)Scala.js sacrifices none of these and still emits efficient (sometime"	lihaoyi	12.557189	-7.843039	comment	5.0	19.0	1613064747	11.935338
13887934	Thank you. I wish to someday walk in	Thank you. I wish to someday walk into an interview and pull out Clojure as my language of choice and write every bit of code they ask me to as a pure function - and then look into the interviewer's eyes and try to decipher if they had seen the eternal light of Lisp yet.	pkd	12.65697	-7.890519	comment	5.0	39.0	1489690622	-11.114728
13929814	Some observations.Wouldn't have thou	"Some observations.Wouldn't have thought of built-in help as a popular (47.1%) way of teaching yourself.Oracle usage only 16.5%, but I guess it makes sense considering the web developer proportion.CoffeeScript as the third most dreaded language, behind only two instances of Visual Basic. But reading the definition of ""dreaded"" in makes more sense.Sharepoint as the most dreaded platform, ha ha, no surprise there.Clojure as the top paying tech worldwide, wow. But missing entirely from the list in US, UK, Germany, France sections, so where are all the Clojure devs? In general that's... comforting, if only there were any Clojure shops in my country (okay, admittedly I've heard about one startup using it)."	provemewrong	12.6561365	-7.8978386	comment	5.0	15.0	1490178860	-11.184665
13954291	Clojure from the ground up	Clojure from the ground up	kercker	12.645788	-7.897594	story	5.0	245.0	1490421201	-11.171079
13979448	I have dabbled in Common Lisp over t	I have dabbled in Common Lisp over the years and am quite comfortable with it.  I know nothing about Clojure.  What are the problems with Clojure?  I am just curious.  Thanks!	sigjuice	12.658178	-7.898512	comment	5.0	35.0	1490726842	-11.092937
14006984	I only worked with Clojure professio	I only worked with Clojure professionally for a couple of months, but the experience was less than stellar. Most of it probably had to do with the codebase being written by people without any experience, but a couple of problems could be traced back to the language itself.I'm preparing to write a lengthy post comparing Clojure and Racket, the other Lisp I have been using for personal projects for a couple of years now. My opinion is that Racket is a better language overall, although it may be less practical in terms of writing production code and it certainly lacks some of the nice features Clojure brings. On the other hand, many of these nice features are available as libraries (not only in Racket - in most Lisps, including Elisp and Common Lisp).For the last two years, I used StumpWM as 	klibertp	12.68696	-7.869765	comment	5.0	55.0	1490986689	13.633296
14008239	Clojure's been my go-to language sin	Clojure's been my go-to language since around 2009, and I use it full-time today. A few points from the article:The horrible if-let code the author shows is exactly the kind of thing people use macros for. I'm surprised nothing exists in clojure.core for this, but every project I've ever worked on has something like if-lets, which short-circuits on the first falsy assignment. Everyone thinks they don't need macros and then finds stuff they hate in the language which is easily fixed by macros. This is probably true of the non-mainstream paradigms in all languages. It takes some willpower and humility to learn all Haskell's lens arrow operators instead of just laughing at them.clojure.spec is nice, and I use it in my current project, but it has performance issues (it is after all basically a	thom	12.529528	-7.848989	comment	5.0	18.0	1490994570	-11.134492
14225911	Good article. He missed out the main	Good article. He missed out the main pro though (and literally the only reason I ever use any Lisp): hot swapping. The ability to change code on the fly as the program is running. For this to actually work you need 2 things:1. No explicit types: Everything in Clojure is just a list or hash map, so I can add extra members to anything at runtime no problem. The amount of static checks Rust does at compile time makes this non viable.2. Fully immutable data structures: If my changes cause exceptions, then the program can just rewind and throw away the new state it was building, let me fix the error I made, and then continue on as if I never committed the broken code. In Rust an exception would mean I've potentially mutated state in a bunch of places, and now can't get back to the previous work	hacker_9	12.489033	-7.9140096	comment	5.0	21.0	1493462286	-11.125804
14361956	Would be lovely if they officially s	Would be lovely if they officially supported Clojure too.	KingMob	12.654644	-7.9001865	comment	5.0	16.0	1495049252	-11.187794
14414100	Agree with most of them, except,Advi	Agree with most of them, except,Advise against higher order functions. Higher order functions separate clojure from other languages, and is one of defining features of this class of languages.Advise to not use threading. Threading is just a series of steps. I find it very readable. If I start using symbols the step sequence can become a step graph FWIW.	abc_lisper	12.625804	-7.890034	comment	5.0	34.0	1495666755	12.439443
14419465	There seems to be a very nice soluti	There seems to be a very nice solution to the parenthesis problem: https://sourceforge.net/p/readable/wiki/Home/I have no idea why it hasn't caught on.  As far as I'm aware, there's no Clojure implementation.   Lispers like their parentheses.	bryanlarsen	12.606702	-7.8592577	comment	5.0	22.0	1495740279	-11.018978
14419716	I don't really have anything to say 	I don't really have anything to say about your other points, but the only comparable compile-to-JS tech in your list to ClojureScript is Scala.js. The other options assume you don't see significant value in using the same programming idioms across client and server.	swannodette	12.655267	-7.8761415	comment	5.0	23.0	1495742317	-11.159944
14439165	So sad to see he is leaving Clojure 	So sad to see he is leaving Clojure community. That's a sign of the death of Clojure. A few great developers have moved their focus away from Clojure.	sunng	12.65503	-7.9069347	comment	5.0	16.0	1496067210	-11.177788
14637013	Snake in Elm with WebGL	Snake in Elm with WebGL	tibastral2	13.014014	-7.694496	story	5.0	82.0	1498487043	-12.766351
14643109	The author asks WHY hasn't clojure c	The author asks WHY hasn't clojure caught on if it is great.I think I have a better answer than his conclusion that it aint popular because people shun things that aren't popular.(1) coding when EVERYTHING is immutable by default is a royal pain in the arse.(2) Coding directly in Abstract Syntax Trees is not pretty, there is a reason why most programming languages don't look like lisp.	andriesm	12.642581	-7.8865094	comment	5.0	15.0	1498547613	-11.115085
23418975	As an aside - Is Rich Hickey still n	"As an aside - Is Rich Hickey still not notable enough to have a wikipedia entry?  
Even the person who has shepherded on this paper has a wiki page."	imdhmd	12.654222	-7.906537	comment	5.0	46.0	1591289632	-11.149777
23419537	I love clojure the language but hate	I love clojure the language but hate the tooling.Also a lack of documentation was always a problem, especially around clojure script.I also don't like smug community. When you say about the lack of documentation and get told that's a good thing, clojure is meant to be hard to learn, it's not for everyone and maybe you just aren't smart enough...Hmmm. That attitude might put people off.	LandR	12.659014	-7.91017	comment	5.0	45.0	1591292736	-11.165369
23420843	> The fascinating thing to me about 	"> The fascinating thing to me about Clojure is that it's so vocally a ""practical"" languageI tried Clojure, but the startup times were too large to the point where it became impractical. Especially for small scripts."	amelius	12.655255	-7.8950434	comment	5.0	18.0	1591299558	-11.157704
23927934	Pretty strange how no one else sees 	"Pretty strange how no one else sees that banks are very very fragile institutions, plus this one is heavily VC-ed, which makes everything they claim in public irrelevant (this is if we want to trust what any bank says at all).What is relevant is that Cognitect will now have 100% of income coming from the single (and fragile) source, they now do not have to compete and survive on their own, they can't say ""no"" when having a choice between having to conform or quit the only money source.I am not discussing personalities here - people are free to choose how to sell their products or themselves. Just thinking what this means to me as a software consultant who makes 100% of money from Clojure (yes, a fragile single choice because of sort of falling in love)"	juskrey	12.673472	-7.8812194	comment	5.0	34.0	1595515910	-11.136629
23928712	My entire business is built on Cloju	My entire business is built on Clojure and ClojureScript, and it would not have been possible without these languages. I am always slightly worried by this kind of news, because it means that the main Clojure team is now dependent on a single institution. But it could be good news as well, depending on how things go.Until now, I've been getting nothing but excellence from the Clojure team: not just great tools, but also great thinking behind them. I appreciate what I've gotten (for free!) until now, and hope that the trend will continue :-)	jwr	12.66273	-7.905916	comment	5.0	53.0	1595519843	-11.192266
23934357	>  it would not have been possible w	>  it would not have been possible without these languagesWhat critical features Clojure has, which don't exist in other platforms/languages?	riku_iki	12.63636	-7.8874335	comment	5.0	21.0	1595550752	-11.160208
23955382	Hmm. In my experience, this an unusu	Hmm. In my experience, this an unusual opinion (to me, the author). Over the years the re-frame documentation has been the most praised part of the project.Could you point out the area which you found unnecessarily difficult, and I'll happily review it. Could you also include your background, so I know where you are coming from? The docs are a little oriented towards JS developers coming across, but perhaps you are already very experienced with Clojure and data-oriented design, which makes it seem like the concepts more obvious. Maybe.	MikeOfAu	12.6530695	-7.8819575	comment	5.0	41.0	1595751556	8.30265
24048477	Myth and Monolith – The Nine Elms Co	Myth and Monolith – The Nine Elms Cold Store	yummypaint	13.012653	-7.6946716	story	5.0	11.0	1596536427	-12.747578
24356613	Clojure is a recurring gravitational	"Clojure is a recurring gravitational pull for me. I haven't had time to properly explore yet but I will before end of year.It's not a ""first"" language like JS, Python, Java, C#, Ruby etc. so the community appears to benefit from a higher than average level of skill. In the same way that i imagine Erlang or Elixir might enjoy the benefit of more capable than average users.The fact that entire paradigms can be implemented as libraries is attractive to me - it suggests to me that the Python 3000 or C++11 problems are unlikely to affect Clojure.For example, Go is a language I find interesting. The whole CSP concept makes a ton of sense to me in writing enterprise software - mainly from a ""keeping the architecture cheap to own and change over time"" point of view. I appreciate this isn't where C"	CraigJPerry	12.618943	-7.861716	comment	5.0	20.0	1599073359	-11.098059
20074447	To me, this makes total sense as the	"To me, this makes total sense as the project moved to Apache. Obviously, much more people will be able to consider contributing when it's in Java. Apache goal is sustainability and long-term viability, and Java would work better for that.I also consider this a success story for Clojure. It gives Clojure another usecase: a ""production-ready prototype"" language where the resulting ""prototype"" can last for eight years and benefit thousands of developers until it gets rewritten to something else when all the hard questions are answered, and most experimentation/wandering is over."	unlogic	12.654115	-7.8988667	comment	5.0	28.0	1559468493	-11.178768
20334574	"But: 
- good luck finding a Clojure "	"But: 
- good luck finding a Clojure programmer if your current one quits.   
- good luck finding answers for your exotic bug/performance issue
etc.
Code is a liability, it's much more than language/VM/compiler features"	sydd	12.650725	-7.8937793	comment	5.0	22.0	1562072663	-11.203509
20531861	SVG Jigsaw Generation in Clojure	SVG Jigsaw Generation in Clojure	luu	12.652106	-7.884725	story	5.0	107.0	1564108034	-11.184211
20645058	"Does Racket support ""real"" multithre"	"Does Racket support ""real"" multithreading yet?  I remember looking at their documentation a few years ago and it only had support for a green-threading thing, which (along with the first-class hashmaps) steered me towards Clojure."	tombert	12.639929	-7.8233094	comment	5.0	20.0	1565275605	9.237556
20662192	"Clojure seems to have replaced the """	"Clojure seems to have replaced the ""p""[0] suffix in predicates with ""?"", the former being an old Lisp convention. Interesting choice, I'm mildly miffed they didn't go with the old convention.[0] http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec..."	zshrdlu	12.649402	-7.8836927	comment	5.0	26.0	1565446864	-11.061726
20773921	Clojure is by far the best programmi	Clojure is by far the best programming language I've ever used. Rich Hickey's Sermons On The Mount changed the game of programming once and for all. With Clojure you could finally have your Lisp cake and eat it. Witness the sheer chutzpah of the guy when he basically told Ruby devs they were doing it wrong at Rails Conf in 2012 (https://www.youtube.com/watch?v=rI8tNMsozo0).	cutler	12.633015	-7.865111	comment	5.0	55.0	1566524296	-11.125575
20789270	This is all nice and exciting until 	"This is all nice and exciting until you start to 
1) Debug code, the high density of clojure code means that this is really painful.
2) Read code you wrote a while back. The high density of clojure code means that this is really painful."	hsaliak	12.65206	-7.9018993	comment	5.0	17.0	1566675756	-11.189663
20789913	What is GUI programming like in Cloj	What is GUI programming like in Clojure? What libraries exist, and what paradigms are used? E.g. is it more like React or is it more like Gtk/Qt?	amelius	12.650994	-7.890334	comment	5.0	15.0	1566683320	-11.136508
20847478	Composing libraries instead of buyin	Composing libraries instead of buying into a framework is a wonderful thing. It allows a developer to use just the parts they want, integrate them with just what the developer needs, and get on with whatever they're doing. It's a beautiful idea, and it can enable amazing levels of productivity.With that said, might it also be possible that there could be some drawbacks? Having worked in and with Clojure, I found the ecosystem incredibly immature. It's somewhere beyond arrogant - reckless comes to mind - for most engineers to do all their own plumbing for a web service. The odds that they'll manage to design someone easily long-term maintainable are slim. The chances of authorization, authentication, potential SQL injection, and a thousand other security things being handled well is effecti	Kalium	12.648398	-7.902632	comment	5.0	29.0	1567270982	-11.168245
30922474	Slightly OT, but whenever I see Cloj	"Slightly OT, but whenever I see Clojure projects I think: ""I'd love to write something bigger in Clojure one day, experience it, and see if it's all it was promised to be.""That said, I don't really have any good use case for it right now, whether at work, or among my side projects."	cube2222	12.652103	-7.893842	comment	5.0	24.0	1649181361	-11.166944
31044429	Increasingly, I don't see clojure as	Increasingly, I don't see clojure as primarily a matter of the clojure-on-jvm implementation, but as a distinct and (generally) hosted dialect of lisp. Clojurescript is a clojure. Janet is a clojure. ClojureCLR is a clojure. Fennel is a clojure. Babashka is a clojure. Ferret is (kind of) a clojure. Maybe someday we'll have a bare-metal clojure. So far as I can tell, the lisp landscape (land of lisp?) has changed from common-lisps and schemes, to common-lisps, schemes, and clojures.IMHO. Maybe I overexaggerate. Anyway, the author, from my perspective has decided that clojure IS in fact for him, but clojure on the JVM is not, so he chooses to use a different one.	Gollapalli	12.657104	-7.88675	comment	5.0	18.0	1650049879	-11.080062
31168833	My world revolves around Common Lisp	My world revolves around Common Lisp (with Python for deep learning), but Clojure is also an important language to me because of both professional use and I wrote a Clojure AI book.What is the Graalvm + Clojure situation? A quick web search shows some use cases. I find the idea of using high programmer-efficient Lisp languages and then building small and fast native applications to be compelling. That said, LispWorks, SBCL, and Allegro CL are all good for building standalone apps.	mark_l_watson	12.649018	-7.8565154	comment	5.0	29.0	1650987421	-11.058858
31447107	Clojure, like Ruby, does falseyness 	"Clojure, like Ruby, does falseyness correctly in that there's only 2 cases of false: nil and false. Everything else is true. This is easy to reason about, and it allows for nils to ""flow"" through your logic (especially with nil-punning where in the context of collections, nil is also an empty sequence)."	Slackwise	12.561559	-7.8657074	comment	5.0	26.0	1653053442	-11.105233
31586754	Clojure(Script) holds so much appeal	Clojure(Script) holds so much appeal for me, checks ~all the boxes... I just wish it were more popular. Curious why it's not.	chrisweekly	12.657178	-7.8963175	comment	5.0	30.0	1654111474	-11.169706
31646391	I was exposed to Common Lisp in coll	"I was exposed to Common Lisp in college in a ""Programming Language Concepts"" class, almost 20 years ago, and it didn't ""click"".  I got no help or assistance or explanation, and this was pre-youtube and Google so it was hard to find an answer to ""why is this happening?""But I gave Clojure a try despite the bad taste in my mouth Common Lisp left, and it was def worth it.To try it out real quick: https://tryclojure.org/"	the-alchemist	12.666592	-7.891161	comment	5.0	20.0	1654550211	-11.060334
31655574	Cloture – Implementation of Clojure 	Cloture – Implementation of Clojure in Common Lisp	capableweb	12.660714	-7.8907313	story	5.0	119.0	1654614868	-11.1360445
35684547	As a Clojure programmer, I'm so happ	As a Clojure programmer, I'm so happy that I'm getting all these improvements over many years. It's fashionable to complain about Java — but I don't use Java, and yet I benefit from all the fantastic work that is being done on the JVM.	jwr	12.633354	-7.8785243	comment	5.0	34.0	1682320504	-11.184952
35804469	Rich Hickey: Design in Practice	Rich Hickey: Design in Practice	simon_acca	12.641807	-7.9049087	story	5.0	67.0	1683131901	-11.126776
36275402	I don’t get what’s unhealthy about a	I don’t get what’s unhealthy about anything on that page. Elm’s trade offs are in plain sight. If you don’t want them, then you have plenty of warning.Frankly Elm has more of a problem with negative fanboying: people who have decided it’s not for them yet have to constantly show up to neener neener every time Elm appears on HN instead of just moving on.It’s very weird to me as someone who uses Elm daily. We get it. You don’t like it and everyone needs to know it.That it’s some sort of cult is just HN drama begging fantasy.	hombre_fatal	13.013327	-7.6970215	comment	5.0	24.0	1686432995	-12.767484
34261010	Babashka Babooka: Write Command-Line	Babashka Babooka: Write Command-Line Clojure	Borkdude	12.655454	-7.900359	story	5.0	118.0	1672932562	-11.1638565
34455998	Saw a talk with Douglas Crockford[0]	Saw a talk with Douglas Crockford[0] years ago. He said something like: Before JS classes got introduced he asked why they didn't just implement macros for the language. Classes are in fact just syntactic sugar. Just like async/await, and now this proposal.In hindsight he was right. JS would be better off if it did  have macros. Much of the whole babel/webpack/react/ts stuff would be just a bunch of macros instead of idiosyncratic build tools and so on. And we would have had much less compatibility churn.In fact this proposal here, is trivial to implement with macros. Clojure has the same thing (threading operator) and it's just a macro.[0] https://en.wikipedia.org/wiki/Douglas_Crockford	dgb23	12.63322	-7.8665824	comment	5.0	20.0	1674233867	-11.079881
34775174	While I like Clojure as a language -	While I like Clojure as a language - I have never seen a language that engendered such hatred in PMs, EMs, sales, etc.  I don't know that it survives long term (in industry, it'll survive for a long time as a hobby language.)	gemstones	12.651785	-7.9005165	comment	5.0	41.0	1676303916	-11.165455
34776703	Clojure user here since 2010(my earl	Clojure user here since 2010(my earliest Clojure project on Github), and while I agree with the fun point, the iceberg wart for me at this point is the inelegance of the interface hierarchy and its structure behind the scenes.Clojure's forward-facing interface (a hundred functions that operate on one data structure) ended up breaking down for me at some point and became 10 functions on 10 data structures and those data structures became AFn, APersistentSet, APersistentMap, APersistentVector, IFn, IPersistentSet, IPersistentMap, IPersistentVector, ITransientMap, ITransientVector, IndexedSeq, LazySeq, &c, &c, &c.Maybe I started writing code wrong. Maybe I dived too deep into the internals, Maybe it was something else. But at the end, there wasn't one data structure, there were dozens and doz	kelseyfrog	12.634682	-7.8932433	comment	5.0	36.0	1676309008	-11.171974
34780118	Clojure fans seem quite taken to hyp	"Clojure fans seem quite taken to hyperbole. If the language is such a ""joy"", ""ultra-productive"" etc I would have expected after such a long period of existence some major open source project to be showing off what the language attributes allow you to do.Happy to stand corrected if there is such a slam-dunk showcase that I've missed, I am actually interested to dig into clojure, if nothing else as a way to deepen my understanding of functional programming."	college_physics	12.627394	-7.888503	comment	5.0	24.0	1676320984	-11.115958
34812735	How well would Clojure fit into a Sp	How well would Clojure fit into a Spring Boot centric environment?	rbanffy	12.6494875	-7.895978	comment	5.0	18.0	1676505085	-11.17537
34847807	Same reaction here... wow that is a 	Same reaction here... wow that is a rough looking language. Then again I always disliked those kinds of languages like Clojure. The syntax is just too much for me. I feel like if I used it, it would atrophy my skills in other more traditional languages.	sergiotapia	12.6312065	-7.8919835	comment	5.0	25.0	1676735728	-11.117808
38792073	Every time I see these packages ment	Every time I see these packages mentioned, I’m reminded of an interview with Joe Armstrong. In it, he said, (paraphrasing from memory) “Wouldn’t it be interesting if a language had a global, flat registry of functions that anyone could pull from and contribute to? That way, bugs are fixed in one place, there’s less reinvention of the wheel, things get more correct over time, and programs just become a simple composition of standard functions.”I may be misremembering his meaning, but I remember thinking it was an interesting idea. It wasn’t obviously a terrible idea. I thought it would be like the Clojure standard library on steroids, especially if it was coordinated and vetted by a decent team.But alas, NPM has proven it otherwise.	christophilus	12.648512	-7.8921924	comment	5.0	18.0	1703759917	-11.22439
16001772	I picked up ClojureScript at the end	I picked up ClojureScript at the end of 2013. I was a C++ developer then in a small firm and was tasked to write a web frontend. Outsourcing that project had failed before (2 times iirc), so my boss bet on me to do it. I knew HTML and had written probably < 1000 lines of Javascript code in my life before. Anyway, I needed to write an interactive single page app (basically it was a visualization of simulation results), so I needed Javascript. But it was so frustrating to write Javascript (also, tooling was mediocre back then or I didn't know it). So at the same time, I stumbled over ClojureScript and had a try (I new Scheme before and was especially outraged by JS syntax quirks, so I hoped S-expressions would rescue me). With ClojureScript in 2013 I had a module system that handled dependen	wirrbel	12.6555395	-7.791566	comment	5.0	15.0	1514156769	-11.085178
16332356	I'd encourage Clojure fans to contri	I'd encourage Clojure fans to contribute monthly, even in the smallest amount.A healthy ecosystem has a compound effect (like a feedback loop), which can result in a greater abundance of Clojure jobs.Thankfully Clojure doesn't need to be 'saved' (it's a timeless idea!), but well I often read complaints around its job market and open source ecosystem.As an example, say you get some VC funding. Can you absolutely trust Clojure(Script) and its tooling? How well will non-senior hires perform? I for one would be tempted to go for something with more traction like Elixir + Reason.I adore Clojure and all that, but in the end details matter, especially under budget/time constraints.Of course, this is a (perceived) situation we can change.	vemv	12.660882	-7.9052625	comment	5.0	24.0	1518101718	-11.167621
16417666	Worth noting is that you haven't bee	Worth noting is that you haven't been able to find a single criticism of elm in years. You hired the language designer so it's understandable that you'd have an easier time with the language. However, you've consistently kicked dust in everyone's eyes every time anyone has anything remotely critical to say about elm. It's frustrating because you are so smart and so insightful and it just looks like you're deliberately obfuscating the issue and for what? To what end? Because the language is so good? Bullshit. It isn't. It's a closed off, stagnant language that has no clear plan for its own future and zero plan for what would happen if Evan goes away. Please, for the love of God, just be able to point to a thing that is less than perfect about this average language.	brokenbyclouds	13.009851	-7.6941576	comment	5.0	18.0	1519097614	-12.769265
21092035	Yes not sure what happened to clojur	Yes not sure what happened to clojure. The rise and fall of clojure is really intriguing.Looks like everyone just went back to java.	dominotw	12.654849	-7.89762	comment	5.0	52.0	1569592702	-11.180214
21224061	Love Letter to Clojure	Love Letter to Clojure	gigasquid	12.649753	-7.8971095	story	5.0	161.0	1570800115	3.3049154
21705146	And, Scala is Kotlin without the boi	And, Scala is Kotlin without the boilerplate. Scala is the most expressive and powerful language on the JVM, hands down. Kotlin is just a poor imitation. Of course, Java is way worse than either, but unless you are targeting Android, do yourself a favor and use Scala. Closure is okay, I guess, but I find dynamic typing and the dogma of Clojure counterproductive.	smabie	12.375181	-7.7210574	comment	5.0	22.0	1575483559	11.934946
39121038	It also assumes significant Java kno	It also assumes significant Java knowledge, so I kept finding myself at a dead end where it assumes I know the Java library way to do something and can just call it. I tried Clojure for the Brave and True and Living Clojure. I kept thinking that I wasn't getting anything I couldn't already do in Python (at least for my uses), but there's a lot of baggage like emacs + cider...etc.	7thaccount	12.64319	-7.884336	comment	5.0	21.0	1706121685	-11.124935
39120780	Isn't Clojure the most mainstream Li	Isn't Clojure the most mainstream Lisp at this point?	posix_monad	12.665979	-7.883408	comment	5.0	40.0	1706120572	-11.029878
17946389	Studies have found that bug count is	Studies have found that bug count is roughly proportional to program length, across languages.  Saying you prefer verbosity essentially means you prefer more bugs.  500 lines is generally less understandable than 40 lines.  There may be cases where terseness can be too extreme, but I don't see it here.Is there some particular aspect of the Clojure code here that you think is overly clever, or hard to understand?  This Clojure code uses only one lambda, and in a straightforward way.I've written a lot of Java, and a moderate amount of Clojure, and if I had to place a wager on which version had fewer bugs, I'd definitely bet on the Clojure.  Especially if there were the possibility that it was related to threads.We could write this in assembly language, and it'd take 50,000 lines, and probabl	ken	12.623516	-7.8740206	comment	5.0	23.0	1536507775	-11.145326
18006183	Hey, Michi here, from Arc Studio Pro	Hey, Michi here, from Arc Studio Pro.As MartinMond said, this is indeed an attempt to bring a GitHub style workflow to a field outside of software development.The app is written in Clojure(Script), implementing OT for collaboration.Happy to answer any questions!	michihuber	12.638362	-7.8727117	comment	5.0	20.0	1537194288	-11.216639
18161052	I took a course in Racket in first y	"I took a course in Racket in first year (required for all first year math/CS students at my school) and I've spent some time in the Clojure community as well. ""Code as data"" is an oft-repeated selling point of Lisp and Lisp-like languages.When you actually start using these languages, you find yourself tempted to leverage this property and try writing lots of macros. But then you go back to the community and everyone tells you ""the first rule of macros is you don't write macros."" It turns out that if you use macros all over the place then your code becomes impenetrable. The problem is that macros allow you to circumvent the expected order of evaluation and produce your own novel syntactic structures. This puts lie to the old claim ""Lisp has no syntax."" In reality, Lisp has tons of syntax, "	chongli	12.645956	-7.861174	comment	5.0	19.0	1538926466	-10.892876
18162712	I’ve been about 6 months in Clojure,	I’ve been about 6 months in Clojure, and I am finally starting to like it. Coming from decidedly non-Lisp languages, it’s been a struggle. For example, immutability is possible, but not natural to most other languages; for Clojure, it’s instrinsic. I also often scratch my head at the way things ate scoped and tbe whole concept of purely functional programming. Clojure is very powerful and terse, but what I dislike the most, just like with Ruby, is the culture that the code should be self-documenting and self-explanatory. In all the code I have been maintaining this whole time, comments are rare, whereas in Java, C/C++, JS, etc., comments are plentiful and encouraged. I feel like with Clojure, I am expected to understand the code just by reading it. What gives?	temporallobe	12.645999	-7.898054	comment	5.0	15.0	1538947619	-11.123189
18226402	>nobody has or will make anything pr	>nobody has or will make anything practical with LispI made a website with Clojure (a Lisp) that is indeed practical: http://practicalhuman.org	sova	12.668903	-7.877945	comment	5.0	22.0	1539662785	-11.024468
18345498	"While other posters comment that ""Cl"	"While other posters comment that ""Clojure still works"", IIRC the ""promise"" was that Clojure/Lisp would be much, much more productive, and that claim I feel like must been disproved in daily work, otherwise Clojure would still a main topic around here.Reminds me of the classic Erann Gatt post: https://news.ycombinator.com/item?id=2308370(I loved to play with Elisp, Clojure, Lua, Factor, Ion, Ioke and hope dynamic languages become fashionable again someday...)"	swah	12.650195	-7.889182	comment	5.0	15.0	1540992793	-11.163185
18345831	Also the Clojure language had a huge	Also the Clojure language had a huge growth period around 1.1-1.5 which sparked a lot of excitement and spurred a lot of community growth. But since then, most of the exciting features have been adapted to other mainstream languages either as features or libraries, and most senior developers I know prefer to take the path of least resistance, which includes avoiding less-mainstream languages and frameworks. So instead of using Clojure with Compojure, it's common to move to Java with Dropwizard, or slightly less analogous, JavaScript with Express.js. And instead of using ClojureScript with Om, people mostly jumped to JavaScript + React.Edit: Removed comment about Om, since I must be misremembering something. Om uses React and has since the first commit.	sdegutis	12.66258	-7.848241	comment	5.0	18.0	1540995195	-11.152522
18346401	Thats an interesting point that does	Thats an interesting point that doesn’t answer any of the questions the parent asked. :)Perhaps you can answer this simpler one:Netflix has been using clojure for a long time now; has that been a positive experience broadly speaking, that means clojure is still being used for new projects, or not?Having a large successful project in clojure is lovely, but much of the community’s concern around it is that its hard to maintain, and falling in popularity, broadly speaking.It would be very nice indeed to see those points addressed by a large scale user of clojure.	shadowmint	12.653685	-7.902176	comment	5.0	38.0	1540999172	-11.182621
18565826	Hickey's `Maybe` example feels misgu	"Hickey's `Maybe` example feels misguided (about breaking existing callers). If Maybe is an input just keep the original function around and provide a new one that wraps it.    originalF :: x -> y

    f :: Maybe x -> y
    f None = newDefaultBehavior
    f (Some x) = originalF x

If `Maybe` is an output then existing callers SHOULD be broken, because they must now handle a new possibility of failure they didn't before. The fact that this doesn't happen in Clojure is actually a source of pain for me.It's also rather interesting that Hickey also comes to the same conclusion that optionality doesn't belong in a data structure, but for slightly different reasons: https://news.ycombinator.com/item?id=17906171"	dwohnitmok	12.617682	-7.9078236	comment	5.0	39.0	1543541101	-11.159128
18564894	Sometimes it seems as if Cognitect j	"Sometimes it seems as if Cognitect just doesn't want people to use Clojure. It's like they looked at the results from the survey[0], created a tool that appears to address some of the main gripes that people have, and then proceeded to say ""screw you"" to all of the people that use Clojure commercially and may actually pay for Datomic...[0]: https://danielcompton.net/2018/03/28/clojure-survey-2018"	kickopotomus	12.66643	-7.897255	comment	5.0	16.0	1543531765	-11.201774
18703237	Are there any plans for a native ver	Are there any plans for a native version of Clojure? I'd rather avoid the JVM if possible, but I suppose the whole ecosystem is dependent on it so that's unlikely?	kbd	12.650292	-7.8939624	comment	5.0	33.0	1545089116	-11.166532
18773933	> You get a kick of doing everything	> You get a kick of doing everything in ClojureI'm a fan of Clojure, but having this is the first reason to try an app is unattractive. It's saying that this project is first about the technology and second about solving your problems. That's fine and I wish them luck. But for those of us who aren't enthusiasts but just use editors to get work done it's a dissonant sales pitch.	hirundo	12.656195	-7.897294	comment	5.0	15.0	1545957480	-11.178919
18798891	Ask HN: What's your ideal tech stack	Ask HN: What's your ideal tech stack for 2019?	NightMKoder	12.633116	-7.8812103	story	5.0	12.0	1546316092	-11.147626
18842078	Outside of applying the research of 	Outside of applying the research of persistent immutable data structures (which I think is from the Okasaki paper[0]), I think the most innovative part of Clojure is the fact that it's actually used -- they've managed to build a community and ecosystem with high quality packages and buzz around lisp.I don't pick Common Lisp/Scheme/Racket despite desperately wanting to because IMO Haskell has a better package ecosystem in my eyes, which is saying a lot. For example, try and find a HTTP server (by far the most common usecase for new projects IMO) that is both multi threaded and async IO capable (i.e. maximally using every core) -- it's surprisingly difficult, I found decent seeming libraries that did either-or, with varying levels of polish and paradigms involved.I personally prefer CL to Cl	hardwaresofton	12.626594	-7.8794312	comment	5.0	27.0	1546825123	-11.129426
18899898	I live in SF and am charging $15/hr 	I live in SF and am charging $15/hr for Clojure exclusively. No bites yet. My budget is $1,500/mo total, $600 being food. Awe yea. I charge what the market will bear, starting at minimum wage. China is about $45 fyi, last I paid—good talking point.	harlanji	12.660855	-7.908326	comment	5.0	15.0	1547429105	-11.158208
29780306	Ask HN: Why's Clojure the top paying	Ask HN: Why's Clojure the top paying programming language?	ihojman	12.649457	-7.892594	story	5.0	22.0	1641214721	-11.171094
30149730	Weirdly enough I do believe Clojure 	"Weirdly enough I do believe Clojure ticks the boxes from that checklist.It's familiar in that it both ""supports popular language runtimes"" (runs on top of the JVM or transpiles to JavaScript) and it's a Lisp dialect (or close enough) and Lisps have been around since a very long time.It's incredibly stable: so stable some libraries commonly used haven't been updated in years.  There's also very little code churn inside Clojure's own codebase.It is very reliable.It's limits and trade offs are well known.Somehow I though my language of choice was ""edgy"" but I realize it may actually be ""boring"": a dialect from a very old family of language running on top of a boring tech (the JVM)."	TacticalCoder	12.654333	-7.8921328	comment	5.0	47.0	1643646109	-11.143871
30150275	I like Clojure, but it's really the 	"I like Clojure, but it's really the exact opposite of the sort of ""boring technology"" that this post advocates. If MongoDB costs you 2 innovation tokens, Clojure costs at least 2, perhaps all 3.The cost of innovation is not so much in the core of Clojure itself, but that once your company gets larger, you will want to integrate with more and more things that have not put effort into Clojure compatibility, just because the language is not very popular. Also hiring."	lacker	12.65827	-7.897082	comment	5.0	18.0	1643648389	-11.166005
32823469	Clojure has massive amounts of ecosy	Clojure has massive amounts of ecosystem and toolchain pain, even though it is a cool language. Most common dev environment for it is a complex emacs tool chain. If you are seeking the simple joys of programming, Clojure is unlikely to be what you want.	billfruit	12.649848	-7.8874145	comment	5.0	15.0	1663072542	-11.153324
32835983	Would be really awesome if JavaFX co	"Would be really awesome if JavaFX could work together with GraalVM and Clojure. Then I'd be in ""desktop application development"" nirvana, when I can ship binaries to all platforms and build the application itself with cljfx (https://github.com/cljfx/cljfx).Once every ~6 months for the last 2 years or something I've given it a try but there is always something broken or missing. Not sure what the status is right now."	capableweb	12.588045	-7.789476	comment	5.0	22.0	1663157042	-11.167834
36887792	I use Clojure at work but wow do I m	I use Clojure at work but wow do I miss just about everything about Common Lisp whenever I have to debug anything or want performant code. Being able to be in nested errors and click at any part of the stack to inspect lexical bindings is extremely useful, and more importantly, clicking on an object then pushing M-<RET> to copy it to my REPL is much nicer than what Clojure offers (tap>, which I consider a glorified pretty printer even if you use tools like Portal).As for performance, well, Common Lisp lets you statically type things, and SBCL can emit really efficient code if you do this. I find it helpful to run DISASSEMBLE on my own code to see what exactly is being emitted and optimize from there. And more importantly, packages like SB-SIMD and Loopus are a god send for any number crunc	koito17	12.658288	-7.885112	comment	5.0	18.0	1690422139	-11.045397
37046353	A History of Clojure (2020) [pdf]	A History of Clojure (2020) [pdf]	ndr	12.6356325	-7.894496	story	5.0	134.0	1691485873	-11.168118
37068227	Isn't that Clojure?(let [p obj]  (if	"Isn't that Clojure?(let [p obj]  (if (instance? Point p)

    (let [x (.x p)

          y (.y p)]

      (println (+ x y))))"	nkh	12.605975	-7.8839765	comment	5.0	23.0	1691614367	-11.166308
37076101	I think Clojure had a moment 2015 to	I think Clojure had a moment 2015 to 2020ish, but it's passed. People still use it, even though it sucks. What's not to love:- Incredibly slow- Hosted on the JVM, so you're going to be dealing with Java eventually- No automatic tail call optimization because of the limitations of the JVM, so it feels like you're writing a mess of macros rather than real functional code	shrimp_emoji	12.640257	-7.8888226	comment	5.0	16.0	1691675155	-11.162251
37413354	This is great, JQ is brilliant.I lov	This is great, JQ is brilliant.I love JQ so much we implemented a subset of JQ in Clojure so that our users could use it to munge/filter data in our product (JVM and browser based Kafka tooling). One of the most fun coding pieces I've done, though I am a bit odd and I love writing grammars (big shoutout to Instaparse![1]).I learned through my implementation that JQ is a LISP-2[2] which surprised me as it didn't feel obvious from the grammar.[1] https://github.com/Engelberg/instaparse[2] https://github.com/jqlang/jq/wiki/jq-Language-Description#:~....	d_t_w	12.6420555	-7.8875732	comment	5.0	126.0	1694047388	-11.086722
24732576	Its not all roses; I tried to commen	"Its not all roses; I tried to comment out a few routes in my clojure compojure code by doing something like this to my code a while back.  (defroutes data-routes
  (GET ""/something1"" []  (sample-json-data))
  (GET ""/something2"" []  ""hello1"")
  (comment 
  (GET ""/something3"" []  ""hello3"")
  (GET ""/something4"" []  ""hello4""))
  GET ""/something5"" []  ""hello5"")
)Then when  a client tried to access /something5 , I began getting null pointer execptions. This took me a while to figure out what I had done wrong."	manishsharan	12.645536	-7.901013	comment	5.0	16.0	1602266375	8.852829
24836873	Must be amongst the largest public f	Must be amongst the largest public facing products that's all clojure/script..?	danpeddle	12.656295	-7.8978944	comment	5.0	20.0	1603199586	-11.195683
25086256	Simulating RAM in Clojure	Simulating RAM in Clojure	stopachka	12.656061	-7.9095883	story	5.0	136.0	1605295232	-11.166849
25094074	>I will at this point sympathise wit	>I will at this point sympathise with people who have criticised Elm in the past for some of its most vocal proponents being frustratingly unhelpful.As always, Elm's biggest flaw is the sanctimonious nature of its design committee. No native modules, no custom operators, no lenses (would they really ban them?), etc.That second one even comes back to bite the code here, because compared to e.g. Haskell lenses, the Elm lens code is ugly and verbose. Having to manually write lenses instead of being able to auto-generate them with macros is yet another Elm failing, though to be fair, I don't know that macros are opposed by the committee.	ivanbakel	13.000837	-7.691097	comment	5.0	15.0	1605376685	-12.757674
25375105	I used Clojure in financial services	I used Clojure in financial services, specifically at a trading firm. When I left we’d stopped writing new Clojure services, and had started to replace existing ones with Java. Finance, at least in our area, turned out to be a pretty tough place for Clojure’s style of dynamic typing.For those that don’t know, Rich Hickey (and by extension, Clojure) is really big on data-first dynamic typing. So idiomatically you’re supposed to do most of your work in Clojure using their first-rate immutable collections library, primarily maps and their sequence abstraction. Clojure provides some mechanisms for specialized domain objects, but it’s fair to say that this is typically considered non-idiomatic.This works great if one of the following conditions are true:1) All data flows through your system on 	ashtonkem	12.594155	-7.8716936	comment	5.0	26.0	1607616109	-11.166842
25379891	Honest question: Why is clojure so m	Honest question: Why is clojure so much better than the rest?	bIAW7hAhDO	12.649879	-7.8918815	comment	5.0	32.0	1607640778	-11.167697
25380648	As a person who has and currently do	As a person who has and currently does work professionally in clojure (at multiple all-clojure shops):  The smart engineer effect is extremely overblown.You will hire smarter-than-average engineers, but with a caveat that no one talks about: they are all self-selected for being people who enjoy tinkering on computer science problems to a fault, and not necessarily your business.  So the breakdown is that you get 10 super-smart people, but 9 of them are focused on myopic bits of code plumbing or reinventing APIs or something, and in practice you only have 1 smart person focused on your business.As the other 9 continue to reinvent wheels, the nature of clojure being small relative to other open-source communities means that eventually your shiny new clojure tools get replaced by better commu	pinchhit	12.66053	-7.916872	comment	5.0	27.0	1607645664	-11.174025
25441899	Is there a good argument against Clo	Is there a good argument against Clojure in this case? My impression is that it's a good lisp and you can get actual work done in it which is an advantage over some of the other options.	st1x7	12.647903	-7.894105	comment	5.0	52.0	1608122953	-11.131899
33021520	Clojure goes out of its way to be in	Clojure goes out of its way to be insular. Creating a PR upstream requires you to have been given access explicitly from Rich Hickey (or whoever admins their Gitlab instance). The Clojurians slack is invite-only. etc.	ironmagma	12.654352	-7.901718	comment	5.0	19.0	1664463084	-11.178361
31793595	I thought I wanted static typing unt	I thought I wanted static typing until I started writing clojure.	ilikehurdles	12.544394	-7.8496504	comment	5.0	22.0	1655584600	-11.124707
32203454	I do definitely recommend Clojure - 	"I do definitely recommend Clojure - I've switched to it in 2019 coming from Rails and JS and never looked back.Clojure's job market is great, there's no shortage of offers, even for newcomers and it has been the top paying lang in stackoverflow surveys for years https://survey.stackoverflow.co/2022/#section-salary-salary-...However, the most important part is that Clojure is a very powerful piece of technology that made me reevaluate what software engineering really is.
You can efficiently use Clojure for both backend and frontend with easy access to libraries from JVM and npm so you will never run into the problem, common in other niche langs, of too few libraries.
Nevertheless, Clojure's own ecosystem is filled with many great, cutting-edge ideas that you wouldn't find working so well el"	ptttr	12.656809	-7.895885	comment	5.0	44.0	1658585113	-11.159038
32284524	Meh.  ClojureScript is just as leaky	Meh.  ClojureScript is just as leaky as Clojure.   Clojure brings all the XML pain of Java dependencies and slow start times, ClojureScript gets callback hell.  They're fantastic languages but I couldn't help but wonder if there were a better VM to base them on.	inferiorhuman	12.653698	-7.8901706	comment	5.0	17.0	1659159419	-11.181074
32322700	Because of the Java ecosystem, in Cl	Because of the Java ecosystem, in Clojure you are in much more advantageous position than with Elixir.	Scarbutt	12.6559925	-7.805677	comment	5.0	21.0	1659465866	12.879609
22091827	Also, the following part isn't neces	Also, the following part isn't necessarily because of dynamic typing vs static> what types all the variables are, what expectations are attached to them, what mutation, if any, each method call performsBut more about what the language offers. Clojure for example, goes beyond types with it's abstractions (like seq, that can be applied to strings, lists, maps and so on) and normally stays away from mutation, but when needed, makes it really explicit and easy to find those mutations.	capableweb	12.4904995	-7.846124	comment	5.0	18.0	1579447031	-11.091378
22141280	Been a while since I touched Clojure	Been a while since I touched Clojure but at the time nothing beat light table's insta-REPL. Anything replace that, or any insta-REPL come close to replicating that experience for any language?	Rapzid	12.650129	-7.894594	comment	5.0	21.0	1579892049	-11.119253
22141945	I've never spent any serious time wi	"I've never spent any serious time with Clojure/Lisp, and the nested parens have been a pretty major impediment. I'm curious if anyone's ever experimented with dialects that replace brackets with significant whitespace (newline+tabs), similar Python? I could also see a drag-and-drop coding GUI being pretty powerful.I'm sure once one spends enough time with it, one starts to think in Lisp, and the desire to solve the ""problem"" disappears. :)"	lukifer	12.654531	-7.8489795	comment	5.0	18.0	1579896477	-10.752026
22253959	Solid tooling can really boost a lan	Solid tooling can really boost a language. Clojure advocates should internalize that.	thowfaraway	12.651163	-7.898327	comment	5.0	40.0	1580971523	-11.176235
37003465	Rich has to be my favorite thinker i	Rich has to be my favorite thinker in this space, absolutely love his talks and the way he articulates things, and I often draw from his philosophies in my workBut, I've always been turned off to Clojure by the lack of static typing (I know spec exists, but it's not really the same thing). I did a little project once to try it out, and even there I found myself spending time debugging basic issues like passing the wrong number or wrong kinds of arguments to functionsCan somebody sell me on it? I feel like I'm the target audience	brundolf	12.6245	-7.891679	comment	6.0	21.0	1691171851	-11.136912
23921220	Show HN: Biff – Self-hosted Firebase	Show HN: Biff – Self-hosted Firebase alternative for Clojure	jacobobryant	12.656617	-7.8792815	story	6.0	103.0	1595449730	-11.180368
23927020	Throwaway account, for obvious reaso	Throwaway account, for obvious reasons.This is great for nubank, but how is this supposed to work for other users of Clojure and Datomic? Who is really going to be interested in building on top of tech owned by a (new, unknown, regional) bank?Someone said that this is just like Amazon (who would build on top of tech from a bookstore??), but I hope it's obvious the two situations are very different.I expect that I'll have to be looking for a new job in a year's time :-(	clj_throwaway	12.671036	-7.8862805	comment	6.0	33.0	1595510217	-11.196177
20052344	"So a sort of ""Learn JVM (with Clojur"	"So a sort of ""Learn JVM (with Clojure)"" book?I myself would be interested in writing something like this, but I am not sure that enough people would want to buy that?
Would YOU buy that book if it was available today?"	dragandj	12.652879	-7.8925886	comment	6.0	18.0	1559231029	-11.149319
19218053	Deep Learning on the GPU in Clojure 	Deep Learning on the GPU in Clojure from Scratch: Sharing Memory	dragandj	12.639965	-7.8976803	story	6.0	105.0	1550767238	-11.148261
19246163	I'm a bit surprised that there didn'	I'm a bit surprised that there didn't appear to be any mention of Clojure's built-in concurrency support outside of basic immutability.  core.async gives a nice channel-based system, agents give an actor-ish system, and STM/atoms let you mutate the variable safely, without having to manually work with locks.This is definitely a good high-level article, just something I was surprised by, since core.async is what drove me (and several other people I know) to start using Clojure.EDIT: Just a note that I know core.async isn't built in, that was a mistake.  It is a first-party library, however.	tombert	12.59164	-7.8709307	comment	6.0	32.0	1551107717	-11.251641
19522501	Should I be using a Modern do-it-all	Should I be using a Modern do-it-all frameworks for Clojure and Clojurescript? My opinion is of course colored by my years spent in JAVA/J2EE's world of web frameworks ( Wicket, Tapestry, JSF + Hibernate EJBs etc.). In this world, I found most of my time was spent in   learning the deep intricacies of the framework and fitting it to my use case. I began to hate every minute I spent on these frameworks.And then I discovered Clojure and Ring and later Liberator. What I like about my current setup is that I have full control over my framework and my team knows its ins and outs and the corresponding Clojure code is succinct enough to allow developers to come upto speed quickly. Our set up is not sexy but it works and we know how exactly it works.I am not sure what I would miss if I did not use	manishsharan	12.65832	-7.8951964	comment	6.0	23.0	1553873340	-11.154813
19522630	Would anyone recommend Clojure if yo	Would anyone recommend Clojure if you run an engineering org and get to make decisions about languages?I've been running node shops for the last several years, and love Clojure since having hosted a couple meetups a while back.That and being most influenced by lispy/ai culture from SICP, CTM, PAIP, AIMA books. Node is getting tiresome due to not being able to trust the ecosystem quality (which takes away some of the common justification of huge ecosystem).Not worried about hiring since not open to fresh grads from universities or bootcamps without lots of training anyway (which can include a new lang). Are there crappy/charlatan Clojure devs out there or is it more of an elite/experienced culture?With stuff like Fulcro, could we replace our basic REST APIs and business logic without having	chartpath	12.654884	-7.897045	comment	6.0	27.0	1553874223	-11.137007
19756823	Elm gets plundered repeatedly before	Elm gets plundered repeatedly before it ever reaches version 1.0. Is name-brand Elm still growing in adoption?	frou_dh	13.012334	-7.693556	comment	6.0	21.0	1556282575	-12.764874
19874858	Java is confusing, Clojure is simple	Java is confusing, Clojure is simple	viebel	12.641102	-7.897245	story	6.0	30.0	1557459569	-11.155218
19953644	I've done some elisp (and a tiny bit	"I've done some elisp (and a tiny bit of racket) and some Clojure and honestly I struggle to see why I would ever pick a racket/scheme/elisp over Clojure unless I desperately needed to do a ton of C ffi. Clojure is much more opinionated but I never find myself feeling like it's constraining or a straightjacketWhen do people say to themselves ""screw this, I need a more flexible tool like Racket""? Is it when you get super deep in the macro magic? (I'm not reallt sure how the Clojure macro system compares to the Scheme one)"	geokon	12.660515	-7.8778524	comment	6.0	25.0	1558278415	-11.0461445
15878938	Flare: Clojure Dynamic Neural Net Li	Flare: Clojure Dynamic Neural Net Library	ghosthamlet	12.651772	-7.9020257	story	6.0	148.0	1512744612	-11.176545
15882616	Is clojure.spec a replacement for st	Is clojure.spec a replacement for static typing? I ask because I've taken a look at clojure in the past and generally like what I see, but after moving from JavaScript to TypeScript at work I don't think I can ever return to a dynamically typed language again. Types are just priceless when refactoring, integrating someone else's code with your own or just exploring new libraries or APIs.	disease	12.506062	-7.8415346	comment	6.0	26.0	1512771902	-11.100462
15881440	Clojure 1.9 is now available	Clojure 1.9 is now available	myth_drannon	12.655815	-7.9048233	story	6.0	298.0	1512762699	-11.164821
16009127	> Clojure both Keeps and Breaks Trad	"> Clojure both Keeps and Breaks Tradition ... When Rich Hickey invented Clojure, he kept the gems of the LISP tradition, but jettison much of the muck. This is why Clojure has first instead of car and rest instead of cdrRich Hickey did not invent 'first' and 'rest'. LISP has those since the end of the 70s in language standards.From Common Lisp the Language, published 1984, chapter on lists:    [Function]
    first list 
    second list 
    third list 
    fourth list 
    fifth list 
    sixth list 
    seventh list 
    eighth list 
    ninth list 
    tenth list

    These functions are sometimes convenient for
    accessing particular elements of a list. first
    is the same as car, second is the same as cadr,
    third is the same as caddr, and so on.
    Note that the ordinal number"	lispm	12.642791	-7.8938155	comment	6.0	22.0	1514304019	-10.992886
17904778	I love this. But go ahead and have a	"I love this. But go ahead and have a look at the ""Who's hiring"" post and you'd be correct to think that investing in languages like Clojure does limit your career choices.It's depressing I know. I will always write my personal projects in Clojure but it's a shame that I can't rely on it as the primary means of making a living."	mavdi	12.652613	-7.8981214	comment	6.0	38.0	1536007547	-11.16033
17966905	Why Clojure?	Why Clojure?	kadishay	12.645136	-7.9015994	story	6.0	34.0	1536745525	-11.215749
18162167	That is pure and utter FUD I'm afrai	That is pure and utter FUD I'm afraid. My team has been working with Clojure for over 8 years now. We have tons of code in production, and we don't have any problems maintaining these projects. Furthermore, there's absolutely no empirical evidence to support the notion that static typing results in statistically significant reduction in defects, speed of development, or ease of maintenance. Considering how long both disciplines have been around, and the sheer amount of software written in each, that's quite the elephant in the room. I also have no idea who the people migrating from Clojure to OCaml, Haskell, or F# are. I don't think I've seen a single story about a company doing that.My experience is that dynamic typing is problematic in imperative/OO languages. One problem is that the dat	yogthos	12.485593	-7.841463	comment	6.0	27.0	1538939860	-11.126362
18701834	From the perspective of a (fairly la	"From the perspective of a (fairly large-scale at this point) app developer: I find it great that Clojure places such emphasis on backwards compatibility. In general, migration to newer Clojure versions is completely painless.The language has been designed by experienced and mature people and doesn't go through ""let's throw everything out and start again"" phases like so many other languages do."	jwr	12.659228	-7.9028006	comment	6.0	61.0	1545078132	-11.177048
18703971	Congrats. I'm trying to learn Common	"Congrats. I'm trying to learn Common Lisp for great good. And, I love that lisp is still alive. I think we still haven't learned all that lisp has to offer.For me personally, I think Clojure (or any lisp) targeting Go would be awesome.The JVM lacks a killer Go ""feature"" which is _native binaries/easy deployment. Common lisp and many other lisps lack community which is why I think Go+Lisp would make a great combo. Go, even though it is a new language, already outpaces (a much older) Common Lisp as far as libraries go due to the huge community Go has.I know there is `zygomys` but it doesn't reach Clojure popularity/maturity.Can Clojure target Go?Edit:Maybe it is infeasible but I think targeting JVM, Go, and JavaScript would give Clojure a ridiculous advantage over almost any current programm"	marcrosoft	12.660582	-7.8834352	comment	6.0	19.0	1545098465	-11.048024
18820026	Backstory:We did our last delivery b	Backstory:We did our last delivery back in late Spring of 2017, though we had experienced a decent amount of traction. The economics of on-demand gas delivery are difficult. B2B (e.g., delivery to car dealerships) seems to be profitable, but it is tough to achieve a price point high enough to warrant B2C sales (though perhaps in some ZIP codes it is possible (e.g., 90210)).It was a fun ride, especially getting to use Clojure. I was the founding engineer (converted from an independent contract), so had plenty of room to make tech decisions.Besides Clojure, there's a mobile app at that link as well, using Sencha Touch Framework. At the time we closed up shop, I had been experimenting with React Native + CLJS.You'll also find an repo called opt that contains some interesting routing optimizat	elwell	12.659286	-7.8943605	comment	6.0	24.0	1546555085	-11.220286
29747828	The Clojure Mindshare (2019)	The Clojure Mindshare (2019)	tosh	12.653531	-7.9045053	story	6.0	78.0	1640957425	-11.185518
29812347	Show HN: Bel in Clojure	Show HN: Bel in Clojure	stopachka	12.642121	-7.891997	story	6.0	116.0	1641405040	-11.186194
29824638	That is the frying pan to the fire.J	That is the frying pan to the fire.JDK 17 has most of the good features of Scala and Kotlin.Scala seems to be designed so that you can write a short book with very fluent and natural looking demos.  Make a small deviation from that and there is nothing fluent or natural about it.Kotlin is OK but isn't sufficiently better than Java to be worth using when any Kotlin dev is going to have to know Java and Java-Kotlin mapping pretty well to use libraries.  (It's a similar problem to Typescript.)Both Scala and Kotlin are sufficiently similiar to Java to provide no real benefit.  I'd point to Clojure as a language that is radically different from Java AND that takes advantage of the strengths of the JVM to be worth the cognitive load of having to know both a new and old language to be productive.	PaulHoule	12.495388	-7.7423935	comment	6.0	24.0	1641482584	-11.210044
30035052	I was initialy excited to try learni	"I was initialy excited to try learning Elm, until I saw some of the drama on the GitHub issues and a blog post about leaving the Elm ecosystem after having a bad experience with the project leads (I think [1] was the post).I've since put it in my little red box of ""hot but you'll be better off staying away from"", depsite the numerous podcasts praising the incredible effort and design that went into the language. Has anyone got any thoughts on this?[1]: https://lukeplant.me.uk/blog/posts/why-im-leaving-elm/"	marcus_cemes	13.009542	-7.692804	comment	6.0	34.0	1642842909	-12.763393
30149764	How about hiring though? If you have	How about hiring though? If you have a vacancy for a Clojure developer, how many applicants could you expect?When it comes to programming languages, I'd stick to the top 10 languages if your company isn't hip enough to attract a certain kind of developer on its own.	Cthulhu_	12.655212	-7.901338	comment	6.0	29.0	1643646258	-11.16243
16407681	Clojure is a Lisp. One of the distin	Clojure is a Lisp. One of the distinctive things about Lisp is that it has dialects. You wrote your comment using software written in another of them.The youngest of the companies you list was founded in 2007. The first stable Clojure release was in 2009.	montrose	12.660978	-7.9062505	comment	6.0	27.0	1518981587	-11.179789
17431152	>  It is more useful to think of err	>  It is more useful to think of error messages as non-existent than to think of them as bad.If this is true, my respect for Clojure just completely dropped.Error messages are a crucial part of a language and they are instrumental to the robustness of the programs it helps create.The fact they have been so severely neglected by the Clojure teams makes me think the authors of the language don't really understand modern large scale programming.	hota_mazi	12.653146	-7.914515	comment	6.0	41.0	1530372329	-11.180291
17643452	SICP Distilled – An Idiosyncratic To	SICP Distilled – An Idiosyncratic Tour of SICP in Clojure	Philipp__	12.684491	-7.845978	story	6.0	211.0	1532947074	-11.178272
17669735	Eden: a Lua-based scripting language	Eden: a Lua-based scripting language in Clojure	tosh	12.65026	-7.899151	story	6.0	50.0	1533194202	-11.146101
17706929	What Are the Differences Between Clo	What Are the Differences Between Clojure, Scheme/Racket and Common Lisp?	tosh	12.684781	-7.8456435	story	6.0	58.0	1533652158	-10.87865
17724492	I was just considering learning Cloj	I was just considering learning Clojure recently, what resources would you recommend?	mi_lk	12.6568165	-7.9000006	comment	6.0	21.0	1533825111	-11.184958
17846551	Just pulled an all-nighter deciding 	Just pulled an all-nighter deciding what to use instead of Elm. We have a 45kloc codebase in Elm and, despite having some big pros, the closed source development it goes through, along with the 0.19 debacle, just pushed us over the edge. The team is very motivated to ditch elm over something else.So, Bucklescript seems great (and it's wonderful how OvermindDL1 explains in the open his design decisions. An openness that I've missed in Elm), and IMO superior than Typescript, and comparable with Fable (in that case being mostly a matter of personal taste: F# vs ocaml).But, as long as we are trying new stuff, I've decided to use Clojurescript with Reagent and re-frame. The tooling around it seems very mature (even more so than Elm, but I may be wrong), with a good community and macros!For anyo	napsterbr	12.843143	-7.6916943	comment	6.0	50.0	1535300629	-12.650791
21145083	To people saying that writing a comp	"To people saying that writing a compiler is almost always an overkill - that's because you and author mean different things by the word ""compiler"". Or, in other words, that's because your intuition is based on the inflexible languages you're working with.It's not an accident that the talk/article is about Clojure[0]. A Lisp. In Lisp, ""writing a compiler"" is a fancier way of saying ""writing a possibly code-walking macro"", which is still just a fancy way of saying ""writing a function that transforms a tree into another tree, and having it run compile-time on parsed program source as the input"". 99% of the usual compiler work - tokenizing, building an AST, generating machine/bytecode, optimizing - is handled for you by the host Lisp compiler. All the mechanics are there, and all you have to d"	TeMPOraL	12.641129	-7.886955	comment	6.0	47.0	1570094516	-11.0845995
21190234	Clojure 1.11 planning	Clojure 1.11 planning	galfarragem	12.661945	-7.9157	story	6.0	188.0	1570526243	-11.177091
21299768	Learn ClojureScript: Discovering Seq	Learn ClojureScript: Discovering Sequence Operations	kendru	12.6446295	-7.8977537	story	6.0	143.0	1571507883	-11.134259
21300664	Does it make sense to use Clojure wh	Does it make sense to use Clojure while reading the book?	Stormwalker	12.6537695	-7.903915	comment	6.0	19.0	1571517979	-11.170974
12906782	I'm not particularly interested in E	I'm not particularly interested in Elm, but basically this post is about one problem in the language. One. This doesn't make the language a pile of garbage as the author seems to let you think.I'm a Python programmer. I fully expect dict keys to be able to be arbitrary objects. But after coding a lot in JS, I realized I could live without it. It's nice, but it's not a show stopper if I don't have it.Same goes here. Yes, typing is not as good as you wish it was, but Elm is a young language, give it time to evolve. In the meantime, what about the innovative things in it ?	sametmax	13.015971	-7.7059464	comment	6.0	43.0	1478673689	-12.766413
13056128	ClojureScript and optimized C [video	ClojureScript and optimized C [video]	tosh	12.658645	-7.9105167	story	6.0	52.0	1480348053	-11.161166
13201307	My biggest complaint remains that wi	My biggest complaint remains that without a meaningful concurrency story in js, the benefits of clojure dont make much sense to me.Its just another hard to debug compiles to js language.I get you can share some code between server and client... but we've used it in production and now we're getting rid of it; there just wasn't a compelling reason to keep it over es6.	shadowmint	12.643081	-7.875779	comment	6.0	37.0	1481993207	-11.146788
13283582	So, why not clojure? (Warning: subje	So, why not clojure? (Warning: subjective, and a bit toungue in cheek):- Clojure is a Lisp. Lisps are very elegant in their simple tree syntax, so compilers like them, and reasoning about Lisp code is a joy. However no one has yet figured out how to represent Lisp code in good a way that doesn't require a large number of parentheses, often stacked together in groups of three or four. If you have a slight astigmatism this (((()) will not help.- It's a jvm language. That has gives all the benefits you want in a functional language such as type erasure meaning you can't make a data structure of primitive types without either pretending they are objects (boxing) or writing a custom type. Also, you have access to the vast amount of jvm libraries, almost all of which use mutable data structures 	alkonaut	12.5135355	-7.8020706	comment	6.0	38.0	1483091825	-11.132899
13342107	I hear this a lot, but it totally my	I hear this a lot, but it totally mystifies me.You lose all the good parts of clojure when you go into the js runtime; stm, parallel processing, java interop, hot reloading, and it pulls in some really quite large js dependencies, and it's impossible to debug. Even console logging becomes a case of 'convert to readable object and log' using special helpers.What's the benefit?I don't see any meaningful reason to use clojure in this context; what's the draw? Why would you bother over any other compiles-to-js language?You.. just like the syntax? That's the best answer I've gotten so far.	shadowmint	12.646175	-7.8832674	comment	6.0	23.0	1483756956	-11.133072
13373426	A deep dive into ClojureScript reage	A deep dive into ClojureScript reagent	kimi	12.656508	-7.8917704	story	6.0	107.0	1484137247	-11.15062
13410398	The last time I wrote any ClojureScr	The last time I wrote any ClojureScript was over a year and a half ago. I played around with Reagent a bit and remember really liking it. I never used it for any serious projects or in anger though - how is the tooling and debugging experience? I would love to use ClojureScript for my front end work (since I always end up using React + ImmutableJS anyways) but developer ergonomics are really important to me.	arms	12.659111	-7.863376	comment	6.0	21.0	1484579865	-11.1399765
13478310	Since they cite me (and my essay fro	Since they cite me (and my essay from 2014) as part of their decision making process, I want to throw in 2 cents here. They ended up deciding on Go, whereas I have ended up preferring Clojure, yet I agree with a lot of what they say, so I'll try to clarify why I ended up with a different decision than what they made.I understand what they mean when they write:I think the first time I appreciated the positive aspects of having a strong type system was with Scala. Personally, coming from a myriad of PHP silent errors and whimsical behavior, it felt quite empowering to have the confidence that, supported by type-checking and a few well-thought-out tests, my code was doing what it was meant to. There are times when I appreciate the strict type-checking that happens in Java. I do get what they 	lkrubner	12.522464	-7.8553834	comment	6.0	49.0	1485316199	-11.10335
13482090	The way you describe your experience	The way you describe your experience with Scala makes me think you only had a very superficial look at it.At it's core Scala is very simple & the syntax is very regular, far more than Go or Java and a lot less complex than C++. It's the most expressive typed language on the JVM, so if you like to think in types & you're on the JVM it's your best option.Clojure is untyped, I hear many people praising it but I don't know any big project done in Clojure. So if you're doing short-lived projects I'm sure it can shine but for software that will be around for more than 5 years I would stay away from it. Btw, if misused, just like Scala, Clojure code can be extremely cryptic.Go likes it's superficial simplicity, syntactic irregularity & stubbornly refuses to accept that PL design has evolved since	oelang	12.487762	-7.804634	comment	6.0	24.0	1485357792	11.913714
27866065	Feels like Elixir has stolen much of	Feels like Elixir has stolen much of Clojure's appeal and 'thunder' as the niche pragmatic functional language.	rainygold	12.655124	-7.825984	comment	6.0	42.0	1626532471	12.881143
27901030	What all the critics miss is that Le	"What all the critics miss is that Lein is ""Easy"" but tools.deps, tools.build are ""Simple"". Rich wants all of clojure to be built from simple orthogonal parts that compose together. Ideally a multi-purpose tool like leiningen should be built on top of those simple parts. Other tools can re-use those parts in different ways. With Leiningen - its a great tool but it's a complex thing that you take on an all-or-nothing basis."	fungiblecog	12.646668	-7.885821	comment	6.0	24.0	1626828487	4.3840036
12136677	I don't feel like clojure stalled ou	I don't feel like clojure stalled out. You have to realize the redmonk rankings are using very weak heuristics to get these results. I'd rather choose languages and tools by how much they match the problem space rather than how popular they are at any particular point in time.If you trim out all the worthless SO questions/anwsers you'll get radically different rankings on redmonk. JavaScript could very easily drop from its first place doing just that.I don't get why people chase popularity in programming languages. That's what you do in a pop culture, not in an engineering one.	jeremiep	12.6525135	-7.8878584	comment	6.0	27.0	1469107655	-11.161721
12429437	Literate Clojure Programming: Anatom	Literate Clojure Programming: Anatomy of a Org-Mode File	type0	12.645455	-7.9009542	story	6.0	105.0	1473073216	-11.183197
35496792	He doesn't go into much detail here 	He doesn't go into much detail here but what I _imagined_ he meant was that if someone came to an interview excited about Elm but knew nothing about the company, that would be a strike against them. If someone came excited about Elm _and_ was interested in the company's product that was fine.But this is just me filling in the blanks as I think they should be filled in. It'd be great to see him spell this out a bit more.	autarch	13.01083	-7.692887	comment	6.0	22.0	1680982550	-12.762424
28399811	This project looks awesome, though I	"This project looks awesome, though I'm a bit sad that ""performance"" is a non-goal as stated in the README. Clojure being able to compile to a single shippable binary is just what I need in my life. Kudos to the author."	masijo	12.645353	-7.890676	comment	6.0	65.0	1630636427	-11.160914
28595853	All this just to avoid writing JS in	"All this just to avoid writing JS in nodejs for simple scripts? why add more complexity to simple things? just to write JS with parenthesis? clojurescript is overkill and definitely tedious to use for this because is not suited for scripts just doing lots of imperative, side-effecting stuff and dealing constantly with mutable APIs.I love lisp but... https://github.com/borkdude/nbb/blob/main/examples/puppeteer...""Look how cool I'm, I downloaded this thing just to add parenthesis to my JS script!"""	ithrow	12.651564	-7.860752	comment	6.0	32.0	1632156582	-11.143592
22422347	Show HN: Word Champions, a word game	Show HN: Word Champions, a word game written in ClojureScript	nathell	12.635238	-7.8757315	story	6.0	76.0	1582720263	-11.023809
22459781	While we are at it - how do you refa	While we are at it - how do you refactor a mid-sized/large Clojure project?	zerr	12.650988	-7.900761	comment	6.0	25.0	1583101327	-11.178195
22754288	Yep, that's why Clojure struggling a	Yep, that's why Clojure struggling and has no future. Not strong in any domain and doesn't have any fundamental benefits over other dynamic programming languages like JS/Python/Ruby.	Scarbutt	12.645806	-7.8875313	comment	6.0	27.0	1585781190	-11.154575
22754370	That is only if you try to program C	"That is only if you try to program Clojure as if you were programming JS/Python/Ruby. In this case I can understand you may think this is funky, strange but otherwise useless language.The trick with any Lisp is to ""get it"". Once you do there is no comparison between Lisps and any non-Lisp language.Let's compare it in some useful way. If I was assembly developer for my entire life, ""getting"" C++ would be comparable to getting Lisp for any JS/Python/Ruby developer.From my point of view JS/Python/Ruby is just a reiteration, variation on roughly similar, impaired subset of features that I can roll off in Lisp on my leisure. By definition, any language feature can be written in Lisp (well... more in Common Lisp than in Clojure which is hindered by its integration with Java environment) which is"	lmilcin	12.702685	-7.8725853	comment	6.0	20.0	1585781794	-10.839305
22784148	Guide to Starting with Clojure	Guide to Starting with Clojure	flaie	12.657597	-7.9037886	story	6.0	58.0	1586068668	-11.17626
22809438	Clojure is the most productive(and b	Clojure is the most productive(and beautiful) language in existence(personal preference) as long as you don't have to leave its world.I stop using it because the lack of Clojure libraries pushed me to use Java libraries, and that was a life-sucking experience. Java is fine as language but you cannot say the same about the APIs of many of its libraries. I also started sensing that new open source libraries are not being created in Java which worsens the story for Clojure.	ithrow	12.627302	-7.8768897	comment	6.0	36.0	1586311725	-11.165222
22817323	I'm reluctant to because I've had ze	I'm reluctant to because I've had zero time to dedicate to it for a couple of years and there's a laundry list of improvements I have been intending to make.But, with that caveat, it's https://www.folktunefinder.comIt's a mix of clojure and java. And there's a half written rust search backend waiting for a rainy day...	afandian	12.628672	-7.896691	comment	6.0	18.0	1586381058	-11.1561165
22824318	For me, the best thing I got from th	"For me, the best thing I got from this critique was the link to this 2018 talk by Evan:The Hard Parts of Open Source, https://www.youtube.com/watch?v=o_4EX4dPppAI found Evan's talking style really entertaining and enjoyable, and I totally relate to the first part about ""why don't you just..."" and ""have you thought about delegation...""!The HN comments here are near uniformly negative towards Elm and supportive of Luke's criticisms.  Fair enough, it's a reasoned critique and those are definitely issues that would affect users.I found the critique informative and useful.  I don't use Elm though I've watched with passing interest for a while.  Now I feel there are gotchas or expectations I should be aware of if I'm considering using it, about the way the project is heading.But I felt it came o"	jlokier	13.012916	-7.6948547	comment	6.0	39.0	1586450254	-12.768474
33165313	Not to hijack the thread, but does a	Not to hijack the thread, but does anyone know what's going on with Elm right now? There hasn't been a release since Oct 2019 or any real communication from Evan (that I can see in public) for quite a while.	ch4s3	13.013016	-7.693712	comment	6.0	28.0	1665505448	-12.749576
33455782	Elm is stagnant. There's been no rel	Elm is stagnant. There's been no release since October 2019. It's a problem because there are known bugs.Elm is also unstable; there's no guarantee Evan won't break things in the next release.It's a bad combination. A fork could in theory fix this. Has anyone done it, though?	skybrian	13.013642	-7.693043	comment	6.0	19.0	1667502181	-12.7606945
33457070	16 years.  Working at the Senior/Sta	16 years.  Working at the Senior/Staff level.Most recently Clojure work.  I’ve done a lot of Java of course, although I’ve been rejected from some of those jobs because I spent the last year doing Clojure full time instead of Java.	jcadam	12.653924	-7.899747	comment	6.0	48.0	1667507443	-11.129858
33462445	One of the main reasons I don't even	One of the main reasons I don't even want to touch Clojure is because I don't want to be trying to figure out Java stacktraces when things go wrong.	pmoriarty	12.639666	-7.887284	comment	6.0	34.0	1667538485	-11.183263
26714119	For those with experience, would you	For those with experience, would you say that ClojureScript for frontend stands on its own without a Clojure backend?	ragnese	12.654436	-7.8671002	comment	6.0	27.0	1617727455	-11.154508
26714589	Since this thread/Clojurescript is g	Since this thread/Clojurescript is getting some love I'd like to express something to a hopefully receptive audience:There was a point where Clojurescript and Javascript sort of walked hand-in-hand during the advent of when React started to make sense in the minds of the community[0].It felt really exciting because of the cross pollination that was happening between the two languages, Redux felt very familiar, and we have re-frame for clojurescript.There was a ton of promise with Apollo.js and an improvement on the `connect` functionality by upgrading to a proper query language for getting state into a component versus wrapping functions around multiple `state.some.path` `state.some.other.path`.David Nolen built om.next around that very idea, it was basically Apollo.js lite, and it was ver	pizzeriafrida	12.661538	-7.8331923	comment	6.0	30.0	1617729389	-11.1354475
27258218	Ask HN: Best Course to Learn Clojure	Ask HN: Best Course to Learn Clojure?	35mm	12.661546	-7.9023056	story	6.0	12.0	1621801132	-11.174701
27276992	Developing mobile digital key applic	Developing mobile digital key applications with ClojureScript	swannodette	12.659072	-7.8915257	story	6.0	101.0	1621952067	-11.177769
27387568	we have a clojure codebase that's ab	"we have a clojure codebase that's about 100k lines.  Honestly I'm kinda fed up with it.   Certain 3rd party libs we've used have been abandoned.  We wrote our own libs for a major framework and it is failing behind.Too many ""I'm very clever"" functions that are hard to understand and also have subtle bugs."	fnord77	12.662923	-7.9011955	comment	6.0	27.0	1622755620	-11.161754
27387853	> One of the coolest parts of our co	> One of the coolest parts of our codebase is the new general purpose language at its foundation. Though the semantics of the language are substantially different than Clojure, it’s defined entirely within Clojure using macros to express the differing behavior. It compiles directly to bytecode using the ASM library. The rest of our system is built using both this language and vanilla Clojure, interoperating seamlessly.Actually this sounds quite horrible.	chromanoid	12.640983	-7.8873687	comment	6.0	36.0	1622757106	-11.136504
27412676	I was one of those who disagreed wit	"I was one of those who disagreed with that, but then I was forced to learn several new languages for work.  Now I agree with it wholeheartedly.my favs:-clojure for processing deeply nested data-rust for general stuff-java for concurrency support and general stuff-c for easy pointer manipulation and ""tricks""-sql-bash for scripting (I'm that weirdo who would rather make a huge shell script rather than using python)I still need to find something good for arrays/ matrices.  MATLAB was kinda fun I can't see it being used in production in anger too easily"	fnord77	12.596477	-7.848011	comment	6.0	24.0	1622982303	-11.057039
38152073	Please PLEASE enough with the charac	"Please PLEASE enough with the character assassination of the Elm guy.He wants to run his own project his own way.There's a small but dedicated residue of people who just can't stand being told ""no"" and go around crapping on the kid whenever they get a chance.I get it.  You don't like Evan's project management style.  Move on already.- - - -The fact of the matter is that he's a person who took his thesis, made it into a product, and got traction in the real world.  People have used Elm to make things.  Things that go.How many of us can say the same?And that's before you get to all the fascinating and as yet still-too-obscure things that the OP talks about.  Things that are in part a little more widely known and understood thanks to Elm project."	carapace	13.010269	-7.694516	comment	6.0	37.0	1699198924	-12.763511
38527646	> Maelstrom is a Clojure programI wa	> Maelstrom is a Clojure programI was interested in trying this out, but why closure?	Racing0461	12.645232	-7.902414	comment	6.0	29.0	1701756610	10.502174
38541028	Clojure’s biggest issue is definitel	Clojure’s biggest issue is definitely the ecosystem. As far as the bell curve goes for accessible and usable tooling it’s usually either on the far left end and terrible but easily accessible (but doesn’t follow the functional paradigms well) or it’s on the far right end -extremely esoteric, LOTR quote in the readme, everything is data to the n-th degree, only accessible to dragons who can write emacs plugins blindfolded and upside down. The language itself is amazing, and Java interop is much better than Aphyr makes it sound. If there was a rails or Django for Clojure for instance (or better yet, a Phoenix) it would be an easier sell and methinks more widely adopted. The juice needs to be worth the squeeze - particularly when you’re convincing a team to jump from Algol style imperative la	whalesalad	12.646763	-7.8882113	comment	6.0	42.0	1701844549	-11.16298
14766627	Is this the only big success story f	"Is this the only big success story for Clojure or other companies using the Lisp family of programming languages? I know there is Paul Graham's Viaweb. [1] Does anyone know of other examples?I like the fact that they are a practical company, using Go when needed where ""static dependency compilation and fast start-up are more important"". I wonder if the ClojureScript's annoucement on integration of NodeJS modules [2] changes that? Also, Lumo [3] is definitely a move in the right direction for this, addressing the slow start-up times for Clojure/ClojureScript, making it suitable for shell scripts and CLI binaries.> Having a lingua franca also helps reduce overhead when engineers want to move between layers of the stack.The way I see it, Clojure allows you to use a single language and syntax "	priornix	12.643246	-7.885361	comment	6.0	37.0	1499993482	-11.101974
14928645	I'm an EE who is getting more and mo	I'm an EE who is getting more and more interested in software development and computation in general. I've been reading Paul Graham and Peter Norvig and decided to learn Scheme. Any thoughts on Scheme vs. Clojure for learning?	extra__tofu	12.659828	-7.8754325	comment	6.0	19.0	1501854923	-11.055446
14928704	Having spent some time programming i	Having spent some time programming in Clojure, for the purpose of expanding my brain, I suspect a better Lisp to start with might be one of the classics - Racket, Common Lisp, etc... One of the reasons I gave up on Clojure was the lack of documentation of libraries, the bad debugging experience (those stack traces!) and the fact that there's no avoiding the JVM. They're all distractions to the learning (that was 2 years ago, I'd be happy to hear that things have changed).I think Clojure is a great language, but if you just want to expand your mind via a Lisp then I think you'll get more for your time with another implementation.	vosper	12.661851	-7.887446	comment	6.0	25.0	1501855287	-11.04582
14952366	Seems like a cool project if you alr	Seems like a cool project if you already know Clojure and hate the start up time, but also seems like it sidesteps one of the main benefits of Clojure which is Java interop obviously... Which Clojure has to do a fair number of handsprings to accomplish. Begs the question, why pick Clojure as the lisp to compile to C++? Why not Racket or Common Lisp etc?	gleenn	12.668138	-7.8863873	comment	6.0	28.0	1502151209	-11.102464
15082799	I tinkered with D a bit (along with 	I tinkered with D a bit (along with Nim, Dart, and C as a comparison) while writing a Clojure interpreter.D seems to be a nice language, but I found the editor integration wasn't the best. I also found it annoying that the docs used `auto` all the time, so you could never figure out the right type annotations for their APIs (e.g. I want to call the foo API and return its value from my method, but the docs all use `auto` to refer to its return value, so I don't know how to annotate my method.)I liked Nim better in almost every way but one: the compiler was fickle and would just fail silently sometimes.	christophilus	12.578742	-7.88175	comment	6.0	70.0	1503505404	3.1037672
15092647	Rich Hickey's Greatest Hits (2013)	Rich Hickey's Greatest Hits (2013)	tosh	12.66338	-7.9098506	story	6.0	109.0	1503599078	-11.18511
15183963	The Quest to Restore American Elms: 	The Quest to Restore American Elms: Nearing the Finish Line	ohjeez	13.010025	-7.691361	story	6.0	98.0	1504708266	-12.755449
15392477	Learning Clojure Made Easy	Learning Clojure Made Easy	ertucetin	12.649089	-7.900357	story	6.0	137.0	1507039489	-11.190133
15396992	Serious question: what problems does	"Serious question: what problems does Clojure solve for programmers? Every time I try a new and interesting language I end up saying ""Gee, that was pretty fun I guess"" and then go back to whatever it is that I was using prior to that. I have never been able to justify moving away from Python or C. Learning a new language can be fun and enlightening in it's own ways, but it also feels like a waste of time.Just curious if anyone can add some perspective."	justaquickquest	12.648006	-7.8958573	comment	6.0	21.0	1507072168	-11.111834
15629162	Lightmod – A beginner-friendly, all-	Lightmod – A beginner-friendly, all-in-one tool for full stack Clojure	malloryerik	12.650369	-7.8992167	story	6.0	152.0	1509886228	-11.163325
20266171	I have never really understood what 	I have never really understood what people get from these slides, but my while my experience with clojure is extremely limited I can say that I found it to be rather interesting but hard.I could not grasp several error messages, took me a long time to write something to a database and it didn't really feel at all natural to me. But I guess you'll have to get used to the functional nature, but I don't believe all the hype about functional programming in general.If it was so effective as people seem to claim, I am sure everybody would use clojure. My experience is rather the reverse, it is harder and takes a long time to develop in. Maybe it's more predictable and is better software with less bugs in the long run, but I wouldn't really know since I lack the experience.A lot of programming la	ecmascript	12.635036	-7.883722	comment	6.0	21.0	1561397856	-11.140303
20362248	Clojure and Deps.edn: A basic guide	Clojure and Deps.edn: A basic guide	tomekw	12.650957	-7.902356	story	6.0	138.0	1562332407	-11.182518
20381423	React Server Side Rendering with Gra	React Server Side Rendering with GraalVM for Clojure	tosh	12.653166	-7.8639817	story	6.0	175.0	1562581104	-11.182269
20383907	I've noticed HackerNews has a lot of	"I've noticed HackerNews has a lot of Clojure activists posting.I worked with Clojure for about a month.  Then I decided to go back to NodeJS.- I have no need to java or JVM.- The Clojure stack traces aren't easily decipherable- One doesn't need Clojure for functional, immutable programming.  NodeJS is flexible & has a massive community with tons of packages, including ones for immutable work.  Functional programming on the other hand is simple-- just create & use JS functions (in the context of JS that is).- Ultimately I saw no need for ClojureWhat I do see though, is a small group of outspoken activists pushing clojure.Now, why don't I want to use it, besides what I've written above?Another contributor to my dislike of the language/""community"" is the founder's stance-- Rich Hickey in this"	pdub1	12.652887	-7.8964334	comment	6.0	18.0	1562602177	-11.172044
20439113	In Scheme, the only way to loop is v	"In Scheme, the only way to loop is via recursion. In Clojure, all high level functions and looping macros (for/doseq) are implemented via recursion as well (loop/recur).Yes, it requires significant paradigm shift when you start to use these languages, but after a while, you start to appreciate high level functions (map, reduce) instead of language looping constructs (for, while) - they can be easily composed, parallelized, scaled over cluster, refactored... Even code looks much cleaner.You like it even more if you are mathematician, because things looks more ""natural"" :D"	dig1	12.613816	-7.8802	comment	6.0	30.0	1563180710	12.367645
20548092	My personal choice would be Clojure.	My personal choice would be Clojure. I learned Racket and Common Lisp but haven't used them build something production-grade yet. I don't even know how to properly build, deploy and monitor a Racket server yet.Racket is good but the toolchain and libraries are far behind Clojure. Especially Cider and Cursive are so great, and for libraries, there are a lot of solid ones like Ring/Compojure, interesting things like Duct, Pathom, Fulcro.Common Lisp is also good, SBCL/Slime is solid, but it has its own idioms, a multiple paradigm Lisp-2 and feels pretty different from Scheme and Clojure. I found single-paradigm languages like Clojure and Scheme are sufficient to do most things already.Java-world-wise, you don't have to deal with Java most of the time if you don't want to. There are plenty of 	namelosw	12.663898	-7.869669	comment	6.0	45.0	1564328640	-11.013867
20551154	Am I wrong for saying that the Cloju	Am I wrong for saying that the Clojure community has not yet achieved consensus for things as simple as a build system? In some ways that seems like there would be more up-and-going friction than the JS build world.	traderjane	12.649837	-7.896284	comment	6.0	25.0	1564368395	-11.147994
20606204	This is not like the clojure is to j	This is not like the clojure is to java, it's only a syntax transformation, superficial.Usually lisp and FP means that you get immutable data structures and a good concurrency system, both of which you get in clojure.I looked at this a while ago and figured it's not useful for production, but an interesting project none the less.	fhennig	12.636034	-7.882341	comment	6.0	29.0	1564923139	-11.050722
20805613	Duckling: a Clojure library that par	Duckling: a Clojure library that parses text into structured data	getdreambits	12.6416855	-7.897963	story	6.0	121.0	1566870528	-11.170283
20846016	Need someone to explain why I should	Need someone to explain why I should use clojure over scala because typelevel seems pretty well developed	nautilus12	12.482736	-7.815951	comment	6.0	29.0	1567256219	11.887082
20847136	I love the language. I’ve never foun	I love the language. I’ve never found a language where I found the learning curve so shallow for being able to do so much.That said, I do find myself pining for the ability to easily compile a static executable (maybe with a small embedded runtime). Some time ago there was an attempt to port Clojure to Gambit Scheme, but that appears to have fizzled.More recently, I’ve seen Ferret, which compiles a subset of Clojure down to C++. Also Joker, which is a Clojure-ish interpreter in Go.Then there’s GraalVM, which I don’t trust, because it’s Oracle.I feel like the relative lack of traction for non-Java / non-Javascript implementations is part of the brilliance and sadness of Clojure. Namely, the JVM is a rocket ship and a boat anchor.Racket (modulo the uncertainty cast by the Racket2 discussions	peatmoss	12.650958	-7.8783774	comment	6.0	19.0	1567267678	-11.115499
20921554	I haven’t had a chance to spend much	I haven’t had a chance to spend much time with Clojure, but I have spent time learning both Groovy and Scala which are similar.  Both have a steep learning curve (which I can’t say I’m entirely over), but I have noticed that, in the nearly 3 decades I’ve been programming, I’ve never seen anything with a steep learning curve really catch on.  The things that catch on like wildfire are things like Java, JavaScript, Cobol, VB, C#: things that take a moment to learn but a lifetime to master.  The reason seems pretty obvious - you can produce results and feel productive (and demonstrate productivity) quickly even if you’re less productive in the long run.  Short term results matter more than long term efficiency.	commandlinefan	12.536178	-7.8377523	comment	6.0	26.0	1568057683	-10.933033
14007257	Show HN: My Interactive ClojureScrip	Show HN: My Interactive ClojureScript book	jdeisenberg	12.6410055	-7.8833847	story	6.0	134.0	1490988286	-11.123868
14301180	Typically you are limited at compile	Typically you are limited at compile time because Lisps -- especially Clojure -- do not allow the same computing resources you get at runtime to be used at compile time, so there are some clear limits.This can be true in C++ as well, but those limits are quite high and are easily set to something else. Perhaps Clojure also allows you to reset what these limits are.	hellofunk	12.650118	-7.8927555	comment	6.0	29.0	1494346039	-11.122933
14405132	Simple Ain't Easy, but Hard Ain't Si	Simple Ain't Easy, but Hard Ain't Simple: Leaving Clojure for Ruby	sharksandwich	12.636983	-7.891884	story	6.0	34.0	1495572106	-11.181974
14416420	Reagent: Minimalistic React for Cloj	Reagent: Minimalistic React for ClojureScript	tosh	12.664916	-7.869299	story	6.0	91.0	1495708345	-11.178205
14420018	"Clojure's ""killer feature"" for me is"	"Clojure's ""killer feature"" for me is the by-default persistent data structures.Are there any other functional languages out there with similar features? Lisp or otherwise."	ubercow	12.583854	-7.8442974	comment	6.0	20.0	1495745044	-11.15019
14420856	It is now official. Netcraft has con	It is now official. Netcraft has confirmed: Clojure is dying.One more crippling bombshell hit the already beleaguered Clojure community when Lambda Island confirmed that Clojure market share has dropped yet again, now  down to less than a fraction of 1 percent of all new code. Coming on the heels of a recent Netcraft survey which plainly states that Clojure has lost more    market share, this news serves to reinforce what we've known all along. Clojure is collapsing in complete disarray, as fittingly exemplified by failing dead  last in the recent comprehensive programming languages survey.You don't need to be the Amazing Kreskin to predict Clojure's future. The hand writing is on the wall: Clojure faces a bleak future. In fact there won't be   any future at all for Clojure because Clojure	reality_czech	12.656232	-7.900124	comment	6.0	23.0	1495754160	-11.133667
14420912	Oddly, as someone who was reasonably	Oddly, as someone who was reasonably into Common Lisp, what really viscerally turned me off to Clojure was the use of square brackets.This sounds petty but I actually have some rationalization for it.  Once you learn to read Lisp (mostly looking at the indentation and ignoring the parens) it's really nice that there's only one kind of delimiter in the language.  It allows a lot of easy structure editing with a decent editor.  I had emacs set up to use the unshifted square bracket keys to create and exit balanced parenthesis pairs.  Once you got used to this, this was really pleasant to write and mutate code.As soon as I saw Clojure, I knew that my setup would unavoidably get twice as complicated because they added another delimiter that's used in random places in the code.  (Why are functi	phs2501	12.623708	-7.867475	comment	6.0	31.0	1495754893	-11.041723
14421770	Lisp used to be the language for AI,	Lisp used to be the language for AI, could Clojure possibly steal the machine learning niche back from Python?	seanmcdirmid	12.658386	-7.8851843	comment	6.0	35.0	1495768653	-11.061223
14480559	Clojure Linear Algebra Refresher: 1 	Clojure Linear Algebra Refresher: 1 – Vector Spaces	tosh	12.631516	-7.9046435	story	6.0	142.0	1496569393	-11.184636
30732384	I'm a member of the team that create	I'm a member of the team that created Polylith, so feel free to ask questions or give feedback.Polylith has been gaining momentum within the Clojure community. As an example, you can follow along with Sean Corfield's journey migrating the World Singles codebase to Polylith: https://corfield.org/blog/2021/02/23/deps-edn-monorepo/There's an active Slack channel, with people and teams using Polylith on both commercial and side-projects: https://clojurians.slack.com/archives/C013B7MQHJQOutside of the Clojure community, there's a project to port Polylith to Python, using Poetry: https://pypi.org/project/poetry-polylith-plugin/We'd love to see it get ported to other languages too!	logarhythm	12.655534	-7.8902216	comment	6.0	25.0	1647682034	-11.141231
31365224	Notes on Virtual Threads and Clojure	Notes on Virtual Threads and Clojure	Borkdude	12.63818	-7.894937	story	6.0	110.0	1652435155	9.023557
31655993	Why would someone use Joy on Janet o	Why would someone use Joy on Janet over Reitit & Ring on top of Clojure?I see Janet is small and embeddable. Does that mean faster startup time than a full JVM? It's nice that most of Janes the literals match Clojure, so aside from `def` inside a function (as opposed to `let`), it's natural for a Clojure user to read.	pgt	12.685152	-7.883048	comment	6.0	27.0	1654616582	-11.124026
25623494	I was using Clojure for a while befo	I was using Clojure for a while before 2018, and the error messages were brutal. Has that improved since then?	fmakunbound	12.649583	-7.905581	comment	6.0	18.0	1609696821	-11.176808
25622943	Having used Clojure and Common Lisp 	Having used Clojure and Common Lisp professionally, I think advocates for REPL driven programming universally overstate the utility of a first rate REPL.Yes, it’s nicer than Python’s. Yes, it’s convenient. No, I never ended up doing my development in the REPL first. Why? Because editing mistakes in a REPL usually sucks, because a REPL is not a text editor.What I ended up using heavily was REPL to file integration, which gave me the ability to write a function normally, evaluate it in the attached REPL session, and then play around with it in the REPL. This is far short of the “REPL driven development” that’s commonly discussed, and frankly something that’s probably possible with the Python REPL if they wanted to.Editing data and functions in the REPL is a neat trick, but it’s a double edge	ashtonkem	12.599384	-7.8412986	comment	6.0	41.0	1609693077	-11.110242
35728170	Aside, I remember HN in 2009 or so w	Aside, I remember HN in 2009 or so where Clojure was a daily homepage staple and Rich Hickey was putting out his talks about Clojure and code design.I watched a lot of that and used Clojure fulltime for five years. Wonder what he's up to these days.	hombre_fatal	12.653589	-7.904636	comment	6.0	35.0	1682603799	-11.145268
35852792	I work with clojure and test driven 	I work with clojure and test driven development is not nearly as productive as repl driven development imo.	jgoodhcg	12.629173	-7.874479	comment	6.0	26.0	1683475254	-11.13412
36043358	Would you mind sharing a link / cita	Would you mind sharing a link / citation for this? Elm releases are intentionally long and the project appears to be ongoing [1].[1]: https://iselmdead.info/Edit: moved the position of the citation.	gekkostate	13.011256	-7.693805	comment	6.0	26.0	1684845205	-12.759305
36094258	There are things I'll never understa	There are things I'll never understand. Why would anybody do this? Why Clojure and not Emacs Lisp?	ReleaseCandidat	12.660224	-7.8865175	comment	6.0	22.0	1685191159	-11.046014
36380636	Moldable Live Programming for Clojur	Moldable Live Programming for Clojure	simonpure	12.647759	-7.8979197	story	6.0	105.0	1687098947	-11.165277
29009883	I love Lisp and Scheme and all their	I love Lisp and Scheme and all their relatives (Clojure, Logo, Racket, etc.). However, the fact of the matter is, Common Lisp has not kept up with modern developments in terms of presenting a cohesive ecosystem with forward momentum. Everybody is off on their own doing their own thing with no shared goals or cohesion.Clojure seems to have this (I have not used Clojure much, so I don't really know). Elixir definitely has this. I think Elixir is the language ecosystem to look at in terms of having a solidified core language that is essentially done, and now the goal is to continue to flesh out the ecosystem with things like Nx, Axon, Livebook, Liveview, Mix improvements, Phoenix, etc. Elixir is pretty similar to Lisp/Scheme anyway given its macros, ability to live update, dynamically typed p	bmitc	12.673856	-7.841107	comment	6.0	29.0	1635312845	-10.982154
29110468	What do most here use Clojure for? F	What do most here use Clojure for? For me, there was little value in using it over nodejs for single server CRUD apps with postgres. Some things I liked are namespace keywords, REPl integrated with your editor, immutability. But still, it felt like swimming against the current. Immutability is not as useful in a single-threaded event-loop like nodejs. No third party SDKs, even though I know Java using the Java SDKs was tedious labor, most Clojure wrappers are pretty bad too, so more interop.	romero-jk	12.65231	-7.884558	comment	6.0	31.0	1636048802	-11.149878
29202544	But repl workflows are not special t	But repl workflows are not special to Clojure and Scheme. People in JS set breakpoints in their IDE, pause at a point in their script to interactively explore program state all the time.Is this not the same?	threatofrain	12.639278	-7.868829	comment	6.0	32.0	1636740443	-11.134266
29552485	I've never done any Lisp before, is 	I've never done any Lisp before, is Clojure a good starting candidate?	nop_slide	12.664959	-7.8769526	comment	6.0	18.0	1639495245	-11.026748
29571786	Clojure Macros and Metaprogramming	Clojure Macros and Metaprogramming	todsacerdoti	12.629448	-7.8802576	story	6.0	110.0	1639603308	-11.030847
34811575	I’m noticing a lot of clojure posts 	I’m noticing a lot of clojure posts recently. Has the language become more popular lately? Is there any reason behind it?	thih9	12.660346	-7.9005575	comment	6.0	28.0	1676499603	-11.180694
24471015	Show HN: O'Doyle Rules – a new rules	Show HN: O'Doyle Rules – a new rules engine for Clojure	gw	12.646641	-7.9007564	story	6.0	100.0	1600095940	-11.163132
25374654	The truth is that the candidates we 	The truth is that the candidates we are receiving are barely able to code in Java. Not all know differences between linked lists and arrays and if they know what a breakpoint is they are hired.Now, imagine giving the people environment that imposes no structure on your project and gives hyper powerful tools like macros and you are in a big problem.At least with Java you get Spring and this is how you do endpoint, this is how you connect to the database, and so on. The structure is suboptimal and redundant but at least they are getting some guidance which are most likely already familiar with.In Clojure, as a lead of the project, you would have to do the same but now it would be up to you to define all of that guidance. The question is, are you better at this than entire organization that s	lmilcin	12.651879	-7.8962693	comment	6.0	21.0	1607613974	-11.152254
25376433	Many Clojure companies find it easy 	Many Clojure companies find it easy to hire smart non-Clojure developers and teach them Clojure. You can learn the basics in a week or two and be a pretty effective Clojure developer (especially if supported in a team) pretty easily.	puredanger	12.657454	-7.9033837	comment	6.0	25.0	1607623348	-11.171421
32742897	Analyzing Every Clojure Project on G	Analyzing Every Clojure Project on GitHub	jjwiseman	12.65583	-7.900695	story	6.0	85.0	1662496755	-11.174525
33010596	I'm an experienced Vue/Nuxt develope	I'm an experienced Vue/Nuxt developer. After trying out Typescript and Svelte, I think I want to go all in on ClojureScript.Currently learning through an open source book right now (https://www.learn-clojurescript.com/). I was planning on paying for it after I read the book to see if it was worth it, but I paid for it halfway through.	b0afc375b5	12.656435	-7.884017	comment	6.0	25.0	1664385869	-11.169845
31957770	One submission in the past with lots	One submission in the past with lots of good discussions: https://news.ycombinator.com/item?id=18538123 | 734 points | 2018 | 281 commentsOne of the main takeaways personally from this post, is the unique position Clojure (and other lisps) are in, where language additions can be done as libraries instead of changing the core of the language.Other languages don't (always) have this possibility.Taking TypeScript as one example. If 20% of users want to be able to do something in TypeScript that the language doesn't support, they either can try to get the change into the core language, or live without it (or fork it). If it changes, it'll change for everyone using TypeScriptBut in Clojure (lisps in general), you don't have this restriction, so modifying the language for your own need, becomes 	capableweb	12.647695	-7.887974	comment	6.0	31.0	1656757609	-11.09922
32288589	At some point, do we have to conside	"At some point, do we have to consider that the problem might be Clojure itself? Does LISP lend itself to ""Rails"" -- a Rails that people want to work with? I ask, genuinely, as a near-total outsider.The comparison to Elixir got me really thinking. I appreciate your ""call to action"", but community consensus gathering wasn't necessary for Phoenix to emerge as an option-of-choice, it gained traction because it is _good_.Surely there are large organizations using full stack Clojure, similar to the Lawrence World-Journal. Is there something about LISP that makes it hard for them to abstract their ""framework"" bits into an open source package?"	ttymck	12.658233	-7.870456	comment	6.0	23.0	1659202250	-11.110339
32288629	> If we used interop for everything 	> If we used interop for everything mundane, Clojure would really just be an S-expression shaped husk over Java code. Not a very good solution.I don't have a lot of experience with Clojure, but speaking as someone who uses Kotlin on the server side, this attitude strikes me as odd. Most of the reason to use a JVM language is to take advantage of the mature and well-maintained Java libraries for basically everything.If interop is considered a last resort (to the point where you reach for a 3-year-old unofficial Stripe library over the officially maintained Java one), what's the point of running on the JVM at all?	lolinder	12.638415	-7.881589	comment	6.0	55.0	1659202516	-11.140255
32289689	I developed for fun in Clojure and C	I developed for fun in Clojure and ClojureScript probably for 3 years, it was tremendous fun and got me into Lisps. In many ways Clojure does still hit the sweet spots from a language design perspective for me.I have revisited Clojure  every now and then after and IMHO its in a weird state, too popular and successful to completely die, but also limited to reach wider adoption.When revisiting old projects I have seen countless of Clojure dependencies having died in the meantime. I have replaced utility libraries with more recent utility libraries sometimes several times. Very annoying. Paradoxically the core API is really stable to a degree that bugs aren't fixed that are a behaviour userland code might rely on.But its overall I think more of a symptom than a cause for frictions when develo	wirrbel	12.652706	-7.8945765	comment	6.0	32.0	1659210512	-11.17671
32298007	Ask HN: Does an equivalent of Clojur	Ask HN: Does an equivalent of Clojure exist for .NET?	rawland	12.473203	-7.7913537	story	6.0	13.0	1659295359	-11.100033
32352491	What is this? What is Clojure and wh	What is this? What is Clojure and why do you need it in node?	solardev	12.647586	-7.9002037	comment	6.0	25.0	1659680996	-11.153806
23420794	Here is a very simple example that I	"Here is a very simple example that I think does a great job of illustrating how Clojure was designed to deal with ""data"" in a straight-forward and concise way:  (defn csv-data->maps [csv-data]
    (map zipmap
      (repeat (first csv-data))
      (rest csv-data)))

This is a function that, when given a contents of a CSV file (list of sequences), converts it to a list of maps, where the keys are the column headers.I'm sure there are clever ways of accomplishing this in other languages, but the default way a Java/C# dev would probably approach this is to create a class that represents the CSV columns, and imperatively iterate over the contents.With Clojure, the above function is idiomatic, and 4 lines long.When it comes to ""information processing"" systems, which is what a lot of us work on, "	adamkl	12.622873	-7.886661	comment	7.0	56.0	1591299232	-11.145568
23454515	Warning possible flamebait: could Cl	Warning possible flamebait: could Clojure be the solution?	barking	12.652065	-7.9017324	comment	7.0	26.0	1591602776	-11.177806
23569536	1) Nobody has any idea what they're 	1) Nobody has any idea what they're doing 2) If you think you know more than your manager – you are absolutely right 3) HN is 3 years ahead of mainstream, but 10 years behind the edge 4) React was made by an OCaml programmer 5) if you want to be that good, learn emerging languages (all of them) 5) don't optimize for money too soon, if you follow these instructions you will quadruple soon enough 6) Whatever your problem is that is holding you back – drinking, eating, whatever – fix it today 7) Learn Clojure	dustingetz	12.644932	-7.8853774	comment	7.0	46.0	1592524884	-11.118756
23926518	what does this mean for the future o	what does this mean for the future of clojure?I am a bit worried that a startup has acquired two companies that have extremely deep experience in specialised languages Platformatec (Elixir) and now Clojure (Cognitect)	kgraves	12.656393	-7.9023304	comment	7.0	31.0	1595506913	-11.18808
23938679	People who like static typing seem t	People who like static typing seem to really like static typing.I'm honestly not convinced it helps that much. And it seems to cost a lot to me.I like database and API schemas though. And I like clojure.spec and function preconditions a lot.	GlennS	12.523839	-7.835055	comment	7.0	67.0	1595593878	-11.130989
23941311	I went to a Clojure meetup one time 	I went to a Clojure meetup one time and they all went on about how using Datomic in production is a nightmare and it's generally an over-engineered product that isn't worth the trouble in the end. Do most people who have dealt with Datomic in production feel this way?	archarios	12.69133	-7.8265033	comment	7.0	44.0	1595607671	-11.217865
23948579	Re-Frame: Build web apps in ClojureS	Re-Frame: Build web apps in ClojureScript and React	tosh	12.67869	-7.8144927	story	7.0	123.0	1595678873	-11.204931
20074251	"""While Storm's Clojure implementatio"	"""While Storm's Clojure implementation served it well for many years, it was often cited as a barrier for entry to new contributors. Storm's codebase is now more accessible to developers who don't want to learn Clojure in order to contribute."" - interesting phrasing. Seems that the authors assuming that new contributors are more willing to learn Java instead of Clojure. And those who know Java find Clojure difficult to learn? Clojure, in fact is quite easy to grasp - especially for someone coming from Java, as you would still be working on JVM and always have Java Interop. I guess same thing goes to someone coming from Erlang to Elixir, where you are still working in the familiar ecosystem."	zenlot	12.648242	-7.8987947	comment	7.0	28.0	1559464605	-11.190472
20197184	Slightly tangential, but I wish some	Slightly tangential, but I wish some Lisp would make a serious comeback and challenge mainstream languages. For this purpose, libraries are essential. So better tooling would help, and that's why Ultralisp and Quicklisp are interesting.Clojure is very nice. I have used it for several projects. But sometimes I would prefer not to rely on Java libraries so much, and cleaner stack traces.Racket may get some critical momentum now, with the whole merge with Chez.I don't have high hopes for a Common Lisp implementation, as the ecosystem has become too fragmented and stagnant. But I wish I could be surprised here. Shen introduced some great ideas to make a powerful static typing an option in Lisp [1].[1] http://www.shenlanguage.org/	nextos	12.667218	-7.824117	comment	7.0	49.0	1560711054	-10.6357565
20220351	Sorry for the off topic.Any good rec	Sorry for the off topic.Any good recommendations for a Clojure book for a seasoned programmer but with little exposure to Lisps?	noncoml	12.6590395	-7.9025383	comment	7.0	23.0	1560911540	-11.137575
20262695	Productivity brought by Clojure [sli	Productivity brought by Clojure [slides]	tosh	12.648753	-7.9068766	story	7.0	140.0	1561378482	-11.167692
20789895	> 1. Economy of expressionFunny, thi	> 1. Economy of expressionFunny, this list is the same one I use as to why I'm so annoyed with Clojure right now.I inherited a mission-critical Clojure ML library my team uses for it's primary business goals. It was written 4 years ago by a research scientist- who quit 3 years ago. We know what it's supposed to do. We know that it seems to do the job well. We just can't understand the code well enough to be certain of what it's doing or how it's doing it. If this thing breaks or stops working, we're screwed.The problem is that the author, like most of us, found great joy in writing very few characters to express very big ideas. Clojure let him do that to an extreme degree. And I'm sure if you were sitting beside the author, with him explaining these dense expressions, you would be enlighte	mabbo	12.6557	-7.9043665	comment	7.0	32.0	1566683141	-11.15582
25999916	Choice paralysis between CL and Cloj	Choice paralysis between CL and Clojure	TornadoFlame	12.674412	-7.867039	story	7.0	7.0	1612266860	-10.833058
26377770	Could recursion be ( one of ) the re	Could recursion be ( one of ) the reasons why ML and Scheme ( and lisp, clojure, etc. ) aren't popular as industry languages?I learned recursion in University, it's undeniably a foundational piece of Computer Science theory. I use recursion when I have to do interview problems. And I think that's about it.The number of times I actually used recursion in production was maybe twice. And one of those times the PR was rejected. In my experience the overhead of understanding the code outweighs its terseness. This is also how I sometimes feel about macros in clojure. The cons outweigh the pros.	Naac	12.471728	-7.802028	comment	7.0	51.0	1615138308	8.943226
35590873	Clojure Rationale (2008)	Clojure Rationale (2008)	djha-skin	12.645189	-7.90394	story	7.0	88.0	1681659288	-11.1606045
28725218	I regularly work with Clojure.This i	I regularly work with Clojure.This is probably an unpopular opinion in this thread, but despite having worked with it for years, I still don’t much like it, mostly because it’s far too terse and the syntax is so far removed from that of C-based languages. The other day I wrote a Java-based DTO and it was refreshing how clear and verbose everything was, despite the almost comical volume of code it took in comparison to what similar functionality would look look like in Clojure. Plus, the state of tooling in Clojure is not the best.I would also add that while you might initially do well with something like Clojure, it may be difficult to maintain, especially if you plan to make it a legacy product with O&M support in the future.	temporallobe	12.645638	-7.8895254	comment	7.0	23.0	1633138264	-11.144299
28735841	Ask HN: Have you felt that Clojure i	Ask HN: Have you felt that Clojure is a bad version of Common Lisp?	wizardofmysore	12.647672	-7.891994	story	7.0	14.0	1633254621	-11.085627
28831243	Yeah, I currently do. I only work wi	Yeah, I currently do. I only work with companies who can ensure I get to write and maintain Clojure/ClojureScript projects, or any other lisp-like languages.Just like I'm sure many people would reject jobs that would force you to write assembly code now when we have higher abstraction languages, I reject jobs that are requiring me to work with inferior languages and ecosystems like Rust, Go or JavaScript. It's simply not worth the frustration anymore.In the beginning of my career I didn't have the flexibility to choose what languages to work with though, but nowadays I am that lucky.	capableweb	12.625464	-7.8583183	comment	7.0	47.0	1633976472	-11.208138
29091751	Maybe a more seasoned LISP-`aterian`	"Maybe a more seasoned LISP-`aterian` can answer me ?I'm in the process of learning ClojureScript - real fun so far. I have of course also looked at other LISPs and have noticed that in CJS the use of square brackets[] for 
vectors, let and  `function params`    (defn myfunc []
       (let [some-var (:some-key some-state)])
       (.log js/console some-var)
    )

I almost never see square brackets in other LISPs (yes I'm truly a beginner and haven't looked too hard), but it stiked  me as odd ? The square bracket syntax really helps to differentiate and with reading the syntax. (The syntax is not bad it is just different than what most programmers are use to)Am I wrong or just stupid or is there another reason most other LISP doesn't follow this ""convention""?Again I'm super-newbie, just som"	rawoke083600	12.567545	-7.783604	comment	7.0	41.0	1635922132	-10.694149
13056162	But would it put Rich Hickey's child	But would it put Rich Hickey's children through college?This is just not something we've got a good, reliable answer for.  E.g. I'm pretty confident that his creating and being the BDFL of Clojure wasn't sufficiently remunerative.	hga	12.6513	-7.909641	comment	7.0	24.0	1480348303	-11.164803
13096325	Macchiato: ClojureScript on the Serv	Macchiato: ClojureScript on the Server	macco	12.655845	-7.8888793	story	7.0	125.0	1480783425	-11.15621
13200378	The Next Five Years of ClojureScript	The Next Five Years of ClojureScript	tosh	12.656798	-7.8974085	story	7.0	128.0	1481976067	-11.187889
27598540	The more surprising/interesting thin	The more surprising/interesting thing to me is that it uses React. I'd be curious to see a performance breakdown (how much headroom is left for a more complex game?)I am also curious how Clojure(Script)'s persistent data structures work out for data structures that update 30 or 60 times per second. That's a lot of allocation and deallocation	brundolf	12.632561	-7.876796	comment	7.0	33.0	1624403635	-11.175291
27938131	Odd choice to use ClojureScript in a	Odd choice to use ClojureScript in a tutorial. The point of a tutorial is to convey information effectively. This is like a physics professor deciding to lecture in French because they think it sounds better.	underwater	12.661148	-7.892233	comment	7.0	31.0	1627096915	-11.168483
19096601	I don't hear as much about Clojure t	I don't hear as much about Clojure these days, and I don't know if it's because my reading habits have changed or if the community has become quieter. My impression was that other languages have captured the zeitgeist and that the enthusiasm for Clojure has abated. I could be wrong though.	msvan	12.656566	-7.904456	comment	7.0	23.0	1549470971	-11.167619
19277272	Hy: A Dialect of Clojure Embedded in	Hy: A Dialect of Clojure Embedded in Python	asimjalis	12.628726	-7.891578	story	7.0	42.0	1551404657	-11.155804
19678694	If you like this sort of thing, here	"If you like this sort of thing, here are some others in a similar humorous style for other languages.1. Kaufman, Roger. A FORTRAN Coloring Book (probably the first funny programming book -- from 1978).2. Lipovača, Miran. Learn You A Haskell for Great Good.3. Hebert, Fred. Learn You Some Erlang for Great Good (inspired by the Haskell book).4. Felleisen, Matthias. Realm of Racket (basically Land of Lisp for Racket. Oddly, nobody's done a ""Commonwealth of Clojure"" or ""Society of Scheme"" yet.)"	jhbadger	12.404414	-7.7264094	comment	7.0	31.0	1555462237	-6.5226974
19775179	"Some dev: ""Hey, I noticed one of our"	"Some dev: ""Hey, I noticed one of our more complex API endpoints had some pretty bad response latency, so I dug into it a bit.  It turns out our PHP/Symfony/Doctrine stack was generating over a hundred SQL queries, all of which were being performed sequentially because we don't have a good per-request concurrency story in this tech stack.  So I wrote an alternate implementation in Clojure which has a great concurrency story and cut the latency by 75%.""lol yeah that guy should totally be fired."	cellularmitosis	12.548349	-7.7044315	comment	7.0	33.0	1556502077	9.366135
16315472	Programming Clojure applications wit	Programming Clojure applications with CIDER[0] is a really slick experience. By connecting through an nREPL port to a running environment you can capture variable values like function inputs, change and re-evaluate function definitions on the fly, and test hypotheses by calling funcs directly with whatever input you want. Not to mention the speed of prototype iteration. This has been invaluable when trying to quickly track down production bugs.I've lately been working in Python, and even with IPython/Juptyer the workflow isn't quite as magical as  Clojure's.[0]: https://github.com/clojure-emacs/cider	mbil	12.651139	-7.895935	comment	7.0	28.0	1517914150	-11.143658
16407650	I should expand then: 17 years later	I should expand then: 17 years later, where are the successful Lisp (ok, and Clojure) startups fighting the Microsofts (C++, .Net), Facebooks (PHP!!), Apples (Objective-C, Swift), Amazons (Java, C++, Perl), Googles (C++, Java, Python, Go), Twitters (Ruby, Java, Scala), Dropbox (Python, C++), etc.?	oblio	12.659345	-7.792688	comment	7.0	45.0	1518981268	-10.5457735
16412391	Not sure why the excitement around d	Not sure why the excitement around ditching Lein when it looks like there is little or nothing to be gained at this time? The author describes a handful of other tools that are necessary to do things Lein does out of the box (uberjar)The Clojure ecosystem (specifically through the lens of this post) reminds me of the Linux desktop ecosystem. Lots and lots of tweaks and knobs and dials for the sake of having tweaks and knobs and dials.That’s my biggest gripe with Clj... there is hardly ever a “right way” to do things and usually a dozen esoteric approaches to organizing your application. It’s a blessing and a curse. All the rope to hang yourself with.That being said I really like writing Clojure in the pure sense but have yet to see a really pleasant 1. App architecture and 2. Web applicati	whalesalad	12.645854	-7.8925076	comment	7.0	31.0	1519042333	4.251235
16412050	A Clojure learning journey	A Clojure learning journey	robstu	12.649257	-7.9020414	story	7.0	215.0	1519036811	-11.187794
16415137	Don't you want people that care abou	Don't you want people that care about your product instead of the technology behind it?  I do.  Because there may come a time when another technology is a better fit for your product and ultimately your customer's experiences.  Then what?  Now your not using elm and your team leaves or is disgruntled.  I hire on passion for what we are trying to accomplish, not the technology stack.	onebot	13.010819	-7.692651	comment	7.0	27.0	1519069198	-12.769888
16604673	That's why I like Clojure's philosop	"That's why I like Clojure's philosophy of a few data structures and many functions operating on them.Of course Alan Perlis wrote ""It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.""  in  1982.But pipelining outputs into inputs (you'll see it a lot in F# too) is just a simple, flexible concept.As Rich Hickey once said, ""We're data processors"".I think we somehow took a wrong path when OO got embraced as wholly as it did back in the 90s or so."	Bizarro	12.418442	-7.750914	comment	7.0	54.0	1521242232	-11.12366
16939013	Lisp in Small Pieces of Clojure, par	Lisp in Small Pieces of Clojure, part 3	ghosthamlet	12.652429	-7.8914256	story	7.0	183.0	1524813629	-11.086166
17439861	Clojure for me is the perfect modern	Clojure for me is the perfect modern LISP, too bad it seems it's dying (happy to stand corrected there)	eafkuor	12.660568	-7.889985	comment	7.0	81.0	1530516374	-11.073259
17464093	I would wonder: is there any person 	"I would wonder: is there any person with (enough of) experience with both Clojure and Kotlin to say how these two compare together as Java alternatives? Couple of years ago I was looking for ""Java.next"" and back then I chose Clojure. Needless to say I have been sooo happy with the language... Now for past year or so I have heard so much praise on Kotlin - it always came from Java devs and it seems like a great language with great support from IntelliJ and I am very enticed (but sadly have not enough time to play with it). So I'd wonder how this language is perceived by fellow people from Clojure community..."	newcrobuzon	12.4270525	-7.697554	comment	7.0	33.0	1530805071	-11.323428
17536432	I don't really get why you'd ever wa	"I don't really get why you'd ever want a Lisp-2. Is there an argument/explanation somewhere that I could read up on?(I've used Clojure and JS, which also seems like a ""Lisp""-1 in that you can just put fns into variables and call them like 1st class fns, I just don't get why the distinction is in any way positive rather than confusing, and in Lisp-2s you now need to dereference everything all the time, like in Ruby)."	gtdthrow	12.660217	-7.868303	comment	7.0	26.0	1531680538	-11.034083
17574351	Command-line apps with Clojure and G	Command-line apps with Clojure and GraalVM: 300x better startup times	kimi	12.565045	-7.7303047	story	7.0	118.0	1532088888	-11.074735
17723744	Problem Solving and Clojure 1.9 with	Problem Solving and Clojure 1.9 with Rich Hickey	tosh	12.643144	-7.9097443	story	7.0	231.0	1533819071	-11.156593
17724353	On a tangential note, I'm learning C	On a tangential note, I'm learning Clojure and kind of just getting started on using it.I like it how its a Lisp, and ever since I've learned Common Lisp, I've been wanting to use Lisp at work for everyday projects, and Clojure seems to fit just perfectly well.As with these new things you are always excited to explore further and see what's about to come next. After searching, I was not able to find anything on the Clojure roadmap anywhere on the internet. I understand that Clojure is largely an Cathedral kind of an open source project, largely developed in private at Cognitect and released to the world. But it was still a little strange to not see anything on Clojure's future plans. Sometimes you also see the Clojure repo on Github go without commits for weeks, for example the last commit	kamaal	12.660774	-7.897938	comment	7.0	35.0	1533824106	-11.118049
17843006	The reddit discussion for this post 	The reddit discussion for this post is a telling confirmation of the articles complaints about the community forums/interaction: https://www.reddit.com/r/elm/comments/9a0hc6/elm_019_broke_u...	detaro	13.014499	-7.6972885	comment	7.0	54.0	1535237390	-12.7510805
21092197	It hasn't fallen. The Clojure commun	It hasn't fallen. The Clojure community has been growing steadily and continues to grow (it's a great community, I'll add). Things have just settled down since, that's why there are fewer announcement.As an aside, the 2019 SO survey shows Clojure programmers are the best paid [1].Most Clojure programmers I know (myself included) would not choose to go back to Java.[1] https://insights.stackoverflow.com/survey/2019#technology-_-...	snapey	12.652168	-7.89626	comment	7.0	50.0	1569593529	-11.179546
21300503	I stopped using clojurescript around	I stopped using clojurescript around 2015, primarily because I was tired of searching for/implementing clojure-idiomatic wrappers around the many javascript libraries out there. Put another way, I left clojure on good terms, and often missed its core functions, immutable data structures and lisp syntax when writing front-end applications. However, since then, javascript has changed a lot, specifically in terms of execution-suspending operators like async/await/yield/yield*. Meanwhile, the core clojurescript team has almost completely ignored these developments, preferring the immutable seq abstraction over iterators, and the core.async channel abstraction over promises/async iterators.For this reason and this reason alone, I’ve personally stopped considering clojurescript as a viable techn	bikeshaving	12.621699	-7.868989	comment	7.0	47.0	1571515804	-11.161358
21333169	I cannot believe that you make more 	I cannot believe that you make more from such a niche dev tool  than your job at Google. I always thought people who use clojure/scheme would be using their custom setup in emacs or vim.I'm interested to learn more details, how things were when you first started out selling the app and the trend.	spv	12.656779	-7.89686	comment	7.0	30.0	1571826767	-11.201977
21604850	Clojure-flavored WASM text format	Clojure-flavored WASM text format	tosh	12.648937	-7.902788	story	7.0	112.0	1574424737	-11.1598215
39183666	Don't really get the criticism of Cl	"Don't really get the criticism of Clojure for being hosted on the JVM, particularly relative to its status as a ""productive"" Lisp. Like oh, you get access to one of the biggest and most mature library ecosystems out there as well as best in class operational tooling? Obviously there are use cases where the JVM doesn't fit and all things being equal I prefer shipping statically linked binaries too, but the JVM still feels like an obvious ""pro"" here."	charlotte-fyi	12.639891	-7.8614907	comment	7.0	46.0	1706567488	-11.16426
18139367	Scmutils in Clojure	Scmutils in Clojure	tosh	12.621729	-7.893918	story	7.0	101.0	1538657219	-11.169024
18345911	This is a bit tangential to the post	"This is a bit tangential to the post, but I've seen a couple comments in this thread that amount to ""Clojure is hard to read"", but I think that's a really unfair comparison, because people are unwittingly comparing apples and oranges. It seems to me the reason people think Clojure is hard to read is that the language is so powerful and expressive, that when you're reading Clojure code, you're typically trying to understand the actual problem that's being solved, as opposed to just reading a bunch of code that's necessitated by the lack of power afforded by the language. For example, I can easily ""read"" a bunch of nested for loops in Java, but then I still have to try and understand what the actual problem is that's being solved. People seem to confuse those two things when comparing Clojur"	projectileboy	12.649627	-7.8971276	comment	7.0	37.0	1540995808	-11.109991
18376652	Learning Clojure: comparing with Jav	Learning Clojure: comparing with Java streams	nfrankel	12.648776	-7.8925543	story	7.0	117.0	1541349329	-11.175259
18476137	Genetic Programming in Clojure	Genetic Programming in Clojure	sulami	12.63273	-7.8920226	story	7.0	83.0	1542472363	-11.194129
18539939	Though Rich is right, it pains me to	"Though Rich is right, it pains me to read this because it is indicative of some disputes in the clojure community. I might be mistaken, but it seems that Rich is reacting to Chas Emericks' twitter post (https://twitter.com/cemerick/status/1067111260611850240). 
In his comments he has stated: ""Finally, from a practical perspective, my core-level contributions always came from some source of pressing need in an actual, present, needs-to-work project. If I know a problem isn't going to be triaged for months and solved for years, then I'm out.""So this is not some grieving random person from crowd - Chas is a person whose libraries and contributions I value tremendously and he certainly made LOTS of contributions to clojure OSS landscape for free and out of his good will as well. 
So ultimately"	newcrobuzon	12.660822	-7.90655	comment	7.0	80.0	1543299528	-11.197204
18767592	Clojure is Capable	Clojure is Capable	ahungry	12.65481	-7.8919935	story	7.0	198.0	1545888930	-11.1781025
33165098	Elm at a Billion Dollar Company with	Elm at a Billion Dollar Company with Vendr CTO Aaron White [audio]	dillonkearns	13.012334	-7.6969147	story	7.0	64.0	1665504458	1.0130094
33887813	Loopr: A Loop/Reduction Macro for Cl	Loopr: A Loop/Reduction Macro for Clojure	tosh	12.622649	-7.884837	story	7.0	115.0	1670364495	-11.156197
33962984	It's good to see this acknowledged. 	It's good to see this acknowledged.  I tried to learn Clojure and appreciated the language but I just couldn't get my vim head around the emacs ecosystem well enough to experience the nirvana.I may well try again.	__MatrixMan__	12.650053	-7.8960624	comment	7.0	22.0	1670892625	-11.1615
33962090	Clojure is a trinity of language, RE	Clojure is a trinity of language, REPL, and structural editor	pgayed	12.645739	-7.903249	story	7.0	99.0	1670888361	-11.147252
26637994	I haven’t written any Clojure for a 	I haven’t written any Clojure for a few years now. So my knowledge and technique is out of date, but I have a contrary opinion on “repl driven” development vs many Clojure advocates. In short: your repl compiled code is state that you now have to track in your head.Yeah, great, you can compile a single function and it hot loads. It’s pretty awesome for experimenting and debug, but the longer your repl session is open and the more you change and compile, the more likely you are going to end up with a mixed state in memory that does not reflect how your program would behave if run from scratch.You are going to forget to save a change or your manual tinkering with a data structure will leave it inconsistent. These errors accumulate, like navigation error with an IMU.It’s got use cases for sur	FPGAhacker	12.620324	-7.8839135	comment	7.0	32.0	1617127221	-11.165874
27060157	Unfortunately, despite consistently 	Unfortunately, despite consistently hearing about how enjoyable Clojure is, I think many people are turned off by the JVM. This is probably also the problem with Scala, which is apparently also enjoyable to use.	rychco	12.608566	-7.866582	comment	7.0	33.0	1620286220	-11.176036
27278828	Random question: Can ClojureScript b	Random question: Can ClojureScript be compiled in the browser? I only looked at it when it first came out and at that time the ClojureScript compiler only ran via the JVM.	benjaminjackman	12.66366	-7.8863983	comment	7.0	26.0	1621959831	-11.170982
27277482	ClojureScript 1.10.866 Release	ClojureScript 1.10.866 Release	tosh	12.664622	-7.9062223	story	7.0	152.0	1621953987	-11.163425
38434994	I wonder why isn't Clojure more popu	I wonder why isn't Clojure more popular.	hu3	12.657886	-7.9031234	comment	7.0	27.0	1701105264	-11.191729
14928694	"If ""expanding your brain"" is really "	"If ""expanding your brain"" is really what we want to optimize, why not learn Haskell?  Or for that matter, why not learn something even more strongly typed, like Agda or Idris?  Or even a theorem prover like Lean?Most of the reasons the author presents would either be expanded in one of those languages, or is immaterial to the goal of maximizing learning.  After reading the article I have no more reason to consider learning Clojure over learning any of the languages above."	cderwin	12.44329	-7.8562546	comment	7.0	35.0	1501855260	10.426494
14929074	I don't like working with clojure.It	I don't like working with clojure.Its basically modern perl. I've worked with both professionally, and the outstanding point with both has been:- programmers try to be clever in their code, write one giant file full of complicated specialized 'beautiful' code, forget everything they know about breaking big tasks into simple small ones.- code is a nightmare to maintain for non-author- non-authors working on code results in adhoc mess of stylesPlay with, sure. Learn a few things and watch the videos, absolutely. Rich is a really thoughtful talker. I actually quite enjoyed clojure before I had to collaborate on a code base....but goodness me. I cannot strongly enough recommend against using it professionally.	shadowmint	12.647937	-7.8966866	comment	7.0	49.0	1501858272	-11.1404085
15426106	>, couldn't actually determine what 	>, couldn't actually determine what point it was trying to make.In the poorly written Chris Zheng rant, there was a link to a more mature blog post by Eric Normand.[1]  (It would have been better use of Rich Hickey's time to ignore CZ and respond to Eric, but alas.)In any case, CZ is upset that Cognitec drives the evolution of Clojure and its libraries more than the community outside of Cognitec.  E.g. one of his frameworks he liked (Noir) was ignored while Cognitec pushed its own.Here's my question, what mainstream programming language community actually meets CZ's criteria that the outside community drives the language with equal or more power than the internal team?  It's certainly not Golang (Rob Pike, Brad Fitzgerald, Ross Cox, etc), nor C# (A Heilsberg, et al), nor Clang (Apple devs)	jasode	12.613264	-7.8701406	comment	7.0	27.0	1507416692	-11.125831
15525908	It's a business struggle. You're not	It's a business struggle. You're not going to hire Clojure devs. You're just not.So every hire will be a cost to cross train through language as well as get used to the codebase. And a lot of more seasoned devs are very binary about lisps. I personally wouldn't work at a place that wanted me to do Clojure over Scala/Java/Kotlin.I worked at a globally known media company that were primarily a Scala company and they had made a handful of applications from people with Scala experience a year at best. The churn of every skilled dev leaving being replaced by someone very green is a horrible opportunity cost even for a large business.	weego	12.65383	-7.897674	comment	7.0	41.0	1508665120	-11.124144
15573203	" ""Messenger used to receive bugs rep"	" ""Messenger used to receive bugs reports on a daily basis; since the introduction of Reason, there have been a total of 10 bugs (that's during the whole year, not per week)!""That's truly amazing.Interesting how Elm is inspiring other frameworks and languages. First Redux and now Reason's error messages."	myth_drannon	13.003953	-7.6934395	comment	7.0	25.0	1509148628	-12.758653
15595469	I have some doubts about this one, d	I have some doubts about this one, despite my love and ongoing professional work with Clojure. For overall productivity, I find the issue of typos more significant than this slide leads us to believe, especially in a language like Clojure where the compiler does not catch nearly 90% of my typos. It's very easy to have a nil running through your program in Clojure because you either mistyped a keyword or you just picked the wrong one when pulling something out of a map, for example. But that is just one example, I find that I spend a fair amount of my work day tracking down silly typos at run time, which frankly disappoints me tremendously. I really like Clojure but tackling this problem has been non-trivial.	hellofunk	12.609098	-7.8871207	comment	7.0	27.0	1509475056	-11.143099
15603906	The dueling rhetoric is the same rhe	"The dueling rhetoric is the same rhetoric that has been around for decades: Some people really feel type systems add value; others, feel it's a ball and chain. So which is it? The answer is probably ""yes."" We should all believe by now since history has proven this correct. Most of the time you start with no type system for speed. Then you start adding weird checks and hacks (here's lookin' at you clojure.spec). Then you rewrite with a type system.I'm a devout Clojure developer. I think it delivers on the promises he outlines in his talk, but I also have no small appreciation for Haskell as an outrageously powerful language. Everyone robs from Haskell for their new shiny language, as they should. Unfortunately, not a night goes by where I don't ask God to make me smart enough to understand "	bpolverini	12.448673	-7.8575044	comment	7.0	43.0	1509559777	10.4766655
28397893	Joker: A small interpreted dialect o	Joker: A small interpreted dialect of Clojure written in Go	rcarmo	12.632867	-7.9016895	story	7.0	183.0	1630619847	-11.168339
28441512	JUXT Clojure Radar 2021	JUXT Clojure Radar 2021	denisw	12.651275	-7.9028277	story	7.0	83.0	1630995470	-11.213659
22323895	I can understand escaping from Java 	I can understand escaping from Java enterprise hell to Clojure but devs using a CL runtime will just write CL?	Scarbutt	12.649088	-7.893706	comment	7.0	45.0	1581653447	-11.128699
22380396	I'm glad that Clojure users seem hap	I'm glad that Clojure users seem happy with their language.  But it seems like a worrisome sign that their survey has roughly the same number of respondents year after year...* 2020: 2519 responses* 2019: 2461 responses* 2018: 2325 responses* 2016: 2420 responses	Taikonerd	12.655323	-7.903678	comment	7.0	47.0	1582250823	-11.199302
22735678	Hmmm... Lets see the HN Reader examp	Hmmm... Lets see the HN Reader example then...95MB for the macOS DMG.177MB for the actual example app.For a typical hello world application like the HN example, it appears that it would be no better than running an electron-made version given that they both include their own versions of their respective runtimes. In this case, this includes the entire Java runtime which Clojure needs to run.I think I would be better off with using either C++ with Qt5 or even FreePascal with the Lazarus IDE for this instead.	rvz	12.6260605	-7.866349	comment	7.0	46.0	1585641291	-11.109104
23067987	Saying Thank You to the NHS, Using C	Saying Thank You to the NHS, Using Clojure	DaveWM	12.653151	-7.9044194	story	7.0	60.0	1588600001	-11.180574
29342656	What is Clojure's main selling point	What is Clojure's main selling point?	potency	12.65642	-7.9080105	comment	7.0	27.0	1637857925	-11.183744
14006399	I loved the either-monad solution. T	I loved the either-monad solution. The problem is something I've experienced many times in my clojure adventures, usually resulting in either dirtying the function in question with its own, case specific logging or creating the if-let monstrosity you demonstrated.As a side note: there's something very comforting when you immediately empathize so strongly with a programming problem someone is writing about	jtmarmon	12.40558	-7.8571906	comment	7.0	30.0	1490983828	10.420208
14009239	The problem is that problem clojure 	The problem is that problem clojure code is the gift that keeps on giving, and it boils down to the problem I have with clojure in general:Bad clojure code is unmaintainable spaghetti code; which gets worse over time, as people attempt to 'patch on' fixes without doing the heavy lifting of trying to figure out:- What was the original author actually trying to do?- Why the heck did they do it like this?- How do we create the same functionality and prove it works with these rubbish tests that only test the individual units of work, not the application function?- Why is it all in one giant file?I've never seen code bases descend into chaos as fast as our clojure ones have.Nice, elegant clojure is a pleasure to work with for personal projects, but I'm never using it professionally again.You mi	shadowmint	12.659988	-7.9003987	comment	7.0	30.0	1491001903	-11.148998
14419764	I think Clojurescript might be the t	I think Clojurescript might be the thing. With advances in the Google Closure compiler, it's getting better and better. And the front end developer tools and libraries in Clojurescript are _the best_ out there. The holy grail for javascript exists in Clojurescript. Until then I'll keep making my Javascript env look like Clojurescript. With janky react devcards, Immutable.js, and react-redux.	modularfurnitur	12.657598	-7.8235416	comment	7.0	43.0	1495742835	-11.108344
14498261	> how do I find eigenvalues and eige	"> how do I find eigenvalues and eigenvectors? The function is called ev!Why not call that function eigen-vectors instead of ev?Some library authors need to be smacked on the head with a programming book and learn how to design sensible API's.Seriously, Clojure is typically easy on the eyes but this is just garbage:    (require '[uncomplicate.neanderthal
       [core :refer [col entry nrm2 mv scal axpy copy mm dia]]

axpy? mm? dia? nrm2?"	hota_mazi	12.609353	-7.888406	comment	7.0	37.0	1496765103	-12.122823
31214837	I'm surprised people have managed to	I'm surprised people have managed to port Clojure to so many platforms. Seems like a ton of work! :)From what I understand the vanilla JVM implementation isn't built around a small core. So it's not like porting a Scheme. All the data structures and what-not are written with Java (not a criticism, it's great for performance and interop)But wouldn't it make more sense to first rewrite Clojure itself in some small/minimal scheme-y subset of Clojure - and then port that subset to Rust/Dart whatever? (With some performance penalty)I'm not super on top or Clojure's implementation, and people are prolly not doing this for a good reason - so I'm likely off base here somewhere	geokon	12.654103	-7.902424	comment	7.0	29.0	1651314332	-11.172853
31274886	I implemented these a while ago in C	I implemented these a while ago in Clojure because it was part of the job application process at roam research.Didn't even get a reply... it cost me quite some hours to do this in a language I have almost no experience in.At least there was the upside that I got to experience Clojure and Om which was great to learn about :D	azeirah	12.649233	-7.906008	comment	7.0	31.0	1651765789	-11.1712675
36776173	Go really is great. There was a big 	Go really is great. There was a big argument around a new project we were starting whether to do Go or Clojure.What we did to settle the debate was to ask an entry level dev that was just starting if he was interesting in writing two sample applications in each language, having known nothing of either. Nothing complicated but touched enough points (HTTP endpoints, database interaction)A full day later was still trying to get the Clojure app working correctly.He finished up the Go one in like an hour.Since then we've brought new devs on with zero Go experience and they are up writing good code in a day. I can't imagine where we would be if we had gone down the Clojure route.	nullwarp	12.604527	-7.9062557	comment	7.0	35.0	1689701205	-11.1949005
36988012	Overtone – programmable, live music 	Overtone – programmable, live music in Clojure	elamje	12.652513	-7.902184	story	7.0	132.0	1691079934	7.3551555
37073180	I’m seeing a lot about clojure langu	I’m seeing a lot about clojure language, especially recently. I’m missing an insight into the clojure community, especially in the context of libraries and job market.E.g. I’m not aware of any large framework like Rails or Phoenix. Is this something that is missing and yet-to-come, or there is no need for that?How does this affect job search, are Clojure jobs less about SAAS/CRUD apps? Does each place build their own custom tooling?	thih9	12.647866	-7.896354	comment	7.0	44.0	1691653396	-11.163147
24444434	You really should look to other ecos	"You really should look to other ecosystems and see what lessons they've learned. In java, packages are normally ""namespaced"" by the author's reverse domain name, like `org.lwjgl/lwjgl`.Since clojure uses maven as well, the same applies, but clojure tools like leiningen decided to create a shortcut: if the group and artifact name are the same, like `iglu/iglu`, they can be collapsed into one name: `iglu`Well, that just encouraged everyone to choose collapsible names. In retrospect, this didn't buy us much. Who cares about saving a few characters of typing? Most now seem to agree it wasn't a good idea.When the ""collapsed"" name falls out of maintenance, the forks will all seem somehow less ""official"", even if they are much higher quality. Forks are inevitable; why would you want to discourage"	gw	12.642023	-7.8977923	comment	7.0	54.0	1599841680	-11.113347
24701737	Simulating Machines in Clojure	Simulating Machines in Clojure	stopachka	12.653481	-7.9064655	story	7.0	161.0	1602014460	-11.201383
25376063	> The converse of this is that good,	> The converse of this is that good, wise developers are going to (ultimately) _demand_ Clojure.HN seems to blindly accept the idea that developers using niche languages are good but I certainly haven't seen any proof of that and I haven't seen anything to even remotely suggest that good developers gravitate towards Clojure.Great developers have to be working on hard problems and almost all of the hard problems in our industry, outside of language/chip design and correctness proofs, are being worked on in relatively boring languages (C, C++, Java etc.).  Most of the niche language users I've met are working on basic CRUD web applications.	throwaway92938	12.63748	-7.8757763	comment	7.0	49.0	1607621384	-11.158727
32282244	Clojure Web Development Evolved [vid	Clojure Web Development Evolved [video]	yogthos	12.655061	-7.902416	story	7.0	129.0	1659131943	-11.182257
22253999	I was surprised to see that Clojure 	I was surprised to see that Clojure scored better than Scala. Is Scala loosing its appeal? Did Dotty scare people away, because it smells like Python 2 vs 3?	insulanian	12.531181	-7.833986	comment	7.0	42.0	1580971965	11.919209
23420267	Could you elaborate on a problem tha	Could you elaborate on a problem that illustrates this property of Clojure? This sounds awesome, but I have a hard time understanding what you're getting at without knowledge of Clojure.	natdempk	12.60415	-7.883985	comment	8.0	144.0	1591296416	-11.147653
23420361	I just wish it didn't target the JVM	I just wish it didn't target the JVM. I think if it had a native runtime that loaded quickly like Python it would be more popular. I love Clojure and really wish I could use it, but I just don't do the kind of things that can justify running a JVM.	globular-toast	12.598042	-7.8277707	comment	8.0	37.0	1591296924	-11.175981
23420504	Three examples of this:1. core.async	Three examples of this:1. core.async: So the guys who built golang did it because they had this cool idea for creating coroutines using channels. However, since it required very low-level functionality to be part of the core of the programming language, they thought they'd have to design a brand new language to implement their idea. However, shortly after golang was released, Rich and some other clojure folks implemented the same feature in clojure as a totally ordinary external library, proving that the core of clojure was general enough to support this. And it wasn't just a gimmick: I use core.async every day and think it is better than golang's implementation.2. The Expression Problem: One of the core challenges in language design is designing it so that (simplifying a bit) you can tran	drcode	12.434524	-7.867904	comment	8.0	79.0	1591297671	-11.159664
24080930	Python or Clojure for Data Analysis?	Python or Clojure for Data Analysis?	s_c_r	12.642421	-7.8885555	story	8.0	16.0	1596801411	-11.152527
20605694	Well, Go seems to have enabled a new	Well, Go seems to have enabled a new wave of software renaissance - Kubernetes, Docker, you name it - Go seems to have filled the space that Java was too fat for, JavaScript too light for, and C/C++ too difficult/fun-less to use for (which is everything).After 20 years of coding, and having just recently discovered LISP and learned Clojure, I believe the perfect language will be a Clojure compiled to native with the ease of Go (e.g. w/ similar import system).One such direction seems to be Carp (https://github.com/carp-lang/Carp), but I haven't tried it yet.	ypcx	12.595228	-7.900185	comment	8.0	67.0	1564916421	-11.176699
20950123	I have spent a lot of time experimen	I have spent a lot of time experimenting with the Haskell bindings for TensorFlow and a little time with HLearn. Sorry for a negative opinion, but as much as I don’t particularly like Python, I would suggest to almost anyone that they stick with Python for deep learning for now. In a year or two, I might recommend TensorFlow implemented turtles all the way down in Swift, but let’s wait and see how that project progresses.I have only spent a few evenings playing with Clojure and mxnet and while I appreciate the efforts of the Clojure mxnet subproject team, I think you are still better off for now with Python, TensorFlow, and PyTorch.A little off topic: I had a deep learning example for Armed Bear Common Lisp (implemented in Java) and DeepLearning4j in the last edition of my Common Lisp book	mark_l_watson	12.541929	-7.853528	comment	8.0	65.0	1568286551	-10.813031
24939863	Clojure had STM from the start, and 	Clojure had STM from the start, and it was one of its selling points,  but the real world experience with it is that nobody uses it - atoms (i.e. global serialized write access, with non-locked reading) are 99.9% good enough.	kimi	12.646732	-7.8952427	comment	8.0	32.0	1604041696	-11.198488
25262764	Piggybacking this question for peopl	Piggybacking this question for people interested in the topic:Which everyday high level data structures you use are built on lock-free implementations?Clojure's maps/vectors (which are persistent data structures) come to mind for me, for one.	fulafel	12.505991	-7.7862115	comment	8.0	38.0	1606802014	-11.109386
25287750	I only had deeper interactions / usa	I only had deeper interactions / usage with two Lisps so far: Racket and Clojure.CL must have some unique appeal that I'm missing. It's community seems to praise it's properties, but is rather quiet otherwise: Interesting talks, projects and companies are be eluding me, especially when compared to the above two Lisps.	dgb23	12.691103	-7.8459244	comment	8.0	32.0	1606993774	-10.679071
25343084	Indenting styles is, humorously, a m	"Indenting styles is, humorously, a massive problem for the lisps.Consider, say,  for (i in [1, 2, 3]) {
    x(i);
    y(i);
    z(i);
  }

The indentation here very naturally demarcates between control structures and non-control code.Compared to similar lisp-y code:  (map
    #(-> % x y z)
    (range 3))

The indentation doesn't give the programmer any hints that map is actually a control structure fulfilling the same role as a for loop.Given that indentation is critical enough to be a major language feature of something like Python, lisps have a weakness here that isn't dealt with very often. This so-called 'semantic indenting' doesn't go far enough - programmers want much more of it if Python and C-like languages are any indicator. I think there is a very desirable equilibrium here; some"	roenxi	12.64848	-7.869316	comment	8.0	45.0	1607415526	-10.967701
38814031	It's a post about being conservative	"It's a post about being conservative with technology yet most of the choices seem hipster. Clojure, why not java? Diatomic, why not postgres? Flutter... it's gonna be cancelled.Though I agree with the message that keeping the library choice small is good. I just think they already lost that war at some point. There are cracks in the argument in the article. Diatomic... ""For high value data"", implying it did not generalize to low value data, or they have several other dbs around. Shoulda picked postgres, it's more general, but hand was forced by clojure, which was the original hipster in the stack I expect."	tlarkworthy	12.658419	-7.8979993	comment	8.0	46.0	1703930692	-11.148006
32284109	Another attempt at the Rails for Clo	Another attempt at the Rails for Clojure. Great. The web stacks (yes stacks, there are many at this point) are very mature. I'm getting tired of seeing people re-inventing the wheel over and over again.I love Clojure, but this language is going to die off if people don't start putting more effort into building mundane, everyday libraries. (I know I am). Clojure has high velocity, but it's always offset by having to create new libraries or update rotting ones.I've noticed a ton of software rot in what were once major Clojure libraries, like Onyx and Cortex, now fading into obsolescence.I'm sorry, but I will keep bitching about this on HN until people help me.	janetacarr	12.6502075	-7.8973994	comment	8.0	42.0	1659152830	-11.163085
32295666	New Clojure Project Quickstart	New Clojure Project Quickstart	yogthos	12.649987	-7.9037766	story	8.0	126.0	1659277371	-11.145381
32339979	Clojure Scripting on Node.js	Clojure Scripting on Node.js	reil_convnet	12.647083	-7.883177	story	8.0	143.0	1659596070	-11.17844
22139668	Clojure – Fascinated, Disappointed, 	Clojure – Fascinated, Disappointed, Astonished (2016)	systems	12.651903	-7.9058347	story	8.0	138.0	1579883303	-11.179405
14006999	From someone that has never touched 	"From someone that has never touched clojure ( or any lisp) i would say that the python equivalent using either/right libraries made me feel like running away as far as i could.Could anyone provide me with an example of a code that would actually read nicer in clojure than in python ? Make it as arbitrary as you'd like, i'm honestly trying to understand 
.  i've read enough about lisp bluring the line between data and code, so i'm starting to get an intuition of its benefit. I was just hoping to finaly see a real world example, and i'm a bit disappointed."	bsaul	12.624422	-7.87762	comment	8.0	27.0	1490986776	-11.134464
14007239	Clojure is interesting in a lot of w	Clojure is interesting in a lot of ways. I've toyed with it a lot, but what actually keeps me from using it much is how tightly coupled it is with the JVM. I know this is its big selling point for a lot of people but for me personally I don't enjoy having to know Java's APIs and ecosystems to get things done.Is anyone else out there like me who wishes there was a standalone clojure implementation that wasn't a hosted language? Add a modern package manager on top of that like cargo or mix and I would love to write new projects in it, because clojure itself is a very pleasant experience.	jfaucett	12.655953	-7.8959093	comment	8.0	48.0	1490988144	-11.169429
14611880	Here are the reasons I stopped using	Here are the reasons I stopped using clojure (a phenomenal language) a year ago, in order of importance:1. No C/C++ FFI.2. Lack of a strong type system (clojure.spec almost solves this problem now, but when I quit this didn't exist yet).3. Horrific startup times: although clojure itself is fast, its startup time isn't. This makes scripting in clojure unsatisfying. And you don't feel like a ninja when it takes 30 seconds to start a REPL. You can use clojurescript to target node to get around this, but then you cut yourself off to most of the powerhouse clojure libraries.I now use Haskell (with C/C++ FFI). I do miss the homoiconicity (and slightly more concise syntax) of clojure. In my opinion Haskell and clojure are the two sexiest mainstream languages that you can get stuff done in.	georgewsinger	12.652431	-7.895233	comment	8.0	38.0	1498136182	-11.228257
14663619	I've never ventured into a lisp like	I've never ventured into a lisp like language. Would you recommend starting with common lisp or is jumping into clojure ok?I have been in the JS, Java, Python world for a while and this looks like a language that could stretch my brain a little bit.	fokinsean	12.668533	-7.870337	comment	8.0	55.0	1498747006	-10.90683
30971282	Starting Your Computer Music Journey	Starting Your Computer Music Journey with Clojure and Overtone in Emacs	ThisIsSavo	12.6527815	-7.9008303	story	8.0	137.0	1649533123	7.271059
25623486	I always think it's hilarious when C	I always think it's hilarious when Clojure enthusiasts try to address concerns about the language by talking about parentheses, as if that was actually the major barrier to entry. The parentheses are at best a mild inconvenience...many people love them, including myself, but few people cite the parentheses as a reason to not use the language after actually trying it out. A non-exhaustive list on why not clojure:* It's slow* Development with the REPL is slow because the startup times are glacial and REPL-oriented development usually requires tons of from-scratch restarts.* The tooling sucks: build systems, IDEs, debuggers, etc. If you feel like writing code with just an editor and a terminal is like going back to the stone ages, you're gonna want to bash your own head in with a mammoth bone	darksaints	12.638439	-7.879268	comment	8.0	40.0	1609696745	-11.079986
25623787	"> In Clojure, whenever you ""append"" "	"> In Clojure, whenever you ""append"" to a vector (array) you get a ""new"" vector and the original does not change. Anyone with a reference to the original can always count on it being the same.This has never made any sense to me. Can someone please explain why you would still want the original vector to continue to exist with data that no longer reflects the current system? What am I missing?"	tkdc926	12.641562	-7.910888	comment	8.0	25.0	1609698732	-11.157148
25656075	State of Clojure 2021	State of Clojure 2021	bladerunnerXxX	12.659991	-7.905345	story	8.0	28.0	1609925495	-11.197905
25794739	Clojure Core	Clojure Core	tosh	12.642751	-7.8961735	story	8.0	167.0	1610737227	-11.168998
25836345	Lispsyntax.jl: A Clojure-like Lisp s	Lispsyntax.jl: A Clojure-like Lisp syntax for julia	phonebucket	12.602483	-7.90402	story	8.0	162.0	1611078804	-10.990664
36438715	Currently whenever I think of Clojur	Currently whenever I think of Clojure I remember this posthttps://www.reddit.com/r/Clojure/comments/a79aln/clojure_web...As far as I know the situation did not improve, I had high hopes for Clojure, but i think it will eventually be as forgotten as Groovy	systems	12.651294	-7.900302	comment	8.0	27.0	1687466760	-11.176313
28831444	There are a lot of people who would 	"There are a lot of people who would debate that point. There are even some fairly common macros that are used when this comes up. My favorite is this one:«I find Clojure revolting.It is the most explicit to date abandonment of the age-old Lispers' Dream, ""Lisp All The Way Down."" Clojure is the antithesis of the Lisp Machine. Instead of a crystalline pyramid of comprehensible mutually-interlocking concepts, behind every Clojure primitive there lurks Black Magic. The Clojure user who is missing some routine or other will run crying to Java for help, rather than implementing the feature himself correctly - that is, as a natural part of the entire language, built on the same concepts. Clojure pisses on everything I've ever loved about Lisp.Clojure is the False Lisp, which Reeketh of the Cube F"	metagame	12.641113	-7.8810806	comment	8.0	32.0	1633977618	-11.021762
28976053	The biggest performance issue Clojur	The biggest performance issue Clojure has, which isn't mentioned in the article and is fundamentally unsolvable, is that it misses the CPU cache - a lot.The data structure that drives the immutable variables, the Hash-Array Mapped Trie, is efficient in terms of time- and space- complexity, but it's incredibly CPU cache-unfriendly because by nature it's fragmented - it's not contiguous in RAM. Any operation on a HAMT will be steeped in cache misses, which slows you down by a factor of hundreds to thousands. The longer the trie has been around, the more fragmented it is likely to become. Looping over a HAMT is slower than looping over an array by two or three orders of magnitude.I don't think there is really a solution to that. It's inherent. Clojure will always be slow, because it's not cac	MillenialMan	12.654244	-7.9160233	comment	8.0	55.0	1635065771	-11.175078
29107392	Clerk: Local-First Notebooks for Clo	Clerk: Local-First Notebooks for Clojure	tosh	12.651029	-7.901741	story	8.0	130.0	1636035042	-11.177444
34802147	The problem with Datalog, and Clojur	The problem with Datalog, and Clojure in general are the licenses. Terrible licenses.Everything is about Rich Hickey. Apache 1.0.Now that Nubank basically owns it and there's very little progress or activity as of late, I don't see why one would chose to use Clojure, Datalog etc.Also, a lot of functional programming concepts has been since added to big programming languages like Javascript and hell, even Java has lambdas now.I'm guessing that also hardcore FP people have moved on to Haskell. The ones that like LISP to Racket... and only people tied to the JVM in legacy projects are with Clojure.	thiago_fm	12.660737	-7.88841	comment	8.0	28.0	1676457744	-11.245426
19098639	I am not disagreeing nor challenging	I am not disagreeing nor challenging you; I'm happy you like it and I think you should keep using it since you enjoy it so much. My question is: Wouldn't the same be said by most programmers with a high degree of proficiency with a language? What sets Clojure apart from Haskell or Scala or Elixir or Erlang? Do you have a high degree of proficiency with something else?Clojure is the language that I have always wanted to learn, but the benefits never seemed very apparent. I'm hoping your response will make them clear.	_t0du	12.6500845	-7.8945823	comment	8.0	51.0	1549480455	-11.16211
19347432	Back when I worked on building softw	"Back when I worked on building software for clients, I used to tell people ""we run all software on the Java Virtual Machine"" instead of ""it's written in Clojure"", because I was afraid they would get scared.But then I noticed that nobody actually cares much about what tools you use, as long as they get the job done. The end result is what counts."	jwr	12.645759	-7.8790836	comment	8.0	64.0	1552154473	-11.17892
19472620	What's the case for using clojurescr	What's the case for using clojurescript these days in a company compared to JS 2019? the project has almost no contributors, no one working full time on it, the closure library they use its from 2016, the friction to interop with JS is still too high and too much of a hassle, they never embraced npm because they didn't want to listen to their users like typescript, etc..	Scarbutt	12.655421	-7.8728523	comment	8.0	27.0	1553379140	-11.160269
19521254	Clojure is awesome. But refactoring 	Clojure is awesome. But refactoring a big project without a type system is very hard and error-prone, and clojure error messages are very difficult to understand.	G4BB3R	12.604091	-7.875632	comment	8.0	29.0	1553864840	-11.182461
19707660	Show HN: Tetris Implemented in Cloju	Show HN: Tetris Implemented in ClojureScript	djblue	12.639795	-7.8743052	story	8.0	135.0	1555780796	-11.161117
19952122	Supdate – A Clojure library for tran	Supdate – A Clojure library for transforming nested data structures	tosh	12.621785	-7.886617	story	8.0	155.0	1558253287	-11.170046
16508990	Clojure Don’ts: Lazy Effects (2015)	Clojure Don’ts: Lazy Effects (2015)	lsh	12.651184	-7.9076695	story	8.0	108.0	1520080157	-11.173683
17037142	Often those who are curious to try L	Often those who are curious to try Lisp are faced with a number of choices: Which dialect to choose? Which implementation to choose? Which book or tutorial should one follow? Is it necessary use Emacs? SLIME?Here are my recommendations:- Choose Common Lisp because it has been the most popular dialect of Lisp in the overall history of Lisp. It is more convenient than Scheme if one decides to develop serious software in Lisp. Clojure appears to be more popular in the technology industry than Common Lisp among organizations (my workplace included) that use Lisp. I still recommend Common Lisp because I believe that it is more likely that one would work on an independent open source or hobby Lisp project than one would encounter one of the rare organizations who use Clojure at work.- Choose SBC	susam	12.682012	-7.8492885	comment	8.0	37.0	1525940016	-10.735857
17126007	Are the elm overlords still hell ben	"Are the elm overlords still hell bent on ""thou shalt program our way or not at all""Because that kind of dogmatism is a complete show stopper for languages that want to be deployed on even medium term projects."	grandinj	13.007291	-7.692428	comment	8.0	39.0	1526998128	-12.752907
17633556	I loved using Parinfer when I was wr	I loved using Parinfer when I was writing ClojureScript, but it also made me question the value of Lisp syntax.If brackets can be inferred from indentation, doesn't this imply that they're extraneous — that indentation only would be sufficient to write many Lisp structures?	modernerd	12.634297	-7.854264	comment	8.0	34.0	1532791915	-10.891073
17784028	Publishing an iOS App with ClojureSc	Publishing an iOS App with ClojureScript and React Native	spinningarrow	12.68219	-7.7971635	story	8.0	76.0	1534523683	-11.223063
21190458	I enjoy Clojure and spec is very int	I enjoy Clojure and spec is very interesting; but it remains uncertain if I have any problems that spec will solve. I'm not really that interested in the generative testing aspect since I write mostly amateur code.So I can't figure out if it is more like a debugger for targeted location of difficult bugs or more like compiler error messages where it becomes a pervasive part of the workflow.There is obviously something to this spec if it warrants a v2. It just isn't obvious whether it solves my problems, library maintainer problems or professional problems. It is very different to the immutable-everywhere design where a Clojure beginner is forced in to understanding it to even try trivial experiments.	roenxi	12.649377	-7.902489	comment	8.0	36.0	1570528816	-11.120227
39121392	Babashka: Fast native Clojure script	Babashka: Fast native Clojure scripting runtime	zbentley	12.635726	-7.890128	story	8.0	204.0	1706123391	-11.12521
18160390	A Year in Clojure	A Year in Clojure	tosh	12.657913	-7.9109917	story	8.0	313.0	1538918097	-11.175412
18162279	From what I have seen in this articl	"From what I have seen in this article, and hn thread, and every time in general when there is a discussion about clojure or dynamic typed languages, you are only speaking about tiny examples and even more tiny projects.
I can’t really imagine myself working on a million line project written in clojure or another language without any type safety.
Happy to be wrong, but I’d like to hear the experiences of people actually working on this kind of big projects rather than pointing to toy projects less than 10k lines maintained by tens of people...
From my experience dynamic typing can be awesome for small prototypes, but to be production ready you need to spend much more energy for testing.More on the topic I can say that I don’t really see anything compelling that you can’t easily do in F# wit"	tigershark	12.457433	-7.8184404	comment	8.0	37.0	1538941583	-11.086903
18364342	Do you reccomened Clojure over Haske	Do you reccomened Clojure over Haskell to learn ?	verymelo_	12.519103	-7.8718004	comment	8.0	29.0	1541176155	10.429552
18698802	I've been looking at the Clojure imp	I've been looking at the Clojure implementation, core.logic, but can never figure out what to use this paradigm for. Can anybody name the cases where logic programming really shines?	simongray	12.739284	-7.7443523	comment	8.0	35.0	1545053555	-11.5391245
18741495	"""Maybe Not"" by Rich Hickey: https://"	"""Maybe Not"" by Rich Hickey: https://www.youtube.com/watch?v=YR5WdGrpougAnother excellent talk by the creator of Clojure, and like the previous ones, relevant for all programmers."	ttiurani	12.657876	-7.9103694	comment	8.0	69.0	1545499757	-11.151555
18896154	An Experimental Port of Clojure to C	An Experimental Port of Clojure to Common Lisp	tosh	12.64733	-7.8871517	story	8.0	108.0	1547377203	-11.07033
13025941	Elm for the Front End, Right Now	Elm for the Front End, Right Now	listrophy	13.010381	-7.693477	story	8.0	101.0	1479936381	-12.769739
13134104	How to Use Clojure for Scripting	How to Use Clojure for Scripting	asimjalis	12.647012	-7.8995104	story	8.0	116.0	1481229810	-11.1692505
13282240	They left out the part where Clojure	They left out the part where Clojure DOES NOT implement tail-call optimization for mutually recursive functions. Without TCO, you can't fully leverage functional composition and immutable data structures without introducing some ugly hacks or relying on other language-level constructs offered by the implementation--that they can't be implemented in the language strongly suggests something about the limitations of the language.[1]A great language that does optimize mutually recursive tail-calls, among many other elegant features: Lua!... TCO, asymmetric stackful coroutines (90% as powerful as call/cc, but with zero calories), lexical closures, prototype-based object orientation, duck typing-based object orientation (among other possibilities), and a first-class C API that allows C code to w	wahern	12.468845	-7.7906694	comment	8.0	77.0	1483067882	8.9438095
13408196	Re-Frame:  a Reagent Framework for W	Re-Frame:  a Reagent Framework for Writing SPAs, in ClojureScript	jdnier	12.648497	-7.891193	story	8.0	146.0	1484540907	-11.155289
13451456	"""Ok the app works now!""I say this af"	"""Ok the app works now!""I say this after running the last command in the REPL - it's what I've been doing for the last 2 hours. I haven't looked at the browser since I started.I switch to the browser and sure enough, the whole thing works perfectly.This is the Clojure(script) experience - it's a different method of developing applications. Combined with the brilliant weirdness of the language itself, it sucks you into the REPL and persists even after you've finished coding.The most suitable word for this experience is ""hacking"". You don't code your program, you hack it.The only drawback of Clojure/Clojurescript is the high learning curve.Maybe the 20 years of OO programming have really left a dent on my brain or maybe it was because of the young age of the ecosystem, or maybe because toolin"	delegate	12.651258	-7.88937	comment	8.0	49.0	1485025133	-11.158964
13591939	I really want to love Clojure. I've 	I really want to love Clojure. I've been playing with it recently and I still have some hopes for it. I am comparing it to Elixir for my next language of love. I have a lot of experience with Javascript/Node and secondly Ruby.I want to embrace a functional paradigm. I want to lean on Clojure because of the versatility of also being able to leverage ClojureScript.So far I have hit some bumps that are a bit frustrating.1. I changed too many files at once and the stack trace error I got gave me literally 0 clue on what was wrong. It was such a feeling of doom that it scared me on how to debug Clojure apps. The stack trace was full of Java errors and nothing pointing me in the direction of where the app was failing from Clojure's perspective.2. Momentum of Web-Development and embracing new tec	dfischer	12.650785	-7.8922353	comment	8.0	44.0	1486495942	-11.100913
27699531	I think you might be missing the mai	"I think you might be missing the main ""aha!"" of clojure REPLs vs REPLs in non-homoiconic languages:   you can very easily execute small parts of the program you're editing without re-typing the code.In emacs, for instance, you often use `eval-last-sexp`, by default bound to C-x C-e.  This lets you move your cursor to a particular point in the file, often deep in a function, and get the results of just the form(s) you're pointing at.This is a superpower!  It lets you test small pieces of your code without writing any test harnesses or scaffolding.  Try it with an editor that embeds the repl and has these commands, and you'll never want to develop any other way.It does cause you to want to structure your code in 'repl-friendly' ways, so that you can, say, restart your main server or reset yo"	smw	12.629265	-7.871691	comment	8.0	84.0	1625150715	-11.14007
27819323	Serious question: how popular is Elm	Serious question: how popular is Elm? I've recently seen some tutorials showing up and anecdotally know some friends that have played around with it, but I haven't seen any job postings for it and so I'm wondering if it's just hyped up or if there is real demand for Elm developers professionally.	yladiz	13.004683	-7.692001	comment	8.0	48.0	1626171718	-12.771264
27937910	I'll take the downvotes, and no disr	I'll take the downvotes, and no disrespect to the project itself - but only to the falling-over-self comments about ClojureScript.If you care about semantics at all, or even want your code readable by someone who is in their early days of trying to understand and learn code - it's just ugly and hard to read.I've been coding since I was 14, and I don't feel bad in saying that I can't tell you what this line does without looking it up. (reset! caret-location nil)))) I can't imagine how you could argue this is good and adheres to any philosophy of openness or readability.	tomlin	12.653863	-7.8939705	comment	8.0	53.0	1627093700	-11.183819
22473380	I'm a Programming Language enthusias	I'm a Programming Language enthusiast, currently making my own language.  I'm really curious what makes Clojure different - it's pretty much the most loved language among its proponents (i.e. people love e.g. Rust and Go as well, but not as much as those who love Clojure, love Clojure). Is there any very Clojure-y code you can point to, that would showcase it? Is it just the libraries - collections, concurrency primitives - that could be replicated in another language? It's can be just homoiconicity, as that's just Lisp, but it could definitely be a big part of it... Do you have any ideas what any other language (e.g. Python, TypeScript, Go, Rust, Julia, Haskell, OCaml) would need to change to make you as productive as Clojure?	tomp	12.639657	-7.8793993	comment	8.0	27.0	1583232612	-11.128611
22562344	A story, since in retrospect I think	A story, since in retrospect I think it's worth telling.Some years ago I was at the SF Clojure meetup.  Arthur Whitney's daughter worked at the sponsoring company, and he agreed to come tell us about K.In retrospect, I don't think we gave him the welcome he deserved.  No one was rude or anything, but it seemed there was a disconnect:  Arthur was keen to show off how fast K (and Kdb) was, over zillions and zillions of rows.But the thing that the Clojurists were all searching for (that got them into Clojure in the first place) was expressivity.  Is Clojure fast?  I don't know, generally the problems I face come down to avoiding balls of mud rather than performance bottlenecks.  And I think that was true of most there.So Arthur got something of an underwhelming reception.  I remember someone 	invalidOrTaken	12.650152	-7.898264	comment	8.0	64.0	1584050631	-11.16497
22823767	These posts (and HN comments) really	"These posts (and HN comments) really make me wonder if adopters of fringe languages are always going to be thin-skinned developers who get emotional when they realize they won't be part of the language's design decisions. That ""On Whose Authority"" rant about Clojure complains about the exact same things. And I'll refer to Rich Hickey's response: https://old.reddit.com/r/Clojure/comments/73yznc/on_whose_au....Elm in particular has this weird problem where there are vocal people in the community who you can count on to drape a wet, accusatory blanket over every discussion, and you wonder why they can't just find another language that they do like. Sometimes you need to leave the theater so other people can enjoy the show.Also what are these languages yall are using where you're part of steer"	hombre_fatal	12.653822	-7.9025426	comment	8.0	34.0	1586447790	-11.160301
23166072	I've posted this quote before, but i	I've posted this quote before, but it might help explain why making Clojure easier to get into maybe hasn't been a priority for Hickey et al.So we need players. I would rant here, but I won't. But look at this guitar player with blisters. A harpist has blisters, a base player with blisters. There's this barrier to overcome for every musician. Imagine if you downloaded something from GitHub and it gave you blisters. - Rich Hickey (Design, Composition and Performance)Clojure seems more concerned with power, expressiveness, and reach, rather than ease of use. Does this alienate new users, sure, but the Clojure community seems OK with that as a trade-off.	adamkl	12.648864	-7.9081573	comment	8.0	43.0	1589372264	-11.157456
33081672	If I was choosing a language to base	If I was choosing a language to base the tech stack for a startup on these days I'd be very reluctant to pick anything that didn't have a local user group. Slightly more esoteric languages that enable you to write better code faster are brilliant, but if you're successful enough to grow quickly, or you can raise funding, you'll need to hire devs relatively early on. If you've chosen a stack that's too esoteric then this will be a huge blocker to making any real progress.When I did my last startup we switched from a Python API to Node for this reason. Python is a great language but there are no devs available where I live. I can't even imagine considering Clojure unless I was in a major tech hub.The move to remote work is probably going to be a massive benefit to building in less mainstream	onion2k	12.6403675	-7.88564	comment	8.0	50.0	1664897024	-11.13069
33296590	As someone who really really tried t	As someone who really really tried to like Clojure, here's the issues I faced, roughly in order starting from biggest:1. No framework. Clojurists tend to prefer libraries and I would too, but for a newbie starting out, when every other language seems to have converged on one standard way of doing things (Spring, Rails, Phoenix, Django etc), Clojure just gets in the way with decision fatigue.2. Leaky abstraction. At every level it is apparent that Clojure is hosted on JVM or Javascript. Simply knowing Clojure is not enough, and you have to understand the underlying semantics to know what is going on. Exception stack traces are excellent example.3. Unmaintained libs. While the language is stable and libs are much more likely to work still, unmaintained libs often mean some stuff does not wor	e3bc54b2	12.644294	-7.89281	comment	8.0	43.0	1666428462	-11.146042
33801575	A related question is why would you 	"A related question is why would you want to reload the entire file/namespace every time you make a change?Coming from a Common Lisp background, I am used to evaluating single forms/functions. I would sometimes re-evaluate the entire namespace, but that would be relatively rare.I switched to Clojure many years ago and followed the same workflow. Then ClojureScript and tools like figwheel came along and I was somewhat surprised to find that people admire the ""auto-reload"" functionality so much: save a ClojureScript file and all of it gets re-evaluated in the browser interpreter. I found this to be inefficient, somewhat annoying, and a big step back from evaluating exactly what you wanted to.My guess is that lots of those people never worked with a REPL where you eval single forms from the ed"	jwr	12.6358795	-7.875092	comment	8.0	35.0	1669820177	-11.157865
33843493	This day I asked it not too fundamen	This day I asked it not too fundamental questions about Clojure and it was able to provide impressive, accurate answers and provide correct code examples.  However if you continue the dialogue and ask it to do more advanced stuff, it will just make up stuff out of thin air.  For instance it will use functions that don't exist and claim that they can be imported from packages that don't exist or don't have them.  Once you point out these mistakes, it will admit them and come up with different changes which can be even worse, but sometimes also be better and save the whole thing.  Overall I'm not sure how useful this will turn out, given that its not reliable.  It may be useful to get some initial intuitions and informations (non specific stuff it usually gets right), but it can also mislead	lgrapenthin	12.652314	-7.901245	comment	8.0	27.0	1670075847	-11.1656685
26586209	Do people still use Clojure?  For a 	Do people still use Clojure?  For a while I was really hot on Clojure ... but then I haven't had a project in ten years where it even makes sense to introduce it into operations ... generally I've got Python or Go on the server and some mix of JS, Dart, Objective C, or Kotlin on the front end depending on the client platform.Maybe someday I'll be responsible for writing a system back end from scratch and I can take off on a flight of fancy like this.	TheMagicHorsey	12.657412	-7.8890166	comment	8.0	37.0	1616710411	-11.193807
27286856	Are there any other resources that y	Are there any other resources that you'd recommend to people coming from languages like Python or JavaScript? I'm assuming 'Clojure for the Brave and True'?	avtar	12.647831	-7.8894205	comment	8.0	26.0	1622008314	-11.160157
38528700	What do you prefer?(I quite like Clo	What do you prefer?(I quite like ClojureScript.)	stefcoetzee	12.654979	-7.8860197	comment	8.0	25.0	1701769203	-11.174063
14870642	State of Elm 2017 Results	State of Elm 2017 Results	myth_drannon	13.013301	-7.6959434	story	8.0	83.0	1501197799	-12.746969
15568386	Clojure vs. Kotlin vs. Elixir which 	Clojure vs. Kotlin vs. Elixir which has the brightest future?	ahoibro	12.637693	-7.759835	story	8.0	15.0	1509113319	12.895058
15577879	Clojure transducers from the ground 	Clojure transducers from the ground up: using them in practice	ghosthamlet	12.60753	-7.8821115	story	8.0	79.0	1509248935	-11.15609
23419216	Has anyone used Clojure much? I love	Has anyone used Clojure much? I love Rich's talks so I've been very interested in it but there are so many great languages to learn these days.	redisman	12.655051	-7.9028625	comment	9.0	46.0	1591291034	-11.166285
23792645	I started learning Clojure yesterday	I started learning Clojure yesterday,I've gone through the docs here and have a grasp of the language. Does anyone have some good resources for further learning? Maybe some high quality tutorials? I'm mostly interesting in web / apis	derision	12.658904	-7.901852	comment	9.0	31.0	1594395595	-11.166928
23927947	can one make a career out of clojure	can one make a career out of clojure?	dbancajas	12.7131815	-7.955524	comment	9.0	28.0	1595516038	-11.160394
20264168	The fact that Clojure runs on JVM tu	The fact that Clojure runs on JVM turns me off. I find that Elixir is very similar to Coljure, with a runtime that better supports immutability and concurrency.	erokar	12.639352	-7.8532906	comment	9.0	41.0	1561388311	12.849221
20268205	I'm pretty sold on Clojure's value, 	"I'm pretty sold on Clojure's value, I've read up on its structure/syntax, but generally struggle with learning the standard lib and trying to read/write actual code. Any resources you can recommend for gradually ramping up, and/or ""lightbulb moments"" for a dev steeped in C-like languages?"	lukifer	12.649932	-7.8950176	comment	9.0	30.0	1561408694	-11.177384
20428727	Clojure’s Approach to Identity and S	Clojure’s Approach to Identity and State (2008)	tosh	12.653667	-7.9017525	story	9.0	190.0	1563034130	-11.174394
20661874	I’m used to 0 and [] being falsy. Up	I’m used to 0 and [] being falsy. Upsides and downsides to Clojure’s choice here?	asplake	12.64022	-7.901046	comment	9.0	71.0	1565443304	-11.169912
20846527	Clojure Help:This is super apropos s	Clojure Help:This is super apropos since I am JUST learning Clojure via the Clojure Koans.Any tips from clojurists on getting the repl (and readline) working fluently? I'm using Leiningen but it's not responding as I'd expect. I would think this would all set up more effortlessly.Tips on getting a new Clojure setup working would be appreciated.	rrosen326	12.652414	-7.9018483	comment	9.0	32.0	1567262324	-11.168004
20937215	Rich Hickey on Datomic (2012) [video	Rich Hickey on Datomic (2012) [video]	tosh	12.678425	-7.906	story	9.0	121.0	1568184247	-11.188866
13661418	At some point it felt like Clojure w	At some point it felt like Clojure was the future, the new thing, so amazingly better - was that just a feeling of novelty? Or something went wrong with its use case?Of course, these days its about Rust, Swift and LLVM, but it doesn't have those lispy properties we love...	swah	12.643821	-7.892575	comment	9.0	36.0	1487264096	-11.159541
13869706	I would love for there to be a simil	I would love for there to be a similarly thorough project with Clojure. It really bothers me there's no good native compiler. Apart from anything else, it means that Clojure lives and dies by the languages it compiles to, and while Java is used everywhere still, it probably isn't the thing the kids are learning these days. Besides, without going into any further rational arguments for why using the JVM (or another VM) isn't always great, something about it feels a bit icky to me. On an aesthetic level.	scotchmi_st	12.646147	-7.892699	comment	9.0	54.0	1489513421	-11.171147
13981261	Curious over why CL vs Clojure? Any 	Curious over why CL vs Clojure? Any comments.	shady-lady	12.651858	-7.902053	comment	9.0	54.0	1490739279	-11.173871
14376919	Alternatively, just write software i	Alternatively, just write software in a Lisp variant (with good macros, clojure is quite meh here) or Ocaml or Haskell.These languages put you at the level of writing a language for each problem domain immediately and with a comprehensive and useful toolkit. These languages also do this while directly competing with all but the most carefully tuned of C++/C environments. Steel Bank Common Lisp and the Glasgow Haskell Compiler are good references here.These languages are often considered strange because of this, and feel somewhat alien. But once you realize you're building a language to model your problems, suddenly tons of stuff makes more sense. Previously alien concepts like Macros and Monads are outside the typical language's experience precisely because the language authors created the	KirinDave	12.570688	-7.7963853	comment	9.0	60.0	1495209490	-11.047652
19096932	Okay, here's my take on the implicit	"Okay, here's my take on the implicit narrative here: Clojure is done. It will continue to improve, people will continue to use it and build cool things with it, but maintainers are burnt out, mostly because there aren't enough of them and partly because of the passive-aggressive relationship Cognitect has with the community.There's a whole bunch of languages with small dedicated communities doing interesting stuff. D and Julia occur to me off the top of my head. It's not ""failure"" that Clojure doesn't really challenge Kotlin or Scala for mindshare. It's nonetheless disappointing for people like me who used to be really excited by Clojure's potential.Could it have been different? I don't know. The powers that be could definitely have been more committed to growing the base, but it never see"	moomin	12.647424	-7.899622	comment	9.0	100.0	1549472378	-11.16457
19479167	I can, and do, appreciate opinions o	I can, and do, appreciate opinions on languages themselves. But my decision to continue using Python over Clojure is much less about the language's syntax and more about the available libraries. How do Clojure web frameworks compare to Django/Flask? What would I use instead of Pandas for data analysis? Are there keras-like deep learning tools?Switching languages based on a comparison of idiosyncrasies between the two seems like moving to a new city based solely on the weather: a valid consideration, but nowhere near sufficient.	Townley	12.645389	-7.8868065	comment	9.0	56.0	1553466944	-11.14709
15978612	Macchiato – A way to build Node web 	Macchiato – A way to build Node web applications using ClojureScript	tosh	12.657255	-7.8883753	story	9.0	132.0	1513863350	-11.151602
17640414	As someone running a technical recru	"As someone running a technical recruitment agency, I can assure you that it is true that someone having built stuff in Clojure is more likely to be considered as a good engineer than someone who did JQuery all the time.Recruiters use an intuitive approach to conditional probability. Given only the info alone (if someone did JQuery or Clojure) exposes you to two bell curves, with the X-axis being ""programming ability"". The first bell curve that has all JQuery people is more on ""the left"" and the one having all Clojurians is more on the right. The Clojure bell curve has shitty engineers and some really good people are part of the JQuery one.Prejudice is sort of rational. If a recruiter looks at one datapoint, it's unlikely that it is at the tails of the bell curve, so the Clojurian applicant"	iwangulenko	12.654379	-7.9189305	comment	9.0	86.0	1532900348	-11.175289
21090288	Elements of Clojure	Elements of Clojure	tosh	12.631603	-7.8952127	story	9.0	381.0	1569579752	-11.164936
18014002	GraalVM is very impressive. But cloj	GraalVM is very impressive. But clojure is very much associated with Java/JVM Ecosystem which makes it very hard to  convince people to use it. My ruby friends would say oh i cant install clojure because i have to install JVM. Clojurescript like lumo or planck is still better, but it isnt a real backend solution. Clojurescript is great for the frontend though. I think clojure needs a native solution written in Clojure + LLVM that leverages existing C-libs. A seperate JIT/compiler that is not JVM, that is not a language with Borrowed GC + VM.	pankajdoharey	12.615208	-7.8416543	comment	9.0	50.0	1537266532	-11.173047
29774874	I've learned Clojure. Tried and fail	I've learned Clojure. Tried and failed to see this unique power of macros.Truly asking for help: can you help explain what can I do with macros that I cannot do with functions? Or, maybe, cannot do with high quality or low complexity using functions?	rmbyrro	12.619054	-7.87517	comment	9.0	67.0	1641163375	-11.00109
30424234	Do I need to have a somewhat decent 	Do I need to have a somewhat decent knowledge of Java to plunge into Clojure right away?	forlorn	12.65314	-7.897021	comment	9.0	30.0	1645506801	-11.198516
30428242	How do people who write Clojure deal	How do people who write Clojure deal with lack of type checking?And auto-complete when it comes to Java library interop?I tried Clojure, to build a tool on top of a popular Java library that I was new to.And compared to other JVM languages it was not good because there was no type-checking or intellisense/autocomplete popups for the methods.	gavinray	12.587743	-7.883206	comment	9.0	27.0	1645539870	-11.175303
13216365	I'm a massive fan of Clojure (I spok	I'm a massive fan of Clojure (I spoke at EuroClojure this year), and have used Unity3D for 5 years... I was also the developer of the first big iOS Haxe game, another unproven platform at the time, years ago.I would be very concerned about straying too far from the garden path while also trying to ship a commercial game.Unity's GC isn't even generational, a very bad mix with garbage heavy Clojure code. Expect confusing, bizarre and transient performance and memory use issues. Debugging will be a nightmare.And on top of that, Stack Overflow doesn't have an unlimited supply of Clojure JVM answers; Clojure .Net through IL2CPP? Forget it; you'll have to figure everything out yourself.It's generally a mistake to make the initial development more pleasant at the expense of long term maintainabil	reitzensteinm	12.649688	-7.891223	comment	9.0	44.0	1482194530	-11.144653
13398426	Learn ClojureScript in a Cloud IDE	Learn ClojureScript in a Cloud IDE	gw	12.658377	-7.900569	story	9.0	101.0	1484403232	-11.160626
13514568	ClojureScript 1.9.456, Externs Infer	ClojureScript 1.9.456, Externs Inference and Comprehensive JavaScript Modules	tosh	12.657268	-7.882686	story	9.0	166.0	1485704562	-11.138822
27700811	Maybe I'm wrong, but I don't think E	Maybe I'm wrong, but I don't think EDN really has anything to do with homoiconicity. You're just parsing in data (strings) into other data (internal Clojure data structure). It's nice that the syntax matches how you'd write the data structure in Clojure itself.. but you could also parse EDN in a non-homoiconic language.Clojure's lispyness is a bit overplayed? I feel it's generally irrelevant for the vast majority of language users and it's really not what makes the language great. I seldom seeing custom macros... and while I'm sure it's important for a minority and I'm glad it's there - if it was disabled tomorrow (outside of the language internals) I'd probably take me a while to even notice :)	geokon	12.623073	-7.8580523	comment	9.0	35.0	1625156487	-11.045226
27829635	Zig, Skia, Clojure, Geometry and the	Zig, Skia, Clojure, Geometry and the Japanese TV Show: ICFP Contest 2021	ajxs	12.653154	-7.9035583	story	9.0	262.0	1626235840	-11.164567
27865143	Elixir protocols vs. Clojure multime	Elixir protocols vs. Clojure multimethods	sandbags	12.651824	-7.783435	story	9.0	160.0	1626522432	12.897784
28036654	> An incoming HTTP request? it is a 	> An incoming HTTP request? it is a plain Clojure dictionary.I learned to code in Python. Loved it. Dynamically typed dicts up the wazoo!Then I learned why I prefer actual types. Because then when I read code, I don't have to read the code that populates the dicts to understand what fields exist.	EdwardDiego	12.634422	-7.872434	comment	9.0	77.0	1627913041	-11.103839
22380439	Because with modern Javascript you g	Because with modern Javascript you get most of the niceties of Clojure (immerjs for immmutability, lodash for data processing, babel for macros) without the disadvantages (no job market, no ecosystem). The debuggers in JS are so good that you don't need the Clojure repl. JS under v8 is also faster at raw processing(single thread but there are also workers now) unless you write Java with parenthesis, which at that point, you are not writing clojure anymore.OTOH, Rich Hickey has influenced(in good way) a generation of programmers and doesn't get credited enough.	Scarbutt	12.6519375	-7.865197	comment	9.0	42.0	1582251481	-11.164596
22809667	I don't see anything profound here, 	"I don't see anything profound here, except perhaps that the language will gladly accept the user's blatant type error and just explode at runtime. For the most part this article is fetishising over basic syntax.Surely the compelling parts of Clojure go somewhat deeper than basic syntax. And if this is another tired discussion about legibility of syntax between languages, I have to wonder why people are still so fascinated by this?Between the following two representations of the same function…  (defn f [x] (+ (* 3 x) 1))

…and…  f x = 3 * x + 1

…I see very little difference in legibility. Sure, one is visually noisier (and incidentally, the noisier, less clean(!!!) notation is Robert C. Martin's favourite) but if you can afford to navel-gaze this much on syntax I'd question why you don't h"	yakshaving_jgt	12.644072	-7.888656	comment	9.0	41.0	1586315227	-11.095891
22810937	Maybe this lisp syntax intro is a go	Maybe this lisp syntax intro is a good place to ask veterans a related question.I find s-expressions quite beautiful and simplistic way to express both logic and data as a tree. On the other hand, top-level evaluation rules are often glossed over, and seem to mess up this elegance. I feel like there is a set of braces missing at top level, for s-expression concept to be complete. I don't really know enough about specific rules or reasoning why they need to be introduced. My mental model of top-level execution is an implicit `(do ...)` block. In rest of clojure code the `do` is a special form that is frowned upon because it is used only when side-effects are necessary.As it is, the 'module' concept is strictly tied to a file, which feels unnecessary. If top-level was enclosed in braces and 	jmiskovic	12.627066	-7.860041	comment	9.0	39.0	1586333032	-10.896447
22852375	Luminus – A Clojure Web Framework	Luminus – A Clojure Web Framework	Naac	12.6553135	-7.9015803	story	9.0	224.0	1586742425	-11.174964
22861242	I had the same issue. Then I went ba	"I had the same issue. Then I went back to the roots: LispAnd learned Clojure.You will feel like you know nothing.
You will feel handicapped.
You will be confused.Then, one day, you will understand what simplicity means
and how Clojure's design embraces that more than in any other language I know.
By then you will have embraced the flying-by-your-pants-exploratory style of programming at the REPL.
And don't want to go back anymore.It's awesome!"	beders	12.65168	-7.8987293	comment	9.0	40.0	1586819888	-11.164077
33103645	I'm about to embark on my master's t	"I'm about to embark on my master's thesis, in a domain[1] which could realllllly use the ""attach to running process; re-evaluate code and have the system just keep going"" aspect of Lisp languages.I know Python best. But I have reached my breaking point with its syntax, and its lack of binding constructs, and lack of symbol datatype, quote, etc. I am intending to use Clojure ... but I have to ship this thing by May 2023 come hell or high water.All else being equal, I will proooobably be able to go further with Python. But I'm concerned it will hamstring me from doing the crucial feature of ""extending the design [ie code] of a game as it runs"" since, AFAIK, it's difficult to get a Lisp-ish experience of total live reloadability in Python... jurigged[2] and reloading[3] not withstanding.I kno"	maxwelljoslyn	12.62834	-7.8521285	comment	9.0	32.0	1665023550	-11.064423
33622406	Maria: A ClojureScript coding enviro	Maria: A ClojureScript coding environment for beginners	macco	12.650236	-7.893104	story	9.0	212.0	1668604519	-11.185665
33888937	I really wish there was a Clojure-li	I really wish there was a Clojure-like Lisp that wasn't married to the JVM. Yes, I know there are a few, but nothing compiled :(	packetlost	12.6539955	-7.8796606	comment	9.0	43.0	1670371686	-11.111975
26578417	Rich Hickey and Brian Beckman – Insi	Rich Hickey and Brian Beckman – Inside Clojure (2009) [video]	tosh	12.65791	-7.9070964	story	9.0	135.0	1616667949	-11.165578
26861881	Apologies if this is too off-topic, 	Apologies if this is too off-topic, but I'm currently trying to decide between Elm and ClojureScript to get started with FP. Can anyone weigh in with recommendations?The points this article makes like strong typing pull me towards Elm, but people talk about understanding Lisps as a nirvana-like state of enlightenment, which pulls me towards Cljs	deergomoo	12.851805	-7.7137666	comment	9.0	29.0	1618834547	-12.6384535
38540891	Sort of a meta comment -- the articl	"Sort of a meta comment -- the article starts saying that people keep asking ""why Clojure"".Why such an emphasis on what language stuff is written in? Why does it even matter? Sounds like it was a good engineering choice given the constraints of the problem, get over yourself ffs."	qsort	12.635696	-7.906526	comment	9.0	46.0	1701842713	-11.1484785
14788547	I have yet to see anything that actu	I have yet to see anything that actually documents well other than code itself.  Comments are _always_ subject to the problem of going stale or being poorly worded.  I haven't played with it much, but Clojure's spec looks like a good tool for documenting how functions should behave. That plus a description in the docstring might be the best thing out there right now.	wry_discontent	12.641514	-7.9045663	comment	9.0	38.0	1500300141	-11.138466
15464783	No one in this thread is yet talking	No one in this thread is yet talking about the content of this talk, which I think is interesting. Rich is doubling down on dynamic typing. As the world is gradually moving to more statically-typed languages (Rust, Swift, Go, Elm, Purescript, Typescript are all popular tools that come to mind), Clojure remains in the embrace of dynamic typing, and this talk is an interesting look at the perspective of why that is, and adds perhaps a little bit to the debate between static and dynamic typing.I admire Rich a lot, but I also admire John Carmack, and it is apropos that yesterday another comment was shared on another post here [0] about his opinions on static typing, and how in just a few years (his talk was in 2013), the industry as a whole has made considerable changes in its opinions of stat	hellofunk	12.476842	-7.820881	comment	9.0	113.0	1507895305	-11.099583
15567164	Clojure vs. The Static Typing World	Clojure vs. The Static Typing World	keymone	12.559066	-7.8657765	story	9.0	83.0	1509101086	-11.144282
14442715	Notes on debugging Clojure code	Notes on debugging Clojure code	melqdusy	12.647542	-7.9004755	story	9.0	97.0	1496111854	-11.147697
30769577	I do wonder what has to happen for g	I do wonder what has to happen for greater adoption of Clojure.	buzzwords	12.656279	-7.90655	comment	9.0	54.0	1647973379	-11.183858
31214294	ClojureRS – Clojure interpreter impl	ClojureRS – Clojure interpreter implemented in Rust	capableweb	12.355089	-7.933659	story	9.0	122.0	1651306654	-11.131276
26184044	Phel: A language inspired by Clojure	Phel: A language inspired by Clojure that compiles to PHP	yogthos	12.645112	-7.897578	story	9.0	81.0	1613675046	-11.14484
36448293	Tour of our 250k line Clojure codeba	Tour of our 250k line Clojure codebase (2021)	todsacerdoti	12.661411	-7.9102507	story	9.0	86.0	1687534387	-11.170626
28723447	I write Clojure for food, and Common	I write Clojure for food, and Common Lisp for fun. One reason for the latter is CL's speed -- awhile back I compared a bit of (non-optimized) Clojure code I wrote for a blog post with a rough equivalent in CL, and was stunned that the Common Lisp code ran about 10x faster.  This made me curious as to how fast it could be made if I really tried, and was able to get nearly 30x more[1] by optimizing it.Clojure is definitely fast enough for everything I've done professionally for six years.  But Common Lisp, while having plenty of rough edges, intrigues on the basis of performance alone.  (This is on SBCL -- I have yet to play with a commercial implementation.)[1] http://johnj.com/from-elegance-to-speed.html	eigenhombre	12.647839	-7.8850007	comment	9.0	52.0	1633122892	-11.104961
29217755	Show HN: Luna is a Clojure domain sp	Show HN: Luna is a Clojure domain specific language that translates to regex	lazyfolder	12.623235	-7.863052	story	9.0	56.0	1636903841	-11.135747
29448463	Stephen Wolfram – re:Clojure Keynote	Stephen Wolfram – re:Clojure Keynote [video]	tosh	12.65506	-7.906767	story	9.0	81.0	1638703410	-11.163768
29572868	How do you use lisp style macros whe	How do you use lisp style macros when you have 500 developers working on a single product?If you have 500 developers on a java project, you tell the new person which version of java you’re using, you mention whatever libraries or frameworks you lean on heavily and you give them a walk through the subsystems, their key components and essential abstractions and then you spend time showing how the build system is setup and how to create an environment for the system. Then they start knocking out features. There’s a bit more than I’ve said but overall It’s pretty straightforward, any java-for-hire person knows the score and everyone just cracks on with it.How do you do this when the language itself is programmable? Clojure probably avoids my concern by two facts - it embraces immutability and 	CraigJPerry	12.654717	-7.8919454	comment	9.0	41.0	1639610842	-11.056752
25322836	Semantic Clojure Formatting	Semantic Clojure Formatting	todsacerdoti	12.6422205	-7.889012	story	9.0	80.0	1607254448	-11.145927
22245488	Elm has been out a long time and tha	Elm has been out a long time and that is a really short list.  Are there key reasons elm hasn’t seen more adoption? (Please don’t bother with comments about corporate drones etc.... companies are pretty good at taking advantage of a good thing)	kweinber	13.011991	-7.695029	comment	9.0	50.0	1580897458	-12.763877
31050693	Clojure Dart	Clojure Dart	coltnz	12.6466	-7.9145336	story	10.0	156.0	1650097859	-11.144557
31585585	ClojureDocs – Community-powered docu	ClojureDocs – Community-powered documentation and examples for Clojure	capableweb	12.648271	-7.897516	story	10.0	198.0	1654106263	-11.17811
25655354	Clojure, Faster	Clojure, Faster	elamje	12.647261	-7.9022813	story	10.0	127.0	1609917298	-11.163399
35740494	Morse, an open-source interactive to	Morse, an open-source interactive tool for inspecting Clojure	xmlblog	12.6401005	-7.894334	story	10.0	173.0	1682685098	-11.172234
34775518	I love Clojure the language but I’ve	I love Clojure the language but I’ve never seen a more fragmented ecosystem.There seems to be a pattern in the language of “a problem emerges > a community solution gains traction > Cognitect develops their own solution but its weird and undocumented”, like deps.edn over leiningen, spec over malli, pedestal over ring, etc.Many prominent clojurists recommend deps.edn over leiningen and socket repl over nrepl, but I’ve seen very little guidance on how either actually work or how to use them.Spec seems kind of weird and not well thought out either.And Clojure CLI tools also seem like a total shitshow compared to go or rust’s tooling.As a result working with Clojure feels puzzling and unpleasant, and I feel hesitant to use any community library or project in the language.	BaculumMeumEst	12.651316	-7.8918886	comment	10.0	62.0	1676305245	-11.129554
25374378	See... I work for one of the largest	"See... I work for one of the largest banks in the world and in vicinity of me there is a Clojure project. The guys are trying to figure out how to get rid of it. Original developers left the company or advanced to management roles and now nobody is able to figure out what this convoluted, obfuscated, undefined, unstructured mass of code does or how to modify it so that it doesn't blow up more that it already is.As much as I love Clojure I see the problem is you need really good (not just intelligent but also wise) developers to reap benefits. Otherwise you can run into huge problems.""With great power...""Clojure has so bad rep here that even I think I made a mistake that I let on that I use it for my projects."	lmilcin	12.658878	-7.902902	comment	10.0	78.0	1607612663	-11.187989
22254793	Babashka – A Clojure for the grey ar	Babashka – A Clojure for the grey areas of Bash	tosh	12.634538	-7.9002905	story	10.0	238.0	1580982562	-11.1647415
19471879	Replete 2.0: ClojureScript REPL for 	Replete 2.0: ClojureScript REPL for iOS and Android	tosh	12.657562	-7.8981566	story	10.0	190.0	1553368530	-11.110727
16947257	Native Clojure with GraalVM	Native Clojure with GraalVM	sandGorgon	12.644628	-7.8772764	story	10.0	171.0	1524916908	-11.169329
18578920	Clojure's missing piece (2017)	Clojure's missing piece (2017)	tosh	12.653773	-7.9101343	story	10.0	145.0	1543698244	-11.186091
18589289	why did they pick Clojure to do prob	why did they pick Clojure to do probabilistic programming?btw, Python programmers have the option of pymc3 https://docs.pymc.io/	mrcactu5	12.649097	-7.899549	comment	10.0	36.0	1543849652	-11.195029
12914279	Elm from a Business Perspective	Elm from a Business Perspective	amitaibu	13.012218	-7.695383	story	10.0	166.0	1478723203	-12.763734
12918909	Sometimes I think Clojure should hav	Sometimes I think Clojure should have been developed on top of the ErlangVM instead of the JVM. I think that the ErlangVM solves a lot better the problems that Clojure is trying to solve. Also, seems like targeting the ErlangVM is an achievable feat, since Elixir in its version 1.3 has proven to be extremely solid.Crazy idea: if I wanted to implement Clojure on top of the ErlangVM, where should I start?	iagooar	12.645475	-7.8780336	comment	10.0	55.0	1478769704	-11.102202
27751128	Debugging in Clojure	Debugging in Clojure	DaveWM	12.6439905	-7.90073	story	10.0	124.0	1625590371	8.971782
12070906	How to use Elm at work	How to use Elm at work	zalmoxes	13.008659	-7.692618	story	10.0	201.0	1468244083	-12.754802
22974593	ClojureScript 1.10.741	ClojureScript 1.10.741	Jeaye	12.65437	-7.902369	story	10.0	265.0	1587776189	-11.158217
23284196	Ask HN: Who Regrets Choosing Clojure	Ask HN: Who Regrets Choosing Clojure?	shivekkhurana	12.655096	-7.9042172	story	10.0	37.0	1590250971	-11.166584
33297252	Clojure is dynamically typed, right?	Clojure is dynamically typed, right? Just curious: how do you refactor large codebases without a compiler telling you if the pieces still fit together? (I'm coming from Scala)	manx	12.559321	-7.8652782	comment	10.0	33.0	1666436779	-11.149944
27060516	Clojure is the most enjoyable langua	Clojure is the most enjoyable language I've ever used and I love the interactive development. I haven't written code in any other language that even comes close.Unfortunately I am too lazy and careless to use Clojure in any serious capacity though. I really need a Haskell or Rust compiler to remind me of all my silly mistakes. I can't be trusted to get to the same level of confidence through unit tests or linting or spec or malli.I actually tried using Clojure for a little web project (~3k LoC in both Haskell and Clojure) and any refactor that included maps that were passed around in many different routes (think authorization, logging, DB) ended up with me chasing down rather weird type errors. Basically the equivalent of can't call X on undefined in JS.In Haskell I spent at least the same	YuukiRey	12.556967	-7.8677115	comment	10.0	76.0	1620289861	-11.131916
38304661	Pinball implemented using Squint, a 	Pinball implemented using Squint, a ClojureScript dialect	Borkdude	12.644393	-7.8898926	story	10.0	137.0	1700234020	-11.161069
38541955	Does Clojure have a decent web frame	Does Clojure have a decent web framework?	DeathArrow	12.652853	-7.8866777	comment	10.0	59.0	1701854921	-11.166178
24353476	Using Clojure in the command line wi	Using Clojure in the command line with Babashka	Borkdude	12.655499	-7.9024253	story	11.0	152.0	1599056170	-11.154634
20036907	Show HN: Easy intro book to Clojure 	Show HN: Easy intro book to Clojure and immutability	viebel	12.645348	-7.895944	story	11.0	148.0	1559104834	-11.169907
20244899	Show HN: I wrote a maze traversal pr	Show HN: I wrote a maze traversal program in Clojure	netb258	12.626788	-7.880232	story	11.0	91.0	1561140103	-11.086497
20645530	Last week I tried writing a new Love	Last week I tried writing a new Love2d mode for Emacs in Emacs Lisp, but it was on Windows so my muscle memory for Paredit wasn't helpful. Editing s-expressions is a nightmare without some kind of automatic help. Last night I wrote the same plugin for VS Code which used JavaScript, and naturally it was effortless. It got me thinking about how s-expressions are inherently hostile to non-customized setups, whereas JavaScript just uses arrow keys.A former employer was led by huge Clojure fans, who requested that the backend be Clojure, and highly encouraged me to use ClojureScript and something like Reagent for the front-end, which I recently noticed that they finished after my departure. But the more I think about it, the more I can't think of a single feature of ClojureScript that's inheren	sdegutis	12.652723	-7.8747683	comment	11.0	60.0	1565278849	-11.096097
20731619	Sure... and it means that Swift and 	"Sure... and it means that Swift and Clojure are just as useless as Julia for numerous use cases where start-up times matter, like piping CLI commands together, in Julia's case you're looking at pathetic 3 execs per second.Moreover, even in some server-side applications it's super neat to have the luxury to spawn a new process to service certain requests, not having to worry about memory leaks. It's a perfect ""API"" which allows multiple languages to interact together.It always bothered me when people dismiss the start-up time by adding ""just"" in front of it. We're not talking about web frameworks, these are _general purpose_ programming languages, and horrendous start-up time automatically disqualifies them from being general purpose and places them into a niche category, in my humble opini"	old-gregg	12.578032	-7.898534	comment	11.0	58.0	1566149915	-11.167418
14497867	Clojure Linear Algebra Refresher: Ei	Clojure Linear Algebra Refresher: Eigenvalues and Eigenvectors	dragandj	12.626143	-7.9017453	story	11.0	206.0	1496762188	-11.207751
14506702	Disclaimer: as a Clojure developer a	Disclaimer: as a Clojure developer and functional programming evangelist, I do not want to be too critical of this article. It's a really great post about some incredibly valuable and advanced Clojure features.That being said, it really bothers me when functional programming evangelists write out such horrible Python code examples. It makes Python look like it's not a functional language. It perpetuates the idea that Python won't let you write elegant and stateless programs that behave in a functional manner.If the author had not mentioned Python and had instead used it  as pseudocode to represent the entirely non-functional way to write something, I would have been okay with it. But calling out Python specifically is just incorrect!I have rewritten the code in a very pythonic manner that 	whalesalad	12.443788	-7.7292376	comment	11.0	55.0	1496845793	-11.085875
30812665	"Meh the problem is ""Which Lisp?""  Th"	"Meh the problem is ""Which Lisp?""  There are dozens of incompatible Lisps.  Even this site is written in a Lisp dialect written by its author (Arc).In fact I conjecture that this is the reason Unix is more popular than Lisp -- because Lisps don't interoperate well.  They haven't built up a big ecosystem of reusable code.Whereas Python, JavaScript, R, C, C++, and Rust programmers can reuse each others' code via Unix-style coarse-grained composition.  (Not just pipes -- think about a web server running behind nginx, or git reusing SSH and HTTP as transports.)You can also use link time composition.  It takes some work but it's better than rewriting your Common Lisp code from scratch in Clojure.-----Honest question: how do you communicate between two Lisp processes on two different machines?  I"	chubot	12.659172	-7.879524	comment	11.0	49.0	1648308503	-11.032273
30917772	Coast on Clojure	Coast on Clojure	adamkl	12.652224	-7.903466	story	11.0	181.0	1649159236	-11.165707
31203024	Show HN: Joyride: script VSCode like	Show HN: Joyride: script VSCode like Emacs but using Clojure	Borkdude	12.652141	-7.884031	story	11.0	211.0	1651223171	-11.189589
31427824	Why is zero not falsy in Clojure? (2	Why is zero not falsy in Clojure? (2015)	tosh	12.6165905	-7.9040093	story	11.0	40.0	1652908836	-11.189729
25979105	I think Lisp is going to live foreve	"I think Lisp is going to live forever as a niche tool for people who ""get"" it.I use Clojure on a daily basis. Not necessarily because it is best Lisp, but rather because I am working with Java applications and being able to reuse the same Java code I have already developed is a huge boon to me. If I was able to choose, I would be using Common Lisp.The way I use it is to quickly develop adhoc tools and PoCs 
and more rarely small UIs in re-frame.Working with Lisp is a joy for me and I always get this feeling of frustration when I have to go back to Java, especially if I have to translate to Java what I just prototyped in Clojure.Unfortunately, where I work (financial systems for financial institutions), I have trouble finding enough people, mature enough to be able to even propose working p"	lmilcin	12.66062	-7.890491	comment	11.0	79.0	1612103857	-11.140415
34775571	I tried Clojure, but when i look for	I tried Clojure, but when i look for a good ORM, what i see is a paid library.	revskill	12.647782	-7.8858337	comment	11.0	43.0	1676305420	-11.127695
34948816	Relic: Functional relational program	Relic: Functional relational programming for Clojure(Script)	zonotope	12.6524315	-7.905043	story	11.0	224.0	1677441801	-11.166449
36658959	Clojure Plays Mario	Clojure Plays Mario	hotcrossbunny	12.656344	-7.9064784	story	11.0	201.0	1688937257	-11.132671
25375384	A common point is being made in the 	"A common point is being made in the threads here: ""The downside of Clojure is that you need good, wise developers...""The converse of this is that good, wise developers are going to (ultimately) _demand_ Clojure.What I mean by this:I was a Java programmer for years and increasingly started writing code in a more functional, immutable, dynamic style with the occasional need for meta-programming -- for the sheer need of being more productive and writing more robust code.Yes, you can write functional, immutable, dynamic, code in Java and do meta-programming in Java!It's just somewhat cumbersome and prickly.Enter: Clojure.I've seen many an 'unwise' programmer make just as much a mess of Java systems as people are suggesting they've seen in Clojure projects. It may be simply that Java slows you/"	atdixon	12.637301	-7.88953	comment	11.0	87.0	1607617737	-11.171178
32188783	HAMT: Hash Array Mapped Trie.  This 	HAMT: Hash Array Mapped Trie.  This data structure makes efficient immutable data possible.  You can update a list of a million items, and keep a reference to the original list, by changing 3 or 4 references and some bytes.This should replace copy-on-write for scripting languages.  I really want to see it in a JS spec soon.  There are libraries that can do it, but they add translation penalties and extra steps.  I’d complain less if I could use Clojurescript professionally, because it and Clojure are built around them.https://en.m.wikipedia.org/wiki/Hash_array_mapped_trie	filoeleven	12.551497	-7.8036456	comment	11.0	44.0	1658467101	-11.1571045
22137563	Despite the positive tone, what real	Despite the positive tone, what really struck me in this article was that they struggle with getting people to work on the compiler because it is too complex.It just confirms my main criticism against advance statically typed languages: They are simply too complex.It is why I have more faith in languages like Julia, because you can achieve a tremendous amounts of power, expressiveness and performance in a relatively simple language.Dynamic typing gives you simplicity in the type system which is impossible to achieve with static type checking.Long term this has profound implications. People can keep hacking on and expanding Julia because they can wrap their head around the language. You don't need to be Einstein to grok it.I think you may also see Clojure overtake Scala for the same reason.	socialdemocrat	12.488543	-7.825468	comment	11.0	63.0	1579869604	11.905994
22190585	Fancy Clojure REPL	Fancy Clojure REPL	tosh	12.648879	-7.8939652	story	11.0	240.0	1580382980	-11.163725
15771561	Clojure Design Patterns	Clojure Design Patterns	simonpure	12.627734	-7.8867054	story	11.0	315.0	1511540261	-11.185585
16791940	Elm at Pacific Health Dynamics	Elm at Pacific Health Dynamics	mordrax	13.014163	-7.696162	story	11.0	165.0	1523271734	-12.732492
16865805	ClojureScript beginners' home page	ClojureScript beginners' home page	jiyinyiyong	12.657237	-7.9030194	story	11.0	191.0	1524041843	-11.189141
17125882	The Hitchhiker's Guide to Elm	The Hitchhiker's Guide to Elm	roadbeats	13.020712	-7.702226	story	11.0	120.0	1526996862	-12.763338
17423846	Clojure Error Messages Are Accidenta	Clojure Error Messages Are Accidental	bloat	12.652988	-7.9144955	story	11.0	93.0	1530271898	-11.208832
17846940	What I've learned since quitting Elm	What I've learned since quitting Elm	ff_	13.012319	-7.6934943	story	11.0	98.0	1535305852	-12.770239
21204761	Re-writing the site of Norway's larg	Re-writing the site of Norway's largest transport provider in Elm	Skinney	13.025862	-7.692547	story	11.0	197.0	1570638474	-12.769199
21206274	I wonder how involved the customer w	I wonder how involved the customer was in the choice of technology. I think the long term costs of choosing Elm will be higher than any perceived gain during the initial development period.The number of developers with Elm experience in Norway is small, and I think it will make it harder to attract good consultants that want to work on it.	vlangber	13.010714	-7.693288	comment	11.0	80.0	1570645582	-12.770387
18700536	Clojure 1.10 release	Clojure 1.10 release	finalfantasia	12.653184	-7.904046	story	11.0	355.0	1545068577	-11.180898
18772720	Liquid: Vim and Emacs-inspired edito	Liquid: Vim and Emacs-inspired editor written in Clojure	tosh	12.641095	-7.878755	story	11.0	183.0	1545945494	-11.127513
13348685	Challenging Clojure in Common Lisp (	Challenging Clojure in Common Lisp (2014)	krat0sprakhar	12.646987	-7.887991	story	11.0	124.0	1483858797	-11.143408
35439916	Mindset shifts for functional progra	Mindset shifts for functional programming (with Clojure)	janetacarr	12.630227	-7.8896356	story	11.0	162.0	1680617495	-11.159304
22318748	Cloture: Clojure in Common Lisp	Cloture: Clojure in Common Lisp	ruricolist	12.657737	-7.9007516	story	11.0	129.0	1581609733	-11.094543
22797858	A Little Clojure	A Little Clojure	ingve	12.651506	-7.9041953	story	11.0	139.0	1586207082	-11.143993
23046568	Joy: Web framework with Clojure synt	Joy: Web framework with Clojure syntax, fast startup and low memory usage	galfarragem	12.652851	-7.8945303	story	11.0	178.0	1588367681	-11.167016
26713966	"A bit of an obvious question
Elm, Ty"	"A bit of an obvious question
Elm, Typescript and Purescript all offer Javascript + TypesClojurescript is dynamic, beside the lisp syntax which is arguably cleaner, and offer some nice advantages like homoiconicityWhat is the real advantage of Clojurescript (?)"	systems	12.642976	-7.7747197	comment	11.0	51.0	1617726860	-11.074881
27089576	Lessons on Writing JavaScript and Re	Lessons on Writing JavaScript and React from ClojureScript	yogthos	12.6945305	-7.7822876	story	11.0	100.0	1620498494	-11.174649
15525407	I’ve already seen large scale clojur	I’ve already seen large scale clojure projects being rewritten to something average devs can maintain. Don’t expect much more growth out of this language in terms of new projects written in clojure.	ronnier	12.650385	-7.897979	comment	11.0	116.0	1508652343	-11.174679
15593069	Effective Programs: 10 Years of Cloj	Effective Programs: 10 Years of Clojure	kimi	12.651002	-7.902757	story	11.0	215.0	1509456703	-11.188612
20304686	Eva – A distributed entity-attribute	Eva – A distributed entity-attribute-value database in Clojure	CurrentB	12.650053	-7.904913	story	12.0	255.0	1561732540	-11.170189
30768240	Clojure 1.11 is now available	Clojure 1.11 is now available	simongray	12.652928	-7.902923	story	12.0	238.0	1647966934	-11.175627
31055485	I love lispy languages— Clojure bein	I love lispy languages— Clojure being the one I’m most familiar with, but it’s hard to give up static types.Anyone here worked on a large lisp codebase? How big was it? How big was the team? What’s the secret sauce?	christophilus	12.64459	-7.8634086	comment	12.0	75.0	1650138398	-10.938575
36081091	TimL: Clojure-like Lisp dialect that	TimL: Clojure-like Lisp dialect that runs on and compiles down to Vimscript	asimjalis	12.64188	-7.887	story	12.0	113.0	1685085680	-11.120465
28956316	Idiomatic Clojure without sacrificin	Idiomatic Clojure without sacrificing performance	ceronman	12.637854	-7.8902025	story	12.0	150.0	1634904949	-11.160776
25091132	How I write Elm applications	How I write Elm applications	galfarragem	13.009279	-7.692432	story	12.0	109.0	1605345063	-12.741399
18013047	Native Clojure with GraalVM	Native Clojure with GraalVM	tosh	12.646122	-7.878362	story	12.0	197.0	1537253115	-11.176378
18774888	So Clojure and CLJS are amazing. If 	So Clojure and CLJS are amazing. If I were to pick a Lisp for a real world project, Clojure is the obvious pick. The thing is, I'm curious to hear from people who DO use Lisp in the real world.I would characterize my experience with it as 1: Really fun. 2: Productive on a small scale due to the tooling, interop, libraries, and community being innovative and awesome, and 3: Infinitely flexible, because you know .. it's a Lisp. Development becomes like doodling on a piece of paper, like a stream of consciousness.But I ended up choosing Scala for a recent, fairly large, project of mine and I'm convinced it was the right decision. Without a static type system I would have simply lost a handle on the complexity of the project. And this is while working alone (the case where Lisp traditionally h	lopatin	12.640238	-7.86547	comment	12.0	61.0	1545971648	-10.959576
12583704	Racket – Lisp beyond Clojure	Racket – Lisp beyond Clojure	macco	12.686403	-7.835347	story	12.0	220.0	1474910509	13.638523
12918704	Lumo – A fast, standalone ClojureScr	Lumo – A fast, standalone ClojureScript REPL that runs on Node.js and V8	rcarmo	12.646731	-7.88516	story	12.0	218.0	1478766978	-11.171579
13255021	Self Healing Code with clojure.spec	Self Healing Code with clojure.spec	espeed	12.646378	-7.903624	story	12.0	100.0	1482691975	-8.65989
13341176	I don't know what's wrong with me bu	I don't know what's wrong with me but I gave Clojure 3 tries in the past and every time I try to actually build something (aside from 4clojure and solving hackerrank problems with it) I get lost in the tooling and just give up then fallback to familiar frameworks\languages.It just doesn't click with me and the whole leinengen\ring\compojure just seems weird and backhanded.	decebalus1	12.651281	-7.8995237	comment	12.0	55.0	1483744294	-11.189798
27597987	Racing Game in ClojureScript	Racing Game in ClojureScript	winkywooster	12.65634	-7.901048	story	12.0	161.0	1624400530	-11.178448
35452240	> Recursion over LoopingPart of what	> Recursion over LoopingPart of what makes Clojure a great programming language is that you don't have to believe this if you don't want to. Nobody has yet convinced me that recursion has any sustained advantage over looping.Using a loop is generally bad practice if a more specialised operation is available (don't loop if something is a simple map or reduce for example). But if the situation justifies a recursion then it usually justifies a loop unless the recursion is particularly neat. Recursion has the same problem as looping - it doesn't tell anyone anything about what the code is really doing. If I see map then I have implicit and explicit expectations about what is about to happen.I enjoyed the article though.	roenxi	12.574963	-7.8632226	comment	12.0	73.0	1680693380	8.948103
23165096	Okay, so when Clojure came along, it	"Okay, so when Clojure came along, it came with a strong underlying philosophy of what the language was supposed to be/do. Among them were design decisions such as, e.g.,:  - VMs, not OSes, are the platforms of the future, so target the JVM
  - Object Orientation is overrated, but polymorphism is a good thing
  - Multi-core is here to stay, so use immutable data structures to greatly facilitate writing correct concurrent programs
  - Leverage the strengths of LISP but give it a modern overhaul (most notably, throw in different parenthesis)

Now, you may or may not subscribe to any of these but my question is just: how does Janet compete on that front? What is the problem it is trying to address specifically? I looked at the web page a bit but it's still not clear to me."	kleiba	12.650436	-7.892533	comment	12.0	169.0	1589362305	-11.094421
34052268	Structuring Clojure applications	Structuring Clojure applications	nefreat	12.6382885	-7.8952	story	12.0	198.0	1671459411	-11.1766405
27273911	Clojure by Example (2015)	Clojure by Example (2015)	manjana	12.632551	-7.8953648	story	12.0	173.0	1621927569	-11.153837
14754614	ClojureScript Is Not An Island: Inte	ClojureScript Is Not An Island: Integrating Node Modules	swannodette	12.657093	-7.8915844	story	12.0	193.0	1499881098	-11.158687
15126527	Honey SQL – SQL as Clojure data stru	Honey SQL – SQL as Clojure data structures	tosh	12.651409	-7.89703	story	12.0	118.0	1504031544	-11.168964
15464423	Clojure/Conj 2017 – Opening Keynote 	Clojure/Conj 2017 – Opening Keynote by Rich Hickey [video]	kasbah	12.65852	-7.9074593	story	12.0	216.0	1507890484	-11.13896
15602658	Dueling Rhetoric of Clojure and Hask	Dueling Rhetoric of Clojure and Haskell	dukerutledge	12.501833	-7.885215	story	12.0	106.0	1509552773	10.439618
24374389	Specter – Clojure API for immutable 	Specter – Clojure API for immutable programming (2017)	amgreg	12.593733	-7.88928	story	13.0	152.0	1599223304	-11.167383
20219563	Clojerl – Clojure for the Erlang VM	Clojerl – Clojure for the Erlang VM	tosh	12.641034	-7.8812485	story	13.0	309.0	1560901221	-11.183818
36156167	Homoiconicity wins in my book. Cloju	Homoiconicity wins in my book. Clojure is the best proof I have of this: What mattered was not the linked list or the cons cell. What mattered was that all code was just nested calls to functions and macros with the SAME general form: (function arg1 arg2 arg3 ...)Expression-based programming using this core form is trivially easy, and makes immutable data structures downright pleasurable to work with. It also makes code generation easy, though I've never taken full advantage of it; even so, a DSL made of runtime functions is not only possible, but a natural extension of anything you're already doing. Backing those homoiconic expression forms with typical high-performance data structures like arrays and hash maps, as Clojure and Janet do, is a winning formula for making complex tasks simple	netbioserror	12.60632	-7.848385	comment	13.0	65.0	1685647810	-10.995
24432461	What Clojure Spec is and what you ca	What Clojure Spec is and what you can do with it	icey	12.652161	-7.901814	story	13.0	263.0	1599746697	-11.125525
19095952	State of Clojure Survey 2019 Analysi	State of Clojure Survey 2019 Analysis	kgwxd	12.64827	-7.9001975	story	13.0	185.0	1549467705	-11.1816225
39183878	I keep hearing sentiments like this 	I keep hearing sentiments like this but then I wonder, if Clojure or <another awesome Lisp> is so much better than Python <or some other mainstream language>, then why are we still writing in those languages? If it's because of libraries, then the question is: Why do people write libraries for these languages and not the Lisp ones?	behnamoh	12.695128	-7.8393865	comment	13.0	53.0	1706568674	-10.824915
18620309	Better Clojure formatting	Better Clojure formatting	harperlee	12.640124	-7.898514	story	13.0	111.0	1544118524	-11.156874
27894735	Clojure builds as an amalgamation of	Clojure builds as an amalgamation of orthogonal parts	fogus	12.648262	-7.909191	story	13.0	122.0	1626793954	-11.164664
28036282	I found one of the perceived weaknes	I found one of the perceived weaknesses of Clojure (in this article), it being dynamically typed, is a tradeoff rather than a pure negative. But it applies that tradeoff differently than dynamic languages I know otherwise and that difference is qualitative: It enables a truly interactive way of development that keeps your mind in the code, while it is running. This is why people get addicted to Lisp, Smalltalk and similar languages.> To understand a program you must become both the machine and the program.- Epigrams in Programming, Alan PerlisTwo of the big advantages of (gradually-) typed languages are communication (documentation) and robustness. These can be gained back with clojure spec and other fantastic libraries like schema and malli. What you get here goes way beyond what a strict	dgb23	12.493032	-7.8320284	comment	13.0	150.0	1627911194	-11.132123
22381114	Clojure is a decent language. I've w	"Clojure is a decent language. I've worked with it a good deal in work. But I would take any functional language with types over it. Some thoughts:- its dynamic-ness makes it not suited to large projects IMO.- The currently-accepted attempt at a non-type-system-type-system 'spec' is not well thought out.- Biggest wins I think are immutability by default, homoiconicity, and ""simplicity""- The repl is fine but can be a crutch -- see startup time- Clojure still hasn't really found a niche, and I'm not sure I would ever reach for it first unless I was integrating with other clojure projects."	keithasaurus	12.605176	-7.875403	comment	13.0	83.0	1582262771	-11.138559
22460108	Startup time isn't what is holding t	"Startup time isn't what is holding the language back. In my opinion it's:1. Tooling. You end up spending way more time getting your tooling setup than it should be.
2. Difficulty in learning.
3. Clear best practices and frameworks. The philosophy of composing libraries is extremely powerful, but to gain broader adoption you still need straight forward frameworks and opinionated best practices.The last point has many unintuitive consequences. Clojure tends to attract people who enjoy doing new things, or excelling in their craft. But mass adoption also means catering to people who need to do ""boring"" things where people just want to get their job done. For boring code, which is the reality for many developers, they just want a clear best practice to get the stuff done.This could be a clear "	tensor	12.622316	-7.857436	comment	13.0	139.0	1583104721	-11.059871
33909241	Babashka is a fast-starting scriptin	Babashka is a fast-starting scripting environment for Clojure	tosh	12.644404	-7.8916044	story	13.0	217.0	1670514895	-11.162482
14909530	Clojure-turtle – Logo programming la	Clojure-turtle – Logo programming language in a Clojure context	tosh	12.648777	-7.8997946	story	13.0	106.0	1501671520	-11.152778
15473657	Outside of very special circumstance	"Outside of very special circumstances, I don't think it is a good idea to replace Python code with Clojure code. In fact, judging from my own contracting experience and seeing the many mistakes made by first-time Clojure programmers, I more often than not suggest moving from Clojure to anything else.The problem with using esoteric languages is multi-fold. First, you have to trust that the original programmers actually know the language enough to not create a massive disaster. Are they comfortable working without a framework, are they knowledgeable about all the issues that arise from building closer to the metal, so to speak? It seems to me that the answer is ""no"" more often than ""yes.""Once this happens, you end up in a read-only code situation, and this is a problem because they leave the"	dizzystar	12.639907	-7.8818135	comment	13.0	60.0	1508007902	-11.089296
29341400	Abstract Clojure	Abstract Clojure	joelittlejohn	12.633026	-7.8897753	story	14.0	170.0	1637848777	-11.158153
37021933	Critique of Lazy Sequences in Clojur	Critique of Lazy Sequences in Clojure	robto	12.635808	-7.893301	story	14.0	87.0	1691330057	-11.154211
13085952	Spec-ulation – Rich Hickey [video]	Spec-ulation – Rich Hickey [video]	Moocar	12.666136	-7.9065523	story	14.0	283.0	1480652048	-11.203636
27499904	Tetris in ClojureScript	Tetris in ClojureScript	simongray	12.647029	-7.8905745	story	14.0	295.0	1623652692	-11.1574
12134327	Since I've been interested in how th	Since I've been interested in how the Functional paradigm might help us developers deal with concurrency, there are 2 items here that really strike me:1.) Clojure fell back2.) Elixir, though small, is still moving forwardI've been a fan of Clojure since 2009. It grew rapidly for a few years, from 2009 till at least 2014. It has stalled out. This makes me sad because I've loved working with it and I think it a great community, in most ways. But it is true that the community has been unable to answer some of the criticisms leveled against it. The reliance on Emacs has meant it is not easy for beginners. On the other side, the elite (the purists?) have wanted to see Clojure be more like Scheme, or more like Racket, or more like Haskell. Clojure has offered up many interesting ideas, but perha	lkrubner	12.645621	-7.8533425	comment	14.0	114.0	1469070212	12.8723345
28035429	Six Years of Professional Clojure	Six Years of Professional Clojure	erez-rabih	12.683722	-7.936758	story	14.0	223.0	1627905160	-11.192285
33086046	Ah clojure. It's all fun and games u	Ah clojure. It's all fun and games until five years down the line, you've had 100% dev churn, and you have a 100kloc codebase that nobody understands, full of functions that don't give the slightest hint of the shape of the data they're processing (it's all lists!) yet down the bottom of the callstack there's some function that'll explode if the map doesn't have whatever magical key it expects.If you're really lucky, someone will have thrown in a bunch of 'specs' that make a bunch of assertions about the data, put them on the API entry points, and then scattered some slightly different specs with slightly more restrictive assertions on various 'internal APIs', resulting in random explosions in production!And the joy of working with an esoteric language is that it attracts esoteric develope	ldite	12.636822	-7.896402	comment	14.0	85.0	1664914303	-11.153812
33295217	Clojure 15th Anniversary: A Retrospe	Clojure 15th Anniversary: A Retrospective	simonpure	12.649169	-7.906558	story	14.0	170.0	1666406655	-11.175261
26618971	How much can a Clojure developer do 	How much can a Clojure developer do alone?	jgrodziski	12.6634035	-7.9085894	story	14.0	113.0	1617007780	-11.162983
15425632	Rich Hickey's response to “On whose 	Rich Hickey's response to “On whose authority?”	disaster01	12.66836	-7.924305	story	14.0	124.0	1507409480	-11.17255
20074240	Salient line:While Storm's Clojure i	Salient line:While Storm's Clojure implementation served it well for many years, it was often cited as a barrier for entry to new contributors. Storm's codebase is now more accessible to developers who don't want to learn Clojure in order to contribute.Very common story that I hear from a lot of shops that tried to go Clojure first. Great language, but too little penetration amongst developers. Makes it very difficult to effectively recruit employees/contributors.At some point, you just accept that it's more important to get a new warm body than to continue pursuing some idealized programming perfection.	avinium	12.654384	-7.9041348	comment	15.0	131.0	1559464366	-11.189168
20367147	Tangential question, but what Lisp i	Tangential question, but what Lisp is the most promising one to invest time on right now?Common Lisp still has some activity, mainly coming from SBCL, but is a bit stagnant. It has a fantastic literature and many mature implementations.Scheme is great, but a bit too fragmented. Racket seems to be gaining some momentum. The merge with Chez may be the tipping point to attract a critical mass of developers.Clojure has many interesting modern ideas, but I feel being so tied to Java and the JVM has hurt a bit in the long run.I miss a bit of innovation in the typed lisp area, like e.g. Qi or Shen which never took off. Carp [1] looks nice.[1] https://github.com/carp-lang/Carp	nextos	12.688256	-7.831886	comment	15.0	68.0	1562376380	-10.687049
20844978	Why I like Clojure	Why I like Clojure	tosh	12.656337	-7.90745	story	15.0	237.0	1567234451	-11.209355
31282398	I know exactly what you mean. As a c	"I know exactly what you mean. As a counter point to the many ""burnout answers"" here which I completely agree with by the way. It could also be an example of ""neuroplasticity"" (hear me out).I'm 40 and been coding like it feels forever, I find it ""relatively easy"" to learn new frameworks or languages. What is much harder are new paradigms; example OOP vs functional.The last few months I've started to learn Clojure. Man what a frustrating journey it has been ! I keep telling myself I'm a seasoned senior dev, worked on all sorts of systems Web/Non-Web/hardware/software you named it ! Why is it so damn hard for me to ""get it"" or ""become comfortable"" with Clojure.Only answer I can come up with, is that I have become too comfortable or ""set in my ways"" as a dev over the years (decades). I've been"	rawoke083600	12.645816	-7.890744	comment	15.0	69.0	1651822518	-11.130986
18345921	I'd like to learn a modern productio	I'd like to learn a modern production-ready functional language (I have some academic experience with SML), since they seem like a good way to grow as a programmer. Main contenders so far are Haskell, Scala and Clojure (Reason might go on the list soon too) - but the fact that Clojure is dynamically typed is a bit of a turn off for me. My experience with dynamic vs static typing is that as a system grows in size and complexity, the value of static typing goes up. Doing a major refactor is one of those things that I find especially error-prone in dynamic languages, while statically typed languages make this much less daunting (of course they come with the opposite issue that you might not be able to compile for a day until you've fixed all the type errors - but I'd take this trade-off any d	m12k	12.48087	-7.830893	comment	15.0	126.0	1540995863	-11.116344
18870796	IBM releases Elm-powered app	IBM releases Elm-powered app	quickthrower2	13.006755	-7.6912956	story	15.0	263.0	1547084290	-12.763699
30021229	My Elm Experience	My Elm Experience	lawik	13.012559	-7.6911345	story	15.0	114.0	1642757833	-12.767777
27054839	Six years of professional Clojure de	Six years of professional Clojure development	yogthos	12.658668	-7.9074783	story	15.0	174.0	1620244413	-11.177398
27091559	> ClojureScript has unlocked whole n	> ClojureScript has unlocked whole new levels of productivityI keep seeing this claim over and over again about Clojure and Clojurescript. I don't get it, at all. I tried it, multiple times, I don't get where the productivity boost could come from. I though maybe the so-called REPL-driven development (as if clojure is the only language ever with a REPL), I watched videos about REPL-driven development, developed a project that way, cool... not more productive than say TDD or hot-reloading> I enjoy it because there is little cognitive load in terms of understanding what the program is doing.Is there? I mentioned I was not more productive in clojure, in fact I was actually much slower in clojure. It's not lack of FP knowledge, because in fact I love how productive I am with Elm, so maybe it's	rchaves	12.627169	-7.8876586	comment	15.0	63.0	1620514643	-11.157622
15524812	Why I'm Productive in Clojure (2013)	Why I'm Productive in Clojure (2013)	tosh	12.652789	-7.9066916	story	15.0	182.0	1508639111	-11.165985
31485011	Ask HN: Is Elm Dead?	Ask HN: Is Elm Dead?	felixguendling	13.014219	-7.6930146	story	16.0	40.0	1653341477	-12.771139
37444946	My mental model of Clojure transduce	My mental model of Clojure transducers	nathell	12.6256695	-7.890548	story	16.0	135.0	1694265005	-11.1676235
19477990	Why I Switched from Python to Clojur	Why I Switched from Python to Clojure (2016)	bsg75	12.651821	-7.9015	story	16.0	211.0	1553452997	-11.218745
15771791	Clojure is fantastic for its simplic	Clojure is fantastic for its simplicity, and I worked on a Clojure code base full time for 5 years, coming up with ways of translating Java patterns into Clojure. But I've noticed it has not been gaining traction in the job market, and now I feel like that 5 years has been a waste of valuable career building time, which I wish I had spent gaining more experience in (sigh) C# and .NET, so that I could get the more local jobs which all seem to use the Windows ecosystem, so we don't have to uproot our family and move to the city. Not that I don't know C# and .NET, but I definitely don't have 3+ years experience in it and I definitely don't have any experience MS SQL. So being able to do really cool things in Clojure, and especially having excellent rapid development skills with REPL-driven de	_diyu	12.653056	-7.8973913	comment	16.0	105.0	1511543007	-11.1455555
18834945	How innovative is Clojure as a Lisp 	How innovative is Clojure as a Lisp dialect from Lisp expert's perspective?	myth_drannon	12.661326	-7.89278	story	16.0	151.0	1546729752	-11.070027
12677385	Show HN: Nightlight, an editor that 	Show HN: Nightlight, an editor that runs inside Clojure projects	gw	12.648868	-7.8930774	story	16.0	195.0	1476111222	-11.172196
12899838	A small dive into, and rejection of,	A small dive into, and rejection of, Elm	adamlett	13.01216	-7.6947327	story	16.0	101.0	1478610112	-12.742798
13450383	ClojureScript is the most-used funct	ClojureScript is the most-used functional language that compiles to JavaScript	gw	12.647365	-7.8506246	story	16.0	216.0	1485012013	-11.148505
13591321	State of Clojure 2016 – Results and 	State of Clojure 2016 – Results and Analysis	fnordsensei	12.642351	-7.9023843	story	16.0	249.0	1486491402	-11.179941
34054746	I love Clojure and also Common Lisp 	I love Clojure and also Common Lisp (basically, Lisp in general). But I also observed every single corporate Clojure project I had any connection with to fail spectacularly. Typically as a complete unmaintainable mess. Some as unmaintainable mess that is very slow and unreliable.My theory is that this is result of no guardrails on how to structure your application. Clojure to be productive must be used by people who absolutely know what they are doing when it comes to structuring your app.When it comes to Java you get hordes of devs still producing passable results. The structure is largely imposed by the frameworks (mostly by Spring/Spring Boot) and available help, literature. Even some antipatterns at the very least achieve some level of convention/predictability that is needed to be abl	twawaaay	12.650546	-7.8949203	comment	16.0	69.0	1671470725	-11.145504
15600928	Closh – Bash-like shell based on Clo	Closh – Bash-like shell based on Clojure	tosh	12.645971	-7.9025965	story	16.0	259.0	1509542996	-11.19422
13619413	Ellie – An Elm Live Editor	Ellie – An Elm Live Editor	bpierre	13.012808	-7.6956553	story	17.0	224.0	1486765126	-12.75904
31024333	Clojure isn’t for me (2020)	Clojure isn’t for me (2020)	capableweb	12.6509075	-7.9045987	story	17.0	96.0	1649922281	-11.197357
34771771	Electric Clojure – A signals DSL for	Electric Clojure – A signals DSL for full-stack web UI	Borkdude	12.651328	-7.9006224	story	17.0	330.0	1676281759	-11.189977
34801464	Bringing Clojure programming to Ente	Bringing Clojure programming to Enterprise (2021)	jgrodziski	12.656941	-7.899209	story	17.0	190.0	1676450564	-11.145406
22244086	A list of companies using Elm in pro	A list of companies using Elm in production	mc3	13.011439	-7.6943865	story	17.0	139.0	1580877705	-12.76233
17172092	Robust Clojure: The best way to hand	Robust Clojure: The best way to handle nil	ghosthamlet	12.592822	-7.8868303	story	17.0	141.0	1527511111	-11.156309
22710604	Clojure on the Desktop	Clojure on the Desktop	vlaaad	12.651917	-7.899362	story	17.0	300.0	1585396873	-11.172808
26356367	Clojure from a Schemer's Perspective	Clojure from a Schemer's Perspective	todsacerdoti	12.642213	-7.901475	story	18.0	149.0	1614949317	-11.174066
36272692	Why I'm Leaving Elm (2020)	Why I'm Leaving Elm (2020)	bluewalt	13.010195	-7.6931257	story	18.0	52.0	1686418642	-12.760996
36438240	Clojure is a product design tool (20	Clojure is a product design tool (2015)	dustingetz	12.653346	-7.8992414	story	18.0	155.0	1687464967	-11.187579
24718478	Rich Comment Blocks in Clojure	Rich Comment Blocks in Clojure	tosh	12.638183	-7.899482	story	18.0	143.0	1602160053	-11.094165
18563229	Clojure REBL [video]	Clojure REBL [video]	jrsnyder	12.656687	-7.908205	story	18.0	205.0	1543520427	-11.180746
12500293	Haskell vs. Clojure (2014)	Haskell vs. Clojure (2014)	kafkaesq	12.471625	-7.851021	story	18.0	72.0	1473880417	10.4648485
14951116	Ferret – A free software Clojure imp	Ferret – A free software Clojure implementation	greydius	12.644234	-7.8979883	story	18.0	266.0	1502138721	-11.133858
15525570	I have honestly tried many many time	I have honestly tried many many times to read books/tutorials for getting started in LISP. I know there are many LISP inspired languages and Clojure is one of them. Where LISP throws me off is the excessive use of parenthesis, up-to the point my mind can't keep track of them anymore and IMHO language uses it's comprehension abilities. I am still struggling and pushing hard to learn it; hopefully I can get over it and experience the most powerful language. Any good starting projects/ideas I should try doing in LISP/Clojure etc. to help me out?	maxpert	12.686876	-7.86351	comment	18.0	113.0	1508656335	-10.858398
20982433	A nice app on Elm street	A nice app on Elm street	andreascreten	13.007156	-7.691806	story	19.0	149.0	1568627043	-12.767388
25622528	Why Clojure? (2018)	Why Clojure? (2018)	bribri	12.653461	-7.904526	story	19.0	185.0	1609689984	-11.174514
29549392	Sublime Clojure	Sublime Clojure	rcarmo	12.65505	-7.9026136	story	19.0	169.0	1639469257	5.287766
19727972	To be perfectly honest, Clojure's bi	To be perfectly honest, Clojure's biggest mistake, from my point of view, was to be so heavily JVM-dependent.Yes, in certain environments Java is king and a ton of people use it, it's battle-proven, etc. But so are other stacks.Clojure, as a programming language, sparks a lot of joy and is a lot of fun to use and reason about. Yet in reality, when working in a production environment, you're basically fighting the always-memory-hungry JVM.Just give me Clojure running on BEAM and I'll take it over anything in this world.	iagooar	12.647265	-7.8949933	comment	19.0	168.0	1556023197	-11.173987
16637148	From Rails to Clojure, Then to Java,	From Rails to Clojure, Then to Java, Then Back to Rails	donbonifacio	12.650684	-7.8595314	story	19.0	195.0	1521632612	-11.168673
17946047	Clojure is cool	Clojure is cool	jxub	12.6539135	-7.900177	story	19.0	176.0	1536503622	-11.176498
13281413	Why Clojure? (2010)	Why Clojure? (2010)	edem	12.652623	-7.9046354	story	19.0	223.0	1483056812	-11.183757
16510267	Do we need to move away from Elm?	Do we need to move away from Elm?	sridca	13.013394	-7.696265	story	20.0	168.0	1520097384	-12.767554
18345243	Clojure at Netflix (2013) [slides]	Clojure at Netflix (2013) [slides]	tosh	12.655394	-7.906225	story	20.0	369.0	1540990625	-11.179201
15881702	Can anyone sell me on why I should u	Can anyone sell me on why I should use clojure over say, any of the other nice Lisp-1s, given that I don't care about java.	Y_Y	12.649863	-7.8868246	comment	21.0	94.0	1512764516	-11.11112
22379603	State of Clojure 2020	State of Clojure 2020	agumonkey	12.653521	-7.905103	story	21.0	299.0	1582241320	-11.201297
14889605	Elm in Production: 25K Lines Later	Elm in Production: 25K Lines Later	charukiewicz	13.014615	-7.697445	story	21.0	449.0	1501477995	10.0215025
14006242	Fourteen Months with Clojure	Fourteen Months with Clojure	lackbeard	12.662622	-7.914242	story	22.0	300.0	1490982738	-11.1797695
14293310	Why Elm? [pdf]	Why Elm? [pdf]	antouank	13.012115	-7.694039	story	22.0	194.0	1494262227	-12.760757
14413872	Readable Clojure	Readable Clojure	tosh	12.637068	-7.893545	story	22.0	258.0	1495663797	-11.16163
25373831	The Future of Clojure	The Future of Clojure	simonpure	12.651345	-7.9018826	story	22.0	246.0	1607609399	-11.182722
18345305	What happened to Clojure? Was it jus	What happened to Clojure? Was it just a fad, or are people still using it in their day jobs? Are people still hiring Clojure devs? If you write Clojure at work, are you happy with it?	nerdponx	12.652769	-7.9001184	comment	22.0	126.0	1540991208	-11.1712055
27385208	Tour of our 250k line Clojure codeba	Tour of our 250k line Clojure codebase	grzm	12.651835	-7.9061055	story	22.0	373.0	1622743938	-11.161419
20949974	The beauty of functional languages i	The beauty of functional languages in deep learning – Clojure and Haskell	wickwavy	12.493673	-7.8557663	story	23.0	306.0	1568285056	10.475703
36043066	Why I Use Elm in 2023	Why I Use Elm in 2023	surprisetalk	13.009157	-7.696058	story	23.0	151.0	1684843132	-12.776377
19241427	Fearless Concurrency: Clojure, Rust,	Fearless Concurrency: Clojure, Rust, Pony, Erlang and Dart	pplonski86	12.445561	-7.8864894	story	23.0	298.0	1551051861	9.095136
19727551	Why did Clojure gain so much popular	Why did Clojure gain so much popularity?	yogthos	12.661982	-7.905613	story	23.0	182.0	1556019419	-11.186266
13340841	Clojure for the Brave and True (2015	Clojure for the Brave and True (2015)	severine	12.656029	-7.907812	story	23.0	244.0	1483741248	-11.202452
32493217	The Jank Language: LLVM Hosted Cloju	The Jank Language: LLVM Hosted Clojure	bobnamob	12.649105	-7.8957624	story	24.0	320.0	1660720264	-11.168257
21312109	Elm 0.19.1	Elm 0.19.1	roebk	13.015459	-7.69576	story	24.0	348.0	1571665242	-12.759429
35510294	I'm trying to learn Clojure at the m	"I'm trying to learn Clojure at the moment at the recommendation of Paul Graham and other technologists whom I greatly respect. But as I work through various coding challenges in an attempt to come to grips with the language, I have yet to encounter a single problem that is solved more elegantly in Clojure than the equivalent Pythonic solution. I am really trying to have an open mind, but I don't want to join a cult, either.It really feels at this point like Python has subsumed the best features of every dynamically typed language.Typically, people endorse Clojure for the following reasons:
1. It's functional!
OK, well, all the higher order functions exist in Python, too, but in fact you wouldn't want to use them anyway because in Python you have list comprehensions, which, it turns out, us"	blakers95	12.601757	-7.8567185	comment	24.0	95.0	1681115457	-11.116945
28469498	Thoughts on Clojure UI framework	Thoughts on Clojure UI framework	lycopodiopsida	12.659519	-7.8963184	story	24.0	262.0	1631194545	-11.141051
17808940	Small Assets without the Headache in	Small Assets without the Headache in Elm 0.19	liquid_x	13.010175	-7.693874	story	25.0	313.0	1534854550	-12.774755
28222060	Elm at Rakuten	Elm at Rakuten	dragonsh	13.014155	-7.697133	story	25.0	281.0	1629299085	-12.763486
33081443	Building a Startup on Clojure	Building a Startup on Clojure	drikerf	12.650573	-7.897447	story	25.0	222.0	1664896017	-11.166949
30423856	Try Clojure – An interactive tutoria	Try Clojure – An interactive tutorial in the browser	silcoon	12.652572	-7.881376	story	26.0	277.0	1645502537	-11.184338
20773158	Why Clojure?	Why Clojure?	jjgomo33	12.646901	-7.903706	story	28.0	248.0	1566514905	-11.1828165
23418699	A History of Clojure [pdf]	A History of Clojure [pdf]	puredanger	12.646123	-7.8999677	story	29.0	627.0	1591288254	-11.238693
17842400	Elm 0.19 Broke Us	Elm 0.19 Broke Us	maxhallinan	13.013445	-7.695012	story	30.0	276.0	1535228475	-12.757522
22458827	Clojure: A Lisp that wants to spread	Clojure: A Lisp that wants to spread	simonpure	12.651201	-7.882333	story	30.0	386.0	1583092142	-11.116682
38540761	Why is Jepsen written in Clojure?	Why is Jepsen written in Clojure?	manicennui	12.648795	-7.90403	story	30.0	469.0	1701840763	-11.174395
34774498	Clojure Turns 15 panel discussion vi	Clojure Turns 15 panel discussion video	fogus	12.653759	-7.910665	story	30.0	299.0	1676301696	-11.204229
