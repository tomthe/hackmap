id	label	hovertext	author	x	y	type	relevance	size	year	umap1d
37732472	TypeScript Monorepo with NPM Workspa	TypeScript Monorepo with NPM Workspaces	skwee357	8.63726	8.979509	story	3.0	21.0	1696206130	13.833057
37868984	It only works in monorepos, what abo	It only works in monorepos, what about distributed repositories/services then?	madduci	8.630828	8.987393	comment	3.0	10.0	1697192700	13.844787
14974197	As I understand, Daniel Vetter is pr	"As I understand, Daniel Vetter is proposing a ""monotree"" as a source code control pattern where a monorepo (and its branches) is not the primary place where development is done, but is rather where works are integrated from subordinate repositories.  In particular, he's asking for GitHub to support coordination (issues and pull requests) spanning upstream repositories that are indicated by a particular change request.I was hoping to see discussion of the merits of this proposal here on HN... not a regurgitation of Torvalds' positions and personal demeanor. What other projects  use a monotree? does it work well? How do those projects coordinate changes across subordinate repositories?"	clarkevans	8.631477	8.990181	comment	3.0	26.0	1502316667	13.840441
15455875	I understand the theory behind Monor	I understand the theory behind Monorepo but it always just rubs me the wrong way.	donatj	8.632977	8.990571	comment	3.0	11.0	1507786249	13.844276
15461659	Both Google and Facebook are also de	Both Google and Facebook are also dealing with such large repos that they've needed to start either customizing or building their own SCM's. MS started the GitVFS project to do a similar thing to suit their needs.Most people aren't at that scale, but IMO, many benefits people get from monorepos you also get by using GitHub/Gitlab with master projects mapping in git repos via sub-modules.Anyway, it really sucks to work on extremely large monorepos when you don't have access to the same resources as Google and Facebook. For this reason I'm personally always hesitant to recommend monorepos as the be-all-end-all.	bluejekyll	8.631935	8.989459	comment	3.0	14.0	1507845788	13.84979
15725352	If that's the reason, that's a great	If that's the reason, that's a great use-case for it. I am looking at it from a green fields perspective, and it seems more profitable to start with my company's codebase split up into packages from the outset, and focus on building tooling to handle package dependency version management instead of building tools to handle monorepos. The existence of large companies using monorepos creates some cargo cult pressure on those trying to make a decision which path to take, and so I think it's important to discuss what is really the goal to determine the best fit for my own use-case.	philipov	8.631771	8.991002	comment	3.0	12.0	1510947791	13.847371
15728748	PM for Git at Microsoft here.  We ex	PM for Git at Microsoft here.  We explored splitting it up.  It's a 300GB repository and it's been a monorepo for the last 20 years.  Splitting it up logically would take a lot of time (to put it mildly) and development would stall while we did it.  And once we did, we would have 100 3.5GB repositories?  3500 100MB repositories?  Neither of these are particularly appealing and getting changes checked in atomically across multiple repositories is insanely challenging.  There's no doubt that we would need to build tooling to make this work for us.  (We did actually explore this direction, but ultimately decided that it would be too much work for too poor an experience.)Instead, we decided to - as you put it - change Git to fit our needs.	ethomson	8.63052	8.983292	comment	3.0	14.0	1511008612	13.805607
15741787	Repo style wars: mono vs. multi	Repo style wars: mono vs. multi	zeveb	8.632363	8.989352	story	3.0	30.0	1511201059	13.844598
15753001	This is absolutely awesome. I barely	"This is absolutely awesome. I barely use Git myself - my use cases have pretty much been https://xkcd.com/1597/ - but the two main features I have needed to use are --depth=1 (to download just recent files) and ""just fetch this one file from this one directory"".--depth=1 occasionally breaks repos because of the way Git works. I THINK (don't cite!) that Git stores submodule information in the master repo's history. So when I do a depth=1 clone with something that has submodules, I literally don't receive the metadata about the submodule information. But now the local history I do have is borked, and the only way to really fix it is to rm -rf the destination and start again.But it's typically directories with submodules that also have massive histories. Like ffmpeg, for example. Yay.--Git do"	exikyut	8.616456	9.005126	comment	3.0	10.0	1511309655	-12.007469
38010868	In a monorepo situation, can you res	In a monorepo situation, can you restrict read access for certain branches/directories, or is it just writes e.g. push/merge. I was under the impression that isn't really possible given how git works but I thought I'd still ask, just in case.	nsteel	8.631359	8.989772	comment	3.0	12.0	1698225561	13.843586
38528151	> Git repositories sometimes have su	> Git repositories sometimes have submodules. I don’t understand anything about submodules so right now I’m just ignoring them.Submodules are interesting, because they’re next to unusable from a user perspective (they’re a pain to maintain and interact with unless you never ever update them) but they’re ridiculously simple technically which I assume is what made them attractive.A submodule is an entry in “.gitmodules” mapping a path to a repository URL (and branch), then at the specified path in the repository is a tree entry of mode 160000 (S_IFDIR + S_IFLNK), whose oid is the commit to check out (in the submodule-linked repository).	masklinn	8.6167555	9.005126	comment	3.0	14.0	1701762829	-12.005728
26898397	How does multi-repo codebase solve t	How does multi-repo codebase solve that problem? You would still need to keep up with your infra at minimum unless you run everything yourself too. Now you have another problem...Imo mono repo has little to do with it and it’s more just an eng culture of shipping above all else (heavily influenced by their promo process)	dilyevsky	8.632221	8.990995	comment	3.0	13.0	1619062120	-11.832268
27008175	Yes you can, it happens when you bum	Yes you can, it happens when you bump the sub module reference. This is how reasonable people use git.	swiley	8.617226	9.004502	comment	3.0	12.0	1619890870	-12.008262
27008641	We have repository systems built for	We have repository systems built for centralized atomic updates, and giant monorepos, like SVN. Question is why are we trying to have Git do this, which was explicitly designed with the exact opposite goal? Is this an attempt to do SVN in Git so we get to keep the benefits of the former, and the cool buzzword-factor of the latter? I don't know.Also when I try to think about reasons to have atomic cross-project changes, my mind keeps drawing negative examples, such as another team changing the code on your project, is that a good practice? Not really. Well unless all projects are owned by the same team, it'll happen in a monorepo.Atomic updates not scaling beyond certain technical level is often a good thing, because they also don't scale on human and organizational level.	slver	8.631678	8.989441	comment	3.0	20.0	1619894364	13.844619
33614247	In the argument of monorepo vs not, 	In the argument of monorepo vs not, the usual argument goes like this:- It's too hard to scale for a large monorepo!- Google does it just fine!- But I don't have access to Google's tools!So kudos to Meta for both solving the problem and making it available to others.  It will be interesting to see how useable it is outside of Meta.  I know for example that while Netflix open sourced a lot of tools, most of them weren't useable unless you ran all of them together.  So far Meta has been good at avoiding that, so hopefully that remains the case.	jedberg	8.632481	8.988354	comment	3.0	16.0	1668542613	-10.777949
34048109	I maintain the web monorepo at Uber,	I maintain the web monorepo at Uber, so I think I can give some context.Monorepos allows us to centralize important dependency upgrades. E.g. fixing log4j vulns is a lot easier when you can patch everything simultaneously. Same for tzdata (2022g gave very little heads up) Auditing for npm supply chain attacks was a lot simpler in monorepo than microrepos. Etc.Monolithic version control doesn't have to mean monolithic everything.Our web projects can be deployed independently of each other, and we leverage tool like yarn workspace focus and bazel for granular installs and builds/tests/etc.It doesn't have to mean monoversions either. We support multiple version of libraries, though we prefer coalescing them as much as possible to facilitate effort centralization. Finding out that your library	lhorie	8.632886	8.989533	comment	3.0	14.0	1671420866	13.8487
19006435	It has nothing to do with the Window	"It has nothing to do with the Windows filesystem; Git simply cannot support a 5 GB working tree on any filesystem.  You can call this ""pathological"" but this throws a lot of shade on monorepos without much critical examination of how or when they might be useful."	ethomson	8.631732	8.981717	comment	3.0	12.0	1548513423	13.81571
15889514	I wonder what do the bots commit in 	I wonder what do the bots commit in the monorepo. It is something that has been making me curious for a while.	soroso	8.632759	8.991108	comment	3.0	10.0	1512873399	13.845475
15889911	Good point.It's important to stress 	Good point.It's important to stress that Google uses Perforce and not git (at least for that monorepo, they use git/gerrit for Android).A monorepo this size would simply not scale on git, at least not without huge amounts of hacks (and to be fair, Google built an entire infrastructure on top of Perforce to make their monorepo work).	hota_mazi	8.632267	8.986059	comment	3.0	25.0	1512880050	13.836689
15890831	The trick is that Google have their 	The trick is that Google have their own VCS, build tooling, automated refactoring tools, etc etc, specifically designed to deal with their monorepo. Nobody else has that - we're stuck with git and a complex landscape of tools for managing code in ad-hoc ways. As a result, with the tools we have, many repos is better than a monorepo - but perhaps if we had those tools, for some cases, a monorepo might be better than many repos.Note that even where Google are forced to use git (e.g. Android, Chrome) they use a many-repo approach.	vertex-four	8.632351	8.984825	comment	3.0	48.0	1512902452	13.843958
15891050	I will get a furry of downvotes for 	I will get a furry of downvotes for saying it but the cause of your first three problems is git, not the mono repo approach.Git only allows to check/commit/view to the entire repo at once. Then, some git operations are superlinear with the number of files or revisions, they are slow on large repo to the point of being unusable.It's mandatory to have operation on a per file or subdirectory level in a mono repo approach. Companies that have mono repos all built tooling to support it. CVS/SVN used to do that out of the box but everyone hate them now.	user5994461	8.633254	8.988155	comment	3.0	12.0	1512907019	13.84159
15891060	Google has that, Facebook has that, 	Google has that, Facebook has that, Microsoft partially has that, some investment banks have that too.Everywhere I've seen mono repo, mono repo was better than multi repo.They all built special tooling and have dedicated teams to support it.	user5994461	8.6322	8.987582	comment	3.0	45.0	1512907283	13.842971
15891097	I wish someone would create an open-	I wish someone would create an open-source vcs that supports mono-repos at scale out of the box.	perfmode	8.631398	8.988253	comment	3.0	19.0	1512908245	13.847979
15890652	How many people work on the reposito	How many people work on the repository tooling at Google?I'm asking because i wouldn't know how to setup a mono repository at my 50 people Startup even if we deemed this to be necessary.	Roritharr	8.632153	8.98829	comment	3.0	11.0	1512897844	13.842873
15894098	Are you proposing a subversion-based	Are you proposing a subversion-based monorepo?	hennsen	8.629315	8.985517	comment	3.0	12.0	1512948612	13.845549
17057137	git submodules is just /begging/ for	"git submodules is just /begging/ for tooling.On the surface, the commands are fairly verbose. And (as the article pointed out) the documentation on it could use some love.However the biggest problem I have encountered while using it, is that what code I actually have checked out is opaque without doing the song and dance of actually checking out each submodule & inspecting the dir. This sucks when evaluating the codebase without cloning e.g. in code review on GitLab/GitHub. And the commands/UX for updating them is just painful and error prone.Really, the difference between putting something in a git submodule and putting something in a private npm/maven/etc. repo is that I can look at a file and read:    my-dependency v1.1.5

And my human-brain can kind of know what that means.Whereas if I"	lilactown	8.617384	9.004595	comment	3.0	14.0	1526179687	-12.004305
17057569	The point is that git doesn't do the	The point is that git doesn't do the right thing.A random git user with just the URL for my submodule-using repository isn't going to know to use some special thing to clone the repository.  They're going to run `git clone URL` and then be frustrated by the results.	newnewpdro	8.616802	9.004838	comment	3.0	15.0	1526191810	-11.997171
17057600	"""Git's submodules are so universally"	"""Git's submodules are so universally derided that there's practically an entire industry devoted to providing alternatives for managing dependencies."" Stop right there and repeat after me:Git is not a dependency manager, git is not a dependency manager, git is not a dependency manager, git is not a dependency manager.Seriously, use the package manager provided by your build system. Some of them can point to git repos if you don't have a proper package registry, this is a better solution than plain submodules, for many reasons; Transitive dependencies, diamond dependencies, semantic versionion, can't forget to submodule update --recursive, etc, etc."	Too	8.616556	9.005192	comment	3.0	13.0	1526192855	-11.986096
22994666	> I wonder which company successfull	> I wonder which company successfully runs a monorepo in git.Microsoft	Kipters	8.631458	8.9870825	comment	3.0	18.0	1587984647	13.846474
22995094	If that happens often you have the w	If that happens often you have the wrong repo split. This isn't a condemnation of the multi repo approach, only your architecture.Note that this is about trade offs. If you have a monorepo this problem goes away but now you need to manage the problems of monorepos. If you have multiple repos you get this and other problems instead. Pick the right tradeoffs for your own needs. The only things wrong is claiming your answer is the right one for everyone else.	bluGill	8.631326	8.989386	comment	3.0	12.0	1587989928	13.84238
23275291	I work at a FAANG with a monorepo (o	I work at a FAANG with a monorepo (or nearly so). For anything that’s not blue-sky R&D, stalking around the codebase for working examples and patterns is a big part of the job.I’ve felt that there is a potentially a role missing here: a kind of free-floating code librarian who is not attached to any particular team and could be called upon to perform basic research of existing patterns. Part of this role could be to maintain the kind of newbie-friendly documentation that tends to fall between the gaps of tool/infra/product teams. Maybe the job title could be “software informatician”.	pavlov	8.632411	8.989863	comment	3.0	10.0	1590171971	13.849293
28241667	I have a project, a programming envi	I have a project, a programming environment/runtime, that contains a number of overlapping applications. I started with a small number of repos, including one main one. I had a number of frustrations with that. One of them is I didn't like having shared and unshared code from different applications in the same repo, for the sake of managing versioning. I separated into more repos, maybe 20. After I split it up I discovered a number of new issues, much like the OP here. One of which is complications from working with several repos at the same time, such as when refactoring.I'll think about the next steps taken by the OP. Does anyone have any other practices they can recommend for managing these type of projects?	gpsx	8.6296625	8.979465	comment	3.0	25.0	1629425670	13.808266
28244362	I have worked with all of these mode	I have worked with all of these models.I have figured out that monorepo mainly covers for faults in maintaining separation between components (like ensuring only single direction of dependencies and no cycles, ensuring backwards compatibility, self-service, et.c) and to some extend to cover for out of control microservice craze.Kinda like giving unrestricted access to your PROD databases does help improve efficiency, but at the cost of additional risks and deterioration of separation between applications, lack of APIs for users to self service themselves, etc.Especially with microservices, these tend to fare poorly if you don't solve static costs of maintaining a service. So rather than invest in proper tooling let's just plop it into single repository. It will cover some problems a little	lmilcin	8.632801	8.990071	comment	3.0	23.0	1629452919	13.840659
27844865	The problem is that large codebases 	"The problem is that large codebases tend to have a huge footprint if you need to clone the whole repo. Git as-is does not allow you to only pull a subset, i.e. specific paths representing a sub project. That's what josh is trying to solve: a ""virtual"" repo that behaves like a real git repo but behind the scenes seemlessly integrates with the big monorepo."	ganafagol	8.630425	8.988301	comment	3.0	25.0	1626357998	13.836918
27845473	One big advantage of a monorepo is t	One big advantage of a monorepo is that when you check out the tree you automatically get the versions of all the files that work together (assuming there's some CI!).  If you want to refactor an API you can refactor its callers easily and check the whole thing in.  Etc.With each project having its own repo, then you have to track the fact that Foobar 2.2 works with baizo 1.6-1.8 but not more recent versions.Also conceptually it's easier when you are working with the client and the server at the same time, or the two mobile apps, and so on.Of course people manage without this when the project has stuff that doesn't fit in a software repo (CAD designs, artwork, etc...there's a reason why that POS Perforce survives, for example).  Solidworks has its own proprietary RCS that doesn't work with	gumby	8.632877	8.989784	comment	3.0	13.0	1626360851	13.843394
27846312	Like some people, I was expecting to	"Like some people, I was expecting to find a way to have the advantages of a monorepo while having projects in separate repos.
This is something Bloomberg is doing, and it's very cool. Each project is a separate repo, but they have a central integrated ""repo"" with all the repos, which is the ""source of truth"", and were code is built and deployed from.
You can commit changes in your repo, and then you ""release"" the code into the integrated repo, which will rebuild all the transitive dependencies and run their tests to make sure everything still works. If anything fails, your release of the code is not merged in the repo.
I'm now working with a monorepo, and I much prefer the Bloomberg approach.
Cross repo changes can be made atomically (you update the reference in the integration repo for mu"	MakersF	8.632258	8.990878	comment	3.0	11.0	1626365224	13.849002
27845027	Having been to the both sides of it 	Having been to the both sides of it I can say there exist exactly 0 advantages of a monorepo setup.	Glavnokoman	8.632991	8.991772	comment	3.0	12.0	1626358769	13.838018
12135835	Indeed, we should. Comrade Page, com	Indeed, we should. Comrade Page, comrade Brin, I'd like to have the Google software stack. IP rights are an outdated concept and the collective has decided that Google's stack belongs to the people.Besides, everything is just bits! If you represent the whole monorepo as a single integer, denying people access to it would be akin to patenting a natural number!	99127912	8.63435	8.983777	comment	3.0	11.0	1469095594	13.839164
12171008	Wouldn't git subtrees be a better op	Wouldn't git subtrees be a better option than git submodules?(see: http://blogs.atlassian.com/2013/05/alternatives-to-git-submo... and https://codingkilledthecat.wordpress.com/2012/04/28/why-your... )	apatap	8.617	9.004999	comment	3.0	12.0	1469602413	-11.976601
12501326	I would put all projects under one r	I would put all projects under one repo as orphan branches. With some branch-naming conventions you can easily separate those.	dr_win	8.630638	8.973662	comment	3.0	10.0	1473888342	13.806207
13514522	In the article it was google (perfor	In the article it was google (perforce) and Facebook (mercurial with hacks).Both are massive mono repos.At Amazon they were mostly perforce when I was there. Granted that was a few years back.	joneholland	8.635158	8.985036	comment	3.0	14.0	1485704057	13.839084
13560411	But, it seems all large companies (F	But, it seems all large companies (Facebook, Google, Microsoft) are using a mono-repo, and no-one is publicly admitting to using many small repos.If no company is using many small repos for truly massive projects, then it's hard to argue it would be a good idea. Could everyone who has looked at this problem make the wrong choice?	CJefferson	8.632451	8.988514	comment	3.0	11.0	1486135759	13.846307
21234878	Can you elaborate on “monorepos do n	Can you elaborate on “monorepos do not prevent you from checking packages into source control” and how that helps to avoid recompiling everything? Why would you check a package into source control anyway? Surely source control is for source code? And I lean toward monorepos, btw, but there are still lots of obstacles and monorepo proponents don’t tend to acknowledge them or offer clear suggestions for how to solve or workaround them.	weberc2	8.633375	8.988939	comment	3.0	31.0	1570902459	13.849047
21234896	I wonder why nobody have made a good	I wonder why nobody have made a good public monorepo offering similar to what Google have internally. Would probably be a hit at many companies since it fixes so many issues related to working in very large teams.	username90	8.633421	8.986698	comment	3.0	12.0	1570902609	13.819229
21626871	And after I just spent several hours	And after I just spent several hours of headaches rebasing and wrangling git subtree and attempting to git rebase -i branch -s subtree --rebase-merges --allow-unrelated-histories (which doesn't work)...Request: Is it possible to import only one subdirectory of another Git repository as a subtree (excluding unit tests and build scripts and such)?	_fbpt	8.623825	8.993679	comment	3.0	12.0	1574677791	-11.988387
39093816	Monorepos are indeed causing problem	"Monorepos are indeed causing problems with git, and this is one of the main arguments against them (see [1]).
Some companies are building their own solutions (Google, Meta), and some are splitting their monorepos because of these problems. IMO if a company wants to run a monorepo for their reasons, they shouldn't be limited by their VCS.The technical details are for the readers who want to know, I agree it's not really important for the users (most of them, at least).[1] https://medium.com/@mattklein123/monorepos-please-dont-e9a27..."	sasham	8.630717	8.9897175	comment	3.0	21.0	1705950286	13.852168
30439148	There should be a big warning on the	There should be a big warning on the top:Monorepo is a way to morph dependency management problem into source control problem within your organization. Currently, FOSS tools solve none of them.	rfoo	8.634085	8.990039	comment	3.0	14.0	1645606733	13.839152
30686758	> At Stripe, my current project is t	"> At Stripe, my current project is to implement a speculative approach to testing and merging changes, this will allow us to scale merges to hundreds of commits per hour while keeping the main branch green.I don't know how to interpret this sentence. What does the author mean when they say ""implement a speculative approach""? Is this something that other monorepo orgs can also adopt? Or is it specific to Stripe?Merge conflicts seem like an area with heavy potential for headaches that arises from the use of monorepo, and I wish the author would've shared deeper insights here."	educaysean	8.6324	8.990594	comment	3.0	11.0	1647359141	13.84643
30687044	Monorepo is just one small part of t	"Monorepo is just one small part of the puzzle. If you want to actually achieve the dream state that is alluded to when someone says ""monorepo"", you have to be willing to endure a super-deep and honest evaluation of your tech stack and processes.We have been successfully running a monorepo for ~5 years now using nothing more than the bare-ass GitHub PR process with some basic checkbuilds sprinkled on top. We intentionally avoided getting our hands dirty with CI automation as much as was feasible. Building our software manually is so simple its not really worth dedicating a team to worrying about.I would say the biggest key to our success was finding a way to minimize 3rd party dependencies. By making certain strategic technical choices, we were able to achieve this almost by default. Our re"	bob1029	8.632617	8.989837	comment	3.0	15.0	1647360375	13.842459
18812506	My last 2 jobs have been working on 	My last 2 jobs have been working on developer productivity for 100+ developer organizations.   One is a monorepo, one is not.  Neither really seems to result in less work, or a better experience.  But I've found that your choice just dictates what type of problems you have to solve.Monorepos are going to be mostly challenges around scaling the org in a single repo.Polyrepos are going to be mostly challenges with coordination.But the absolute worst thing to do is not commit to a course of action and have to solve both sets of challenges (eg: having one pretty big repo with 80% of your code, and then the other 20% in a series of smaller repos)	sfrench	8.632633	8.990323	comment	3.0	10.0	1546484893	-13.734401
18813499	I think there's a nuance to this tha	I think there's a nuance to this that should be pointed out: Monorepos allow you to do very bad hacks (I need this other component over there; let me just put in a Symlink. Done.). And if people can, they will use those hacks.If you split your repo up from the get go, the worst thing you can get that you'll have to assemble multiple distinct, well-encapsulated (in terms of project structure) things into one. In Git, that could lead to multiple root commits, but that's about it.	btschaegg	8.62769	8.993041	comment	3.0	21.0	1546500616	13.857534
18813635	Components might need to be released	Components might need to be released “together”, but if they are worked on by different teams, it means they’ll have a different release process, as in different timeline, different priorities.First of all this is normal, because otherwise the development doesn’t scale.In such a case the monorepo starts to suck. And that’s the problem with your philosophy ... it matters less how the components connect, it matters more who is working on it.Truth of the matter is that the monorepo encourages shortcuts. You’d think that the monorepo saves you from incompatibilities, but it does so at the expense of tight coupling.In my experience people miss the forest from the trees here. If breaking compatibility between components is the problem, one obvious solution is to no longer break compatibility.And	bad_user	8.631262	8.98951	comment	3.0	14.0	1546503620	13.832093
18813991	Not always. It makes absolutely sens	"Not always. It makes absolutely sense to have a repository for the gui and one for the server.
When writing a new feature you usually write some gui code and some server code and create different pull requests.
I think monorepos are seriously wrong and I completely agree with this article."	tigershark	8.632704	8.989247	comment	3.0	39.0	1546509257	13.852638
18814339	“why on earth would google invest en	“why on earth would google invest enormous effort constructing an entire ecosystem around a monorepo?”Didn’t google have a monorepo before git was created? And was created by academics? Legacy and momentum have a strong influence on the future. Hasn’t google also built a lot of tools for the monorepo and dedicates employees to it? That’s exactly the issue this article is about.From an external perspective, the speed and scale of product rollouts from the bigger tech companies is very slow. I don’t know if the tooling has much to do with it, but I suspect it might. I’ve heard some horror stories (some from here) about how it takes months to get small changes into production.	ashelmire	8.635909	8.980296	comment	3.0	19.0	1546514342	13.832266
18820494	I think that the reason of the argum	"I think that the reason of the argument is that both authors understand the definition of ""large repository"" very differently.With 100 engineers a monorepo might seem a good idea. With 500 it becomes nearly impossible to do anything involving a build. Some isolation is needed.Also from my experience many engineers just don't give a shit about architecture. They create entangled mess, that kind of works for the customer, and go home. Without some enforced isolation it is impossible to maintain it.That being said I am more inclined to polyrepos."	totallysnowman	8.631777	8.990059	comment	3.0	21.0	1546558696	13.850223
18820874	My org went from a monorepo where ev	My org went from a monorepo where every project had to obey the same CI model and you could not introduce entirely new CI tools for new prototypes over to a polyrepo with separated semver library repos for shared dependencies, and it simplified everything so much.Adding additional PRs across different repos is functionally no different than the same PR with scattered dependencies in a monorepo, except that separating the PRs makes each isolated set of changes more atomic and focused, which has led to fewer bugs and better quality code review and, the hugest win, each repo is free to use whatever CI & deployment tooling it needs, with absolutely no constraints based on whatever CI or deployment tool another chunk of code in some other repo uses.The last point is not trivial. Lots of people 	mlthoughts2018	8.632706	8.9903145	comment	3.0	26.0	1546562000	-13.739515
18856249	We are a small 20ish dev company usi	We are a small 20ish dev company using a monorepo with mostly python. Our tooling is Bazel and Drone.- Ease of onboarding. Being able to quickly build or test any target is awesome for the new employee.- Ease of collaboration. I can see all of the code easily and can learn from these patterns. I can also quickly contribute or extend apis and fix all usages without concern for breaking changes.Our use of Bazel quickly gets us around git scale issues by enabling external dependencies that can be loaded into the workspace without fully vendoring everything.	justinwp	8.7258005	9.08735	comment	3.0	13.0	1546961986	13.775233
18856778	You list three items here:“- library	You list three items here:“- library developers can easily see the impact their changes will have on their consumers- library changes that introduce regressions in their consumers can be caught pre-merge given good test coverage- dependency version updates between packages cause less mayhem because they are performed atomically and only merged when green”But I think these are actually signs of big failure modes of monorepos, and each one has analog for solving it with polyrepos and/or versioned artifacts that’s actually much safer and more practical.Firstly, wishing to see how library changes will cause issues in downstream consumers is often a sign of very deep problems, because the library designer should be free to make changes or enhancements as they deem necessary to solve the problem	mlthoughts2018	8.638965	8.978387	comment	3.0	18.0	1546964934	13.8325615
17268208	Google. monorepo with almost full vi	Google. monorepo with almost full visibility, code search/cross referencing/review tools, good infrastructure support, great videoconference and collaboration tools, a culture of written knowledge vs. oral lore, clear strategy in many parts of the business (loosely coupled, tightly aligned). Perks, pay, vacation are excellent. Work life balance is generally good. World experts in relevant subject matter are never far away.	jshute	8.63292	8.989347	comment	3.0	17.0	1528481531	13.848398
17606371	It took me a while to figure out tha	It took me a while to figure out that you're disagreeing with me, because your last paragraph is a perfect example of why monorepos are so dangerous.Imagine a tooling team on a different continent that makes some changes this afternoon. Like you said, their intent is just to add a new option, and it ought to have no extensional changes in behavior, but it still ends up behaving subtly different. The next morning, all your services end up broken as a result.In a versioned world, you can still freeze your dependency at 1.324.5234, and migrate only when you want to, and when you're feeling confident about it.In a monorepo world, you don't have a choice. You've been forcefully migrated as soon as the tooling team decides to make the change on their end. They had the best of intentions, but tha	whack	8.632462	8.990514	comment	3.0	14.0	1532483547	13.847809
17606568	how do you create branches in mono r	how do you create branches in mono repo?for example I want to use branch rev5 from project A and rev3 from project Bhow I do that in a mono repo,  I could not do it in HG, but sure about GIT	bedros	8.631555	8.990465	comment	3.0	13.0	1532486597	13.822508
17606675	My previous had a monorepo for the w	My previous had a monorepo for the website and backend (but not the mobile apps) which was insane to work with (as a coder I had a dedicated 128 core box to work on, some engineers had more than one, less intense engineers shared one) and a substantial amount of my time was spent just finding code. I guess most engineers just end up working in some nook and so that searching code constantly becomes less of an issue (it never did for me) but the code / debug cycle was dreadful.I should add that a huge amount was invested in tooling. We had an in-house IDE with debug tools that could step through serverside code. We had a highly optimized code search tool. We had modified a major version control system so it could handle our codebase. (Indeed we picked our version control system because we n	Tloewald	8.6391325	8.986092	comment	3.0	12.0	1532488366	-11.9253235
16364277	Eventual consistency. The great thin	Eventual consistency. The great thing about multi repo is the ease of decoupling the pieces so they can evolves separately (you can do that in monorepos too, but it's not quite as natural).You're free to PR changes gradually, making sure things work a couple of repos at a time, until you eventually get everything. If you can tolerate temporary inconsistencies, it allows you to scale to infinity, essentially for free.	shados	8.631762	8.988691	comment	3.0	15.0	1518488854	13.847225
16364334	With multiple repos, how do you solv	With multiple repos, how do you solve the issue that the private dependencies installed by package managers are not themselves under source control when you edit them? They are in /vendor or /node_modules or whatever. It's easy to pull them down and of course, for other people's dependencies, this is fine. But say I pull out one component of my app that's used by multiple apps. I set up my private repo or maybe the package manager works straight with git. But when it pulls the dependencies down, it doesn't pull the git subdirectories and so that code is not under source control. I make edits, test, then I have to copy that code back to its original repo, resolve any conflicts, and check it in. If I need to make a change, I have to do that again. If someone worked on that code, I have to pu	mnm1	8.630997	8.981971	comment	3.0	23.0	1518489657	13.745068
16364461	And how do you test if a change in o	And how do you test if a change in one of these repos fixes the problem you’re seeing?  This is what we’re failing at with our multirepo.That and resectioning code to split or combine responsibilities in different ways. Something a monorepo makes trivial.	hinkley	8.631763	8.989988	comment	3.0	16.0	1518491782	13.847843
36720002	Source Depot's largest disadvantage 	Source Depot's largest disadvantage VS git how hard it is to share changes with others.But I miss the ability to only pull down a portion of a monorepo, and the ability to remap where folders are at, or to pull down a single folder into multiple locations.So much bullshit in with monorepos in Git land exists because Git doesn't support things that Source Depot (and Perforce I presume) supported decades ago.As an aside for those who don't know what I am talking about, when pulling down a repo in source depot you can specify which directories to pull down locally, and you can also remap directories to a different path. This is super useful for header files, or any other sort of shared dependency. Instead of making the build system get all funky and fancy, the source control system handled pu	com2kid	8.627711	8.987923	comment	3.0	15.0	1689314440	13.835096
24454386	Because you lose the 'single head' c	Because you lose the 'single head' concept of actually being able to always have a clear view of the current newest version and of linear version history. The ability to map a single revision number into the state of _all_ source code (including third party dependencies) is extremely powerful. You also lose the ability of performing sweeping changes across an entire codebase in lockstep (think: backwards compatibility breaking API changes).Not to mention that Google internally avoids multiple repositories (and instead runs of a single monorepo) - it's just the android/chrome/public stuff that's mostly split up.	q3k	8.633997	8.981539	comment	3.0	14.0	1599935533	13.834299
24454486	I can't say for sure, but I'd be inc	I can't say for sure, but I'd be incredibly surprised if they weren't. What else would they be on? (Don't say Git, they tried to make Git scale for their monorepo and it would have required a lot of changes that the Git community wasn't interested in.)	sulam	8.631493	8.986583	comment	3.0	28.0	1599936421	13.849031
24509870	I think the key difference here is t	I think the key difference here is that there is no network in between components in a componentized monolith, each component runs the entire “monorepo”	jurre	8.632896	8.9914875	comment	3.0	32.0	1600376294	13.852634
38654175	which is a really weird problem to h	which is a really weird problem to have. Only lint files that have changed? How hard that is? our monorepo is 3m lines of code and running lint is not a bottleneck by any means...And once in a while that we have to run lint for entire repo (ESLint upgrade for example) we can afford to wait 1 hour ONCE	msoad	8.63332	8.988328	comment	3.0	10.0	1702648447	13.8427925
31792837	You completely missed the problem th	You completely missed the problem that submodules are actually supposed to solve though. Using them for either of those cases would almost definitely be the wrong choice.What they're really for, is vendoring someone else's code into yours. They're still not great even at that, but sometimes they're the best option.	aslilac	8.620177	9.002068	comment	3.0	11.0	1655579646	-12.024141
31795218	Interesting!I've never thought of do	"Interesting!I've never thought of doing commits in submodules. We use them a lot at work but only in a ""import a specific revision of this other repo into our repo"" sense, if we needed to make changes we would do them in the repo that the submodule points to and then just update the ref that the submodule points to.What's your use case for making and committing changes inside the submodule tree?"	jhugo	8.617642	9.004109	comment	3.0	12.0	1655600473	-11.990618
31898561	I don't understand all the negativit	I don't understand all the negativity in this thread. Submodules can be annoying in that they require special attention and treatment all the time. You need to keep the mental model of your entire project's tree in mind so that you don't screw up or mix up something. The whole thing just feels a bit too fragile.Submodules are usually good for frameworks and libraries that are more stable than your main codebase. However, those submodules under active development within the same organizations can be a pain to maintain.I'm not sure there's a good solution to this under git at all, but at least there's a product that makes an attempt and I absolutely don't mind the commercial intent here. For example GitHub is commercial after all, what's wrong with that?	mojuba	8.617635	9.003973	comment	3.0	12.0	1656354219	-12.020975
32295340	Good overview, I know these sorts of	Good overview, I know these sorts of pains well. Lots of hard questions and few definitive wins/right answers. How to organize a massive repository out in the open is still an open question. On that note, recently, I've been experimenting with this project called josh, which basically is like 'git subtree on extreme steroids, functioning as a git proxy':https://josh-project.github.io/josh/It basically lets you unify/view many repositories as a single one, or equivalent to split a mono-repo into smaller sized units of work for CI, specific teams, etc. It's bidirectional, so you push and pull from josh and everything goes into a single linear history in the mono repo. And because it's bidirectional, people in the mono-repo can still do things like make large-scale atomic changes across all s	aseipp	8.631572	8.985094	comment	3.0	14.0	1659273961	13.826674
32296664	I would pay $20 if git would disallo	"I would pay $20 if git would disallow committing from within the submodule directory (single source of truth), because it makes it so easy to forget a git push from within that submodule and now ""works on my machine,"" but ""special wtf edition!"""	mdaniel	8.617561	9.004301	comment	3.0	13.0	1659285053	-12.010537
22020728	Naive questionCan't we call Github a	Naive questionCan't we call Github a monorepository, as it is a single area one can use to access code?Implementation details likely differ from whatever Google and her engineers are cooking up, but at the end of the day I point to an archive and pull artifacts. Certainly not every Googler clones the entire monorepo...	tomrod	8.632778	8.988266	comment	3.0	15.0	1578760573	13.8503895
22020901	That still sounds like a monorepo.  	That still sounds like a monorepo.  Google is using external projects and has public facing projects so isn't mirroring the way you should handle it?  In what way could it be more monorepo like?	jayd16	8.633086	8.987748	comment	3.0	13.0	1578762115	13.847748
22022000	Don't try a monorepo unless you have	Don't try a monorepo unless you have a team of engineers who can work full time on maintaining the build tooling, enforcing good practices, and training the rest of the engineers on how to behave in a monorepo.	twblalock	8.635136	8.990923	comment	3.0	18.0	1578773706	13.8401
22079909	Interesting. I've been wanting somet	Interesting. I've been wanting something like that for submodules. Can the two features be combined?For instance, if you need a single file/directory from another project in your repository.	MayeulC	8.617698	9.004153	comment	3.0	21.0	1579298386	-11.994385
22081581	How does a sparse checkout not defea	How does a sparse checkout not defeat the purpose of a monorepo?  I thought monorepos existed so it was easy to make changes that affect the whole codebase and to test those changes.  If you only checkout a portion of the files, how are you going to test against the whole repo?EDIT: my overall concern is that it looks like people are reinventing clearcase.  Please speak to an older developer who worked at an HP/IBM type company in he late '90s/early 2000's before you do that.  Please!	krupan	8.633929	8.990307	comment	3.0	11.0	1579311974	5.1925416
16483187	Given that Nix is already popular in	Given that Nix is already popular in the Haskell ecosystem and it's also polyglot, why not build the monorepo with that instead of Bazel?	aphexairlines	8.697972	9.029584	comment	3.0	11.0	1519828298	13.80115
16807694	Start working in a repo with submodu	Start working in a repo with submodules and you suddenly have to understand a lot more and can get into trouble with no idea how you did it.	flatline	8.617536	9.003478	comment	3.0	21.0	1523415510	-12.020669
16807970	I use submodules every day, never ha	I use submodules every day, never had a problem with them. What do people complain about when it comes to them?My mental model is basically that they're separate repos, and the main repo has a pointer to a commit in the submodule. Do your work that needs to be done for the submodule, push your changes, and then check out that new commit. Make a commit in the main repo to officially bump the submodule to that new commit. Done.The annoying part is when you do a pull on the main repo, you have to remember to run git submodule update --recursive.	xxpor	8.6173315	9.005166	comment	3.0	13.0	1523419921	-12.004087
19309103	During my 18 months at Google circa 	During my 18 months at Google circa 2015, I used the following repos: google3, Android, ChromeOS, and Chrome browser. 1 is 4 for large values of 1, after all.One telling question is whether there have been any efforts to unify these repos. Monorepos can come about passively, through uncontrolled growth. But if you truly believe in the monorepo, surely you'll knock down the barriers and unify the distinct repos. Has Google done that?If they've actively chosen not to, why not? Is Android separate from google3 for hysterical raisins, or on sound principles, or some mix? Is there a cross platform repo for shared code?	ridiculous_fish	8.632527	8.988771	comment	3.0	10.0	1551775100	13.848922
19590556	How difficult would this be to add G	How difficult would this be to add GIPO to?This crushes the Raspi3 for the value.	robertAngst	8.631555	8.979226	comment	3.0	15.0	1554556543	-11.976483
19693820	Adrian Colyer dug into this a little	"Adrian Colyer dug into this a little further on the morning paper:https://blog.acolyer.org/2019/04/18/keeping-master-green-at-...His analysis indicates that what uber does as part of its build pipeline is to break up the monorepo into ""targets"" and for each target create something like a merkle tree (which is basically what git uses to represent commits) and use that information to detect potential conflicts (for multiple commits that would change the same target).what it sounds like to me is that they end up simulating multirepo to enable tests to run on a batch of most likely independent commits in their build system. For multirepo users this is explicit in that this comes for free :-)which is super interesting to me as it seems to indicate that an optimizing CI/CD systems requires deali"	underrun	8.632967	8.989723	comment	3.0	25.0	1555614176	13.842455
19740796	This is such a pain point for me.I w	This is such a pain point for me.I would LOVE something between subtrees and submodules.I have explored this many times, and if I had the ability to write something like this, I would.I would love it if I could have a child repo that did not require an external remote and could be bundled and stored within a parent repo, unlike a submodule. But I would also like it if it could be more decoupled from the history unlike a subtree.I can get most of what I want from submodules and subtrees, but not really enough.It might be possible without even having to change git. Perhaps if there were a way to have branch namespaces of some kind, and I could have a subtree have completely separate history, but have it checked out within the same working tree. Many of my projects that are submodules only ma	apostacy	8.617067	9.004998	comment	3.0	11.0	1556127161	-11.986017
19793303	I'm a bit confused.Are you critical 	I'm a bit confused.Are you critical of the size of the monorepo, or the number of builds?	algorithmsRcool	8.635763	8.994434	comment	3.0	21.0	1556669480	13.846052
35756784	>For example, if an engineer is unsu	>For example, if an engineer is unsure how to use a library, they can find examples just by searchingIsn't that the case with all libraries? How does the monorepo help here?	falcor84	8.635275	8.986255	comment	3.0	18.0	1682799735	13.845523
35759311	They should also look at deleting th	"They should also look at deleting third_party directories and replacing them with package manager dependencies. For example Qt WebEngine embeds Chromium, which embeds Blink, which embeds wpt, which embeds a bunch of Python libraries and one of those Python libraries (six) is embedded in three other locations within Chromium.https://sources.debian.org/src/qtwebengine-opensource-src/5....
https://codesearch.debian.net/search?q=package%3Aqtwebengine....I wonder how many copies of the Python six module the Google monorepo contains."	pabs3	8.634008	8.989666	comment	3.0	11.0	1682822934	13.848483
34361308	''I am here to tell you: if you are 	''I am here to tell you: if you are running a software business and you aren't at, like, Google-tier scale, just throw it all in a monorepo.''Google _is_ a monorepo	xiphias2	8.673578	8.947814	comment	3.0	27.0	1673563417	13.838492
34362447	> Rolling out API changes concomitan	> Rolling out API changes concomitantly with downstream changes to the documentation or the OpenAPI spec.> Introducing feature-level changes and the blog post announcing those changes.These are horrible reasons to use a monorepo. Commits are not units of deployment. Even if you're pushing every system to prod on every commit, you'd still basically always want to make the changes incrementally, system by system, and with a sensibly sequenced rollout plan rather.To take one of the examples above, why would you ever have the code implementing a feature and an annoucement blog post in the same commit? The feature might not work correctly. You'd want to be able to test it in a staging environment first, right? Or if you don't have staging, be able to run it in prod behind a feature flag gated t	jsnell	8.633534	8.983043	comment	3.0	10.0	1673570381	13.849874
34362249	No!  I'm tired of being told how to 	"No!  I'm tired of being told how to architect systems because other folks refuse to grow their knowledge.Because I'm good at my job, a monorepo would be pants-on-head stupid.  Because I know how to make separate codebases interact with one another successfully, it would be a massive mistake to lose those advantages, all because you (not me) run into problems when you try to do what I find perfectly natural.And if you work with me, you will learn, and I will guide you, and in time you will experience systems design as I do, and no longer be shackled to only doing the things you understand today.But no, ""do this because I don't know how to do that"" will never be a winning argument."	SpeedilyDamage	8.633764	8.981974	comment	3.0	12.0	1673568997	13.797815
34362894	Submodules are hell. I work somewher	"Submodules are hell. I work somewhere with a polyrepo topology, with the inevitable ""shared"" bits ending up integrated into other repos as submodules. Nothing has been more destructive to productivity and caused so many problems.A plain old monorepo really is the best."	_rm	8.62237	8.999769	comment	3.0	13.0	1673573999	-11.990271
34434658	I've eased this multi-project burn o	"I've eased this multi-project burn out in those steps:- move all projects to a monorepo. This is great because all projects are in one place, they become interconnected as some code will end up being a library for multiple ones. This ensures that even when I'm doing side-project ""foo"" some of the code or stuff will also end up improving ""foo"" or ""bar"".- move the monorepo to github codespaces. The very last thing I want to do when I want to work on my side projects after some time is to remember how I had to setup everything, from ide, to the os, etc.- keep todos, documentation, notes, all in the monorepo. What did I have to do? `apps/foo/todo.md` or search in the project for ""TODO:"". No point into having docs on different services, they stay close to the project.- write E2E and integration"	epolanski	8.63289	8.990627	comment	3.0	10.0	1674084588	-12.867809
23482607	Author of the post here.I think Git 	Author of the post here.I think Git upstream is trying to simplify configuration. They have a config option called `features.manyFiles` which enables most of the features we enabled for our developers (https://git-scm.com/docs/git-config#Documentation/git-config...).We wanted to use this instead of deploying a wrapper, but it turns out that some of Git's features like fsmonitor do not interact well with repositories with submodules (there were Git crashes). And we have some developers that work on repositories with submodules. So we needed something more flexible, like enabling these features only on particular repositories.	ublaze	8.617759	9.004204	comment	3.0	13.0	1591826168	-12.008559
23483436	Is there a reason people prefer a mo	Is there a reason people prefer a monorepo to submodules?I worked at one place that kept everything in a mercurial mono repo and it was a real pain keeping branches in sync.	swiley	8.624807	8.996815	comment	3.0	10.0	1591832169	-11.965016
23483565	The fact that so many are using mono	The fact that so many are using monorepos points to a weakness in revision control and dependency management tools. This is a big gap where someone will invent Git’s replacement. What features will it need to replace Git?	silverlake	8.632126	8.988765	comment	3.0	10.0	1591833191	13.841568
30946520	The main downside that people always	The main downside that people always mention is it takes a long time to clone or pull a large repo. This is actually a flaw of git, not a flaw of the monorepo as a concept.	jeffbee	8.631954	8.990784	comment	3.0	14.0	1649348175	13.84564
30947418	People hated that they couldn't make	People hated that they couldn't make atomic changes across components. Google's monorepo means everybody has to move in lock-step, which is bad for everybody:* library maintainers must make sure they don't introduce any regressions to any users at all. There's no major version number that you can increment to let people know that something has changed. Development necessarily slows.* Library users must deal with any breakage in any library they use. Breakage can happen at any time because everybody effectively builds from HEAD. There are complicated systems in place for tracking ranges of bad CL numbersMonorepo isn't entirely to blame for this, but it certainly doesn't help. I've been at Google 15 years and I'm tired of this.	inoffensivename	8.635417	8.984329	comment	3.0	10.0	1649351482	13.842879
30959234	Your best bet for monorepo building 	Your best bet for monorepo building across a variety of languages is Nix. If money is no object you can also make do with Bazel.	tazjin	8.675949	9.028147	comment	3.0	13.0	1649435528	13.811748
34969251	the gratitude thing is kinda fun. I 	"the gratitude thing is kinda fun. I imagine that managers treat that as a ""positive only"" indicator (lack of gratitude markers should not be counted as a negative, but a lot of them should be counted as a positive), since it's dependent on coworkers who do that kind of thing.In a previous job I would always offer ""e-bux"" for fixes. I was half tempted to write a quick backend to track these e-bux, but gamifying that sort of stuff has its own consequences as well...> If there is an issue with a single deploy, it stops the whole company from shipping changes.This definitely feels odd to me. Monorepo shouldn't mean mono-artifact! Perhaps this is more theoretical/one point, but if Stripe engineers feel this and this person felt this after less than a year... Bazel is nice y'all. (EDIT: I'm bein"	rtpg	8.634798	8.988868	comment	3.0	10.0	1677592233	13.845032
36953713	> which is distributed and egalitari	> which is distributed and egalitarian at its core, is a better model for a fast-paced, globally distributed community of developers than previous monorepo systems like MercurialI'm a bit confused by this. I don't think that's what monorepo means, is it? Monorepo is what you choose to put in a repo? And I thought Mercurial was extremely similar to Git as it's also a DVCS?	robertlagrant	8.631258	8.986482	comment	3.0	10.0	1690878433	13.846996
36964083	What is your spiciest take on monore	What is your spiciest take on monorepos	pperi11	8.63206	8.990898	story	3.0	5.0	1690928844	13.844165
37292567	Most large monorepos simply are not 	Most large monorepos simply are not on git. Google has Piper, Yandex has arc, Facebook has eden (which is actually semi-open-source, btw!), some companies use Perforce and so on.	tazjin	8.63339	8.9906845	comment	3.0	13.0	1693222986	13.845669
37292571	for each submodule affected by some 	for each submodule affected by some change you would need an additional commits, yes. But those commits are bundled together in the commit of the parent repo where they act as one.So, atomicity of changes can be guaranteed, but you need to write a few more commits. However this effort of small increases of commits is far outweighed by the modularity imo.	steffres	8.617257	9.00514	comment	3.0	13.0	1693223032	-12.009491
29190959	Google had to build an internal vers	Google had to build an internal version control system as an alternative to git and perforce to support their monorepo.Microsoft forked git and layered their own file system on top of it to support a centralized git workflow so that they could have a monorepo.	anon9001	8.632415	8.987628	comment	3.0	13.0	1636653834	13.839244
29195112	I understand that your customers wan	I understand that your customers want very large git repositories, so that's the need you're going to serve.  As a (very large) bonus, you're going to sell a lot of cloud services to people that can't manage to work with their monorepo on local machines.  I won't be surprised if in 5 years, most big companies are just leasing GitHub instances as the only reasonable way to edit/build/test/deploy all of their code from the browser.  I think it's a concerning trend if you're not GitHub.Also, I appreciate that you're upstreaming to core git and not trying to build a technical moat.But why do so many people want these monorepos?This seems like a serious developer education problem to me.If I'm wrong that Google is the cause of this cultural shift toward monorepos, what do you think caused it?I 	anon9001	8.632307	8.987261	comment	3.0	13.0	1636677928	13.850674
29195687	> No one has claimed that a monorepo	> No one has claimed that a monorepo lets you magically do atomic RPC API migrations.Plenty of people have claimed and continue to claim that a monorepo lets you magically do atomic API migrations, and skate over how the fact that many APIs go over RPC these days.> It won't though: if you cover both code paths at each stage of the three stages, you'll cover all possibilities (its also not clear that you need integration tests to cover this, you can fake the client or server and test against both versions and be fine). This is the same if you've got multi or mono-repo, although with a monorepo there's a decent argument that maintaining integration tests is easier, as you can build both the client and server from within the repo.This relies on assuming that you perfectly maintain the previou	lmm	8.632769	8.99074	comment	3.0	20.0	1636683898	13.851788
29510150	> The Commission will make its softw	> The Commission will make its software available as open source in one single repositoryLet's hope this is not a git monorepo...I wonder where they will release it? Github would be the easy choice. They could self-host a forge or just a web frontend, publish tarballs, etc.An interesting choice would be to use SourceHut, which is now based in the Netherlands with ddevault. (edit: well, maybe it's still incorporated in Delaware).	MayeulC	8.631893	8.986109	comment	3.0	17.0	1639146172	-11.757835
36258360	Ask HN: Branching strategies for mon	Ask HN: Branching strategies for monorepos, what is your approach?	floppydisc	8.631416	8.990939	story	3.0	2.0	1686321044	13.841616
36400671	I doubt the fact they use a monorepo	"I doubt the fact they use a monorepo has any impact on this thinking. A versioned sourced repository is no different from a file server. If some ""ai copyright infringed"" code made it into the monorepo it doesn't compromise the whole thing. There are still clear distinct projects and products.But exactly, this is a hygiene thing. Staff will still be using these tools anyway."	samwillis	8.632395	8.989056	comment	3.0	24.0	1687245007	13.842317
25907222	Ask HN: Monorepo design best practic	Ask HN: Monorepo design best practices? (naming convention etc.)	bredren	8.632662	8.989168	story	3.0	2.0	1611601469	13.847114
26165355	Both --recursive not being default a	Both --recursive not being default and then using --recurse-submodules when pulling are my top annoyances in git.	c03	8.616605	9.005912	comment	3.0	12.0	1613562415	-12.055562
26167836	I absolutely despise submodules, but	"I absolutely despise submodules, but under many use cases you don't add or remove that often. We definitely run into errors people complain about. In fact there are errors that the average user (that doesn't really care about SVC) pretty much can't fix... or with much difficulty. I don't know that I'd still say it's a dealbreaker, but that's definitely very bad. Very much does break some of the spirit of git and what makes it ""nice"".We've been using them, and our system is still very usable (obviously this is a ridiculous thing to brag about, but worth pointing out).I'm wondering if there's a better way to handle shared code between two repos, where the users of either don't have access to the other parent? You might be able to use subtrees? Email source code and just create n separate com"	P_I_Staker	8.617588	9.002205	comment	3.0	13.0	1613577538	-11.994331
26239575	Anyone know a clean way to have nest	Anyone know a clean way to have nested git projects? Every time I make a commit in B (the nested git project), there are changes in A. Previous searching of a solution was hard to understand..	moosebear847	8.617097	8.994056	comment	3.0	14.0	1614099272	-11.948894
31160410	The rub for me here is that making o	The rub for me here is that making one change in a core library ideally wouldn't touch 100+ other source files. This feels like a separation of concerns issue in which a module is being over used.Perhaps I'm just in the wrong headspace, as I have never had to work in a monorepo fashion. That being said just because your code is in a monorepo, does that directly mean that you aren't versioning your libraries?To my understanding most package management tooling in most echo systems allow for versioning. With that said, wouldn't you slowly roll out the version to the downstream projects Monorepo or not?	DerArzt	8.633104	8.990249	comment	3.0	10.0	1650919779	13.848392
31515321	This is an interesting write up!The 	This is an interesting write up!The only question I have is around your point on monorepos - every monorepo I’ve seen has been a discoverability nightmare with bespoke configurations and archaic incantations (and sometimes installing Java!) necessary to even figure out what plugs in to what.How do you reason about a mono repo with new eyeballs? Do you get read in on things from an existing engineer? I struggle to understand how they’d make the job of auditing a software stack easier, except for maybe 3rd party dependency versions if they’re pulled in and shared.	zer01	8.633296	8.990122	comment	3.0	16.0	1653546589	13.842424
31597568	I'm currently evaluating/tinkering w	"I'm currently evaluating/tinkering with an idea:I think that a well structured monorepo might make a move away from all-encompassing full-stack frameworks and plugins to libraries, tools and special purpose frameworks easier to get close to a best of both worlds situation.The background is deploying up to a dozen or less new sites and apps per year as a small team while continuously maintaining the old ones and wanting to merge in new improvements found in newer development.---Rationale:Big web frameworks and similar give you per-project productivity, structure and are batteries included, but come with downsides, such as less control, less flexibility, unneeded complexity and abstraction, legacy cruft and gotchas, generally poor performance that you ""fix"" with caching where you can etc. Yo"	dgb23	8.632875	8.989073	comment	3.0	10.0	1654189517	13.82702
31764005	If you don't have a couple of hundre	If you don't have a couple of hundreds engineers who would write a custom file system for git (Microsoft), or who would take an existing source control system and nearly fully rewrite it (Facebook), or who would write a custom source control system from scratch (Google, Yandex, etc) DON'T USE MONOREPO.Otherwise you are risking to end up in a situation when hundreds of your engineers have to spend tens of minutes every time they need to simply push their code changes.	kanu666	8.633013	8.991304	comment	3.0	10.0	1655371421	13.87733
31766986	I get a headache imagining everythin	"I get a headache imagining everything Google in a monorepo.  So how do you reconcile this single GIT repository approach with Infoworld's ""The case against monorepos""? [1]:Reason #1. Monorepos go against single-team ownership principlesReason #2. Monorepos encourage bad practices involving massive refactoringReason #3: Small repositories are better than large ones[1] https://www.infoworld.com/article/3638860/the-case-against-m..."	stevenjgarner	8.631988	8.989279	comment	3.0	10.0	1655392375	13.846343
14411508	Why split it into separate modules? 	Why split it into separate modules? Seeing that big companies are very successful with monorepos (Google, Facebook, Microsoft), has made me reconsider if repository modularization is actually worth it. There are a host of advantages to not modularizing repos, and I'm beginning to believe they outweigh those of modular repos.	arjie	8.630456	8.991457	comment	3.0	28.0	1495645284	13.844716
14412979	I'd rather see google open up their 	I'd rather see google open up their monorepo as a platform, and compete with github.  git is fine, but there's something compelling about a monorepo.  Whether they do it one-monorepo-per-account, or one-global-monorepo, or some mix of the two, would be interesting to see how it shapes up.	daxfohl	8.632154	8.987281	comment	3.0	20.0	1495656017	13.844007
14662586	There is no better, there is only tr	"There is no better, there is only tradeoffs, and some people prefer one tradeoff and others prefer another tradeoff. That's just how it is.So before making any siginficant changes one should discuss what the desired tradeoff is, and then measure the continuous change towards that tradeoff.For instance monorepo is a goal for people who want interacting tools to be build in their corresponding state without need to consult someone else. Can you do that? Check out the repo (for 2-5 hours depending on your code size) and then just hit ""make"" and ""make test"" and it runs through? If yes it's a success, if no something went wrong in the process.PS: There are actually build tools that are language independent, e.g. make, CMake or Maven. You can just use these.PPS: I'm personally really happy to se"	erikb	8.646077	9.000571	comment	3.0	11.0	1498738459	13.822482
14662746	Monorepo doesn't imply read permissi	Monorepo doesn't imply read permissions for the entire repo for everyone in the company.	klodolph	8.63252	8.990703	comment	3.0	12.0	1498740071	13.846789
20566165	Ask your doctor if Monorepo is right	Ask your doctor if Monorepo is right for you.	rezmason	8.633862	8.982347	comment	3.0	11.0	1564502487	13.846888
20567094	My team just switched to a monorepo.	My team just switched to a monorepo. It's been only a few weeks, so I can't claim any results yet, but we've lived w/ the pain of poly-repo for long enough that we were ready to invest in a single repo.We've spent a lot of time building and iterating a unified ci/cd environment to support the new repo. Previously each project had it's own test/deploy/build/publish story and usually it's own jenkins project. Now, each project is registered and triggers its own steps. Cross-project edits can happen in a single pull request. We have an incredible amount of integration tests (more so than unit tests), and getting them to work corss-project while migrating has been challenging.We've gone from ~10-15 actively maintained repos to about 3 as we're slowly migrating. We have a mix of services, libra	DanFeldman	8.632139	8.990285	comment	3.0	18.0	1564507907	13.841536
20568139	Let's assume without proof that Glib	Let's assume without proof that Glibc developers are good. Similarly, kernel.org developers are good as are the gcc.gnu.org people.Should glibc, gcc and the kernel be in a monorepo?(Cue laugh track ...)	kazinator	8.632555	8.985662	comment	3.0	10.0	1564513926	13.846506
20569721	How do you handle building changes t	How do you handle building changes to just one of those projects? Can Jenkins do that (easily)?I think that's the big thing that always puts me off monorepo... We'd basically be going from ten 5 minute builds to one 50 minute build if it wasn't possible to do incremental builds. IIRC Google and MS have purpose built tools that do impact detection to work out what to build for their monorepos to keep build times down.	joshschreuder	8.644732	9.002244	comment	3.0	12.0	1564524610	13.8266
20911893	I thought the monorepo setup made cr	I thought the monorepo setup made cross-project dependency changes easy?	tedmiston	8.632304	8.990984	comment	3.0	12.0	1567963467	13.8436365
20917409	that stood out to me too... not the 	that stood out to me too... not the monorepo really, but the fact its a monorepo of a billion lines of code. seems almost impossible to maintain when you have a dependency change at the lowest levels that affects numerous projects.If i am understanding google was in a situation where they had to update every project that used typescript inside the entire company at the same time, that seems untenable.	apalmer	8.633542	8.987694	comment	3.0	11.0	1568031477	13.863749
24173670	I think if git submodules were archi	I think if git submodules were architectured differently, they could have been a really interesting solution for package management. In fact my last place of work uses a layer on top of submodules as part of their internal package manager. I think they could be really special but unfortunately are now sort of relegated to history.	anchpop	8.614819	9.007675	comment	3.0	23.0	1597537419	-11.999753
24175686	I won't suggest others are referring	"I won't suggest others are referring to the same issues necessarily, but try switching between branches(/commits) when you have submodules. Let alone rebasing etc... they simply  don't ""just work"". You always get some odd vestige of a submodule hanging somewhere that ends up causing problems, either in the index or the .gitmodules or somewhere in .git/ or whatever. Hell, the fact that there are so many places where git submodules are recorded itself has caused me so many headaches."	mehrdadn	8.61734	9.005346	comment	3.0	10.0	1597558859	-12.006772
24256041	Is there actually any veracity to th	Is there actually any veracity to this claim or is it general anti-google shit-flinging?I ask because from what I understand from Google's monorepo, it should be easy for engineers to take direct dependencies on whatever they want.Of course TF is an exported out library so things might be different, but surely it won't then be a good example of Google's DNA?	kinkrtyavimoodh	8.634209	8.985623	comment	3.0	11.0	1598223952	13.853941
34049286	Monorepos and monoliths are orthogon	Monorepos and monoliths are orthogonalMonorepos are a tooling nightmare. Monorepos are a bandwidth black hole.Monorepos make some things possible that are just not possible or very very hard when you have multiple independent repos that are built and tested independently.Namely,a) they allow you to test the effects of a change on all the components that depend on you, before you merge your change. This reduces the noise caused by regressions (API or behaviour) introduced in one component that is depended on by many consumers.b) they are a practical way to ensure that all components have up to date internal dependencies: by placing the burden of API and behaviour breakage to the author of the change, you don't end up having hundreds of teams each struggling to keep up with dependencies that	ithkuil	8.632685	8.989313	comment	4.0	20.0	1671432807	13.846362
26479390	Nice work, really interesting blog p	Nice work, really interesting blog post!On a sidenote, git itself can also get painfully slow with large monorepos. Hope GitHub can push some changes there as well.I know FB moved off git to mercurial because of performance issues.	iliekcomputers	8.633296	8.986372	comment	4.0	20.0	1615913565	13.824696
26479399	Offtopic, but I often wonder if ther	Offtopic, but I often wonder if there are people using `git worktree` to have several related code trees within the same repo.Technically it works the mostly the same as multiple repos, but theoretically allows to have something like a bootstrap script with everything self contained in the same repos. Looks like an alternative tradeoff between a monorepos with shared history and multiple repositories.	tuyiown	8.629493	8.981832	comment	4.0	16.0	1615913586	-11.897061
26920494	I've considered building systems tha	I've considered building systems that would speculatively run builds using forward projections of all pending pull requests, as well as run multiple parallel scenarios on merge order + rebase such that merge conflicts are minimized. Maybe sprinkle in some monte carlo if the numbers get a little intense.In practice, I feel it is much easier to assign work and organize your codebase so that logically-different business functions can be managed in isolation.We rarely have merge conflicts these days, and we are also on 1 big monorepo. It mostly boils down to discipline and architecture.	bob1029	8.635685	8.991257	comment	4.0	12.0	1619220631	13.837659
27010518	I’ve always found that the biggest i	I’ve always found that the biggest issue with monorepos is the build tooling. I can’t get my head around Bazel and other Blaze derivatives enough to extend them to support any interesting case, and Nix has too many usability issues to use productively (and I’ve been in an organization that gave it an earnest shot).	throwaway894345	8.647735	9.001252	comment	4.0	22.0	1619908673	13.824677
12737307	Then maybe you can answer a few ques	Then maybe you can answer a few questions:- Do you have zero external dependencies on 3rd party library not own by Google? These must still be managed anyway? How do you deal with project X is not ready to move to external library version N but project Y needs version N?- What about release branches? If you need to intergrate a bug-fix in a sub-system, the magic mono-repo now means merging a fix is harder as it may depend on other unrelated changes all over teh repo? The laissez-faire attitude of not having to care about details in HEAD would seem to bite back in release branches.	pierrebai	8.632848	8.989583	comment	4.0	15.0	1476815438	-9.282005
13598968	> Git is more pleasant when you brea	"> Git is more pleasant when you break your codebase into isolated components. These can be pretty large—the Linux kernel has 16 million lines of code—but if your codebase is many times larger than a complete modern kernel, you might want to split it.As part of a company that switched to same kind monorepo structure form several separate repositories - there is nothing ""pleasant"" about having to deal with multiple Git repositories for connected components. Subtrees, submodules are utter hell of maintenance, checkout bugs (which hurt CI) and bad UX across the board (""why doesn't this build?"" ""you forgot to checkout submodules"" ""no you forgot to move the commit pointer"" ""no you forgot to change dependant tests because you didn't see them in an isolated repository""...)It's not a GOOD approach,"	izacus	8.623487	8.9969225	comment	4.0	17.0	1486567907	-11.967117
27844640	From the title I expected it to be a	From the title I expected it to be a tool for treating multiple separate repos as though they were all just one single monorepo. But from the description in the README, it seems to be for treating subsets of a monorepo as though they were separate repositories.PS: The title, in case it is changed, is currently “josh: Get the advantages of a monorepo with multirepo setups”	codetrotter	8.632069	8.991403	comment	4.0	34.0	1626356825	13.846626
27845593	What are these tools designed for mo	What are these tools designed for monorepos and sub trees?	endisneigh	8.634915	8.9794655	comment	4.0	16.0	1626361517	13.844571
27904772	The advantage of a monorepo in this 	The advantage of a monorepo in this particular case is that it makes easy things easy: if you want to remove a parameter of a function in some library and that function has just a few callers in dependent executables, you can just do that in a single commit. Without a monorepo, you have to do the full-blown iterative rollout described in the OP even for small changes, if they cross VCS boundaries.	bla3	8.63285	8.990376	comment	4.0	43.0	1626866210	13.8474655
19851830	my own anicdata:  Integrate a defaul	"my own anicdata:  Integrate a default proxy into our existing ""choose proxy"" workflow takes about 2 weeks, and I'm currently on my 3rd month of those 2 weeks :)Reasons for the delay:1) Proxy is a stand-alone application.  Needs it's own deployment and build configuration
2) Main app was running on Node 6.x.   High time to upgrade to 10.x as 6.x LTS is running out.
3) Upgrade to 10.x breaks some modules we depend on (Google Cloud datastore) and that module has been deprecated in Node 8.x+..   time to refactor that....
4) Main app is in a mono-repo with backend systems still running node 6.x   Don't want to spend the time upgrading everything to node 10, so need to split Main app into it's own repo, decoupling from existing mono-repo codebase
5) Since we are upgrading main app to Node 10, Be"	novaleaf	8.632356	8.989326	comment	4.0	31.0	1557251790	13.865008
15889912	I have two main concerns when I see 	"I have two main concerns when I see monorepos being used.First, like in other areas, I see companies that want to ""google 
scale"" and blindly copy the idea of monorepos but without the requisite tooling teams or cloud computing background / infrastructure that makes this possible.Second, I worry about the coupling between unrelated products.  While I admit part of this probably comes from my more libertarian world view but I have seen something as basic as a server upgrade schedule that is tailored for one product severely hurt the development of another product, to the point of almost halting development for months.  I can't imagine needing a new feature or a big fix from a dependency but to be stuck because the whole company isn't ready to upgrade.I've read of at least one less serious c"	epage	8.632267	8.989893	comment	4.0	17.0	1512880059	13.848222
15890819	Software A version 1 consumes format	Software A version 1 consumes format F1 and produces format G1 data, and software B version 1 consumes format G1 and produces H1.To upgrade format G2 we must change both software A and B.First, software B version 2 must accept both G1 and G2. To do this we may need to build software A version 2 and try them in a sandbox environment to gain confidence that ∀F1 we produce the correct G2. If F1 is complete, we may be able to do this exhaustively, but if F1 is sufficiently diverse, monte carlo simulation might be used.Then, if there's a 1:1 relationship between A/B we can upgrade pairs.If there's a N:M relationship, we need to upgrade all of the instances of software version B1 to B2 (at least within a shard). If you're running in a non-stop environment, this might have it's own challenges. On	geocar	8.63222	8.990853	comment	4.0	20.0	1512901956	13.850252
17978970	Since we're doing an aside, what adv	"Since we're doing an aside, what advantages do those ""monorepo"" things have over git submodules?"	Touche	8.623278	8.998424	comment	4.0	12.0	1536849801	-11.963497
18164031	I call this: Headline Driven Develop	I call this: Headline Driven DevelopmentAnother good example are monorepos. A decision maker sees a headline about Google and Facebook using monorepos and mandates his company to switch. Unfortunately, he or she didn't read or didn't understand the actual article that explains that it only works because of strict code reviews and extensive integration tests.	latch	8.635709	8.976865	comment	4.0	18.0	1538970969	13.825029
18537647	I'd like to hear the logical conclus	"I'd like to hear the logical conclusion of ""Large Modules Considered Harmful."" Is he implying infrastructure code (e.g., terraform or ansible or cloud formation) should be split between the repositories for each component? Or just saying, ""be smart about how you layout the infrastructure repo""?"	Boxxed	8.628255	8.989935	comment	4.0	13.0	1543273292	13.8404665
18809702	I wish this had touched on polyrepos	I wish this had touched on polyrepos' ability to pin known-good versions of dependencies; that tends to be the Achilles' heel of monorepos.	erik_seaberg	8.633337	8.991026	comment	4.0	18.0	1546459954	13.845091
18809904	Alternate title: monorepos - ideal f	Alternate title: monorepos - ideal for teams under 100 devs	pbiggar	8.634979	8.991208	comment	4.0	24.0	1546461210	13.886989
18813279	I do really like mono-repos, but goo	"I do really like mono-repos, but google's other significant new project: fuchsia - is set-up as multi-git repo (and I believe chromium too, maybe android (haven't checked)). For fuchsia, they use a tool called ""jiri""[1] to update the repos, previously (and maybe still in use) is the ""gclient"" sync tool [2] way from depot_tools[3][1] - https://fuchsia.googlesource.com/jiri/
[2] - https://chromium.googlesource.com/chromium/tools/depot_tools...
[3] - https://chromium.googlesource.com/chromium/tools/depot_tools...It even reflects a bit to the build system of choice, GN (used in the above), previously gyp, feels similar on the surface (script) to Bazel, but has some significant differences (gn has some more imperative parts, and it"	malkia	8.633579	8.988287	comment	4.0	12.0	1546496838	13.846202
18813682	My rule of thumb is: if you need to 	My rule of thumb is: if you need to do PRs in several repositories to do one features, you should probably merge the repositories. At work, we have code spread among a bunch of repositories, and having to link to the 2/3 related PRs in other repos is a major PITA, and even more so for the reviewers.	forty	8.63029	8.957512	comment	4.0	51.0	1546504449	13.731884
18812069	I’ve found monorepos to be extremely	I’ve found monorepos to be extremely valuable in an immature, high-churn codebase.Need to change a function signature or interface? Cool, global find & replace.At some point monorepos outgrow their usefulness. The sheer amount of files in something that’s 10K+ LOC ( not that large, I know ) warrants breaking apart the codebase into packages.Still, I almost err on the side of monorepos because of the convenience that editors like vscode offer: autocomplete, auto-updating imports, etc.	olingern	8.632782	8.990499	comment	4.0	15.0	1546479272	13.85186
18820699	the fact that essentially 100% of bi	the fact that essentially 100% of big tech companies use monorepos seems like evidence that it is at least possible to do it in a scalable way...	thurn	8.633701	8.991157	comment	4.0	15.0	1546560280	13.840988
18820755	"""Shared responsbility"" is one of tho"	"""Shared responsbility"" is one of those ideas that sounds good on paper, but doesn't really scale terribly well in the real world.  As the old saying goes ""when everybody is responsible, nobody is responsible"".More to the point, as the author of TFA allows, once a system reaches a certain size, nobody can understand it all. At some point you have to engage division of labor /specialization, and once you do that, it doesn't make sense to have just anybody randomly making changes in parts of the code-base they don't normally work in.I'd rather see a poly-repo approach, with a designated owner for discrete modules, but where anybody can clone any repo, make a proposed fix, and submit a PR. Basically ""internal open source"" or ""inner source""[1].In my experience, this is about as close as you can"	mindcrime	8.634099	8.981987	comment	4.0	14.0	1546560898	-11.837103
18825031	So, the thing that is still buzzing 	"So, the thing that is still buzzing in my head now and not mentioned in the article (maybe I didn't read carefully enough), what actually gets released into prod after a change is reviewed and merged.If the monorep contains let's say five different products and in a day only one of them gets a merge, then Blaze still builds all five and all five are released (based on successful integration testing)? OR only releases the changed product (and any other ones which depended on the changed one)EDIT: Also, the ""canary"" server is still for testing ? There may exist practically a set of canaries running very different versions ? Is there any correlation or any version ""roll-up"" constraints between various canaries ?"	stillworks	8.632568	8.990432	comment	4.0	13.0	1546618286	13.855766
18856980	Whenever I hear smart and reasonable	Whenever I hear smart and reasonable people argue well for both sides of an engineering issue, my experience is that it will turn out that we're arguing the wrong question.  The perspective is wrong.  We can't get past thinking in terms of our old terminology.What we all really want is a VCS where repos can be combined and separated easily, or where one repo can gain the benefits of a monorepo without the drawbacks of one.Another crazy tech prediction from me: just as DVCS killed off pre-DVCS practically overnight, the thing that will quickly kill off DVCS is a new type of VCS where you can trivially combine/separate repos and sections of repos as needed.  You can assign, at the repo level, sub-repos to include in this one, get an atomic commit hash for the state of the whole thing, and wh	ken	8.631536	8.988695	comment	4.0	16.0	1546966172	13.85143
29993555	Out of curiosity, why the hate for g	"Out of curiosity, why the hate for git submodules? They've worked really well for me over the years. They solve the problem of ""pin a specific version of some external 3rd-party repo"" really nicely.The only complaint I have is that the git-submodule CLI has unintuitive syntax. But this is Git after all, so it's par for the course. :v"	nrclark	8.618174	9.002004	comment	4.0	25.0	1642600016	-11.992166
16364285	> With a monorepo, projects can be o	> With a monorepo, projects can be organized and grouped together in whatever way you find to be most logically consistent, and not just because your version control system forces you to organize things in a particular way. Using a single repo also reduces overhead from managing dependencies.This is the major thing I miss about Subversion, and the fact that in Subversion a subdirectory in a repository can be checked out on its own.At the top level of our Subversion tree, there were 'web', 'it', and 'server' directories, reflecting the departments in the company (at least those departments that dealt with source code).In the 'server' directory, there were things like 'payments', 'reports', and 'support', for things like payment processing, reporting, and stuff to help the customer support p	tzs	8.629837	8.992558	comment	4.0	18.0	1518488954	13.846861
17267192	My startup's monorepo has 2 root com	My startup's monorepo has 2 root commits as well. When the company was first starting out, my co-founder and I created independent git repos. I was writing OCR type research-y code and he was doing more traditional CRUD REST webserver things.When it came time to pull things together, we thought it'd be fun to try and maintain the histories. So I added his repo as a remote and simply merged his unrelated history into mine.Fast forward and now we offer hoodies as swag to anyone who contributes to the repo. We personalize the hoodie with your git username, the truncated commit hash of your first commit, and the number of parent commits to your first commit.Having 2 root commits means that both my cofounder and I have hoodies with a large 0 as number of parent commits. Just a nice way to comme	rraval	8.631663	8.990757	comment	4.0	20.0	1528476142	13.850457
22993940	In the last few years, I saw a lot o	In the last few years, I saw a lot of people using monorepos, and discouraging using submodules.Frankly, I don't know why. For small projects, sure - it it an overhead. For anything larger, I find it useful to encapsulate things - be it installable packages, or if it is not the case - at least other repositories.In the last months I split one project into 4 repos (https://github.com/Quantum-Game/) and couldn't be happier about that move. It makes the code cleaner, Pull Requests more separated, etc.	stared	8.627571	8.994678	comment	4.0	24.0	1587975435	-11.971133
22994018	Once your code grows and you end up 	"Once your code grows and you end up with too many repos you'll be yearning to get back to monorepos. It allows to make changes in one go instead of having 3-4 PRs that all have to be merged at same time or otherwise the build breaks.Having separate repos only makes sense if they are maintained by separate teams with a well defined API in-between that doesn't change often.
If the same team maintains all repos  then it is just overhead, especially if you end up with a 100 repos and you have significantly less than 100 engineers in your team.There are also potential build time savings when having a monorepo since you can do parallel builds across different subdirs without serialising at package boundaries."	edwintorok	8.631994	8.989346	comment	4.0	18.0	1587976381	13.856293
22994133	Because it turns out big corporation	Because it turns out big corporations that use multirepos tend to be even less efficient (about versioning) than those that use monorepos.What are those far simpler, better, more open alternatives?	beagle3	8.633296	8.990221	comment	4.0	26.0	1587977793	13.84395
22994600	In git I fully agree, and I wonder w	In git I fully agree, and I wonder which company successfully runs a monorepo in git.For me, I prefer git submodules, which seem to have the benefit of both monorepo and separate repo's.	koonsolo	8.630498	8.993548	comment	4.0	24.0	1587983980	13.863323
23283543	Boy look at that architecture diagra	Boy look at that architecture diagram, I'm going in the opposite direction. A mono repo that compiles to one single binary that does everything. Sort of like how an fertilised egg divides and each cell finds its place in the organism. A self organising architecture, you hear'd it here first.	wrnr	8.631777	8.990791	comment	4.0	17.0	1590246550	13.833932
25536257	Git submodules just don't seem to wo	Git submodules just don't seem to work in practice, and that could be a big chance for a competing scm to overtake git. Having dependency management inline with scm would allow for more simplicity in the overall process.	seanalltogether	8.617091	9.005293	comment	4.0	35.0	1608901801	-0.11026541
26165111	IME submodules are mostly fine for e	"IME submodules are mostly fine for external dependencies that only very rarely change and remain pinned at a specific version over weeks or months.Giving submodules a special set of git commands, and providing the users so many easy opportunities to shoot themselves in the foot are baffling design decisions though.E.g. I'd really like to know why ""git clone --recursive"" isn't the default."	flohofwoe	8.617114	9.005114	comment	4.0	21.0	1613560188	-12.007615
26165151	I've found that git subtrees are a m	I've found that git subtrees are a much better option. Good intro here:https://www.atlassian.com/git/tutorials/git-subtreeThey're like submodules, but you can edit them and they're embedded in your history, not just a reference.	wheybags	8.616933	9.001222	comment	4.0	18.0	1613560519	-11.946993
36975565	There are no true monorepo companies	There are no true monorepo companies	fosterfriends	8.633664	8.985039	story	4.0	12.0	1691003309	13.836963
37121763	DISCLAIMER 1: Current Googler here, 	DISCLAIMER 1: Current Googler here, but opinions are my own.DISCLAIMER 2: I think from a hands-on-keyboard SWE there is a lot of useful stuff. What you mentioned about Google culture of killing products and such I am not gonna talk about.I recommend chapters about testing first and foremost. Among all the codebases I saw (both OS and proprietary) Google tests are the most comprehensive and reliable. However, If you are in a startup-like environment you should pick and choose and not try to follow every single principle listed as they could sink your velocity drastically in the short run.Other interesting points (IMHO) are Monorepo, Build System, and Code Reviews.For the Monorepo I discover being a huge lover although I was skeptical. The sad thing is that it's a rather niche practice and t	marcyb5st	8.633054	8.987947	comment	4.0	19.0	1692024996	13.845538
25218175	Can I ask a monorepo question: what 	Can I ask a monorepo question: what do you when you’re trying to upgrade dependency XYZ, and a moderate or large refactor is required in another team’s code?	dannyw	8.632911	8.990873	comment	4.0	15.0	1606380795	13.859614
39052528	> Code at Google3 is one giant monol	> Code at Google3 is one giant monolithI’ve heard this stated before, and something about it feels off. There’s no way all of Google’s code is in one repo.Like, does that monorepo contain the full Android operating system with Google Services and the firmware for all the Pixel devices? I feel pretty sure multiple teams at Google must have forks of the Linux kernel for one reason or another, would those be in there too? Is Chromium in there too? What about the whole golang project?Even if I’m off about some of this, it feels like the statement “Code at Google is one giant monolith” needs some qualifiers.	Uehreka	8.634405	8.9832535	comment	4.0	14.0	1705648753	13.847179
15724961	Are there advantages to using a mono	Are there advantages to using a monorepo rather than having a proper package manager? Seems like the problems they're trying to solve would be better solved by not insisting on using a monorepo.	philipov	8.633802	8.99107	comment	4.0	21.0	1510945394	13.8445015
15726144	IMHO it is a major failure that git 	IMHO it is a major failure that git doesn’t scale for org-wide mono repos. Software development process should not be dictated by limitations in the VCS. It surprises me that others are so willing to settle.	perfmode	8.630687	8.985934	comment	4.0	33.0	1510954417	13.841187
17548154	Well, Google has succesfully defende	Well, Google has succesfully defended their monorepo approach on multiple occasions.So, before dissing this approach as 'non-SV-canon', read Google's [1] and Twitters [2] accounts on why they do what they do.[1] Why Google Stores Billions of Lines of Code in a Single Repository (2016) https://cacm.acm.org/magazines/2016/7/204032-why-google-stor...[2] On monolithic repositories (2014) https://gregoryszorc.com/blog/2014/09/09/on-monolithic-repos...	edejong	8.632582	8.9881	comment	4.0	18.0	1531815605	13.848111
17606933	Same line of thinking, just differen	"Same line of thinking, just different conclusions.I feel terrible for anyone trying to run a company with open-source style independent repos. On a popular github project, you have MANY potential contributors that will tell you if a PR, or a release candidate break API compatibility, etc. There are thousands of hours in open source dedicated to fixing integration issues due to the (unavoidable) poly-repo situation.Monorepos in companies are relatively simple. You need to dedicate some effort in your CI and CD infrastructure, but you'll win magnitudes by avoiding integration issues. Enough tooling is out there already to make it easy on you.Monorepos' biggest problem in an org is the funding, as integration topics are often deprioritized by management, and ""we spend 10k per year on monorepo"	wirrbel	8.632496	8.99088	comment	4.0	15.0	1532493390	-13.728402
17605817	How does CI work with a monorepo? Do	"How does CI work with a monorepo? Do you always have to run all the tests and build all the artifacts? Or are there nice ways to say ""just build this part of the repo""?"	jbergknoff	8.6329155	8.99076	comment	4.0	12.0	1532475732	13.843733
17606573	"Both monorepo or ""micro repo"" end up"	"Both monorepo or ""micro repo"" end up falling apart at scale without some devops work involved. Either will work if you only have a few dozen projects. Neither will work once you hit 10s of millions of lines of code.But people seem to forget that it wasn't that long ago that git didn't exist, making multiple repos was a pain in the butt. Managing multiple repos locally was hell. Monorepos were the norm.Then as the state of version control ramped up, and making repos became easy, and having so much code in one repo had performance issues (overnight CVS/SourceSafe/SVN pull on your first day at work anyone? Branches that take hours to create?), people started making repos per project. The micro-service fad made that a no-brainer.Now, for companies like Facebook and Google, or really any compan"	shados	8.631772	8.988651	comment	4.0	19.0	1532486641	13.845897
17607121	"I call this ""Google Imposter Syndrom"	"I call this ""Google Imposter Syndrome"". Because Google (insert Facebook, Apple, Amazon, etc) has success with Monorepos (insert gRPC, Go, Kubernetes, React/Native, etc), it must be a great idea, we should do it. You see this everywhere. Also known as an Appeal to Authority.My personal opinion: very few companies will hit a point where sheer volume of code or code changes makes a monorepo unwieldy. Code volume is a Google-problem. But every company will have problems with Github/Gitlab/whatever tooling with multiple repos; coordinating merges/deploys across multiple projects, managing issues, context switches between them, etc. And every company will also have problems with CI/CD in a monorepo.Point being... there are problems with both, and there are benefits to both. I don't think one is "	013a	8.63256	8.989777	comment	4.0	13.0	1532497448	13.838902
21234677	The main driver of success in either	The main driver of success in either model is in the tooling and practices invested in it to make it work in an organization. Google is successful with their monorepo because they have invested in building (blaze), source control (piper, code search), and commit to always developing on HEAD. Multirepo is currently easier for most companies because most public tooling (git, package manager) is built around multirepos. One place I see multirepos fall over is awful dependency management practices internally and in open source. Many dependencies quickly become outdated and are not updated in cadence, slowing down writers and consumers. Better tooling can help here but an organization needs real discipline to stay on top of things.	Cedricgc	8.633492	8.988855	comment	4.0	27.0	1570900801	13.840714
21607323	> Counter-argument: Just let it sit 	"> Counter-argument: Just let it sit there and keep working? Outside of security patches, if there even are any, there's always the option of ""just stop touching it.""That's not exactly possible with a monorepo that has no branches and everything has to be maintained 'in step'. Any time a library breaks API, all dependents must pass tests, and/or be fixed so that they do. Any time a runtime API breaks (think things like interfaces to runtime authentication, compute scheduling, database services, network bandwidth scheduling), updated services must be made to conform and then be rolled out. As with real life, this might mean getting a 1 or 2 year old deployment system (configuration for production, roll out code, ...) undusted, understood, probably fixed in turn, etc.As such, some SRE/SWE tea"	q3k	8.633407	8.989796	comment	4.0	35.0	1574441481	13.846197
31792691	Git submodules aren't bad in that th	Git submodules aren't bad in that they're buggy, they do what the documentation suggests.I think they're difficult to use, because it breaks my mental model of how I expect a repository to work. It creates a new level of abstraction for figuring out how everything is related, and what commands you need to be able to keep things in sync (as opposed to just a normal pull/branch/push flow). It creates a whole new layer to the way your VCS works the consumer needs to understand.The two alternatives are1. Have a bunch of repositories with an understanding of what an expected file structure is, ala ./projects/repo_1, ./projects/repo_2. You have a master repo with a readme instructing people on how to set it up. In theory, there's a disadvantage here in that it puts more work on the end user to m	d_watt	8.618638	9.000611	comment	4.0	17.0	1655578611	-11.973966
31792728	Beyond how hard to use they may or m	Beyond how hard to use they may or may not be, my personal hatred of git submodules is about bypassing your normal dependency management system. See 12 Factors on Dependencies[1].I've not seen many uses of submodules that weren't better served by adding the package from pypi/npm/crates/...[1]: https://12factor.net/dependencies	FrenchyJiby	8.617094	9.004732	comment	4.0	17.0	1655578913	-12.014587
31792887	What's the mental model for the use 	"What's the mental model for the use of a git submodule?I've always thought of them as a way to ""vendor"" a git repository, i.e. declare a dependency on a specific version of another project. I thought they made sense to use only when you're not actively developing the other project (at least within the same mental context). If you did want to develop the other project independently, I thought it best to clone it as a non-submodule somewhere else, push any commits, then pull them down into the submodule."	arjvik	8.616896	9.001907	comment	4.0	12.0	1655579989	-12.011374
31793805	There are git options for managing t	"There are git options for managing these difficulties like:git config --global submodule.recurse truehttps://git-scm.com/book/en/v2/Git-Tools-Submodules search for ""git config"""	agilob	8.617543	9.003315	comment	4.0	19.0	1655586229	-12.012099
31882822	Well, it's not that easy. Let's say 	Well, it's not that easy. Let's say you have this layout :- applications: front, backend, background-worker- libs: database-ormIn a multi-repo layout, if you want to make a change in database-orm, you'll make your PR in its repo, test, and make a release with your changes.Nice and easy right ? Well, you're not done. Now you have to make a PR to update the dependency on each repo using this library. If you're lucky, nothing breaks and it's quite quick.But it's not always so easy : you notice that you actually broke something down the line in the backend. You have to fix it (in your library), and do it all over again. You can also have libraries depending on other libraries, multiplying the effort when you messed up something.The monorepo handles that, you update one library and you can see 	ZeKK14	8.632581	8.990432	comment	4.0	22.0	1656241531	13.847577
31883226	> Alternatively don't use monoreposA	> Alternatively don't use monoreposAnd now you get into the fun situation of having to handle ecosystemic asynchronous updates between your multiple repositories.	masklinn	8.632534	8.990107	comment	4.0	29.0	1656245372	13.826501
39636236	Ctrl+F 'Sapling'Ctrl+F 'Eden'Yeah th	"Ctrl+F 'Sapling'Ctrl+F 'Eden'Yeah the author of this doesn't really know what's going on with regards to source control at Facebook/Meta.Meta doesn't actually use Mercurial and hasn't for several years now. They basically wrote their own custom centralized version control that uses Mercurial-inspired client commands in order to adapt to the scale of their massive repos. Actual Mercurial scales just as bad as ever if the repo is too large because that breaks a fundamental assumption of distributed version control.Massive repos simply don't work with the traditional model of ""no master server"" distributed version control. In DVCS, a client checkout is supposed to contain the entire repo metadata. That's why the git people told Facebook that they were doing it wrong.Anyways, stacked diffs are"	sneed_chucker	8.630345	8.969517	comment	4.0	14.0	1709856924	-11.923609
32294850	I'd be interested to know why projec	I'd be interested to know why projects like this don't make use of git submodules. They take some getting used to but once understood seem to do a reasonable job of multi-repository projects to me.	zmmmmm	8.618825	9.002626	comment	4.0	16.0	1659266984	-12.055006
22021014	Monorepos are cool but I hate perfor	Monorepos are cool but I hate perforce with a passion.  How can we use git?A lot of work is going into making git scale better which is nice but there will always be small open source repos. You could mirror them but it seems like it would be nice to not have to do that.Is there any research going into figuring out how to keep many repos in sync with a single commit?  Maybe you could use submodules across your company...have a single master repo that essentially just keeps track of working version sets.  That might work but it sounds torturous.  Is anything on the horizon to solve this problem with git?	jayd16	8.631743	8.987737	comment	4.0	23.0	1578763335	13.834747
23884588	For some historical perspective, con	For some historical perspective, consider this. When Tomboy was new, people complained about its ‘bloat’. Why? Because it’s ‘unnecessarily’ written in .NET, and Mono was a ‘huge and bloated’ dependency.	FooBarWidget	8.634595	8.98197	comment	4.0	15.0	1595104271	-9.195078
24110531	This would be insanity in a mono rep	This would be insanity in a mono repo. A developer would have to look over every PR to make sure some critter from the marketing department didn't accidentally change an important bit of code.	scoopertrooper	8.632472	8.989805	comment	4.0	13.0	1597074434	-11.832982
20567484	Does anybody know some monorepo horr	Does anybody know some monorepo horror stories?I have heard plenty of people complain about their many-repo structure and wishing for a monorepo. I would like to hear some concrete  story where a monorepo went wrong. This article is just abstract opinion.	qznc	8.632873	8.989849	comment	4.0	21.0	1564509966	13.837576
20568789	Is the monorepo/multirepo choice rea	"Is the monorepo/multirepo choice really the most important thing to consider?Branching: monorepo or not, if a feature-incomplete development branch for one of the supported targets can ""hold the entire organization as a hostage"" then the SCM people, and/or persons responsible of the SCM policy, should do some introspection...Why are deliveries done from a branch which is obviously still in development? Why does code-to-be-released need to depend on incomplete work? Why aren't something like ""topic branches"" used?Modularity: monorepo or not, problems will certainly appear when the complexity of implementation outpaces the capacity created by the design. To get modularity, one needs actual modules with properly designed (=not brittle, DRY, KISS, YAGNI, SOLID, etc. etc.) interfaces between th"	jnurmine	8.632794	8.991339	comment	4.0	12.0	1564518547	13.850445
14411905	How does a mono-repo company manage 	"How does a mono-repo company manage open sourcing a single part of their infrastructure if things are in one large repo? 
For example, if everything lived in one repo, how does Facebook manage open sourcing React?
Or if I personally wanted to switch to one private mono-repo, how would I share individual projects easily?"	jonathanpoulter	8.632502	8.9906025	comment	4.0	13.0	1495647830	13.847195
30946524	That's factually untrue. Google, Mic	That's factually untrue. Google, Microsoft, Facebook, Twitter, Airbnb all have a huge monorepo. Splitting it out is obviously not necessary with the right tools.	exitheone	8.6333685	8.986729	comment	4.0	14.0	1649348186	13.85549
30946690	One upside of smaller repos that I r	One upside of smaller repos that I rarely hear about is that it forces you to think about versioning. If you have a monorepo, you often don't version individual components, you just have master that always builds. If your product is a user facing website, that is fine. But if you make releases, and have multiple components in different versions that have a stable API, and are expected to work in different combinations, then it is a real hassle. Of course you can tag individual library versions in a monorepo, but that is not the way of least resistance.One place I've worked at migrated to a monorepo, the ATLAS experiment at CERN. It was not bad, although there were the usual problems with long checkout time. But it worked because we tended to version every single piece of software together 	captainmuon	8.632619	8.98748	comment	4.0	20.0	1649348781	13.847845
30947178	How do you manage versions / tags wi	How do you manage versions / tags with monorepo? If you need to tag something ( a lib ) everyone gets the same, the entire repo now has a tag v0.0.1 eventhough only your library changed.	Thaxll	8.632431	8.989889	comment	4.0	12.0	1649350593	13.84777
30960249	Is it possible to integrate Turborep	Is it possible to integrate Turborepo with general-purpose monorepo build tools? Bazel, in particular?(Is Bazel designed in a way that make it impossible to do JS monorepos well?)	dfabulich	8.714371	9.068928	comment	4.0	12.0	1649440051	13.79352
31008990	If your company is small, I don't th	If your company is small, I don't think you should be using git submodules at all.My last place was about 10 years young, 150 engineers, and was still working within a single git repo without submodules.There is a non-zero amount of discoverable config that goes into managing a repo like that, but it's trivial compared to the ongoing headaches of managing submodules, like you suggest.	gen220	8.616502	9.004479	comment	4.0	12.0	1649802402	-12.020421
31762821	I feel like I've read about several 	I feel like I've read about several big companies using monorepos, but I've never understood why. It feels like the source-control equivalent of writing your code in one big file.Does anyone have any good resources for why and how best to implement a monorepo?	barbs	8.63298	8.990737	comment	4.0	16.0	1655358746	13.844747
31762947	One of the benefits of monorepo is r	One of the benefits of monorepo is refactoring. You can just apply a renaming command across all of the files in the solution and all the related names are properly updated.Not that easy to get this to work on multiple repos.	nsoonhui	8.632332	8.991006	comment	4.0	30.0	1655360227	13.844356
29190743	I'm glad you're having a good experi	I'm glad you're having a good experience now, and git as a monorepo will work fine at smaller scales, but you will outgrow it at some point.When you do, you have two choices.  You can either commit to the monorepo direction and start using non-standard tooling that sacrifices decentralization, or you can break up your repo into smaller manageable repos.I don't have any problem with small organizations throwing everything into one git repo because it's convenient.My objection is that when you eventually do hit the limits of git, will you choose to break the fundamentals of git decentralization as a workaround?  Or will you break up the repo into a couple of other repos with specific purposes?I don't like that GitHub makes money by encouraging people to make the wrong choice at that juncture	anon9001	8.631455	8.989595	comment	4.0	26.0	1636652601	13.8473425
34361613	My 2 cents: monorepos try to solve w	My 2 cents: monorepos try to solve what is actually a series of devops problems, by essentially abusing the way an organization or individual uses git (or VCS of your choice). These tools that were never designed for devops in the first place.To elaborate: I think you are much better off, whether as a team or solo developer, developing small, isolated, and tested / reliable libraries and / or packages that can be combined as needed. Ideally, each package or library can build, test, and ship itself at the CI/CD level. Trying to encapsulate all that into one giant conglomerate of potentially different languages, file types, frameworks and much more sounds exactly what it is: a mess!	fullstackchris	8.625156	8.978474	comment	4.0	14.0	1673565306	13.830833
34362129	Could it be that submodules are unde	Could it be that submodules are underused?	solarkraft	8.620163	9.002168	comment	4.0	20.0	1673568228	-12.003826
34364770	I strongly prefer the simplicity of 	I strongly prefer the simplicity of a monorepo, but I once worked on a project that used three repos, and kept them in sync by having IntelliJ keep the branches in sync. Make a new branch, and you make it in all three branches simultaneously. Switch branch, and you switch in all three. That made it very convenient.The project I'm currently working on just switched from polyrepo to monorepo. Interestingly, front and back end were in a single repo, but there was another repo with a bunch of definitions and datatypes, and a third with a frontend component library that was meant to be shared with another team, but that never happened. And that just made development really awkward.I think polyrepo only makes sense if you actually have multiple teams with clearly separated responsibilities. But 	mcv	8.631922	8.989498	comment	4.0	14.0	1673593441	13.847968
34767826	You don't need google scale tooling 	"You don't need google scale tooling to work with a mono repo until you are actually at google scale. Gluing together a bunch of separate repos isn't exactly free either. See, for example, the complicated disaster Amazon has with brazil.In the limit, there are only two options:  1. All code lives one repo
  2. Every function/class/entity lives in its own repo

with a third state in between  3. You accept code duplication

This compromise state where some code duplication is (maybe implicitly) acceptable is what most people have in mind with a poly-repo.The problem though is that (3) is not a stable equilibrium.
Most engineers have such a kneejerk reaction against code duplication that (3) is practically untenable. Even if your engineers are more reasonable, (3) style compromise means they c"	patrick451	8.631749	8.9904585	comment	4.0	12.0	1676240991	13.846779
34768936	Effort to update something is high b	Effort to update something is high because there's a lot of code, not because it's in a monorepo.  Updating the same code scattered across multiple repositories takes as much work in the best case.  More realistically, some copy of the same code will stay unupdated because the cost to track down every repository in the company is too much.	yongjik	8.632906	8.989332	comment	4.0	32.0	1676250151	13.849948
34768415	> There's no requirement to have sin	> There's no requirement to have single versions of dependencies in a monorepo. Google allows[0] multiple versions of third-party dependencies such as jQuery or MySQL, and internal code is expected to specify which version it depends on.Sure, but this is unsustainable. If service Foo depends on myjslib v3.0.0, but service Bar needs to pull in myjslib v3.1.0, in order to make sure Foo is entirely unchanged, you'd have to add a new dependency @myjslib_v3_1_0 used only by Bar. After two years you'd have 10 unique dependencies for 10 versions of myjslib in the monorepo.At this point you've basically replicated the dependency semantics of a multi-repo world to a monorepo, with extra cruft. This problem is already implicitly solved in a multi-repo world because each service simply declares its o	lopkeny12ko	8.632599	8.989981	comment	4.0	27.0	1676245277	13.84732
34886598	IMHO, if you're targeting the Javasc	IMHO, if you're targeting the Javascript ecosystem, this area is already fairly crowded, with Turborepo, Nx and various open source tools providing various degrees of functionality (Bazel, Pants, Lerna, etc) already competing in the space.I'm a tech lead for the web monorepo at Uber. We talked to the Turborepo guy a few years ago, and he admitted that he wasn't sure if it could handle our scale in terms of all the bells and whistles that a repo of our size leverages - and his is one of the more feature packed commercial offerings in this space.As a random example: we see thousands of commits a week, so invalidating the whole build graph when the lockfile changes is a complete non-starter, yet most turn-key solutions target small teams and are not equipped to cope with this problem. Phantom	lhorie	8.637122	8.983557	comment	4.0	29.0	1677011140	-9.466973
35007822	The fact some developers hate them i	The fact some developers hate them is reason alone to never use them. Using them means you don't care about developer productivity.You will incur thousands or tens of thousands of dollars in additional costs by using submodules, via wasted developer time.	0xy	8.621866	9.000445	comment	4.0	14.0	1677838809	-11.990192
35007662	How about using gitsubrepo ? https:/	How about using gitsubrepo ? https://github.com/ingydotnet/git-subrepo>This command is an improvement from git-submodule and git-subtree; two other git commands with similar goals, but various problems.	sligor	8.617408	9.004629	comment	4.0	12.0	1677837217	-12.009448
35008240	For avoidance of confusion, a submod	For avoidance of confusion, a submodule is just:- committing a commit hash from a foreign repository in a text file (.gitmodules), along with- some convenience tooling to check out that repository's tree at that commit in a subdirectory.It is useful exactly when you want both of those things at once. Wanting the first is common enough, it's wanting the second that's more rare.For example, you wouldn't submodule a Rust dependency, because you get what you want by committing the hash to a text file (Cargo.toml), and tooling to check it out in a subdirectory of your project gets you nothing.I think the error the Git project made with submodules is trying to make them transparent, i.e., allowing you to use Git inside the submodule checkout. This is basically never a good idea; it is understand	juped	8.618164	9.003995	comment	4.0	24.0	1677843296	-11.997234
35008399	>  This is basically never a good id	>  This is basically never a good ideaI find this to be one of the most useful features of git submodules. I can easily just cd into the module and do whatever related work I need to do there and then commit to both projects when I'm ready.	michaelmior	8.616643	9.005506	comment	4.0	16.0	1677844830	-12.004953
17354558	That repo encourages mindless microo	That repo encourages mindless microoptimization. Don't waste your time worrying how to iterate a slice. Most of the time it makes no difference.	lmb	8.635022	8.960659	comment	5.0	15.0	1529496404	-11.917713
17606028	But what are the alternatives to the	But what are the alternatives to the monorepo in git?All the ways of splitting code up and deploying multiple git repos for one project seem terrible.	acomjean	8.631217	8.991443	comment	5.0	45.0	1532478454	13.844647
17606236	We moved to a monorepo about 2 years	We moved to a monorepo about 2 years ago and it has been nothing but success for us.We have quite a few projects but only 4 major applications. Maybe it is that a few of our projects intertwine a bit so making spanning changes in separate repositories was a pain. Doing separate PRs, etc. Now changes are more atomic. Our entire infrastructure can be brought up in development with a single docker-compose file and all development apps are communicating with each other. I don't think we've had any issues that I can recall.We are a reasonably small team though, so maybe that is part of it.	adamrt	8.631349	8.988633	comment	5.0	28.0	1532481189	-13.340588
19795967	Hmm, if you're working on a single p	Hmm, if you're working on a single product (like the author is), then of course it makes sense to stick them in the same repository. But isn't this just common sense?I mean, if you have a single product split over many repositories then you will run into the issues mentioned by the author: A change will invariably involve multiple repositories. Again, to me this seems to be just an indication that you are, in fact, working on a single product.	royjacobs	8.631397	8.967575	comment	5.0	24.0	1556707964	13.814792
19796416	These benefits do exist, but drawbac	"These benefits do exist, but drawbacks still exist too. The ""constantly updating, constantly recompiling"" problem can get pretty bad when there are many developers. Developers either lose time recompiling more than they should need to, or keep working in out-of-date trees and dealing with trickier merges. Multiply by the number of developers in a large org, and that can be a lot of lost productivity.The thing I don't see discussed often enough, in all of the ""monorepos are good/bad"" debates, is that they require a certain discipline. When one commit can span multiple components, it's easy to add or ignore bad coupling between those components. That contributes to the rebuild treadmill for everyone, and is bad design in a bunch of other ways as well. IDEs make it worse, because they obscure"	notacoward	8.632506	8.990885	comment	5.0	39.0	1556713481	13.848713
33602655	I'm going to channel the efficient m	I'm going to channel the efficient market hypothesis (I apologize) here and say that people have done that cost comparison and not one of them bought mainframes. Heck, Google ported their entire monorepo to Power but not to z.	wmf	8.6389065	8.968554	comment	5.0	22.0	1668467085	13.833037
27580534	Yes. Especiallygit init --submodule 	"Yes. Especiallygit init --submodule --recursiveOr is itgit submodule --init --recursive?God I hate this UX so much I usually have a ./fetch-subrepos.sh that runs a bunch of ""git clone"" commands.And if I push without first pulling, must it always punish me with a merge commit? Can't I say ""oh shit I don't want to do this, go back and git pull""?"	dheera	8.617087	9.005115	comment	5.0	45.0	1624291626	-12.041102
27763039	Having hundreds of developers work o	Having hundreds of developers work on the same code repository seems insanely complicated. What are the advantages? Where can I read more about monorepos?	prionassembly	8.631766	8.992763	comment	5.0	23.0	1625675881	13.841273
27789260	I can imagine a big company with a m	I can imagine a big company with a monorepo (i.e. Google) reaching that number in a few years.	988747	8.640415	8.967201	comment	5.0	29.0	1625869966	2.8363185
27789316	Generously, there are about 40,000 p	Generously, there are about 40,000 people at Google who might commit to the monorepo. That's only 6,000 or so commits per person, a fairly achievable number. Although since they're not purposely generating every shorthash, it would take significantly longer for the absolute last unique hash to be created.	whatshisface	8.632553	8.988439	comment	5.0	21.0	1625870367	13.8455105
27845135	disclaimer: I haven't seen for mysel	disclaimer: I haven't seen for myself what benefits monorepos actually provide so I don't fully grok them.This is the kind of talk about monorepos that makes me think they are a bad idea. Why would someone want to maintain a monorepo and then pretend it's not a monorepo? Not only just pretend it isn't, but invest not-insignificant time on the problem of pretending it's not a monorepo?I am immediately thinking of the horribleness of how some of the (older) javascript frameworks re-invented the back button (and browser history in general) instead of.. ya know, using the browser.	Jenk	8.633878	8.991444	comment	5.0	23.0	1626359251	13.848798
27846281	IANAMU (I Am Not A Monorepo User), b	IANAMU (I Am Not A Monorepo User), but as far as I understand monorepos and their advantages, I'm not sure what the use-case for this tooling is.Most of the time, when an org chooses to move to having a monorepo (rather than just being left with one by accident of history), the key advantage they're striving to attain, is the ability to make changes to cross-cutting concerns across many distinct applications/libraries, with single commits/PRs. To change an API, and all of its internal callers, atomically, without having to worry about symbolically binding the two together with dependency version constraint resolution.Which is to say, the key advantage of a monorepo comes from having the whole monorepo checked out locally.	derefr	8.63228	8.991311	comment	5.0	36.0	1626365052	13.846088
23181077	The article says that monorepos are 	"The article says that monorepos are more efficient but also that ""As the monorepo grew, the build target list increased to a point where it became too long to pass it through Bazel’s command line interface."".Monorepos are not efficient. They are easier to manage when a team is small but as the team grows and you have more and more deliverables with separate versioning you are introducing control structures in your automation. Complexity explodes!Anyway, all this does matter if you don't make any profit :)"	agounaris	8.648321	9.004416	comment	5.0	19.0	1589471921	13.843209
26480883	Semi-related: when people talk about	Semi-related: when people talk about monorepos, is it implied that all the project has only one version number? Why not just version subprojects of the monorepo, that way you have a small vetting process when cutting a release of a specific subproject. The rest of the subprojects that depend on it can read the release notes for breaking changes, etc.	lalos	8.63276	8.991231	comment	5.0	16.0	1615919448	13.851394
26614650	What do people think of git subtrees	What do people think of git subtrees?https://codewinsarguments.co/2016/05/01/git-submodules-vs-gi...Or the non-standard git-subrepo?https://github.com/ingydotnet/git-subrepo	skyfaller	8.61778	9.003468	comment	5.0	21.0	1616966041	-12.005685
26614824	I've been the git fixer for a few di	I've been the git fixer for a few different teams. I want to like submodules, but there's something that doesn't fit my brain the way the rest of git does. It feels half-baked. I think we're still missing the best way to model the problem as a tree of related states.	erik_seaberg	8.617394	9.003652	comment	5.0	17.0	1616967098	-11.984735
27009109	Very well written post and upstream 	Very well written post and upstream work is always appreciated.I also really like monorepos, but Git and GitHub really don't work well at all for them.On the Git side there is no way to clone only parts of a repo or to limit access by user. All the Git tooling out there, from CLI to the various IDE integrations, are all very ill adjusted to a huge repo with lots of unrelated commits.On the Github side there is no separation between the different parts of a monorepo in the UI (issues, prs, CI), the workflows, or the permission system. Sure, you can hack something together with labels and custom bots, but it always feels like a hack.Using Git(hub) for monorepos is really painful in my experience.There is a reason why Google, Facebook et all have heaps of custom tooling.	the_duke	8.63257	8.989323	comment	5.0	35.0	1619897524	13.84302
14976140	Especially in a world where GVFS is 	"Especially in a world where GVFS is a thing (not quite yet), I fail to see the advantage of a monotree over a monorepo with lots of branches and scripting around a MAINTAINERS file.What's wrong with branches and folders? Why are upstream repositories needed? (My hunch is the answer is just ""it's slow with that much code"" to which I again say ""not when GVFS is ready"").Not to say Linux should change their ways, just that I wouldn't adopt them as part of a company."	rattray	8.631922	8.989047	comment	5.0	19.0	1502336446	13.840919
28940487	Like versioning services, deployment	Like versioning services, deployment of the code base, breaking out new microservices, transitioning to any container based deployment solution. Monorepos aren’t just a nightmare for release management, they’re a nightmare for any sort of single responsibility oriented architecture. I’m really exhausted of “senior devs” that believe they’re architects championing monorepos just because they’re too lazy to change minor versions in a repo.	randmeerkat	8.6325445	8.989369	comment	5.0	28.0	1634792484	-13.762663
28940384	You lost me at monorepo. That might 	You lost me at monorepo. That might work at a very small scale, but past that monorepos create more problems than they solve.	randmeerkat	8.632355	8.987874	comment	5.0	38.0	1634791647	13.845218
23432138	How do you achieve this technically?	How do you achieve this technically? Monorepo would be a pain to break.Or just break up Google into two but let both of them keep the access to the same repo? Then what would this achieve?	kediz	8.632369	8.989345	comment	5.0	17.0	1591382161	13.848876
30946127	Any suggestions for how to go from m	Any suggestions for how to go from multiple Git repos to a monorepo? Preserving history would be really nice. I've looked at submodules and subtrees and both seem to have huge downsides and don't deliver the same benefits of a true monorepo.	liminal	8.631934	8.990432	comment	5.0	17.0	1649346564	13.843467
30946614	I know some of the FAANGs do monorep	I know some of the FAANGs do monorepo (Google being the biggest) but AWS does not.A monorepo is an organizational mess when trying to manage and transfer ownership across thousands of teams, contain the blast radius of changes, unless you invest a ton of resources into  proprietary tooling that requires a bunch of maintenance, since all the open source solutions are terrible at this and the whole data model is built around splitting out individual project repositories. And then after all that effort, why wouldn’t you just use tooling the way it was intended, and the way it’s used in the open source model, so you can partition your CI/CD without a bunch of hacks, and don’t run into bizarre scaling issues with your VCS.It perplexes me people advocate for this strategy. All I can think is it’	oceanplexian	8.632367	8.989187	comment	5.0	31.0	1649348533	13.845977
30946741	Honestly I would 100% do a monorepo 	Honestly I would 100% do a monorepo every single time if there was good tooling for incrementally building and testing libraries. Having to rebuild every image from scratch for every single change scales miserably. Things like Bazel exist, but you basically have to have a team dedicated to operating it (maybe the difficulty varies by language, but it was a major pain when I tried to use it to build some relatively simple Python projects a few years ago).	throwaway894345	8.675834	9.028315	comment	5.0	23.0	1649348981	13.794307
30959291	Well done and congrats to the Turbor	Well done and congrats to the Turborepo team on the launch as well as the Vercel merger, which I think is a great thing for the JS ecosystem!We now have a healthy competition between several JS domain-specific build tools bit.dev, Nx, Turborepo, and Rush. This is in addition to plugins to general purpose monorepo tooling like rules_nodejs (Bazel). I'm looking forward to the seeing the new ideas that come out from the community as this field matures.However, I feel a bit sad at the state of general purpose build tools (Bazel/Pants/Buck, make, GitHub Actions, Maven, Nix) or cloud-based IDEs (Cloud9, Codespaces). These tools come off as too complex to operate and build on top of such that we, the JS community, seem to be choosing to build JS-specific tooling from scratch instead. There are a 	steven-xu	8.652387	8.988473	comment	5.0	28.0	1649435784	13.7941675
31260124	I generally agree, but two things I'	I generally agree, but two things I'd like to point out.If you're using python for the web you're already part of the complexity problem, atleast from the perspective of someone deploying php 15 years ago.  I use python for web development, and I love it, but deploying webpages used to be copy an apache config and  ftp/scp your files to some location.   Now we need app servers and reverse proxies, and static files are served differently, and even though I've gotten used to it over the last decade it does't mean it's good.The other thing is that MonoRepos are pushing back against complexity for the sake of complexity. Why create a new repo when a directory will work just fine?  I think a ton of people got repo crazy because their coporate jenkins server only allowed one project per repo,  b	dec0dedab0de	8.632756	8.989236	comment	5.0	37.0	1651671200	-13.808488
31598163	Surprised you haven't heard of or us	Surprised you haven't heard of or used lerna (with yarn workspaces), which is the defacto monorepo setup in JS world. I use it to maintain a bunch of monorepos and works pretty flawlessly.	halfmatthalfcat	8.633759	8.990812	comment	5.0	21.0	1654191909	13.841732
34767675	Monorepos are great... but only if y	"Monorepos are great... but only if you can invest in the tooling scale to handle them, and most companies can't invest in that like Google can.  Hyrum Wright class tooling experts don't grow on trees.A good article to reference when this topic gets raised: 
http://yosefk.com/blog/dont-ask-if-a-monorepo-is-good-for-yo..."	zdw	8.633537	8.986268	comment	5.0	23.0	1676240009	13.84396
34887152	Nx is hot garbage imo. Buggy, overly	Nx is hot garbage imo. Buggy, overly verbose, inflexible, poorly documented, and I'm dubious about their peer review process.If I don't need build caching I'm not using any tool but PNPM and its workspace toolset - that's literally all most people need for a monorepo. I've looked into Turborepo, and its simplicity versus Nx is a strength. However, it's not the taskrunner that I want.I now work in a monorepo where build caching is required, so I'm excited about moon and keeping a watchful eye on the project's progress. From my evaluation so far, it fixes all of my gripes about Nx and I'm keen on it not trying to do too much, while allowing me to make it as flexible and extensible as I need. Extending configs is chefs kiss	andrew_	8.634541	8.985666	comment	5.0	16.0	1677013049	13.8308325
16364164	The catch is the tooling.  If you ha	The catch is the tooling.  If you have the time and resources to make the tooling that is necessary to make it work specifically for your org, than great!But if you don't, then a monorepo will generally slow you down because it will require coordinating changes across a much bigger group of people.Monorepos are great for very small companies with a low communication overhead, and very large companies with the resources to build the tooling to make it work.For everyone in between, I feel that small repos and microservices give the best developer velocity.	jedberg	8.63285	8.987454	comment	5.0	30.0	1518487210	-13.805918
16565299	Mononoke – A Mercurial source contro	Mononoke – A Mercurial source control server designed to support large monorepos	gfortaine	8.630529	8.991534	story	5.0	106.0	1520811088	13.887165
21234785	Monorepo shortcomings 1 and 2 seem l	Monorepo shortcomings 1 and 2 seem like bullshit to me.  Perforce, the popular monorepo at most companies I've worked at, supports access control.  Monorepos do not prevent you from segmenting your code into modules and pushing binary/source packages into source control so that builds can avoid compiling everything(TiVo used to do this, and it worked well when you got the hang of it).I feel like these debates are often fueled by false arguments.  Either way you go, you're going to want to build support tools and processes to tailor your VCS to your local needs.	01100011	8.632339	8.990026	comment	5.0	48.0	1570901677	13.8528385
18813238	Can anyone here explain to me how a 	Can anyone here explain to me how a monorepo like Google or Facebook handles security?If I pull the repo - I have the entire contents of Google or Facebook? Is that right?Surely that lacks the normal security measures around what must be highly sensitive information, so there must be more to it than I know of?	laurencei	8.6325245	8.989126	comment	5.0	19.0	1546496161	13.848037
18813417	You can't split monorepos after the 	You can't split monorepos after the fact, at least not without immense costs. You can always just put all your small repos into a big one.	adrianN	8.63138	8.98922	comment	5.0	43.0	1546499009	13.852604
18815380	I think this article is complete hor	I think this article is complete horseshit. A monorepo will serve you 99% of the time until you hit a certain level of scale when you get to worry about whether a monorepo or a polyrepo is actually material. Most cases are never going to get there. Before that point, a polyrepo is purely a distraction and makes synchronous deployment really painful. We had to migrate a polyrepo to a monorepo and it was not fun because it was a migration that should have never had to be done in the first place. Articles like this are fundamentally irresponsible.	yowlingcat	8.632713	8.989899	comment	5.0	48.0	1546526516	13.849635
18815893	I work on CI/CD systems, and that’s 	I work on CI/CD systems, and that’s one thing that definitely gets harder in a monorepo.So you made a commit.  What artifacts change as a result?  What do you need to rebuild, retest, and redeploy?  It doesn’t take a large amount of scale to make rebuilding and retesting everything impossible.  In a poly repo world, the repository is generally the unit of building and deployment.  In monorepo it gets more messy.For instance, one perceived benefit of a monorepo is it removes the need for explicit versioning between libraries and the code that uses them, since they’re all versioned together.But now, if someone changes the library, you need to have a way to find all of its usages, and retest those to make sure the changed didn’t break their use.  So there’s a dependency tree of components som	thanatos_dem	8.632815	8.989991	comment	5.0	19.0	1546530151	13.845932
18824590	People who like multirepos are alway	People who like multirepos are always saying how easy it is to pin dependencies but like you I haven’t seen anyone doing it right since I left Google. The monorepo third-party system works well in practice.Ps thanks for getting scipy into third_party all those years ago.	shereadsthenews	8.63274	8.990512	comment	5.0	29.0	1546615380	13.847197
18855923	In my case, I'm struggling to find g	In my case, I'm struggling to find good tooling to support monorepos. We're running a microservice architecture, but our CI is triggered by GitHub web hooks. Currently we're either doing a full build of everything on each webhook event or we're doing some error-prone git-diffing to try to make sure we're only rebuilding when necessary. I've looked at tools like Buck and Bazel, but they seem really heavy for our ~30 person engineering team and they also seem to have odd ways of doing things (no support for pulling from a package repository, vendoring is assumed to be vendored--which incidentally the author of this blog post characterizes as a Bad Thing). Folks who are using monorepos successfully--what tooling do you use to solve these problems?	weberc2	8.633694	8.990116	comment	5.0	19.0	1546959905	13.830006
24971288	My Thoughts on Monorepo	My Thoughts on Monorepo	shekhargulati	8.632317	8.988677	story	5.0	37.0	1604341499	13.847126
31955057	For Lua, just to be safe, I fork all	For Lua, just to be safe, I fork all my dependencies and when I work on a project I add those forked dependencies as git submodules. Just to feel a bit more secure any dependencies never disappear.Not sure if this is good practice.	wsc981	8.617493	9.003498	comment	5.0	22.0	1656724499	-11.9814205
39478610	Since it uses SQLite under the hood,	Since it uses SQLite under the hood, Fossil as a version control system might be able to scale much more gracefully than git for huge monorepos. I think about this often but haven't found a way to effectively use this knowledge yet, since I haven't worked in a giant monorepo shop yet, nor have I found any third parties talking about their experience with this.	hiAndrewQuinn	8.632148	8.987997	comment	6.0	24.0	1708680269	13.830619
19531938	Editors need to be able to support o	Editors need to be able to support our very unique way of storing code (monorepo).	ilovecaching	8.633088	8.984406	comment	6.0	23.0	1553980879	13.848476
15890440	Large-scale refactorings are actuall	Large-scale refactorings are actually pleasant.My team owns a framework and set of libraries that are widely used within the Google monorepo.  We confidently forward-update user code and prune deprecated APIs with relative ease — with benefits of doing it staged or all-at-once atomically.It's imperfect, but maintenance in distributed repositories is infinitely worse.  Still, I remember the earlier days of the monorepo and keeping Perforce client file maps; that was a pain!  https://www.perforce.com/perforce/r15.1/manuals/dvcs/_specif...	matttproud	8.632651	8.98969	comment	6.0	46.0	1512891887	13.838034
15891299	Must have: Tooling that can interact	Must have: Tooling that can interact on a file or sub directory level. Git cannot do that.Should have: Access control to view and change file on a subdirectory basis. Everyone can see the repo so you can't permissions users per repo anymore. It's optional but these companies have that.Recommended: Global search tools, global refactoring tools, global linting that can identify file types automatically and apply sane rules, unit test checks and on commit checks available out of the box for everything and that run remotely quickly, etc...It's regular tooling that every development company should have, but only big companies with mono repos have it.It's not that the tooling is needed to deal with the mono repo, it's that the tools are great and you want them. But they can't be implemented in a	user5994461	8.632575	8.988207	comment	6.0	31.0	1512912897	13.837356
18810604	My problem with polyrepos is that of	My problem with polyrepos is that often organizations end up splitting things too finely, and now I'm unable to make a single commit to introduce a feature because my changes have to live across several repositories. Which makes code review more annoying because you have to tab back and forth to see all the context. It's doubly frustrating when I'm (or my team is) the only people working on those repositories, because now it doesn't feel like it gained any advantages. I know the author addresses this, but I can't imagine projects are typically at the scale they're describing. Certainly it's not my experience.Also I definitely miss the ability to make changes to fundamental (internal) libraries used by every project. It's too much hassle to track down all the uses of a particular function, 	mrgriffin	8.632939	8.988561	comment	6.0	35.0	1546465991	13.84855
18814027	Hilariously misguided.Pretty funny t	"Hilariously misguided.Pretty funny to read that the things I do every day are impossible.Monorepo and tight coupling are orthogonal issues. Limits on coupling come from the build system, not from the source repository.Yes, you should assume there is a sophisticated ""VFS"". What is this ""checkout"" you speak of? I have no time for that. I am too busy grepping the entire code base, which is apparently not possible.If the ""the realities of build/deploy management at scale are largely identical whether using a monorepo or polyrepo"", then why on earth would google invest enormous effort constructing an entire ecosystem around a monorepo? Choices: 1) Google is dumb. 2) Mono and poly are not identical."	rossjudson	8.632664	8.990103	comment	6.0	42.0	1546509642	13.848704
30635888	Monorepos are changing how teams bui	Monorepos are changing how teams build software	gk1	8.633458	8.989202	story	6.0	8.0	1646970137	13.847075
17239313	Makes sense. Google runs a mono-repo	"Makes sense. Google runs a mono-repo. Microsoft ran codeplex[2]. 
Microsoft wanted to be in Github's space but couldn't compete, so bought the space.[1]: https://cacm.acm.org/magazines/2016/7/204032-why-google-stor...[2]:https://en.wikipedia.org/wiki/CodePlex"	maerF0x0	8.633863	8.979806	comment	6.0	25.0	1528216192	-11.7672825
17504357	It seems like splitting into separat	It seems like splitting into separate repos was a rash response to low-value automated tests. If tests don't actually increase confidence in the correctness of the code they're negative value. Maybe they should have deleted or rewritten a bunch of tests instead. Which is what they did in the end anyway.>> A huge point of frustration was that a single broken test caused tests to fail across all destinations. When we wanted to deploy a change, we had to spend time fixing the broken test even if the changes had nothing to do with the initial change. In response to this problem, it was decided to break out the code for each destination into their own reposThey also introduced tech debt and did not responsibly address it. The result was entirely predictable, and they ended up paying back this d	Floegipoky	8.632849	8.986875	comment	6.0	34.0	1531281101	13.842713
17606103	Maybe I'm not cool enough to underst	Maybe I'm not cool enough to understand this, but I don't see the draw for monorepos. Imagine if you're a tool owner, and you want to make a change that presents significant improvements for 99.9% of people, but causes significant problems for 0.1% of your users. In a versioned world, you can release your change as a new version, and allow your users to self-select if/when/how they want to migrate to the new version. But in a monorepo, you have to either trample over the 0.1%, or let the 0.1% hold everyone else hostage.Conversely, imagine if you're using some tools developed by a far off team within the company. Every time the tooling team decides to make a change, it will immediately and irrevocably propagate into your stack, whether you like it or not.If you were at a startup and had a p	whack	8.632856	8.990541	comment	6.0	42.0	1532479329	13.845971
21626047	Git-subtrac: all your Git submodules	Git-subtrac: all your Git submodules in one place	mrzool	8.61674	9.005113	story	6.0	132.0	1574665287	-12.0451355
27906155	This is the reason for monorepos.It'	This is the reason for monorepos.It's not about migrating APIs or coordinating deployments. That's an impossible problem to solve with your repo. It's to update libraries and shared code uniformly and patch dependencies (eg. for vulns) all in one go.Imagine updating Guava 1.0 -> 2.0. Either you require each team to do this independently over the course of several months with no coordination, or in a monorepo, one person can update every single project and service with relative ease.Let's say there's an npm vuln in leftpad 5.0. You can update everything to leftpad 5.0.1 at once and know that everything has been updated. Then you just tell teams to deploy. (Caveat: this doesn't really work as cleanly for a dynamically typed language like javascript, but it's a world wonder in a language like	echelon	8.632457	8.990445	comment	6.0	24.0	1626875093	13.825358
28384169	Monorepos will ruin your life – but 	Monorepos will ruin your life – but they're worth it	tyson-cadenhead	8.635668	8.98331	story	6.0	64.0	1630522755	13.842312
22576236	Has anyone used Git submodules to is	Has anyone used Git submodules to isolate large binary assets into their own repos? Seems like the obvious solution to me. You already get fine-grained control over which submodules you initialize. And, unlike Git LFS, it might be something you’re already using for other reasons.	derefr	8.617629	9.003048	comment	6.0	26.0	1584201620	-12.005851
13621569	Is the practice of shoving all dispa	Is the practice of shoving all disparate pieces of proprietary software (or individual projects) in the same repo a common occurrence?  I have found that pulling unrelated changes just so that I can push my changes is an inconvenience.  Furthermore, tracking the history of a particular project is confounded due to unrelated commits.  I am sure that their vcs (piper?) makes this a feasible task, but for git, it seems like it would suck.The article posted by kyrra, mentions this.Given the value gained from the existing tools Google has built and the many advantages of the monolithic codebase structure, it is clear that moving to more and smaller repositories would not make sense for Google's main repository. The alternative of moving to Git or any other DVCS that would require repository spl	__strisk	8.632716	8.985567	comment	6.0	32.0	1486797716	13.826887
14411502	Really good question. Actually, spli	"Really good question. Actually, splitting Windows up was the first approach we investigated. Full details here: https://www.visualstudio.com/learn/gvfs-design-history/Summary:- Complicates daily life for every engineer- Becomes hard to make cross-cutting changes- Complicates releasing the product- There's a still a core of ""stuff"" that's not easy to tease apart, so at least one of the smaller Windows repos would still have been a similar order of magnitude in most dimensions"	vtbassmatt	8.632389	8.978856	comment	6.0	57.0	1495645198	13.789645
30946116	It's very simple: with a monorepo yo	It's very simple: with a monorepo you always have access to everything you need, together with a ton of stuff you don't.  Whether or not this is advantageous boils down to whether the cost of not having access to something you need is greater than the cost of having access to a bunch of stuff you don't.  As long as your system is reasonably efficient at letting you select small subsets of everything you could potentially have access to, the cost of having access to a bunch of stuff you don't need is essentially zero.  Perforce is good at that.  Git isn't.  So people who use Perforce tend to think that monorepos are good and people who use git don't.  And they're both right.	lisper	8.631666	8.983716	comment	6.0	39.0	1649346493	13.820385
31597057	What is the beneficial distinction b	What is the beneficial distinction between this and composing the monorepo with git submodules? I have been doing that in my codebase after suffering from all the regrets of attempting to emulate npm package releases of my modules. I feel that utilizing submodules feels more pure and conveys isolation and separation. It feels like I am not grokking something vital about why Monorepos > Repo w/ git submodules.	blorenz	8.623669	8.998237	comment	6.0	25.0	1654187678	-11.989997
31763078	"Right, it's ""I have to send 5 PRs to"	"Right, it's ""I have to send 5 PRs to 5 different repos, get them all cross merged, and then at the end it's wrong anyways so I have to start all over"".Multirepo management is extremely frustrating compared to ""it's all in the same folder""."	rtpg	8.632015	8.987746	comment	6.0	24.0	1655361409	13.791946
31763154	They made a bad design decision 10 y	They made a bad design decision 10 years ago, have been fighting the fallout for years, and will be doing so forever and ever because things will only ever grow.They wrote a blog post on how clever they think all their workarounds are, at least one of which involves sparse-checkout -- which is perilously close to chopping up your monorepo into several, while still pretending monorepo is fine.I feel like somebody's job and/or ego is heavily invested in keeping things as they are, even if it demonstrably does not scale to their needs, and the solution is blindingly obvious to even a casual observer.That is institutional insanity.	the_biot	8.633686	8.989973	comment	6.0	28.0	1655362177	13.843024
36333580	> If done in a company with a monore	> If done in a company with a monorepo I'd be especially interested in hearing moreAre there any big companies left which haven't adopted a monorepo?	aeyes	8.627104	8.976164	comment	6.0	26.0	1686781191	13.869219
29190439	Monorepos create more issues than wh	Monorepos create more issues than what they solve.	speedgoose	8.6335745	8.989564	comment	6.0	23.0	1636651134	13.847921
29190664	> Monorepos are much easier for ever	"> Monorepos are much easier for everyone to use, and are the only natural way to manage code for any project.I strongly disagree with that, but I'll let this blog post explain it better than I can: https://medium.com/@mattklein123/monorepos-please-dont-e9a27...> You keep talking about Google, but a much more famous monorepo is Linux itself.I thought it was fairly well known that monorepos came directly from Google as part of their SRE strategy.  It didn't even come into common usage until around 2017 (according to wikipedia).  If I'm remembering correctly, the SRE book recommends it, and that's why it gained popularity.Also, I don't believe that Linux is a valid interpretation of ""monorepo"".  Linux is a singular product.  You can't build the kernel without all of the parts.A better example"	anon9001	8.632363	8.988112	comment	6.0	22.0	1636652212	13.843271
29191108	The more I've come to rely on techni	The more I've come to rely on techniques like canary testing and opt-in version upgrades the more firmly I believe one of the main motivations for  monorepos is flawed: at any given time there may not be a fact of the matter as to which single version of an app or service is running in an environment.At places I’ve worked when we thought about canary testing we ignored the fact that there were multiple versions of the software running in parallel, we classified it as part of an orchestration process and not a reality about the code or env, but we really did have multiple versions of a service running at once, sometimes for days.Similarly if you’ve got a setup where you can upgrade users/regions/etc piecemeal (opt-in or by other selection criteria) I don’t know how you reflect this in a mon	aranchelk	8.633854	8.988745	comment	6.0	45.0	1636654635	13.84998
34361697	As a big fan of the monorepo approac	As a big fan of the monorepo approach personally, I would say the biggest benefit is being able to always know exactly what state the system was in when a problem occurred.I've worked in large polyrepo environments. By the time you get big enough that you have internal libraries that depend on other internal libraries, debugging becomes too much like solving a murder mystery. In particular, on more than one occasion I had a stacktrace that was impossible with the code that should have been running. A properly-configured monorepo basically makes that problem disappear.This is more of a problem the bigger you are, however.	xmodem	8.632689	8.989931	comment	6.0	62.0	1673565851	13.848583
24874114	Monorepo Is a Bad Idea	Monorepo Is a Bad Idea	treypitt	8.632592	8.989961	story	6.0	8.0	1603486822	13.844473
25001784	Is there demand for this?Most real c	Is there demand for this?Most real complaints about git are around scalability of giant monorepos, and a lot of work has gone into various solutions.The secondary complaints about usability seem to be papered over by popularity, and of course the relevant xkcd: https://xkcd.com/1597/	wocram	8.630418	8.984429	comment	6.0	34.0	1604609223	13.846196
31882920	"Is it just me or most of those ""mono"	"Is it just me or most of those ""monorepo"" articles are about how the company switches to monorepo then just has to fight all the problems that come up with it?Use multiple repos. It doesn't hurt you know. And you can have proper granularityThe costs of monorepo seem to be much higher than just dealing with inter-dependencies. And you can always group projects if it makes sense"	raverbashing	8.62988	8.987623	comment	6.0	20.0	1656242430	13.832141
22020213	Seems like this gets re-posted every	Seems like this gets re-posted every few months.We don't actually have a single repository, although Google3/Piper really is huge and dominant. Android, Chrome, Fuchsia, and myriads of other projects don't exist in the monorepo (well, they are mirrored there) because the tooling and libraries there are really geared towards server deployment, not devices.	cmrdporcupine	8.633152	8.988915	comment	6.0	49.0	1578755414	13.846651
35812377	Another pain with monoliths is that 	Another pain with monoliths is that they can only be deployed if the entire monolith is passing all tests. When you cannot deploy your changes because someone else on an entirely orthogonal team broke something in the monolith which is not related to you it gets old really quick.Large monolithic repos with many independent targets for testing and deployment work the best at huge scales. If you are only a few hundred engineers, monorepo with monolithic deployments and tests work fine.	__turbobrew__	8.632397	8.988094	comment	7.0	40.0	1683185273	13.836405
19353692	Instead, currently, all packages bec	"Instead, currently, all packages become lint-unclean, all maintainers need to read up on what the new thing is, how it might break, whether/how it affects them, manually run some tests, and finally decide to opt in. This causes a lot of overhead and manually executed mechanical changes across packages.I always wondered if Debian/Ubuntu could benefit from a ""monorepo"".  It seems to work for other distributions, e.g. Alpine Linux and Homebrew.https://github.com/alpinelinux/aports/tree/master/mainRight now every Debian package lives in a separate repo, or it doesn't even have to live in a repo at all AFAIK.I think Debian has the most packages because their process is very loose and decoupled (as well as it being one of the oldest distros).  But having tighter integration does help move things"	chubot	8.632877	8.988474	comment	7.0	33.0	1552244800	13.84542
15889543	Google's mono-repo is interesting th	Google's mono-repo is interesting though, in that you can check out individual directories without having to check out the entire repo. It's very different from checking out a bajillion-line git repo.	chias	8.632148	8.986322	comment	7.0	59.0	1512873891	13.847607
15889691	So as someone who previously worked 	So as someone who previously worked for Google and now works for Facebook, it's interesting to see the differences.When people talk about Google's monolithic repo they're talking about Google3. This excludes ChromeOS, Chrome and Android, which ard all Git repos that have their own toolchains. Google3 here consists of several parts:- The source code itself, which is essentially Perforce. This includes code in C++, Java, Python, Javascript, Objective-C, Go and a handful of other minor languages.- SrcFS. This allows you to check out only part of the repo and depend on the rest via read-only links to what you need from the rest.- Blaze. Much like Bazel. This is the system that defines how to build various artifacts. All dependencies are explicit, meaning you can create a true dependency graph 	cletus	8.6345625	8.9839525	comment	7.0	42.0	1512876422	13.845459
16364012	On the other end of the spectrum, a 	"On the other end of the spectrum, a colleague of mine recently told me about when his previous company (big, 100k+ employees) were starting to adopt git, some people seriously considered having a separate repository per file! ""Because then you can just set up your project as using version X of file A and version Y of file B""It's good we now have (at least) Google, Facebook and Microsoft as examples of companies using monorepos. Those are names that carry some weight when thrown into a conversation."	amag	8.6314945	8.98893	comment	7.0	41.0	1518485086	13.846398
17606173	> you’ve just lost your ability to e	> you’ve just lost your ability to easily make breaking changes to the common codeI haven't lost anything, I've gained the ability to make breaking changes because I don't have to update everything that breaks all at once. I don't have to do it at all because that's the job of the team responsible.With a monorepo what happens when their are 17 projects using the common code and I'm not familiar with 16 of them? Do I have to dive into the code of all 16 and fix them?	flukus	8.632159	8.990169	comment	7.0	32.0	1532480090	13.855217
18812782	Can a monorepo support module- or su	Can a monorepo support module- or subdirectory-level ownership controls?  Or do teams using a monorepo just do without them?Partially answering my own question: SVN, recommended in a prior comment [0], supports path-based authorization [1].  But what about teams using another version control system?[0] https://news.ycombinator.com/item?id=18810313[1] http://svnbook.red-bean.com/en/1.5/svn-book.html#svn.serverc...	Mxtetris	8.632212	8.99009	comment	7.0	24.0	1546489058	2.8733132
30439408	I wish they explained how to merge e	I wish they explained how to merge existing repos into one new (mono)repo while keeping git history. Still haven’t cracked that problem	wdb	8.631218	8.989476	comment	7.0	30.0	1645609383	13.847177
34047785	Can someone explain the rationale be	Can someone explain the rationale behind switching to a monorepo? I just don't get it.Does it mean also having a single unified production environment build?I have been managing a stack composed of 500+ repositories, communicating through webservices, files and ABIs for many years now, and never quite hit much of the issues cited as reasons to switch to monorepos.Having multiple small independent environments for each deployed service is a feature to me. It reduces the surface of bugs and regressions introduced by new dependencies.Not having to update dependencies globally has been a feature as well. It allows to prioritize which environments to migrate first. I found that big bang dependency updates burden is the #1 reason of _not_ updating a dependency, while allowing a per-service depen	Galanwe	8.63348	8.988073	comment	7.0	38.0	1671418452	13.849341
26479865	kind of an aside, but what's the bes	"kind of an aside, but what's the best practice for pushing and building separate projects in a monorepo?say you have a structure like:
  projectA
  projectB
  sharedUtilsEach time you push you might have a build for projectA and projectB but it builds both each time you push to master. Ideally you could use Git to see if anything in projectA or sharedUtils changed to trigger projectA's build and same for projectB, but I'm curious what others are doing."	endisneigh	8.633852	8.991709	comment	7.0	33.0	1615915335	13.840559
26480586	As a few others have mentioned this 	As a few others have mentioned this is something that build systems handle since they understand the dependency graph. For example, Bazel is often used to this end.However... I would strongly advise not going for a monorepo. No, I don't mean something like tensorflow where you have a bunch of related tools and projects in a single repo. I mean one repo for the entire org where totally unrelated projects live.Every company I've been at that used a monorepo found themselves struggling to make it work since you need a ton of full time engineers just to keep things working and scaling. Many of the problems that monorepos try to solve (simplifying dependency and version management) are traded for 10x as many problems and many of them are hard (incremental builds, dependency resolution).Google h	alfalfasprout	8.632606	8.989634	comment	7.0	22.0	1615918151	13.847726
34768220	  > The single version dependencies 	"  > The single version dependencies are asinine. We are migrating to
  > a monorepo at work, and someone bumped the version of an open
  > source JS package that introduced a regression.

There's no requirement to have single versions of dependencies in a monorepo. Google allows[0] multiple versions of third-party dependencies such as jQuery or MySQL, and internal code is expected to specify which version it depends on.  > It encourages poor API contracts because it lets anyone import any
  > code in any service arbitrarily.

Not true at Google, and I would argue that if you have a repository that allows arbitrary cross-module dependencies then it's not really a monorepo. It's just an extremely large single-project repo with poor structure. The defining feature of a monorepo is that it con"	jmillikin	8.634245	8.988374	comment	7.0	45.0	1676243790	13.844533
31007803	It’s interesting that they prefer  t	It’s interesting that they prefer  to develop such a tool rather than giving up on the monorepo concept.	speedgoose	8.634203	8.994531	comment	7.0	31.0	1649795051	13.839904
31762908	What's the value of a monorepo if de	What's the value of a monorepo if developers only ever check out a small subset of it? Wouldn't multiple repos allow greater scale without any practical reduction in utility?For example, all the localisation files could live in a separate project (if we accept the need to commit them at all). Some tools would be needed to deal with the inevitable problem that developer working sets would not align with project boundaries, but that seems like an easier job than making git scale while maintaining response times.	urban_winter	8.632694	8.989586	comment	7.0	44.0	1655359749	13.819506
37292494	"How does a ""monorepo"" differ from, s"	"How does a ""monorepo"" differ from, say, using a master project containing many git submodules[1], perhaps recursively? You would probably need a bit of tooling. But the gain is that git commands in the submodules are speedy, and there is only O(logN) commit multiplication to commit the updated commit SHAs up the chain. Think Merkle tree, not single head commit SHA.Eventually, you may get a monstrosity like Android Repo [2] though. And an Android checkout and build is pushing 1TB these days.But there, perhaps, the submodule idea wins again. Replace most of the submodules with prebuilt variants, and have full source + building only for the module of interest.[1] https://git-scm.com/book/en/v2/Git-Tools-Submodules[2] https://source.android.com/docs/setup/download#repo"	avidiax	8.622954	8.997201	comment	7.0	33.0	1693222540	-11.990758
32876866	Monorepo Support	Monorepo Support	bauerpl	8.634018	8.991251	story	8.0	71.0	1663416629	13.847229
31792396	Git submodules are fine and can be r	Git submodules are fine and can be really useful, but they are really hard. I've run into problems like:1. Git clone not cloning submodules. You need `git submodule update` or `git clone --recursive`, I think2. Git submodules being out-of-sync because I forgot to pull them specifically. I'm pretty sure `git submodule update` doesn't always work with this but maybe only when 3)3. Git diff returns something even after I commit, because the submodule has a change. I have to go into the submodule, and either commit / push that as well or revert it. Basically every operation I do on the git main I need to also do on the submodule if I modified files in both4. Fixing merge conflicts and using git in one repo is already hard enough. The team I was working on kept having issues with using the wron	armchairhacker	8.618656	9.002541	comment	8.0	101.0	1655576536	-11.987611
31883168	Monorepos have the big advantage tha	Monorepos have the big advantage that cross-project changes can be made together in one PR.	de_keyboard	8.632801	8.991222	comment	8.0	68.0	1656244726	13.849226
31897920	Are Git submodules really that bad? 	Are Git submodules really that bad? Really? Maybe it's me that haven't yet discovered their true dark side. They're not perfect, but works well for mid-sized projects at least.	vodou	8.618316	9.002642	comment	8.0	29.0	1656351500	-11.998117
14411398	I wonder why Windows is a single rep	I wonder why Windows is a single repository - Why not split it in separate modules? I can imagine tools like Explorer, Internet Explorer/Edge, Notepad, Wordpad, Paint, etc. all can stay in its own repository. I can imagine you can even further split things up, like a kernel, a group of standard drivers, etc. If that is not already the case (separate repos, that is), are the plans to separate it in the future?	tobyhinloopen	8.631209	8.983843	comment	8.0	107.0	1495644524	13.817951
14412933	At Sun Microsystems, Inc., (RIP) we 	"At Sun Microsystems, Inc., (RIP) we have many ""gates"" (repos) that made up Solaris.  Cross-gate development was somewhat more involved, but still not bad.  Basically: you installed the latest build of all of Solaris, then updated the bits from your clones of the gates in question.  Still, a single repo is great if it can scale, and GVFS sounds great!But that's not what I came in to say.I came in to describe the rebase (not merge!) workflow we used at Sun, which I recommend to anyone running a project the size of Solaris (or larger, in the case of Windows), or, really, even to much smaller projects.For single-developer projects, you just rebased onto the latest upstream periodically (and finally just before pushing).For larger projects, the project would run their own upstream that develope"	cryptonector	8.63203	8.985324	comment	8.0	53.0	1495655658	13.831614
14662592	From the arguments I've seen, the to	"From the arguments I've seen, the top highlights of single vs multi repo:Single repo enables company-wide code sharing and refactoring with the least amount of friction. E.g. A programmer can modify ""foobar(x,y,z)"" to ""foobar2(z,y,x)"" and update all the corporate-wide client code that calls it.  This ensures all teams are always using the same code instead of Team A on helperutils_v5.2.3 and Team B on helperutils_v6.1.0 which are incompatible with each other.The biggest downside seems to be slow performance for syncing huge repos.  This was one of the motivations for Microsofts GVFS for git.  It enables sparse downloads.If there are good arguments for multi-repos that are not related to performance which override the benefits of company-wide consistency of code, it would be good to discuss"	jasode	8.632118	8.984379	comment	8.0	39.0	1498738507	13.813611
29190281	This is well written and deserves my	This is well written and deserves my upvote, because sparse-checkout is part of git and knowing how it works is useful.That said, there's absolutely no reason to structure your code in a monorepo.Here's what I think GitHub is doing:1)  Encourage monorepo adoption2)  Build tooling for monorepos3)  Selling tooling to developers stranded in monoreposMicrosoft, which owns GitHub, created the microsoft/git fork linked in the article, and they explain their justification here: https://github.com/microsoft/git#why-is-this-fork-needed> Well, because Git is a distributed version control system, each Git repository has a copy of all files in the entire history. As large repositories, aka monorepos grow, Git can struggle to manage all that data. As Git commands like status and fetch get slower, devel	anon9001	8.632641	8.986851	comment	8.0	70.0	1636650320	13.846326
34362909	For everyone who complains about mon	For everyone who complains about monorepos, remember some of the most forward thinking engineering companies like Google and FB also use monorepos. All the arguments that people make in favor of polyrepo are making so because of lack of strong tooling for monorepos. That's also why Google and FB would not have scaled if they were using GitHub / GitLab but had to build their own. Also Google's original source control was built on top of perforce!	ankitdce	8.63268	8.987692	comment	8.0	34.0	1673574121	13.842153
19693487	facebook, google, airbnb, quora, man	facebook, google, airbnb, quora, many more all use monorepoobviously there are many others who do not use monorepo (amazon comes to mind) but it's reasonable to claim that they are actually widely used and fundamental when used	huac	8.632577	8.988156	comment	8.0	34.0	1555611918	13.8274145
17607262	Is it just me, or are a lot of peopl	Is it just me, or are a lot of people here conflating source control management and dependency management? The two don't have to be combined. For example, if you have Python Project X that depends on Python Project Y, you can either have them A) in different scm repos, with a requirements.txt link to a server that hosts the wheel artifact, B) have them in the same repo and refer to each other from source, or C) have them in the same repository, but still have Project X list its dependency of project Y in a requirements.txt file at a particular version. With the last option, you get the benefit of mono-repo tooling (easier search, versioning, etc) but you can control your own dependencies if you want.edit: I do have one question though, does googles internal tool handle permissions on a gra	jgibson	8.633568	8.985691	comment	8.0	42.0	1532500364	13.841021
18824796	> The monorepo third-party system wo	"> The monorepo third-party system works well in practice.It's worth noting that this is only viable at Google because they don't use git. Git's insistence on every client having a full copy of all history of every file in the repository makes monorepo much more expensive.I see conflicting reports over whether google use Perforce or something proprietary called ""piper""?"	pjc50	8.632471	8.988243	comment	8.0	26.0	1546616807	13.846396
18855857	I’ve never understood the debate bet	I’ve never understood the debate between mono and multi repos. With the right tooling, the line seems to vanish and you just have folders anyway.Each repo may have their own policies and permissions, which is the biggest reason I see to keep them separate, but again the distinction still seems little more than a folder.Am I missing something?	azhenley	8.631657	8.99051	comment	8.0	43.0	1546959407	13.841524
27845573	I've come to learn that git monorepo	I've come to learn that git monorepos are becoming quite popular. What I don't understand is why people are using git for this kind of workflow. It forces you to actively work against git's design goals and implementation. Which then compels the use of several odd workarounds and kludges to kind of seemingly reassemble a half-baked flavor of subversion. Why not just use a tool designed around monorepos and subtrees? I'm genuinely curious. I assume I'm missing something.	im_down_w_otp	8.632078	8.989178	comment	8.0	38.0	1626361406	13.795914
28243034	How far does this have to go before 	How far does this have to go before people realize how ridiculous this is. The Multi-mono-multi-monorepo stage?You don't need a monorepo. It's an anti-pattern that people resort to when their code is a tangled, tightly coupled mess.If the modules are loosely coupled and high cohesion, multiple repos is the ideal approach.The solution to the problem of having to 'constantly update dependencies' is not to bring them all into a single monorepo. The solution is to ensure that these dependencies handle separate concerns and have simple interfaces which allow them to be loosely coupled with the main project logic in such a way that they can be updated independently of each other.If different module dependencies often need to be updated together whenever you add a new feature or fix a bug, it alm	cryptica	8.625506	8.985288	comment	8.0	32.0	1629438212	13.846987
28560639	Monotype acquires Hoefler&Co	Monotype acquires Hoefler&Co	mikedc	8.634335	8.984213	story	8.0	145.0	1631846469	13.887514
22994555	After working on a monorepo and then	After working on a monorepo and then the split up repos for the same codebase, I cannot fathom why somebody would want to take small repos and merge them in a single repo. The mess and complexity just increase.	frollo	8.631907	8.987721	comment	8.0	60.0	1587983389	13.852118
26991505	Scaling monorepo maintenance	Scaling monorepo maintenance	pimterry	8.632764	8.989694	story	8.0	296.0	1619776328	13.841388
19303082	Case Study: Monolithic Repository at	Case Study: Monolithic Repository at Google (2018) [pdf]	svat	8.634498	8.982015	story	9.0	113.0	1551720653	13.848498
18813211	I'm not familiar with how monorepos 	I'm not familiar with how monorepos work in practice, but it seems obvious to me that it's going to complicate everyday tasks.Ready to commit? Whoops, another team made a bunch of commits to their project, and you need to rebase your project before you can commit. (I'm having flashbacks to Clearcase already.)Need to roll back the last two commits you made? Sure, that takes two seconds--oh, wait, another team made multiple commits that got interleaved with yours. Have fun cherry picking the files you want to revert.Of course, I'm apparently a curmodgeon, because as soon as someone starts talking about running a find/replace globally across multiple projects, I want to grab something sharp.	wtracy	8.63249	8.990436	comment	9.0	34.0	1546495666	13.872437
22481176	Don't monorepos solve this? Lets pre	Don't monorepos solve this? Lets presume I'm not a FAANG company (though some of those have monorepos) with a bazillion services, I'm just a startup with say 10 services. At that scale I think its pretty realistic to maintain a monorepo for all 10 services. That way every release only upgrades the version count by one.	dgrin91	8.632829	8.989393	comment	9.0	35.0	1583295686	13.853456
29548592	Ask HN: Monorepo vs. Multi-Repo	Ask HN: Monorepo vs. Multi-Repo	johnnypangs	8.633088	8.985989	story	9.0	18.0	1639460173	-13.81183
34768141	Context: Staff Eng @ Google for 7+ y	Context: Staff Eng @ Google for 7+ years1) This is solved by 2 interlocking concepts: comprehensive tests & pre-submit checks of those tests. Upgrading a version shouldn’t break anything because any breaking changes should be dealt with in the same change as the version bump.2) Google’s monorepo allows for visibility restrictions and publicly-visible build targets are not common & reserved for truly public interfaces & packages.3) “Code churn” is a very uncharitable description of day-to-day maintenance of an active codebase.Google has invested heavily in infrastructural systems to facilitate the maintenance and execution of tests & code at scale. Monorepos are an organizational design choice which may not work for other teams. It does work at Google.	gresrun	8.633857	8.986514	comment	9.0	75.0	1676243210	13.839141
23377012	What is the best and right way to op	What is the best and right way to open-source packages from a company monorepo?	vaughan	8.632447	8.989248	story	10.0	46.0	1591007000	13.846288
30958653	Turborepo 1.2: High-performance buil	Turborepo 1.2: High-performance build system for monorepos	leerob	8.634131	8.989754	story	10.0	157.0	1649432611	13.799013
29188863	Make your monorepo feel small with G	Make your monorepo feel small with Git’s sparse index	CRConrad	8.633995	8.985076	story	10.0	221.0	1636644433	13.828498
34362196	I always find monorepo/polyrepo disc	I always find monorepo/polyrepo discussions tiresome, mostly because people take the limitations of git and existing OSS tooling as a given and project those failings onto whichever paradigm they are arguing against.I'm pretty excited for new OSS source control tools that would hopefully help us move past this discussion. Particularly, Meta's Sapling[0] seems like a pretty exciting step forward, though they've only released a client so far. (MS released its VFS for Git awhile back, but unfortunately now is deprecated.)[0] https://engineering.fb.com/2022/11/15/open-source/sapling-so...	scarmig	8.619168	8.973137	comment	10.0	54.0	1673568644	-11.645766
21568599	"The use case:
A build system runs 10"	"The use case:
A build system runs 100's of compile/test jobs that use the same underlying git repo. The git repo is massive so giving each process its own copy is not practical. Instead each subprocess gets a unique overlay to do it's work. After a subprocess finishes if it has any artifacts that will be used by a later stage of the build they are copied to a ""common"" overlay which will get mounted on top of the original lower file system used in the previous phase. So the system needs to be able to use multiple lower overlays (RO) as it moves through each phase.  After its all over all the data needs to be quickly deleted such that the system is free to perform the next job."	nwellinghoff	8.618742	8.993733	comment	10.0	33.0	1574114695	-11.929256
18811368	My advice is that if components need	My advice is that if components need to release together, then they ought to be in the same repo.  I'd probably go further and say that if you just think components might need to release together then they should go in the same repo, because you can in fact pretty easily manage projects with different release schedules from the same repo if you really need to.On the other hand if you've got a whole bunch of components in different repos which need to release together it suddenly becomes a real pain.If you've got components that will never need to release together, then of course you can stick them in different repositories.  But if you do this and you want to share common code between the repositories then you will need to manage that code with some sort of robust versioning system, and ro	curtis	8.627164	8.984677	comment	10.0	87.0	1546471694	13.800957
28220113	From a Single Repo, to Multi-Repos, 	From a Single Repo, to Multi-Repos, to Monorepo, to Multi-Monorepo	leoloso	8.632439	8.9901905	story	10.0	122.0	1629289168	13.841728
32594915	Best practices for TypeScript monore	Best practices for TypeScript monorepo	iddan	8.634516	8.984749	story	11.0	115.0	1661440948	13.840789
31883018	It seems to me that an easier way to	It seems to me that an easier way to avoid this problem is to not have monorepos in the first place. Uber's architecture is, AFAIK, heavily based on microservices, so I wonder what's the advantage they get in using a monorepo.	hiyer	8.635157	8.9920635	comment	11.0	114.0	1656243293	13.8889065
22078125	Bring your monorepo down to size wit	Bring your monorepo down to size with sparse-checkout	Amorymeltzer	8.632242	8.989691	story	11.0	137.0	1579288741	13.8376875
15890660	I've worked with both a distributed 	I've worked with both a distributed repo model and a monorepo model and vastly prefer the distributed approach (given the right tooling). The trade-offs are complementary and no doubt with proper discipline you can try to maximize the benefits, while minimizing the downside. But here's what I don't like about working in a large monorepo:1) Difficult to track changes to the code I'm interested in. Every day there are hundreds of changes in the repo and almost all of them have nothing to do with what I'm working on.2) all sorts of operations take longer (pulling, grepping source, etc.) to support code I couldn't care less about.3) Frequently have to update the world at once. Unless the repo can store multiple versions of the same module, then all the consumers have to be updated at once, eve	nickm12	8.631337	8.986934	comment	11.0	97.0	1512898187	13.845572
30438579	Everything you need to know about mo	Everything you need to know about monorepos	SerCe	8.632683	8.989031	story	11.0	76.0	1645600930	13.851928
17055919	Git submodules revisited	Git submodules revisited	fanf2	8.617701	9.004035	story	12.0	102.0	1526157782	-11.997902
12736514	I know this is slightly tangental bu	I know this is slightly tangental but I'm always a little shocked that Facebook (and I think Google to some extent) have massive mono repositories.The benefits of having one repository do not seem to be worth the serious performance issues as well as potential coupling that can happen with a gigantic code base as well also making much more difficult to OSS certain parts.e.g. why doesn't FB use dependency management (or binary package management aka maven, npm, etc)? That is have multiple repositories and cut releases. Build tools to help cut and manage the releases and dependency graph of the releases.There are even plugins and shell scripts that will make Mercurial act like a mono repository for many small repositories (I use it for our own Java Maven code base).I must be missing some kil	agentgt	8.631979	8.986261	comment	13.0	67.0	1476810341	13.84502
31924554	Improve Git monorepo performance wit	Improve Git monorepo performance with a file system monitor	chmaynard	8.632071	8.986165	story	13.0	203.0	1656530423	13.814004
23180255	Building Uber’s Go Monorepo with Baz	Building Uber’s Go Monorepo with Bazel	dayanruben	8.698687	9.054283	story	14.0	158.0	1589468007	13.76146
26479127	Improving large monorepo performance	Improving large monorepo performance on GitHub	todsacerdoti	8.634527	8.984821	story	14.0	317.0	1615912620	13.837872
26165445	Here's the lesson I've learned from 	Here's the lesson I've learned from my experience with submodules in git in several different companies: avoid them like the plague. NEVER USE THEM FOR ANYTHING. Use any other solution available to you: use package managers, use monorepos, use subtrees, just copy/paste the files in, avoid the dependency entirely, do ANYTHING it takes to avoid using submodules.They just become a constant source of friction. Basically every action you do in git, there's some tiny bit of annoyance caused by submodules, which adds up to tearing your hair out. Like, read this StackOverflow question and answer, and tell me this is something you want to be dealing with on daily basis (and you will be, you'll regularly be dealing with far worse): https://stackoverflow.com/questions/9314365/git-clean-is-not...The c	OskarS	8.617856	9.004137	comment	15.0	68.0	1613563407	-12.00757
29652451	Ask HN: Mono-Repo or Multi-Repo?	Ask HN: Mono-Repo or Multi-Repo?	niros_valtos	8.631831	8.989751	story	15.0	18.0	1640194399	13.848215
22986303	Monorepoize – Bash scripts for creat	Monorepoize – Bash scripts for creating a monorepo out of smaller repos	deepaksurti	8.632561	8.990193	story	15.0	137.0	1587899684	13.843577
32878240	I don't get the case against monorep	I don't get the case against monorepos, and why it's so polarizing.You can share code without having to stand up infrastructure to host packages and whatnot.You can separate concerns without introducing the infinite complexity of network io, queues etc. This is kind of a dig at microservices I guess, which have their place functionally (decoupled infrastructure, scaled independent of other services).You can still deploy to separate targets, a code repository is not 1:1 with a deploy target, that is a fake constraint that never even existed.Manyrepos ALWAYS end up being second class citizens. Test setup isn't as good as in the monorepo because that means duplicating it N times, and that is obviously wrong.Common patterns are The Same But Different everywhere and/or there is crazy complexity	corytheboyd	8.632199	8.987186	comment	16.0	78.0	1663428183	-13.8204
31882512	We Halved Go Monorepo CI Build Time	We Halved Go Monorepo CI Build Time	kiyanwang	8.63395	8.98873	story	18.0	161.0	1656237667	13.822955
19795482	Benefits of a Monorepo	Benefits of a Monorepo	ingve	8.6329975	8.991455	story	18.0	142.0	1556700215	13.8477745
23480198	Speeding up a Git monorepo	Speeding up a Git monorepo	illuminated	8.6342535	8.987429	story	20.0	147.0	1591812485	13.83171
34767995	There's a lot of love for monorepos 	There's a lot of love for monorepos nowadays, but after more than a decade of writing software, I still strongly believe it is an antipattern.1. The single version dependencies are asinine. We are migrating to a monorepo at work, and someone bumped the version of an open source JS package that introduced a regression. The next deploy took our service down. Monorepos mean loss of isolation of dependencies between services, which is absolutely necessary for the stability of mission-critical business services.2. It encourages poor API contracts because it lets anyone import any code in any service arbitrarily. Shared functionality should be exposed as a standalone library with a clear, well-defined interface boundary. There are entire packaging ecosystems like npmjs and pypi for exactly this 	lopkeny12ko	8.632711	8.987335	comment	20.0	159.0	1676242237	13.845892
21234560	Monorepo or Multirepo? Role-Based Re	Monorepo or Multirepo? Role-Based Repositories	optician_owl	8.632301	8.990663	story	20.0	141.0	1570899662	13.844926
27844363	Josh: Get the advantages of a monore	Josh: Get the advantages of a monorepo with multirepo setups	oftenwrong	8.635159	8.993178	story	20.0	246.0	1626355502	13.843664
17605920	I feel terrible for anyone who sees 	I feel terrible for anyone who sees this and thinks, “ah! I should move to a monorepo!” I’ve seen it several times, and the thing they all seem to overlook is that Google has THOUSANDS of hours of effort put into the tooling for their monorepo. Slapping lots of projects into a single git repo without investing in tooling will not be a pleasant experience.	hobls	8.631683	8.988436	comment	21.0	170.0	1532476990	13.848829
18855660	Monorepos and the Fallacy of Scale	Monorepos and the Fallacy of Scale	loevborg	8.6325	8.991173	story	21.0	104.0	1546957485	13.846694
31596419	Monorepos in JavaScript and TypeScri	Monorepos in JavaScript and TypeScript	rwieruch	8.636566	8.98168	story	22.0	106.0	1654185216	13.844387
12170755	Manul – the madness vendoring utilit	Manul – the madness vendoring utility for Go with Git submodules	kovetskiy	8.588706	9.033134	story	22.0	97.0	1469598227	-12.001615
14662312	We’ll Never Know Whether Monorepos A	We’ll Never Know Whether Monorepos Are Better	kalimatas	8.634174	8.9913	story	23.0	50.0	1498735629	13.850049
27903282	A monorepo misconception – atomic cr	A monorepo misconception – atomic cross-project commits	askl	8.631669	8.991941	story	23.0	102.0	1626851800	13.840989
26164790	Git Submodules: Adding, Using, Remov	Git Submodules: Adding, Using, Removing, Updating (2009)	tigerlily	8.617679	9.0044155	story	24.0	110.0	1613557065	-12.005546
28845570	Monorepos and Forced Migrations	Monorepos and Forced Migrations	zdw	8.632086	8.989823	story	24.0	101.0	1634075932	13.845542
18820258	Monorepo: please do	Monorepo: please do	Soliah	8.634398	8.99154	story	27.0	234.0	1546556792	13.845498
26613473	I Hate Git Submodules	I Hate Git Submodules	Addono	8.617414	9.004962	story	27.0	108.0	1616959967	-12.005462
30664891	Monorepos done right	Monorepos done right	fixel	8.633129	8.98911	story	28.0	141.0	1647200024	13.834419
