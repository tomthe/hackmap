id	label	hovertext	author	x	y	type	relevance	size	year	umap1d
33123249	What’s special about Racket? What ma	What’s special about Racket? What makes it stand out compared to Lisp/SBCL/Scheme?I recall a while back John Carmack tweeted about writing some project in Racket & it’s been vaguely on my radar lately.	rychco	15.33081	-3.710959	comment	3.0	16.0	1665159048	13.651289
33123679	Lisps let you define macros. Racket 	Lisps let you define macros. Racket lets you define languages.https://docs.racket-lang.org/guide/languages.htmlhttps://docs.racket-lang.org/guide/more-hash-lang.htmlExample of a language-in-racket: https://github.com/soegaard/minipascal/tree/master	antipurist	15.356703	-3.6694448	comment	3.0	12.0	1665160780	13.646397
33197015	Forth is still interpreted. Forth's 	Forth is still interpreted. Forth's genius is that it's interpreter is so tiny that it fits as a runtime.	terminalcommand	15.0325165	-3.830714	comment	3.0	40.0	1665698484	6.220543
33318094	I'd hesitate recommend a language wh	"I'd hesitate recommend a language whose symbols are not easily accessible or understandable. Try showing the following snippet to even a seasoned programmer and they'll struggle to understand what it does:    Avg←{(+⌿⍵)÷≢⍵}

Also, if you want a non-programmer to quickly be able to learn a language, the more learning resources they have available to them, the more probable it is that they'll be able to pick it up. APL probably don't have as many modern, free and online resources as other languages."	capableweb	15.565995	-2.6933973	comment	3.0	13.0	1666625798	13.082594
33334159	My experience has involved zero head	My experience has involved zero headachesHow? most libs use reflection.	Scarbutt	15.109438	-3.9263284	comment	3.0	10.0	1666721395	-8.213365
33417611	I'm not a huge fan of the scheme sty	I'm not a huge fan of the scheme style programming languages although pretty standard even in Go templates because the parenthesis end up with ugly syntax that becomes difficult when using multiple levels, but Racket does seem cool. I found their guide on building web apps to be pretty amazing and I think that is what HN uses for their website.	encryptluks2	15.358207	-3.6637187	comment	3.0	18.0	1667283242	13.684835
26667448	Cool! I hope one day Racket will tak	Cool! I hope one day Racket will take off as a serious language for app development.I know it's not really the point of Racket, but it has all the right attributes^, all it needs is a bigger library ecosystem.^: including a package manager & build toolchain, an IDE, nicely-formatted web hosting for docs, runtime is reasonably fast, has plenty of batteries included, has cool stuff like contracts, supports multiple programming paradigms.	nerdponx	15.360418	-3.6639028	comment	3.0	15.0	1617318726	13.652115
26669112	Kind of weird hearing that when we'r	Kind of weird hearing that when we're posting on a website running atop Racket.	giancarlostoro	15.372551	-3.6366174	comment	3.0	12.0	1617339374	13.651323
37680872	I'm a big fan of stack-based languag	I'm a big fan of stack-based languages conceptually, but they always seem to fall flat when it comes to basic reading comprehension. APL has the same issue, as does J. Factor did improve on this a little bit by eschewing the symbol fetish but it was still very difficult to rapidly scan the code for functionality. I'm not convinced the approach shown here is a good pairing with the human brain.	diogenes4	15.539066	-2.7143087	comment	3.0	24.0	1695846791	13.073031
37868502	Rack Attack – Rails Tricks	Rack Attack – Rails Tricks	Alifatisk	15.37414	-3.6284359	story	3.0	16.0	1697188329	13.650496
14726608	The Lisp Works page is kind of cute,	The Lisp Works page is kind of cute, but in bad way as far as marketing goes, at least in my opinion.The IDE screenshots for Windows show off Windows XP.	oblio	15.174527	-3.91531	comment	3.0	17.0	1499539011	-10.451623
14897319	Likewise in Common Lisp, arguably mu	Likewise in Common Lisp, arguably much more easily.	reikonomusha	15.161816	-3.9242363	comment	3.0	12.0	1501552127	-10.478166
15054895	I've been thinking about this for th	I've been thinking about this for the last few years. What would an APL-like language look like with structured data? Is that possible? Could you make a language where you specify if a value is SoA or AoS? Is it possible to automatically convert an AoS-based algorithm to SoA?It really changes how you do basic things like sorting. In the standard AoS approach in C-like languages you swap entire structures around the array. In an SoA approach in APL-like languages you generate a list of indices that would put the data in sorted order then apply it to each column. A number of times I written code to do this in C++ for high-performance systems, and it works great, but is definitely a different way of thinking about things.	jnordwick	15.563117	-2.6996083	comment	3.0	12.0	1503167997	13.049796
15055977	Scheme allows practically infinite p	Scheme allows practically infinite possibility of language extension due to its syntax (this is same with lisp and scheme, but I prefer scheme due to its lexical scoping, a minimal standard like R7RS etc). (Note that I'm a big advocate of Python-C hybrid programming too, and so for me it's either python-and-C or scheme-and-C)Moving towards Scheme-to-C is moving towards solving all performance/concurrency/what-not problems of a high-level-language like Scheme, without having to drop down to a low-level-language like C (or assembly). (I guess I should say that there might be a need for generating code for GPU, e.g., OpenCL. Just a heads up that I'm not trying to ignore that).What I say has to be qualified with two very important assumptions:- I believe 'large-scale programming' is 'research'	fizixer	15.147491	-3.9230602	comment	3.0	15.0	1503181500	-10.446012
15073569	Isn't Racket Scheme? They have an R6	"Isn't Racket Scheme? They have an R6RS language for Racket (http://docs.racket-lang.org/r6rs/Using_R6RS_with_DrRacket.ht...).I don't see how that's ""moving on"" if it's still Scheme."	SwellJoe	15.357136	-3.6619856	comment	3.0	15.0	1503417058	13.651793
15077886	To me, being able to make changes to	To me, being able to make changes to your code while keeping the current state in the REPL is key to interactive development.My workflow is generally to build up state, and then experiment with functions on that state until I get the correct output.This workflow is very natural in Clojure, Common Lisp and even Python (with IPython and autoreload).However, in Racket you have to restart everything on every change. This works ok for smaller applications, but if for example, your state is a large dataset that you pull from a remote database, it becomes a little more difficult.There are possibly workarounds, and I'm not saying that Racket is bad because of this. There are definite advantages to this approach, mainly for keeping everything simple and predictable. However, this was a roadblock fo	mjmein	15.352762	-3.6719646	comment	3.0	14.0	1503452773	13.628186
12553263	What do you mean? Other languages ru	What do you mean? Other languages running on top of the Guile interpreter? Or implementations of Guile in other languages. Why would you want to run Guile if you don't like Lisp?	chrisseaton	15.180458	-3.8210177	comment	3.0	12.0	1474501639	-10.236293
12657960	For me Picolisp is a very nice Lisp 	For me Picolisp is a very nice Lisp implementation; easy to understand, enthused founder who has been at it since the 80s. Which is amazing in it's own right. And a solid community. Won't go away any time soon. Gambit is the same age, but I find the source code far harder to read. That's a matter of taste I guess.	tluyben2	15.135052	-3.9251924	comment	3.0	16.0	1475811297	-10.385645
12660282	"""If so many ""modern"" languages still"	"""If so many ""modern"" languages still copy features from Lisp (hello C++) then why not use the real thing?""Because if it hasn't ""succeeded"", for suitable definitions of ""succeeded"" in 50 years, as an old fart approaching 40 myself my assumption is that there is a good reason. I was much more willing to believe the ""everybody else is just stupid and can't see the obvious brilliance"" reason when I was younger, but as I've learned more, I've learned just how many factors go into a language being successful. Lisp may have all the features, but there are also good reasons why it has never really quite taken off.That said, it is also true that using languages that bodge Lisp-like features on to the side after several decades of usage is generally inferior to languages that start with them. It's o"	jerf	15.160669	-3.924612	comment	3.0	13.0	1475845339	-10.420762
12804330	Do you use Racket? If yes, tell us m	Do you use Racket? If yes, tell us more about your experience with it.	vasili111	15.369785	-3.6423202	comment	3.0	13.0	1477569288	13.647596
27517530	This might not mean what you'd expec	This might not mean what you'd expect at a glance. The agreement here seems to be that IBM has sold all relevant IP for APL2[0] to Log-On Software[1], which will now be offering essentially the same product and some level of support.For some time now APL2 has only barely been under active development, so it's not clear whether this will lead to more or less effort to develop the product. First released in 1984, APL2 is now far from the leading edge of APL development. For example, APLs began adding control structures to free programmers from using Branch (Goto) for control flow in the mid-1990s (late, I know!). APL2 still doesn't have them. Dyalog (my former employer) is pretty clearly the front-runner for commercial APL at this point; APL+Win also sees some level of development and NARS20	mlochbaum	15.565308	-2.686681	comment	3.0	19.0	1623773569	13.088685
27532835	>No one is out to ruin Felleisen's c	">No one is out to ruin Felleisen's career, he will be fine no matter whatI mean, why do you assume that? I don't know the Racket community, but if he is ""the self-styled leader of the Racket project"" being potentially forced to step down/ousted seems like it would very much impact him personally."	ImprobableTruth	15.366868	-3.6154692	comment	3.0	12.0	1623873784	13.660259
27604145	Terrible suggestion. We need to kill	Terrible suggestion. We need to kill all these c'isms as fast as possible. Teach people to write nice data-structures, with good api's, and with generic and sensible types. All these C'isms like returning -1 for false and 'nil' children seriously sucks. For a systems class it might still be suitable, but you could design good courses around other languages like ada, zig, rust w/e.If you want to teach them a lisp as a first language, at least use Racket, which actually have modules designed for education. I think it's less of a headache to use a language with a more modern syntax, like python or pyret, but Racket is excellent of course. You can introduce lisp later in a undergraduate compiler/interpreter class so you don't have to talk about parsing for a month.	ogintherapgame	15.294879	-3.7253935	comment	3.0	12.0	1624453867	13.687721
27772253	I missed the first part, but will ch	"I missed the first part, but will check it out. I'm on sick leave and can't do anything anyway.My main question so far is: Can you make use of the speed of Array-based languages, but save computation time, by compiling it into a solution-graph-assembly? Sorry, if my wording is to amateurish.EDIT:
What's the difference between symbolic computation, graph computation and array-based symbolic computation? I mean they have different internal representations due to semantics, but look alike mostly.Would it be possible to ""generate"" an ""optimal"" internal structure for an array-based symbolic language like APL, based on the input?"	ALLTaken	15.557536	-2.702355	comment	3.0	10.0	1625753979	13.038631
27827768	Probably not.  I've heard of it, nev	Probably not.  I've heard of it, never looked too in depth.As mentioned I've become a fan of Scheme.  The definitive text for learning it is probably SICP, in which Sussman and Ableson call programming a form of magic - calling out certain incantations, knowing their meaning, use, and producing data manipulation from them.  I find this accurate, but as an English speaker, I think I just prefer the Latin Vulgate versions, and not the runespeak of the forgotten gods.  I guess maybe I was a bit harsh to say there is no use case.  Perhaps there is, for someone with a deeper cognitive and memorization pool than I.  For me, though, interpreting such an incantation would be the equivalent of breaking down each operation into it's C-like forms.  If it were broken down for me on the screen, I could	desine	15.561906	-2.6932163	comment	3.0	10.0	1626221307	12.977594
35312681	That’s a strange way to spell libera	That’s a strange way to spell liberate.	midasuni	15.139184	-3.889862	comment	3.0	13.0	1679823469	-10.357568
35370450	"> What I mean by ""readable"" is, that"	"> What I mean by ""readable"" is, that it uses ASCII strings and actual names, not merely 1 characterI urge you to reconsider: That they are 1-character is an extremely important feature of Iverson's work.> instead of symbols, of which I do not know their namesWhy do we write 5+5 and not five plus five? The symbols are important! Gosh, can you even remember not knowing how to do addition? Don't you remember how much easier adding things up became once you learned ""+""?Most of Iverson's ideas for symbols really good -- so good that if you do learn their names and everything about them you will have the most amazing ideas as significant a change in you as learning ""+""> I should not need a special keyboard or special keyboard layout to write programs in the language.You don't need anything of th"	geocar	15.558172	-2.6979165	comment	3.0	27.0	1680171460	13.081226
22341828	See also APL, which was designed as 	See also APL, which was designed as a concise algorithmic notation first and only adopted as an actual language afterwards. (Hence the use of custom symbols)Although unlike this notation, APL is more typewriter-optimized; many symbols are made by double-striking two other more basic symbols, and the typesetting is simple and linear - it clearly doesn't take advantage of the full expressive power of handwriting. (Plus, its array-based programming flow, while extremely powerful, is very different from the way most people write algorithms these days)	MrEldritch	15.563608	-2.6936224	comment	3.0	10.0	1581865454	13.096812
22382648	Racket is not like other languages.R	"Racket is not like other languages.Racket is a language with first class support for building languages on top of it. And so no, Rhombus does not need to be a ""successor"" to Racket. It does not need to ""replace"" Racket. It will have all the current Racket goodness to begin with, because all of its semantics will come from Racket - they will be the same language. Nor will it steal valuable developer attention - a bug fixed in Rhombus is a bug fixed in Racket, anywhere except the syntax parser. They will share all core libraries. The whole point of Racket is that #langs are mutually compatible. And the stress test of using Racket in earnest for what it is actually designed for will make Racket better, not worse.Consider PyonR [0]. This is a similar and yet much more ambitious goal than Rhomb"	dTal	15.353634	-3.6715434	comment	3.0	14.0	1582288981	13.638159
22449159	k, J & APL, in roughly that order.	k, J & APL, in roughly that order.	kick	15.562141	-2.696074	comment	3.0	17.0	1582955488	13.035715
22523837	People are so quick to reject K and 	People are so quick to reject K and APL-style languages for superficial reasons that they never get to the deep and interesting reasons!  I am mostly familiar with APL, but I think the things I appreciate and dislike are about the same in K.One interesting philosophical difference, at least among some APL programmers, is that building abstractions should be avoided.  TFA has a hint of that philosophy, in its suggestion that perhaps naming (the root of abstraction) hinders clarity.  I think this is definitely worth considering, and it doesn't really have anything to do with the (supposedly) cryptic syntax.One reason I don't like K/APL-ish vector programming is performance.  I once spent some time working with others on a GPU-targeting APL compiler, and I found that some common programming p	Athas	15.561715	-2.6979315	comment	3.0	10.0	1583742195	13.064687
22566965	> What interpreters such as GNU APL 	"> What interpreters such as GNU APL does is to first evaluate b+c, resulting in a new array, and then add that result to a.Is this really what most implementations would do? I'd assume it would parse the expression `a+b+c` into a tree like     +
    / \
   a   +
      / \
     b   c

But then run a pass on the tree to identify expressions like this that could be fused together without creating intermediate results. I know that most APL implementations have more efficient implementations of certain idioms (commonly-used sequences of operators/functions), so I figured they must be doing something like this to be able to identify those idioms.This is just conjecture though, I'd love to know more about how this actually works in practice."	ssfrr	15.560323	-2.6982067	comment	3.0	11.0	1584105107	13.070801
22630934	So this:> {.+(k;({x@&~_n~/:x}x@')'k:	So this:> {.+(k;({x@&~_n~/:x}x@')'k:?,/!:'x)}Turns a list of dictionaries to a dictionary of lists. It is clearly amazingly expressive as you can do so much in just half a line of code.However, for someone not used to APL, this is utterly and totally unreadable. I can pick pretty much any ML derivative, C-style or lisp language and make heads and tails of most code, but with the above line I don't even know where to start. Might as well be hieroglyphs :)	short_sells_poo	15.559606	-2.708192	comment	3.0	15.0	1584647327	13.091203
15172183	Therein lies my problem with Forth. 	Therein lies my problem with Forth. Yes there is a ton of power, but that is inaccessible to a lot of users. I know I can look at Jones Forth & MeCrisp, but I honestly couldn't see where to start. I'd like to see a tutorial start with either an assembly or C base and then teach Forth fundamentals such as how to start your dictionary and choose between direct/indirect threading and how to implement each. I'm always curious how so many Forth users got to that stage.Edit: It looks like Snabel is a Forth inspired concatenative language written in C++ with some perl like features. That's pretty cool. If you ever get the chance I think I'd enjoy it if you made some video tutorials explaining the design and some of the code choices.	throwaway7645	15.029283	-3.8223965	comment	3.0	13.0	1504580086	6.0943284
15251144	A real shame that Forth wasn't inclu	A real shame that Forth wasn't included in the tested languages.  Chuck Moore has been an advocate for more energy efficient computation for a while now.	mtm	15.009033	-3.8156083	comment	3.0	18.0	1505414641	-5.9747963
15302390	> you will end up needing something 	> you will end up needing something that is only available for the most popular 5-6 languagesThe thing that is the Special Sauce for Racket is it's macro system. You can build your own language for specific things easily or you can extend Racket with a library also much easier then the other 5-6 languages.Racket really has a chance of being the Python of functional(ish) languages. The ability of the community to produce a great ecosystem  is all right there baked in. http://jeapostrophe.github.io/2013-07-22-123list-post.htmlI also think the documentation is all in one place. The library Scribble makes it simple for everyone to document your macro/library simply and uniformly. I really have high hopes for Racket over the next 5 years.	baldfat	15.35861	-3.6658382	comment	3.0	31.0	1505994456	13.646515
15302462	Racket is interesting, but what turn	"Racket is interesting, but what turns me off about the language is that they decided they needed OO for some things and they... implemented a single dispatch based system.  Why would you limit yourself this way if you don't need to?  Single dispatch systems force you into all kinds of ""power deficiency patterns"" (e.g. all double-dispatch patterns) that just wouldn't be necassary if you do multiple dispatch a la CLOS.  You don't have to re-implement all of CLOS if you don't want but at least use something like generic functions instead of the inferior (and ugly in Racket) single dispatch style."	alien_at_work	15.323748	-3.7084308	comment	3.0	11.0	1505995263	13.646827
15397195	Yes, Chez & Stalin are the fastest i	Yes, Chez & Stalin are the fastest in these benchmarks, which seems to match what the community usually answers when asked about quick implementations.Sadly Stalin is unmaintained. Its whole program optimization techniques were really advanced. I remember it even got my ivory-tower professors, who were big in the static analysis field, excited.Now, a tricky question. I'm mostly unfamiliar with Scheme for writing real-world code. Will the ongoing merger of Chez with Racket make the latter a clear winner in the Scheme camp? How are libraries and FFI?A problem with Scheme is excessive fragmentation. Having a clear winner would be cool for library support. Racket is great due to multiple paradigms and DSLs [1]. I hope it eventually becomes a very practical Lisp with all Mozart/Oz semantic good	nextos	15.164723	-3.914279	comment	3.0	20.0	1507074404	-10.440052
15580782	Dammit, another array language with 	Dammit, another array language with cryptic syntax. It seems to be an unfortunate side effect of APL's custom character set that all languages inspired by it adopt the terse notation, minus the elegant symbology that made it work in the first place.The only array language I've ever found that bucks this tendency is Nial, with the result that it's an extremely fun language to play around in, if impractical due to its ancient interpreter. J claims to have English synonyms for everything, but only as second-class citizens (no working interpreter support). Numpy, sadly, is probably the closest thing.It's a shame because I think it's holding the paradigm back.	dTal	15.54875	-2.7160883	comment	3.0	12.0	1509304029	13.039284
15591046	Racket v6.11	Racket v6.11	nickmain	15.381535	-3.6247325	story	3.0	154.0	1509423197	13.647769
26825283	The reverse operators in APL are ver	The reverse operators in APL are very visually suggestive if you imagine a matrix and mirror it about the centerlines-Reverse around last axis: ⌽Reverse around first axis: ⊖The grade operators (indices by which one could index to sort ascending or descending) are likewise easy to remember-Grade up: ⍋Grade down: ⍒I suspect that the reason only a handful of APL's notational ideas made it into mainstream mathematics is because few mathematicians felt the need to describe algorithmic processes, and those who did were willing to settle for big sigma/pi, set builder notation, piecewise function notation, or a handwave at ALGOL, Pascal, or whatever else was in vogue at the time.Their loss, I'm afraid.	RodgerTheGreat	15.565644	-2.6924183	comment	3.0	13.0	1618515969	13.07721
26924304	The Evolution of Forth	The Evolution of Forth	tosh	15.040138	-3.802122	story	3.0	95.0	1619266015	6.060806
27038242	"> FORTH ... is almost ""take the pare"	"> FORTH ... is almost ""take the parenthesis out of your LISP program, reverse the order of the tokens, and... it works!""Strictly speaking, FORTH does not have a lambda syntax.  But if you literally ""reverse the order"" of function application (while keeping lambda abstraction the same) in lambda calculus, you get De Bruijn notation which is rather more compelling than the LISP default, and also rather FORTH-like as you note.  (Even moreso if variable names are replaced by De Bruijn indices.)"	zozbot234	15.075452	-3.889968	comment	3.0	15.0	1620139994	-10.370208
27074641	I've been keeping an eye on Racket f	I've been keeping an eye on Racket for a few years now, and recently gave their documentation tool Scribble[1] a try, as an alternative to writing LaTeX directly. But honestly I found the experience difficult if you need some custom behavior, and falling back to Racket was very confusing as a relative newcomer to Lisp (with mostly Elisp experience). It doesn't help that their documentation, while detailed, is not very beginner friendly. So I went back to org-mode for exporting to PDF via LaTeX.Congrats on the release![1]: https://docs.racket-lang.org/scribble/	imiric	15.349005	-3.6740592	comment	3.0	11.0	1620386272	13.647464
27074688	I watched the whole video.He acknowl	"I watched the whole video.He acknowledged that Racket has excellent documentation, a wide-ranging toolset, etc. All the good stuff you've heard elsewhere.He criticizes the language-oriented model (in comparison to languages that people are familiar with but that allow embedded Deals, like Lua or Ruby) because creating a new DSL is antithetical to code that communicates with other programmers. This is fair, and a common criticism of Lisps: the complete freedom of the macro system means that individual programmers can create their own dialects quite easily, and other users of that code have a harder time working with it than in languages where there's not as much metaprogramming.On the ""toxic"" front, one of the core team apparently asked a waitress a cringy question about higher education, r"	GavinMcG	15.315707	-3.7263336	comment	3.0	15.0	1620386617	13.678068
27158170	Forth has almost no syntax, which le	Forth has almost no syntax, which leads to every project becoming some kind of domain specific DSL. This is not necessarily a problem, but it leaves Forth without a strong sense of identity as a programming language. This is my opinion, of course.	haolez	15.045329	-3.8184552	comment	3.0	17.0	1621017882	6.0692363
27239500	It's not the last time major portion	It's not the last time major portions of the world fundamentally changed how they did things to align with the major powers at the time.Even WITH all the Unicode support that currently exists in the computing world I don't know of a single computer language that isn't based on English in ASCII. I guess you could count APL there (or perl!).	bombcar	15.529764	-2.7137198	comment	3.0	22.0	1621628849	10.707346
27280324	I'd be curious about a Racket implem	I'd be curious about a Racket implementation. I know Racket is supposed to be a research and teaching language, but in several respects it seems to be a better Common Lisp than Common Lisp itself.	nerdponx	15.282905	-3.7652276	comment	3.0	12.0	1621966781	13.650064
27301688	What’s a Scheme that 1) has fast sta	What’s a Scheme that 1) has fast startup binaries (so no Racket) 2) has a good emacs experience ala SLIME/SLY, CIDER?	Siira	15.154026	-3.839137	comment	3.0	10.0	1622114890	-7.8343678
27455718	Why was the title changed to replace	"Why was the title changed to replace the ordinary word liquefaction?  I clicked the link because I had not seen ""liquification"" before.  Not sure it's even a real word.** (to the extent there even is such a thing as ""real"" and ""not real"" word)"	gumby	15.134825	-3.876176	comment	3.0	13.0	1623288717	-10.462922
27461040	Are there companies still producing 	Are there companies still producing modern keyboards with APL in mind? I like the idea but can't see how it would be practical with a normal keyboard.	NextHendrix	15.554512	-2.6871204	comment	3.0	17.0	1623334550	13.06533
27461632	I really like APL but I cannot imagi	I really like APL but I cannot imagine myself depending on a closed source tool-chain. I've heard that the GNU APL is order of magnitude slower than Dyalog APL, but I can't find a benchmark to confirm that.	JacobiX	15.566397	-2.6911037	comment	3.0	12.0	1623337877	13.056924
27461815	The closest language to APL/J/K is N	The closest language to APL/J/K is NumPy, the numerics library for Python.  It was deliberately designed in the spirit of an APL, but without all the squiggly characters.	gmfawcett	15.559386	-2.7013717	comment	3.0	14.0	1623338781	13.06655
33638647	APL looks like a lot of fun, and I'v	APL looks like a lot of fun, and I've tried to get into learning it for a while, but it's a shame that the most popular implementation is proprietary, and GNU APL is a dialect which is not as featureful and a separate dialect of APL unto itself, so it's not as though you can write a reasonably sized APL program with Dyalog and then expect it to work in GNU APL.	claudiawerner	15.566483	-2.6909678	comment	3.0	11.0	1668692291	13.061605
33639966	You can get everything there is in A	"You can get everything there is in APL, plus no weird symbols in the J programming language.> learning all the alien symbols is a one-time investmentNo one time investment is needed if you want to learn J.And yes, it does teach you to think in a new way. I am not kidding.You can see the plethora of (mostly free) books available at the website [0].Learning J has given me ""enlightenment"" at the same level The Little Schemer has given me.(I don't recommend APL to anyone as you need to learn and painstakingly slowly insert those symbols. If you want to learn array thinking, go straight to J. Why waste time and headspace with APL symbols?)[0]: https://code.jsoftware.com/wiki/Books"	__rito__	15.564116	-2.6955864	comment	3.0	14.0	1668698062	13.064411
33643248	> life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 	> life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}Nope, it should be burned in fire.> Roughly 86% of all the fun you get from APL programming comes from the mysterious symbols and the magic behind them. It’s not that APL is alien to computers, it’s just the computers were alien to APL for quite a while.That's being alien to humans my dude. If understanding syntax is heaviest mental exercise in programming language it is unexcusably terrible. It should be considered torture to even require someone to read it.	ilyt	15.563431	-2.6921608	comment	3.0	10.0	1668709301	13.076279
33774241	Racketfest 2023	Racketfest 2023	jessealama	15.37654	-3.627033	story	3.0	73.0	1669646883	13.627996
33786092	I have tried Forth and failed many t	"I have tried Forth and failed many times.The biggest problem for me was the amount of effort needed to keep track of ""local"" variables.Was I missing something? Is there a way to let Forth keep track of where on the stack ""foo"" lives if it is needed several times in a subroutine instead of always shuffling the stack or counting the elements on it?"	dottedmag	15.016052	-3.831829	comment	3.0	25.0	1669720237	6.1756806
34043543	FORTHLives on in every stack machine	FORTHLives on in every stack machine	danbmil99	14.969101	-3.863065	comment	3.0	14.0	1671398263	8.411888
34064948	> But APL programs are often cryptic	> But APL programs are often cryptic and hard to decode. Some have joked that it is a “write-only language” because even the author of a program might have trouble understanding it later.So the original Perl?	xedrac	15.566149	-2.6931796	comment	3.0	17.0	1671539388	13.097807
34067867	Lots of programming isn't math or lo	Lots of programming isn't math or logic, its shovelling data and manipulating strings. Is APL good at that?	MrBuddyCasino	15.564962	-2.6937354	comment	3.0	17.0	1671552558	13.082082
34098492	Personal Edition LimitationsPlease n	"Personal Edition LimitationsPlease note that the LispWorks Personal Edition, distributed free of charge, has the following intentional limitations:    There is a heap size limit which, if exceeded, causes the image to exit. A warning is provided when the limit is approached.
    There is a time limit of 5 hours for each session, after which LispWorks Personal exits, possibly without saving your work or performing cleanups such as removing temporary files. You are warned after 4 hours of use.
    The functions save-image, deliver, and load-all-patches are not available.
    Initialization files are not loaded.""

And it is not popular because ..."	PeterStuer	15.021073	-3.8814223	comment	3.0	11.0	1671742256	-10.42385
22692768	I think it's fair to say that font i	I think it's fair to say that font issues were a significant reason for its decline in the late 80s and 90s (well before good unicode support). Other major factors were spreadsheets, which did many of the things APL was best at with an intuitive graphical interface, and OOP. APL didn't have OOP, so it was for dinosaurs. Structured programming could have had the same effect—mainstream APLs picked up ifs and while loops 10-20 years later than the rest of the world—but I think the usability gap between APL and anything else for arrays was just too large at the time for that to hurt APL too much.	mlochbaum	15.563369	-2.6925952	comment	3.0	10.0	1585225073	13.085177
17958413	A micro manual for Lisp – Not the wh	A micro manual for Lisp – Not the whole truth (1978) [pdf]	tosh	15.151144	-3.9294388	story	3.0	109.0	1536660889	-10.424268
17982400	A Forth or a Lisp are simple tasks f	A Forth or a Lisp are simple tasks for an experienced programmer, and even basic ones are really satisfying imho. Seeing simple constructs work in an hour of coding really feels great. I implemented more complex languages (with types) for work which were more like DSLs but in languages less suited for the type of DSL we required, but I find most pleasure doing little Forth (like [1]) or Lisp likes when I am waiting for hours (in a plane for instance). It is like playing games for me. I write them on my phone or iPad.I would recommend a lot of books here as well for a solid base and giving you the background needed to write more complex languages including static types, compilers, JITs and VMs. But for me, because I really do not have that much time, that would stretch over too long time an	tluyben2	15.079869	-3.8558385	comment	3.0	10.0	1536871575	6.111762
18008585	Ask HN: Lisp and the Personal Comput	Ask HN: Lisp and the Personal Computer Revolution	Kinnard	15.09015	-3.9256754	story	3.0	2.0	1537208947	6.8215604
18989795	Lisp, Jazz, Aikido – Three Expressio	Lisp, Jazz, Aikido – Three Expressions of a Single Essence (2018) [pdf]	Tomte	15.171614	-3.9080155	story	3.0	22.0	1548345720	-10.456515
19044951	I test drove Racket-on-Chez the othe	"I test drove Racket-on-Chez the other day by attempting to use the pict3d module (since 3d is an application that needs speed). My experience was as follows:1) Install pict3d through DrRacket's built-in package manager - sudden, silent crash. Luckily I ran it from a terminal, which indicates an out of memory error.2) Raise DrRacket's memory limit to ""unlimited"" and retry. Same result.3) Google how to install packages from the command line. Wait for package to build. Build hangs during documentation. Eventually give up and ctrl-c. Hopefully it still works without docs? Racket packages aren't transactional, so every failed build leaves Racket thinking a package is installed, but it's actually broken.4) Run DrRacket. Load pict3d and type oneliner. Incautiously press an F-key I assume will run"	dTal	15.374804	-3.6408873	comment	3.0	10.0	1548945490	13.623725
19045613	So, I am an experienced developer bu	So, I am an experienced developer but new to Lisp based stuff, which seems to be what racket is based on. Can you suggest any books to learn racket.edit: Spelling	kumarvvr	15.341343	-3.6886032	comment	3.0	21.0	1548950141	13.632582
19046484	> and c) has the audacity (combined,	> and c) has the audacity (combined, curiously, with humility) to just swap out the entire backend to eek out more performanceUnfortunately they are not doing it for performance reasons. They are doing it solely to make the code base cleaner and easier to maintain.Based on their most recent blog on the subject (https://blog.racket-lang.org/2019/01/racket-on-chez-status.h...), the new backend is almost uniformly slower to load, takes up twice as much memory, takes more than twice as long to build, takes twice as long to compile Racket code, and the compiled code generally runs slower than it used to. (They expect that this last one will improve, but they have never indicated that they expect it to actually match or exceed the speed of code compiled with the old backend.)Also, the new back-e	velcrovan	15.362626	-3.6552615	comment	3.0	13.0	1548955090	13.660491
19047736	The new backed is overall faster acc	The new backed is overall faster according to that post. In addition, looking at raw Chez, the results are even more one-sided. Chez is always faster and often 2-8x faster. New racket is usually faster and where it isn't is mostly due to new IO. Sure, compile times get bigger -- Chez is doing way more optimization passes than Racket (Chez is the only scheme I know of that can get close to SBCL in performance).http://blog.racket-lang.org/img/posts/2019-01-29-racket-on-c...According to them, fixing things takes much less time and is much easier to understand. For a system where lots of development is free, ease of understanding and fixing is extremely important.> But I do know that I the main thing holding me back from investing more development time in Racket is its poor performance compare	hajile	15.361885	-3.6588259	comment	3.0	10.0	1548961908	13.662338
19289282	The “run” button is however you run 	The “run” button is however you run your CL code. Are you seriously disputing my experience because I said “run” in quotes? Would it please you more if I had instead said I used SLIME with SWANK with emacs and I pressed C-c C-e or whatever?As I sais, I have programmed CL professional. And yes, Racket doesn’t have a real REPL. And yes, CL with emacs and SLIME and SWANK is nice or whatever, but personally, I’ve found that a REPL provides much more value with a dynamic language vs a static language.Why? Because with CL you need to be running each function because you have no faith in your code. The most trivial errors that could have been caught by a simple type checker will crash your program. I’ve almost never had the experience of writing say 300 lines of CL and having it work on the first	mruts	15.33095	-3.7005682	comment	3.0	21.0	1551535415	13.65058
15840054	Mal Lisp for TempleOS	Mal Lisp for TempleOS	bagnalla	15.141655	-3.9269733	story	3.0	120.0	1512340415	-10.474539
16953073	There is some experience with this i	"There is some experience with this in the K community, and the answer is ""it does not gain accessibility""; and ""extracting reusable definitions"" goes against the spirit of APL, at least for the simple stuff.Everyone focuses on the syntax because that's the first thing you see, but it's just the tip of the iceberg. The real problem is that you have to think differently, and a weird representation actually HELPS you start thinking differently.My favourite two examples (K syntax - K is of the APL family) are: maximum subarray sum, written in K |/0(0|+)\ and in english ""max over 0 (0 max plus) scan""; And flatten, written in K ,// and in english ""join over converged"".They are both good examples of K's orthogonality (which is shared by APL and J), and of the fact that the english doesn't make th"	beagle3	15.556227	-2.6987946	comment	3.0	10.0	1525024537	13.051706
16953288	APL was designed to be taught to non	"APL was designed to be taught to non-programmers.  Indeed it was taught in some high school maths classrooms.I have been reading many books and other historical documents on APL from the 1960s/70s/80s and this one I found to be especially interesting:http://www.softwarepreservation.org/projects/apl/Papers/Elem...I would like to thank the HN user who has posted this a couple of times.  I am grateful for this resource and reading it sooner rather than later.Why I found this particular publication unique amongst all the others I have read:It is many pages before the reader encounters any programming jargon.  I believe the use of the term ""primitives"" may be the first slip.It is possible the reader with absolutely no familiarity with programming would not be alienated by any of the terminology"	textmode	15.559666	-2.712101	comment	3.0	10.0	1525027449	13.12447
16954251	Thanks for the link. Do you know if 	Thanks for the link. Do you know if there is something similar for GNU APL?Do you think it will be annoying to switch to GNU APL after going through this? I'd rather not spend time learning a proprietary interpreter if there's a viable free software alternative.EDIT: Have started going through the tutorial using the GNU APL interpreter. I'll see how it goes I guess. 2+5 seems to work the same :)EDIT 2: akt makes it possible to type the symbols without a special keyboard with GNU APL https://github.com/TieDyedDevil/akt	kasbah	15.565829	-2.6940103	comment	3.0	13.0	1525040755	13.083322
17002318	I love that GNU loves Guile. There a	I love that GNU loves Guile. There are few Scheme implementations as well polished as guile is, and what a breath of fresh air it can be to sit down to some '() stew after a few rough weeks of spreadsheet hell at work.Might be just me, but it's kind of like having another universe to take a vacation in.It does make me miss types, doing data structure programming in scheme can be irritating I guess, but still. I can compose, I can syntax-rules if I wanted, etc.The sexpr universe isn't dead yet.	jrq	15.215956	-3.7556171	comment	3.0	14.0	1525535695	-10.237184
17032064	Some I haven't seen mentioned here:1	Some I haven't seen mentioned here:1. Coders at WorkPeter Seibel does an amazing job of asking programmers questions that make them explain their methodology. The interview with Donald Knuth is awesome; really enjoyed hearing him talk about literate programming.2. The Soul of a New MachineTracy Kidder's 1981 Pulitzer Prize winner I think is a brilliant case study on how engineers work together and the things that can go wrong and right with different personalities interacting with highly technical ideas. The project in this book starts without the consent of management, which to me shows the value of questioning the system to add business / engineering value.3. Little SchemerSmall book that will give your brain a serious workout and show you how to problem solve with Lisp like languages. E	pcprincipal	15.136681	-3.9190462	comment	3.0	10.0	1525888432	-10.442724
17033875	I really like this book and highly r	"I really like this book and highly recommend it.My only complaint is that because it is so directed (you're writing a programming language and it wants to get you there very quickly) it abstracts a lot of stuff that you'll need to know if you're doing anything other than following this book. For instance, a lot of the code you write will start with    #lang br

Instead of the usual Racket    #lang racket

That's using some support from Racket where you say ""I'm writing the `br` language"" and Racket goes and runs your code in that language instead of Racket. That ""language"" is really just Racket with some libraries pre-included (https://beautifulracket.com/appendix/from-br-to-racket-base....) and some of those libraries are specific to the book (e.g. https://docs.racket-lang.org/br/index.ht"	ketralnis	15.359042	-3.659814	comment	3.0	18.0	1525898566	13.628212
17034214	Practical Typography (written by the	Practical Typography (written by the same author) has been a wonderful resource for me. Sometime I'll get around to working through this book as well. My high school is actually one of the last places to teach Racket/Scheme as an introductory language. Personally I find it a wonderful way of teaching the basics of computation and recursion. I wish more schools still taught it.	_hardwaregeek	15.357271	-3.6588764	comment	3.0	10.0	1525900947	13.62329
17036975	Great site, seems to have a good col	Great site, seems to have a good collection of lisp resources. I am waiting for the documentation to go online, it says it is still parsing the TeX sources of the commonlisp hyperspec.As a side note, I downloaded the Lispworks Common Lisp Hyperspec, but I could only find the HTML version.I see that the project is on Github, maybe someone will parse the Hyperspec and generate the documentation pages.I am adding a reminder to my org-agenda for next month, maybe I will attempt to do it :).	terminalcommand	15.168164	-3.9131718	comment	3.0	10.0	1525936640	-10.4526005
17173728	I've felt that high-DPI touchscreens	I've felt that high-DPI touchscreens are the opportunity for an APL renaissance, if there's ever going to be one.Once hardware keyboards standardized around ASCII in the '70s, it cramped the promise of APL's custom notation. On touchscreen it's trivial to render a software keyboard that contains the entire symbol set (perhaps even adapted to the user's experience level to make it less scary initially?). Increased resolution could be used to make the programs easier to parse visually by e.g. scaling symbols based on their context and nesting level, just like we do in math equations.I'd like to work on an open source APL variant that runs on iPad and/or touchscreen Windows. It should be aimed at entry-level programmers because they don't have the imperative mindset strongly ingrained yet. It	pavlov	15.554905	-2.6888647	comment	3.0	12.0	1527529637	13.078137
17173741	Could Numpy be considered the APL re	Could Numpy be considered the APL renaissance? Not in syntax, but conceptually?	Ruud-v-A	15.562224	-2.6961946	comment	3.0	11.0	1527529789	13.060634
17174774	APL looks like the best programming 	APL looks like the best programming language I've ever seen. I wish it could be extended with SQL and web-service mappings to input-output data conveniently and to use functions written in other languages (like C and Python) for acceleration and rapid logic prototyping.	qwerty456127	15.566242	-2.69332	comment	3.0	10.0	1527540644	13.085607
21114896	Funnily enough, APL is as unambigous	"Funnily enough, APL is as unambigous as possible when it comes to order of execution. It's _always_ right-to-leftSo ∇⍵-2 does ⍵-2 the applies ∇ to it.Simmilarly (and initially confusing), 2+45-2 evaluates to:
(2+(4(5-2))) = 14From experience, the simplicity of not having operator precendence is liberating (why do we even need operator precendence in the first place, really?)."	maest	15.566821	-2.6918418	comment	3.0	13.0	1569848740	13.081538
21134752	I am just getting into Scheme, and h	I am just getting into Scheme, and have heard good things about Chez. Any pointers to what is standard out in the wild? What are the de-facto Scheme tools are people using these days?	alfiedotwtf	15.328879	-3.687955	comment	3.0	16.0	1570009678	13.6212225
21134868	Making languages is the thing that R	Making languages is the thing that Racket does better than any other language, so they do tend proliferate. However, for getting stuff done the majority of work is done in just Racket. You don't need to know the other languages unless you're interested in some specialist task they target.Back when I was a regular Scheme user Racket had by far the biggest ecosystem and community, so it would be my suggestion if you're interested in exploring Scheme.	noelwelsh	15.357586	-3.6646998	comment	3.0	24.0	1570011410	13.649871
22840569	I completely agree. I work with a la	I completely agree. I work with a large APL codebase and the main problem is not the language but the culture. Overly long expressions, one-letter variable names, gotos etc. make the code obfuscated.	augustk	15.563337	-2.6963224	comment	3.0	10.0	1586596017	13.086579
22842054	That's ridiculous. It's computer sci	That's ridiculous. It's computer science, not computer programming technician. You teach with the tool that most clearly distills the principles of what you're trying to teach. Racket and Scheme arguably do that much better than Python.In fact, Racket 15 years ago still has more cutting edge features than Python has to this day. There is simply no language that provides the breadth of features available in Racket, and I don't even use it.> Academia has scared away an untold number of aspiring students with their nonsense languagesA programmer that's scared or intimidated by learning a new language does not belong in this industry. You might as well say that we should coddle civil engineering students that are scared of computers. If this is a barrier you can't surmount, consider another ca	naasking	15.351719	-3.6730623	comment	3.0	27.0	1586617920	13.64283
22842111	Full disclosure - I took 3 classes i	Full disclosure - I took 3 classes in Racket: Intro to CS, Programming Languages, and Compilers.> Racket is not a very popular language in teaching communitiesThis list of schools with introductory Racket classes isn't accurate, because the author did not look beyond the naming of the courses on the Github page. My school was missed.> Students are unlikely to have had prior experience with RacketThis is good because it means students from varying backgrounds of programming experience start from a level playing field.> Racket’s aesthetic beauty has limited relevance to CS1Computer Science is first and foremost an ivory tower and students are (imo) better off being confronted with this fact up front. Software Engineering is probably better taught with a more practical language.> Students do 	skillpass	15.352592	-3.6593966	comment	3.0	18.0	1586618394	13.640726
22878801	That's my dream! Do you know of any 	That's my dream! Do you know of any existing efforts towards it? I don't know much about Racket, how would #lang Python thing work (i.e. in terms of calling foreign functions etc)?	karlicoss	15.357017	-3.6698184	comment	3.0	11.0	1586964194	13.649381
22907163	> by getting the whole parser onto a	> by getting the whole parser onto a single screen, I find that I can get the whole problem into my brain’s working memory and avoid burning cycles scrolling up and down to pin down butterflies bugs.This is an excellent point, and one that not enough programmers pay attention to (well, outside of the APL family of languages, anyway!)	codesections	15.543038	-2.7168903	comment	3.0	42.0	1587211836	13.115573
22975890	What about macOS? So far Racket seem	What about macOS? So far Racket seems like the easiest solution for a lisp with easy cross-platform GUI support (Linux, Mac, Windows). It would be nice to have more easy choices, but also nice if all 3 major platforms were supported.	_emacsomancer_	15.323737	-3.7160017	comment	3.0	25.0	1587793371	13.656477
23132871	"It wasn't from ""day one"". The name R"	"It wasn't from ""day one"". The name Racket is only about 10 years old. It started life as PLT Scheme.A racket is a kind of scheme.EDIT: You've edited your post to include more ridiculous assertions.Python was literally named after Monty Python.You know what, whatever, I'm not playing this stupid game."	moron4hire	15.357791	-3.6618547	comment	3.0	16.0	1589121157	13.647432
23132981	"I don't know why ""application perfor"	"I don't know why ""application performance"" is brought up here, do you mean adoption?I think Racket is a pretty bad choice, I'm from Italy and here you find that word in news about mafia and organized crime, so imagine the kind of association it bears with it.Naming things is hard, but sometimes hackers seem to choose to make it harder... https://racket-lang.org/new-name.html"	gcmrtc	15.364634	-3.6518667	comment	3.0	11.0	1589121784	13.649151
23133652	I used Racket a lot about 2 months a	I used Racket a lot about 2 months ago. I was prototyping an application [1] in three different languages: Racket, LispWorks Common Lisp, and Swift.Racket produces standalone applications that can be codesigned using Apple's tools, in preparation for their App Store.Best regards to the Racket team.[1] http://www.knowledgegraphnavigator.com/	mark_l_watson	15.351383	-3.6720355	comment	3.0	17.0	1589126763	13.650023
23136662	I don't think this is true. I don't 	I don't think this is true. I don't think racket-mode has a big community around it, and sadly doesn't come even close to slime [1] or cider [2], both very feature full dev envs for Emacs.Magic racket is very bare bones and can't compare to integrations like Calva [3].So I saw someone down voted me... just to be clear, I use Racket despite having to work against a poor tooling experience, when comparing to say, CL or Clojure.I want Racket to succeed in industry, so is not like I'm complaining. I'm pointing out what I think is a weakness, maybe a blind spot by the team, since they seem to be very attached to Dr Racket!1: https://common-lisp.net/project/slime/2: https://cider.mx/3: https://github.com/BetterThanTomorrow/calva	emmanueloga_	15.328378	-3.6943266	comment	3.0	14.0	1589147939	13.636924
23165093	I wonder if his question was not rhe	I wonder if his question was not rhetorical, as in: It is really Lisp if it doesn't have cons?	oblio	15.144021	-3.914219	comment	3.0	16.0	1589362281	-10.445615
23208561	This is a pretty nifty piece of work	This is a pretty nifty piece of work. Not really a oneliner if it requires a 1/4 page of code, but I'll let it slide :)I do like the concept of keeping I/O in a more traditional language and the matrix/array code in something closer to APL.	7thaccount	15.564261	-2.698638	comment	3.0	11.0	1589677930	13.064009
23233654	Guile is almost 30 years old. It’s G	Guile is almost 30 years old. It’s GNU’s Scheme implementation.  People wanted to replace the nonstandard Emacs Lisp with Scheme but since so much code was written in elisp, they didn’t want to throw it out.At this point someone should abstract out the Emacs definition so others could build it with Scheme or Clojure.Emacs is basically a Lisp interpreter. They wrote the parts that needed to be fast in C and the rest is elisp.45 years ago Emacs needed to be built in C.  Today the entire thing could be built with a standard Lisp.I suppose if someone wrote an Emacs in Scheme, the projects could converge once Guile is integrated into Emacs	melling	15.186064	-3.80602	comment	3.0	29.0	1589887565	-10.301169
23233990	Honest question: what are the benefi	Honest question: what are the benefits of Guile Emacs in 2020 and after? Guile speed? I'm aware Guile (especially) later versions got really good VM and general optimizations, but with recent work in gccemacs [1] and having complete gcc optimization engine under the belt, can these two be even compared? Also, gccemacs showed you get visible speedups in some use cases only.Have everything under Guile umbrella? Remember, Guile is getting trickier and trickier to build over the years and I don't want that from scripting language whose main idea was to embed it (presumably also ship the source alongside your program in some cases). I'm getting impression even python source & build is easier to ship and you can't go below that.Also, modern Guile compilation time is abysmal. I recently ditched G	dig1	15.186509	-3.7959275	comment	3.0	32.0	1589890625	-10.252996
28101732	I'm the researcher mentioned in the 	I'm the researcher mentioned in the article.  We used Racket in part because before we transitioned into academic medicine, Will Byrd and I were in academic computer science with a focus on programming languages. Will was building up miniKanren to do lots of cool stuff in program synthesis and program analysis.  When we jumped over, it felt natural to bring the power of relational reasoning to knowledge graphs over biomedical knowledge, and so mediKanren was born.	mattmight	15.362151	-3.6519425	comment	3.0	12.0	1628369750	1.7697221
28179869	> No other language has people claim	> No other language has people claiming what the Lisp people claim. Many langs claim to be influenced by Lisp, or try to do things that Lisp can do, or do things that started in Lisp (which is just about everything but OOP). But the Lisp crowd doesn’t see a need to be like other languages. It’s like fat people want to date fit people, but fit people do not want to date fat people.Considering the whole article is about how to get more users for Racket, maybe they're not doing so well in the dating pool? The author also seems to have forgotten static typing. Isn't Typed Racket precisely the Lisp crowd seeing a need to be like other languages?	Zababa	15.278027	-3.7811034	comment	3.0	13.0	1628941265	-10.3849535
28265472	I was excited that Pyret, which I wa	"I was excited that Pyret, which I was previously familiar with as a Racket #lang, had evidently gained enough independence to warrant its own website that does not even mention Racket. What a vindication of the #lang system! Then I read this:""Ultimately, Racket’s #lang facilities, though designed to create new languages—and a great prototyping ground for Pyret—proved to not be quite enough to support a language creation process of the scale of Pyret""I find this rather sad. The PLT group, dogfooding their flagship product's unique selling point, was not able to achieve their goals and switched to Javascript. I hope that one day it may once again be a Racket #lang."	dTal	15.353847	-3.6749043	comment	3.0	15.0	1629640446	13.594928
28398715	I generally like RSR6, but Chicken o	I generally like RSR6, but Chicken opted to stick with RSR5 for a long time, which honestly was a deterrent for me.  They are in the process of implementing RSR7 which is strangely incompatible with RSR6.  Racket has been my go-to scheme for awhile.  The only time I would consider Chicken over Racket is if I needed tight integration into an existing C project and had size constraints.  Is there something else I'm missing out on?	xedrac	15.275847	-3.7218935	comment	3.0	15.0	1630625820	11.897022
28401378	My understanding is that Chez Scheme	My understanding is that Chez Scheme is pretty fast. Developed by Cisco, and the new backend for Racket.	avhon1	15.349428	-3.6627305	comment	3.0	10.0	1630654237	13.63308
28630697	I am pretty sure they don't. I was i	I am pretty sure they don't. I was interested in LispWorks since the late 90ies. I downloaded and used a bit the free edition, but that was too limited even for hobby usage. The personal edition was a bit cheaper then, I almost bought it. I would assume, if they had offered something in between, I would have noticed.	_ph_	15.11522	-3.9284947	comment	3.0	14.0	1632411263	-10.321977
12094216	For me, the lack of readability isn'	"For me, the lack of readability isn't necessarily about the terseness, per se.  It's about trying to keep track of the stack in my head at all times, and the ""unnatural"" order that the ""keywords"" appear in.    <condition> IF <consequent> ELSE <alternative> THEN

is something I still struggle with, even after studying forth (via Leo Brodie's ""Starting Forth"" and ""Thinking Forth"") for about 3 months.  Something like this I have no trouble with:    IF <condition> THEN <consequent> ELSE <alternative>

but the addition of the (optional) local variables helps me to keep track of the stack more easily (if you could even consider it the stack at that point).In general, I don't have much trouble with RPN, but a few of the constructs in forth have eluded me..."	groovy2shoes	15.02933	-3.8302007	comment	3.0	10.0	1468507362	6.266277
12153312	Matthias Felleisen, one of the devel	Matthias Felleisen, one of the developers of Racket, recently gave a talk about the motivation behind typed Racket; it can be found here: https://www.youtube.com/watch?v=XTl7Jn_kmio	jhck	15.35703	-3.6636117	comment	3.0	10.0	1469368699	13.65391
12153402	It seems that Racket became for Sche	It seems that Racket became for Schemes what Common Lisp was for Lisps, which is really good.Racket is famous for carefully chosen design decisions and nerdy attention to details, so in this sense it is much better than Common Lisp which was a dump.)	dschiptsov	15.331623	-3.7045665	comment	3.0	13.0	1469370604	13.648023
12238832	Are we going back to programming in 	Are we going back to programming in Forth now?	kasajian	15.015195	-3.777129	comment	3.0	28.0	1470502866	1.8003166
12255109	You may want to learn J instead. It 	You may want to learn J instead. It uses ascii, and it's from Iverson, so it's the true continuation of APL.	qwertyuiop924	15.563688	-2.6946008	comment	3.0	16.0	1470755718	13.083612
12257541	It is a pleasure to see APL crop up 	"It is a pleasure to see APL crop up on HN from time to time.  APL was the first language I learned, back in the 1970's.  ""First love,"" and all that.  I remain a devoted user of the language, though only as a thought-amplifier and prototyping tool.The big key to the language IMHO is the idea of computation liberated from time.  This is what I think Dijkstra was getting at when he railed against ""operational thinking"".  Instead of thinking of programming in terms of mentally replaying the execution sequence of the code you are writing, you can step outside of time, as it were.  Computation becomes a way of thinking about mathematical transformations at an abstract, extra-temporal level.  Dijkstra described this as programming via ""predicate transformers"".  But he was still constrained in a s"	gregfjohnson	15.55617	-2.702702	comment	3.0	10.0	1470775065	13.060725
12386295	Can it be true? Can we finally write	Can it be true? Can we finally write our Emacs plugins in Scheme or Common Lisp, and have them work?Wait, then we'll have 2 GCs fighting over data. Dang it. We were almost free!Seriously, though, I do have some concerns. If the new Plugin API becomes widely used enough, elisp may become a second-class citizen in the ecosystem, which would mean that emacs would no longer be easily programmable.  That would be bad.	qwertyuiop924	15.1229315	-3.925221	comment	3.0	10.0	1472514029	-10.345408
12431894	Good context on why Forth didn't pan	Good context on why Forth didn't pan out can be found here:http://yosefk.com/blog/my-history-with-forth-stack-machines....I adore Forth and feel that it's in the small handful of languages / approaches to language that will permanently change a developer's understanding of the field. Perhaps if GreenArrays had succeeded well enough to make a few more generations of processor the landscape would be very different. Perhaps not.Given today's architecture, the impedance mismatch between the stack paradigm and the register architecture costs Forth most of its advantage. Still, if there's another language that allows one to write an interactive assembler for a system with 8k of RAM, I've yet to hear of it.The minimum investment in Forth, which I recommend to all thoughtful developers, is reading	samatman	15.027911	-3.8419006	comment	3.0	17.0	1473104296	6.223461
13096678	Tried to use this to learn Lisp (pre	Tried to use this to learn Lisp (previous experience: one semester of Racket). Couldn't really motivate to keep going. Might just be me, though.	Qwertystop	15.272655	-3.7872858	comment	3.0	11.0	1480788177	13.668758
13137467	A few notes:* Google actively develo	A few notes:* Google actively develops one of the Lisp compilers. Google Flights powers Orbitz, Kayak, etc. That's Lisp.* There are several Lisp compilers in active open source development.* There's a graph database written in Lisp called AllegroCache. It's good enough to support a business (Franz) for more than a decade.* Another company (LispWorks) also exists and has a large portfolio of clients.* Lisp has been used to make entire operating systems. Ones of the past, and ones of now. (Of course, an OS needs a community. But where are real OS's with GUIs in other languages?)* Lisp has been successfully used in my own career for embedded systems to control satellite acquisition systems to, most recently, quantum computing. (At real companies.)Just because there's not this huge buzz around	reikonomusha	15.156605	-3.9281993	comment	3.0	16.0	1481272052	-10.431977
13165611	Use of the word racketeering here is	Use of the word racketeering here is interesting. Wikipedia's definition is:> A racket is a service that is fraudulently offered to solve a problem, such as for a problem that does not actually exist, that will not be put into effect, or that would not otherwise exist if the racket did not existBut it sounds like they were engaging in illegal bribing, not racketeering. I don't know, am I misunderstanding?	wallace_f	15.380508	-3.6232316	comment	3.0	10.0	1481621140	13.623844
13186472	Judging from the red/blue colors in 	Judging from the red/blue colors in the logo and that the website was generated with Frog, I assume that once you feel too big for Pyret's shoes you'll discover that you've actually been using Racket all along and will start using the Racket language directly.	davexunit	15.35902	-3.6625893	comment	3.0	11.0	1481824038	13.619998
13193587	Well, it was. Specifically, Common L	Well, it was. Specifically, Common Lisp was. But that language's standard was etched in stone in 1994 whereas languages like Python (where most deep learning user-facing code is done) continue to evolve.I think Python really took off for that because it already had quality and widely-used libraries for writing the code in Python and doing the work in a more efficient place (numpy, scipy). Clojure has one of those for matrix multiplication but not much else there, and I'm not sure Racket has anything at all.	Blackthorn	15.189242	-3.9074233	comment	3.0	10.0	1481899968	-10.661021
13198738	My understanding is that the first v	My understanding is that the first version of Lisp with true GC was Scheme.  Which was, not coincidentally, the first version of Lisp with lexical scope and closures.The first implementation of Lisp used reference counting.	btilly	15.161113	-3.928918	comment	3.0	12.0	1481940669	-10.469809
13249900	I remember trying do do that years a	I remember trying do do that years ago, and getting hung up as a newbie on there being a million different LISP implementations. I think I tried to use Racket, if I remember correctly, but whatever I picked didn't support some of the book's LISP statements out of the box. Any recommendations for a more friction-free experience?	peller	15.302877	-3.7465324	comment	3.0	19.0	1482590083	13.635955
13477552	I've been getting into Racket recent	I've been getting into Racket recently after spending some time with Chicken. I like Chicken a lot. It has a great ecosystem. However, it can't compete with the Racket standard libraries (and/or libraries that get included by default) -- which are better than most languages its age and popularity (OCaml, Haskell, other Schemes, etc.). For instance, the standard library includes a completely asynchronous web server and asynchronous database drivers.In general, one of the benefits of Scheme versus (say) Python is the regularity and simplicity of the syntax. It also has a better concurrency story.Racket also makes it incredibly easy to parse new languages and run them in a JITed intepreter (Racket). Though I haven't played around with this yet. See [0] for a really great example.There are som	eatonphil	15.357434	-3.6640754	comment	3.0	27.0	1485307062	13.645926
21509292	That is one thing I sorely miss in l	"That is one thing I sorely miss in languages that aren't lisps. The first optimizer pass is source->source. In guile I do    ,opt expression

And it prints the source code after a first basic pass of the expander and optimizer. It does constant folding, inlining, dead code elimination and partial evaluation (and some other things). Being able to inspect what guile does helps a lot with macro writing, and is just a generally handy tool.It beats reading assembly (which is also available) any day of the week."	bjoli	15.181858	-3.8326712	comment	3.0	12.0	1573509234	-10.219501
21535150	Personally, I wish the APL ideas had	Personally, I wish the APL ideas had been taken more seriously, not only as a programming language, but specially as an algebraic notation.I would like to be able to open any text editor and write formulas, and it is not a minor thing to be able to directly use those formulas to solve the problem in the computer. I can do that with J or K, but it does not feel natural at all when using paper or the blackboard, for example. On the other hand, I indeed love the APL symbols (you get used to them much faster than it may look) but, even although they are part of unicode, it is still much less convenient to use than ASCII.	yiyus	15.562859	-2.6955183	comment	3.0	14.0	1573737836	13.082112
21585517	"> Racket CS remains ""beta"" quality f"	"> Racket CS remains ""beta"" quality for the v7.5 release, but its compatibility and performance continue to improve.Does this mean Racket CS is faster than the default Racket?"	Buttons840	15.3715515	-3.645028	comment	3.0	14.0	1574268368	13.65948
21675589	I experimented with Forth with my Ap	I experimented with Forth with my Apple II (I had serial number 71, one of the early ones!). I liked the interactive bottom up REPL coding style, but I found it difficult to read code that I had written the week before.After playing with Forth, I bought Pegasus Lisp for the Apple II and for me Lisp hits a sweet spot of concision, bottom up REPL development, and readability.That said, I can see why some people like Forth if they are very experienced with it and can get things done quickly.	mark_l_watson	15.052609	-3.82275	comment	3.0	10.0	1575210157	6.1781297
21675982	That is an unfair comparison. Forth 	That is an unfair comparison. Forth is designed to run on metal, with no os, no stdlibc, no vector. Can any of other language do that?In fact, by just adding first class function, retro forth makes the code way easier to read.	co_dh	15.034544	-3.815618	comment	3.0	14.0	1575215322	6.108782
21677208	Forth is truly amazing in terms of w	Forth is truly amazing in terms of what you can do with very little RAM and CPU power. It is quite possible to have a working interactive development environment and production implementation in only 4-8 kibibytes of RAM. In the world of small memory 8 bit computers it was amazing.I think Forth can be useful to learn today, at least to stretch the mind to realize that not all programming languages have to be variants of Algol. It can also be a fun game as suggested by the article. I have enjoyed fiddling with it, including re-implementation of the language, and I can recommend it to others as a fun Bazaar toy. In addition, the book Starting Forth is amazing and still worth reading, because it shows that complex topics can be explained clearly and with humor.However, for actual production u	dwheeler	15.040028	-3.8170497	comment	3.0	17.0	1575227417	6.0843625
39152908	I was not aware of this, thanks for 	I was not aware of this, thanks for giving me an explanation. I don't have any experience writing in forth, my friend described this type of language to me and I implemented it.	ret2pop	15.036903	-3.812144	comment	3.0	11.0	1706333798	6.067293
39183346	What about chicken scheme or chez sc	What about chicken scheme or chez scheme?	7thaccount	15.274039	-3.693874	comment	3.0	18.0	1706565767	11.394555
18074039	The article talks about APLs, plural	The article talks about APLs, plural. If APL is a programming language, how can it be plural?	calcifer	15.566419	-2.6933272	comment	3.0	10.0	1537951930	13.096051
18083373	Sly: Sylvester the Cat's Common Lisp	Sly: Sylvester the Cat's Common Lisp IDE	molteanu	15.160924	-3.9226842	story	3.0	86.0	1538045843	-10.443304
18146142	It's like the APL of constructed lan	It's like the APL of constructed languages.	PinkMilkshake	15.562309	-2.697126	comment	3.0	10.0	1538721451	13.088748
18227505	Would it be worth going through SCIP	Would it be worth going through SCIP without prior knowledge of LISP (i.e. could I pick it up from the book) or is it better to have some knowledge beforehand?	collyw	15.156273	-3.9294446	comment	3.0	13.0	1539676558	-10.46329
18227983	Starting Forth by Leo Brodie is a cl	Starting Forth by Leo Brodie is a classic book. Forth is a very elegant language. I came across a javascript implementation of it recently, which you can look up yourself :)	knowingpark	14.9385805	-3.893572	comment	3.0	13.0	1539682762	6.748398
18228628	When I read SICP, I worked through t	When I read SICP, I worked through the exercises in Forth. I had to implement my own garbage collector, create dialect extensions for nice list notation, build a thunk-based mechanism for closure... with the right groundwork laid, Forth can keep up pretty well. I was always somewhat dissatisfied that cute metacircular lisp interpreters leave as tautologies so many important details of their own mechanics.	RodgerTheGreat	15.123736	-3.9137776	comment	3.0	11.0	1539691391	-10.466533
29921147	Also worth noting that language that	Also worth noting that language that runs this very website was implemented in Racket.	noblethrasher	15.358174	-3.6616507	comment	3.0	12.0	1642084611	13.65096
30018316	It won't take longer than 15 minutes	It won't take longer than 15 minutes to get racket installed, and that's being extremely conservative. If you can't spend 15 minutes getting setup done, why would you finish a dense book on the theory of computation?	d3nj4l	15.356046	-3.6520283	comment	3.0	13.0	1642730814	13.648654
30045836	Lisp: Good News, Bad News, How to Wi	Lisp: Good News, Bad News, How to Win Big (1990) [pdf]	capableweb	15.153741	-3.9289672	story	3.0	72.0	1642942856	-10.439373
30079142	Racket does too.    (when (0 . < . x	"Racket does too.    (when (0 . < . x)
         (displayln ""positive""))

Although in Racket you could also add your own syntax."	srcreigh	15.352252	-3.6605165	comment	3.0	13.0	1643150443	13.639969
30139800	"Why ""more of a lisp""? I guess it dep"	"Why ""more of a lisp""? I guess it depends on your personal definition of what a lisp is. For example, I'm much more interested in Racket because my interest is computer science."	rscho	15.170506	-3.9167917	comment	3.0	11.0	1643568089	-10.462717
30419606	One aspect of Racket that I would ex	"One aspect of Racket that I would expect to appeal to students, but which does not appear in this blog post, is its cross-platform (and widget-native!) GUI framework:https://docs.racket-lang.org/gui/The first ""side-project"" I ever did was a tic-tac-toe program in Java AWT during my first year of programming in high school. AWT wasn't even part of the curriculum, it was just what I gravitated towards as a 13-year-old whose experience with computers consisted entirely of graphical applications.Maybe the kids these days would be more interested in building a web app or something, but frankly I don't think it's surprising that writing code that primarily consumes and emits text at a terminal is not interesting to students who have never had any need for a terminal before."	scythe	15.36071	-3.6597402	comment	3.0	10.0	1645471658	13.64922
30462835	I think APL has a lot to teach us ab	"I think APL has a lot to teach us about parallel (specifically GPU) programming. I've rewatched a few talks with Aaron Hsu and listened to his arraycast podcast[1].In researching an upcoming blog post on monoids, I tried implementing the problem in Guy Steele's ""Four Solutions to a Trivial Problem"" talk[2] in APL (actually I tried GNU APL for this, because I didn't need anything fancy). This is what I came up with:    +/((⌽⌈\⌽a)⌊⌈\a)-a

That in turn should be fully parallelizable and run fast on the GPU, as it's based on a couple scan (generalized prefix sum) operations.There's a considerable amount of DNA from APL in modern compiler-based machine learning frameworks, mostly by way of numpy. Dr. Hsu makes a good case that APL has quite a bit of power which is considerably diluted in later "	raphlinus	15.554707	-2.7026606	comment	3.0	25.0	1645754069	13.059277
30577611	I'm wanting to learn APL (I'm leanin	I'm wanting to learn APL (I'm leaning towards J or BQN) and Lisp as two languages/paradigms. APL for is expressivity and Lisp for its ML background.More mainstream I'm wanting to learn TCL and lua.I don't program professionally so don't need to learn anything to get a job.	account-5	15.565192	-2.6956112	comment	3.0	16.0	1646574943	13.092071
18367038	Don't get rid of Apu. He's a hero to	Don't get rid of Apu. He's a hero to many of us	paulpauper	15.56717	-2.6852183	story	3.0	22.0	1541195274	13.120445
18372989	Racket is too powerful to be used by	Racket is too powerful to be used by big corporations. The last thing a company wants is to have their rockstar programmer leave behind a terse, arcane, impenetrable walnut of an application.Languages like Java make it much easier to treat your programmers as interchangeable parts.	chongli	15.361201	-3.6597197	comment	3.0	13.0	1541286304	13.647841
18405341	Wow! It has been almost 6-7 years si	Wow! It has been almost 6-7 years since I used Chicken Scheme, but I have fond memories of it. I wrote a program to automatize the creation of scientific reports in the Planck/LFI project [1]. The purpose was to quickly scan a large number of maps and power spectra produced by the data analysis pipeline, detect any weirdness in the data, and create a report in HTML format. The report included several tables and plots.The ability to natively encode HTML in Scheme syntax was the main reason why I chose Chicken Scheme: LISP is perfect for creating HTML programmatically. However, while using Chicken Scheme, I discovered a few other features that were big timesavers:(1) The simplicity of its FFI was incredible. It was immediate to link existing C libraries we were using in the Planck project, a	ziotom78	15.228692	-3.76761	comment	3.0	13.0	1541671130	-10.367275
18535539	"I had to lookup ""opinionated"" to mak"	"I had to lookup ""opinionated"" to make sure I understand this statement correctly...Forth is on the contrary very opinionated. When you want to implement something in Forth, you have to take into account it's very limited ability to support complexity. Which forces you to think about the problem until you can code a simple enough solution for Forth.It's a severe limitation, but it's one of the rare cases where a limitation is actually a feature. Forth forces its opinion about simplicity on you and that's a good thing in my opinion, because people tend to underestimate the exponential nature of complexity growth: adding a parameter to a procedure at least doubles the amount of unit tests you have to perform on it; add three parameters and that's a 8x the tests.But it also makes Forth far les"	astrobe_	15.030125	-3.8153193	comment	3.0	15.0	1543256453	6.1479573
18689512	Yes! I'm imagining a value propositi	Yes! I'm imagining a value proposition where APL is as fast as C or Fortran, on distributed systems, because at that point it would probably evaporate most of Matlab, Mathematica, and probably TensorFlow's users.Can you imagine? APL is an amazingly powerful language. It's easy to write nearly any mathematical function in it.  What if it was faster than every other mathematical language? It would probably dominate the market overnight.	ColanR	15.565478	-2.6947272	comment	3.0	14.0	1544897088	13.064501
18689829	APL is actually kind of bad at math,	APL is actually kind of bad at math, or well the kind of math people tend to think of when they talk about matlab or Fortran being good at math.What APL does well is filter/select/transform more spreadsheet style work than linear algebra stuff. It's a language to describe computation as meant by the sort of computer scientists that were born when computer was a job description.	Avshalom	15.56463	-2.6950305	comment	3.0	11.0	1544901179	13.082104
18689396	I can imagine that a fork of GNU APL	I can imagine that a fork of GNU APL, re-written in FORTRAN with multi-threaded and maybe distributed computing support, would be an amazing mathematical tool.  Something that's super fast and scales really well, and makes mathematical operations really easy.	ColanR	15.556335	-2.7001266	comment	3.0	27.0	1544896139	13.030938
18689472	> I am firmly convinced that APL and	> I am firmly convinced that APL and LISP are related to each other along an important axis of language design and that acquiring simultaneous expertise in both languages is possible and desirable for the beginning student. Were they unified, the set of tasks that succumb to terse, flexible and expressive descriptions will enlarge enormously without overly increasing the intellectual burden on the student over his initial 16 week contact period.In the context of setting the objectives for education in computer science for general students, I like the idea that the objectives are to (a) understand the limits and potential of computation and (b) achieve fluency in programming such that one can conceive of and describe computational processes for a wide range of tasks.He explicitly suggests t	tumba	15.424408	-3.1399415	comment	3.0	12.0	1544896673	-10.435362
18801875	Forth and Lisp are genius and real p	"Forth and Lisp are genius and real power tools for lone hackers. They are unsuitable for projects with many developers though. Forth in particular has driven the philosophy of not-invented-here roll-your-own to the extreme. That is completely fine for short code but ""brightest shining stars in PL design"" is too much."	qznc	15.107893	-3.9019492	comment	3.0	12.0	1546372212	-10.4876585
17289700	It’s interesting to me because it’s 	"It’s interesting to me because it’s both concatenative—so the basic building block of programs is composition—and array-oriented—so you can implicitly lift operations over arrays like in APL. These are both “weird” families of languages, but people who take the time to learn them tend to speak highly of them, for good reasons that are hard to explain. :)For example, here’s a program to toss a die 100 times and print the arithmetic mean of the results:    : throws(*)
      dup
      6 swap reshape
      ? int 1 +
      '+ reduce
      swap / ;

    100 throws .

“: name … ;” introduces a definition (like in Forth) with the given name, and “.” prints a value.This executes like so:    # push number of tosses
    100
    # stack: 100

    # copy it
    dup
    # stack: 100 100

    # push numb"	evincarofautumn	15.557952	-2.7031481	comment	3.0	14.0	1528762158	13.065266
17535266	APL is cool - but the non-standard n	APL is cool - but the non-standard non-ASCII keyboard is a non-starter for reaching mass-market. Q sitting on top of K is the gateway drug to people using more APL-like languages and vector programming. However, we need an open-source alternative to KDB+. If you want to reach mass-market you need to be free and open and you need to provide something more than just a cool language.KDB+ adds a lot of important features for handling time-series, websockets, web programming and generally scaling up to a distributed system where you could connected different nodes to form a message bus or add your own micro-services framework on top. You can't do that yet with any of the open-source APL and APL-like frameworks I've seen.	anonu	15.557725	-2.7015743	comment	3.0	13.0	1531663230	13.034423
17624791	"""MARTIN HAMMOND, a speech therapist "	"""MARTIN HAMMOND, a speech therapist from New York, spoke for half an hour on the `The psychological ontogeny of sibilant speech impediments' before anyone realized that he was talking about the psychological reality of a different type of lisp; whereupon he was removed from the workshop by the security guards."""	Pseudothink	15.151327	-3.922374	comment	3.0	11.0	1532685546	-10.503038
17645052	Note that while this is one of the r	Note that while this is one of the really good books on Common Lisp it is not new. The copyright is 2003-2005.	todd8	15.153512	-3.9301357	comment	3.0	15.0	1532964280	-10.488303
17654682	I think I fail to understand your so	"I think I fail to understand your somewhat poetic and evocative language, I'm afraid that I'm going to ask you to dumb it down for me:>""The language doesn't really matter"", as such it's imperative Scheme is used.This is an obvious contradiction and clearly you meant it that way but what do you imply exactly?>I strongly feel that if you've worked your way through SICP, and, once finished, you think ""Neat. I'll rewrite this but with language X,"" you've really missed out on value of SICP.>It's challenging enough to follow for people who know a Lisp going in, but using a language more mainstream and familiar to make it easier is largely counter-productive.You claim that using an other language for SICP is ""[missing] out on value"" and ""largely counter-productive"" but you don't produce any evide"	simias	15.130456	-3.9207866	comment	3.0	12.0	1533055448	-10.506018
17663617	But forth is a very low level langua	But forth is a very low level language isn’t it? Even though it’s interpreter, it’s naturally going to be a lot faster than JS and even Java because it maps very closely to the assembler instructions you would normally write by hand. So it would be probably 3x slower than C assuming every Forth instruction takes three C instructions to run (get opcode and arguments, do operation, push on stack).	sbjs	15.025153	-3.837054	comment	3.0	13.0	1533138640	6.1352887
17664943	I wrote jonesforth which is a simple	I wrote jonesforth which is a simple threaded FORTH (in other words, interpreted and certainly not a modern FORTH).  Threaded interpreters produce compact code.  They are not efficient on modern CPUs, because they interact badly with branch prediction.  For embedded cases where memory is at a premium and you usually have a simple CPU like an Arduino, FORTH is a great fit still.Modern FORTHs are all compiled (as indeed are modern Javascripts).  In my view FORTH is a pretty horrible language to write code in, and if you lose the advantage of the compact code for the embedded case then you might as well use a nice compiled language - whatever is your preference, but my preference would not be FORTH if I had to write code all day long in it.	rwmj	15.020507	-3.8371296	comment	3.0	10.0	1533145684	6.0917954
17675611	APL as in... the programming languag	APL as in... the programming language? Or something else? I'm not sure what you're referring to.	mehrdadn	15.566283	-2.693363	comment	3.0	11.0	1533245116	13.091975
16408549	Imagine something like Go and APL co	"Imagine something like Go and APL compile down to the same AST, and imagine two programmers working on the same project with different syntaxes as you describe. The Go user one day finds a function called ""life"" that contains several hundred lines of code, which is clearly bad style and should be broken up, so he goes to talk to his APL using coworker who wrote the function. His coworker seems confused, ""it doesn't seem too long to me"" he says as he shows the APL function on his screen:  life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}

I think what you proposed is a good idea, but it's just an idea. We'd need some new innovation to make it work I think."	Buttons840	15.559333	-2.6994622	comment	3.0	17.0	1518987348	13.0684
16409526	I thought about it some more and I t	I thought about it some more and I think it would go the other way too. APL has a lot of very terse array operations, but in Go you might find a mix of loops and if-statements. Translating those arbitrary combinations of loops and if-statements into APL might be very very ugly, or even impossible.Consider assembly or basic, which use a lot of goto-statements. It can get very ugly trying to fit some arbitrary goto's into the more structured loops and if-statements we're accustomed to.	Buttons840	15.564756	-2.6960385	comment	3.0	12.0	1518996325	13.05876
36640367	Don't hold your breath, these rumors	"Don't hold your breath, these rumors have been going for well over a decade:2018: ""The current owner of Symbolics displayed interest in open-sourcing Genera a few years ago but nothing happened since then."" https://news.ycombinator.com/item?id=178243302014: ""The problem is that the Symbolics IP is now owned by John Mallery; he has stated he has plans for making it available but so far (several years) has not yet done so."" https://news.ycombinator.com/item?id=7882034The software itself can easily be found these days, if you're interested for hobbyist reasons."	pdw	15.186391	-3.8727775	comment	3.0	30.0	1688778863	-10.238073
36751756	My first programming languages were 	"My first programming languages were x86 assembly and Forth. My Dad was into Forth, and I learned programming from him. I wrote several x86 Forth systems for DOS as a teenager, culminating in a somewhat-polished ANS compatible one I called ""Third"": https://github.com/benhoyt/third -- it's kind of amazing being able to have a fully bootstrapped Forth compiler (including an assembler) in a couple thousand lines of code.Just the other day I transcribed an old article I had co-written for the Forth Dimensions magazine. I still like the ideas in Forth, but the stack manipulation quickly gets tedious and is very hard to read. Just look at the code examples in https://benhoyt.com/writings/forth-lookup-tables/ -- especially Search-Table. Yikes! Yes, naming things is hard, but apparently not naming "	benhoyt	15.023598	-3.8342798	comment	3.0	11.0	1689544285	6.166323
36840925	I just really think you should be re	I just really think you should be ready to accept the full force of your words:>Same thing here -- SICP just isn't the same if it's not in scheme or lisp.That straight up reads like SICP and lisp are inseparable and that exactly means that SICP is not as general as people claim.What we have here is unstoppable force meets immovable object (otherwise known as a contradiction). The resolution is simple: either SICP is valuable for the ideas, in which case renderings in js or python are fine, or SICP's value is diminished without lisp, in which case it's not actually about ideas but about the language of choice.Can't have it both ways.	mathisfun123	15.122402	-3.9065661	comment	3.0	10.0	1690153842	-10.490458
24582446	I've been working my way through Bea	I've been working my way through Beautiful Racket [1] over the last week or so. It's been awesome. If this kind of thing is of interest to you, I highly recommend it. It's a book focused on a way of thinking that involves building small domain-specific languages to solve your problems. It's so easy.Racket (if you're not aware of what it is) is just a lisp, but the standard library includes an incredible amount of support for creating readers and expanders for programming languages with very little effort.You aren't even limited to Racket as the target language for your compilation. It's incredibly easy to formulate whatever output you want (like assembly in this article).Of course there's still an incredible amount of value and fun in doing everything from scratch like this article's serie	JHonaker	15.359173	-3.6624062	comment	3.0	11.0	1600975136	13.645999
38912942	Forth is super cool for embedded wor	Forth is super cool for embedded work. The normal dev cycle of build, burn, not work, tweak, build, burn, repeat is quite slow and annoying. It was kind of revolutionary for me to discover Mecrisp[0], which demonstrates how can provide a (fast!) language that also provides a friggin' repl into your hardware.The ##forth IRC channel on Libera is quite active. Would recommend popping in for anyone interested. The two projects that got me interested in Forth are1. JonesForth: http://git.annexia.org/?p=jonesforth.git;a=blob;f=jonesforth...Explanation and motivation for the What and Why of Forth and its implementation. Well, actually, it's actually an implementation in x86 assembly, but the comments are a wonderful exposition and intro into Forth.2. SmithForth: https://dacvs.neocities.org/SF/Imp	xelxebar	15.0212	-3.8287582	comment	3.0	21.0	1704726334	6.0881286
31784419	It’s a lisp, so it’s eminently hacka	It’s a lisp, so it’s eminently hackable - you can do everything with it, and simultaneously nothing ;pI love lisps. Why choose slope over something like racket or maybe clojure(script)?	garren	15.314386	-3.732104	comment	3.0	16.0	1655500263	13.658546
31838192	> a protection racket.A racket impli	> a protection racket.A racket implies they're 'protecting' you from themselves.  I don't think that's true.If protection isn't important to you, you can give Somalia a try.	streb-lo	15.365954	-3.5841846	comment	3.0	13.0	1655915529	-3.1106567
31886308	It is good to see languages like Cry	It is good to see languages like Crystal and Julia having both a compiler and an interpreter.I would really like to see a hybrid approach, where an interpreter is used for the outer loop and a compiler for the inner loop. I believe Guile takes this approach by automatically compiling frequently called functions.	snicker7	15.118345	-3.8879514	comment	3.0	21.0	1656266846	-7.5279574
31906119	> does it have to be a general trans	> does it have to be a general transpose?  And if so, why?There are two answers to this, one less interesting, and one more interesting.The less interesting answer is that it's a primitive in APL, and I have a vested interest in making APL fast.  Then, it needs to be a general transpose because the specific case of a 2-d transpose is already well-studied and has high-quality solutions already.As a language feature, the transpose can be thought of as a calculus on indices.  This suggests a fairly straightforward implementation strategy where no actual data is moved around; instead, a 'strided representation' is used, storing additional information about the array layout, and the indexing procedure is made aware of this.  This seems to be effectively free.  So why am I asking you to move dat	moonchild	15.560644	-2.6963885	comment	3.0	17.0	1656412872	9.385034
31999834	I bought Mastering emacs on a whim a	I bought Mastering emacs on a whim after reading it but am still looking for more in-depth stuff about working with Emacs Lisp in particular.I can do basic stuff alright, being able to jump into source in particular is very helpful to at least find snippets of code doing what I want, but I don't have a good sense of how to work effectively in it.(For example, when trying to test things out I haven't really found a way much better than typing into scratch, selecting code and running it while staring at messages....)I would gladly pay money to watch somebody just write and debug emacs lisp code for half an hour cuz I feel wanting for usability when trying to work with this.	rtpg	15.137078	-3.9268653	comment	3.0	13.0	1657110594	-10.405838
32123171	I fell in love with FORTH recently a	"I fell in love with FORTH recently and wrote a bare-metal ""OS"" (barely!) for the IBM PC based on it. Funny how people are mostly implementing Forths rather than writing programs in Forth. Why is this?I looked to see what Chuck Moore was up to; he's in his 80s and still tinkering and chatting with fans of his work, as recently as late last year:https://www.youtube.com/watch?v=dI0soDMg28Q"	_krii	15.033815	-3.8108966	comment	3.0	11.0	1658017135	6.112169
32137123	Add spaces around APL operators and 	"Add spaces around APL operators and name them.You examples become:  2 partial mod
  1 minus 2 partial mod
  > partial 4

I guess your examples still need some framing to make them somehow passable around, for example, a definition or some kind of closure. Let's say they require no more than square brackets around them.Now your examples will look like this:  [ 2 partial mod ]
  [ 1 minus 2 partial mod ]
  [ > partial 4 ]

And, magically, they are not more terse than what was expressed in Joy. Not at all. Quite the opposite.One character operator is still an operator. If it does not require spaces around it most of the time, for sake of comparison between languages it should have them."	thesz	15.563879	-2.6980145	comment	3.0	17.0	1658144846	13.079114
32178565	Among all languages, APL has the hig	"Among all languages, APL has the highest ratio of times its founding document is posted to Hacker News to lines of code written.I don't mean this to be terribly dismissive: I've always been ""tangentially fascinated"", like I think a lot of people are, by APL and Forth. But I've never properly used it because ultimately it's in conflict with how I think programs should be written: with types, abstraction, a focus on readability etc."	zetalyrae	15.565142	-2.6963124	comment	3.0	19.0	1658406981	13.0881195
32377693	I really like Ivy as a simple, frien	"I really like Ivy as a simple, friendly introduction to APL. There is a surprising lack of APL-derived languages that use words to name things -- most stick with the original symbols; J and friends choose equally-cryptic symbols composed of ASCII characters.Earlier this year I decided to solve AoC 2021 in Ivy, then watch Russ Cox's videos to see how he did it and use that to learn something about array programming -- a topic I knew absolutely nothing about going into this.Unfortunately, Ivy really is, as Rob Pike says, a plaything. It is buggy -- if you ever write a function that returns a vector or a higher-rank array, you are entering bizarre undefined behavior territory. The array-language equivalent of ""concat_map"" or ""flat_map"" or ""mapcat"" or whatever you want to call it just produces"	ianthehenry	15.562139	-2.6980932	comment	3.0	11.0	1659889805	13.041837
22009601	It’s just a different style. After u	It’s just a different style. After using kdb+/q for aoc2019, I quite like the no space one-line style. I find the code easier to read and remember. I think most people who have tried an APL derived language also agree.It’s important that many/most cultural norms are not optimal, they are arbitrary. So don’t immediately discount something for looking weird.	smabie	15.564695	-2.6961846	comment	3.0	18.0	1578647954	13.081089
22023881	Guile has not embraced R6RS:> R6RS s	Guile has not embraced R6RS:> R6RS significantly expands the core Scheme language, and standardisesmany non-core functions that implementations—including Guile—have previously done indifferent ways.  Guile has been updated to incorporate some of the features of R6RS, and toadjust some existing features to conform to the R6RS specification, but it is by no meansa complete R6RS implementation.  SeeSection 7.6https://www.gnu.org/software/guile/manual/guile.pdfNeither has Racket, they aren't even calling themselves a scheme any more.	buzzkillington	15.228266	-3.7684965	comment	3.0	12.0	1578793755	12.067708
22067377	Guile runs elisp just fine, although	Guile runs elisp just fine, although there are quite some low hanging optimization fruit to be picked.From the Emacs side I strongly doubt it will happen. The discussions that have been going on for faaaar less intrusive changes is staggering. Reading the discussions about the portable dumper (new in the upcoming emacs 27, proposed in 2014) is a nice 4 hours. That was in just about every measurable way a step forward for Emacs, yet it took almost 4 years for it to be mainlined,despite glibc more or less deprecating the old unexec from under emacs' feet.I might be misrepresenting just about everything here, but one thing I am pretty certain of: guile Emacs will never happen, despite the promises of running elisp on guile.	bjoli	15.178777	-3.808376	comment	3.0	12.0	1579199458	-10.306901
22088445	Pretty sure Logo was originally impl	Pretty sure Logo was originally implemented with a lisp, no?Don't fall into the trap thinking lisp is just functional.	taeric	15.117322	-3.916721	comment	3.0	20.0	1579393421	-10.484247
22103875	Yeah to be honest one of the things 	Yeah to be honest one of the things that made me skeptical of the code compression / productivity claim is looking at the implementations of Chez Scheme and Racket (after also looking at 20+ compilers / interpreters, and working on a language for a few years).I'm pointing to them as very long-lived and valuable codebases written in Lisp dialects.  Chez Scheme is a 35 year old codebase and Racket is also decades old.So I'm not saying there's anything wrong with them, but I am saying that it doesn't appear that they're 10x easier to understand or modify than LLVM or CPython (Chez being a compiler and Racket being an interpreter as far as I remember).  Or that you can get a 10x better result.Basically for the claim to be true, why can't you write something like Racket in Racket 10x faster?  L	chubot	15.376721	-3.637105	comment	3.0	24.0	1579574042	13.662199
22190640	Realm of Racket	Realm of Racket	tosh	15.378563	-3.628439	story	3.0	145.0	1580383904	13.657572
22225136	April: An APL That Compiles to Commo	April: An APL That Compiles to Common Lisp	kick	15.515073	-2.857635	story	3.0	148.0	1580744816	13.104679
38982944	Nothing has ever convinced me about 	"Nothing has ever convinced me about the potential for array languages in practice quite like watching Aaron Hsu describe how he develops his parallel APL compiler [0] using two Notepad.exe windows side-by-side: https://www.youtube.com/watch?v=gcUWTa16Jc0&t=860sHe has also written many comments (arcfide on HN) about this stuff before, e.g. discussing ""semantic density"" [1]> The compiler is designed so that I can see as much as possible with as little indirection as possible, so that when I see a piece of code I not only know how it works in complete detail, but how it connects to the world around it, and every single dependency related to it in basically one single half screen full of code (usually much less than that) without any jumps, paging, scrolling or any movement. [...] The idea of "	refset	15.557233	-2.7034936	comment	3.0	35.0	1705170625	13.043795
39037528	One analogy I like to tell people wh	"One analogy I like to tell people who are overcome with shock and horror at APL-family languages is to compare it to someone used to Latin-family human languages looking at something like Chinese for the first time --- it's likewise totally ""unreadable"" at first glance, but then you realise that over a billion people can read and write that language fluently every day, many of which may also struggle with a Latin-family language as they've never seen one before.I'm not convinced that APL is ""incredibly hard to scan"" for someone who is familiar with it; it's just a matter of experience. While I'm by no means experienced in APL either, a visually similar thing I did frequently in my younger days was reading x86 instructions not in a disassembler nor hexdump, but displayed as CP437. It was no"	userbinator	15.560423	-2.7055469	comment	3.0	10.0	1705549607	13.085528
32609294	Depending in Common Lisp	Depending in Common Lisp	Tomte	15.151211	-3.9299822	story	3.0	112.0	1661530435	-10.478287
39467217	I love it that Paolo says that Medle	I love it that Paolo says that Medley is his preferred environment. I try Medley periodically, and for me in modern times, Emacs with SBCL or LispWorks fits my needs better.I was fortunate enough to have had a Xerox 1108 Lisp Machine purchased for me in 1982. I loved it with InterLisp-D but a few years later I started running it in Common Lisp mode, and the 1.5 megabytes of RAM in my 1108 was not really adequate.In any case, the Medley developers make it easy to try Medley so give it a try.	mark_l_watson	15.171694	-3.857649	comment	3.0	15.0	1708610711	7.2403464
39471430	I wanted to do some statistics, so I	I wanted to do some statistics, so I accidentally learned J (thinking it was R). J is like APL, but with digraphs (multiple characters) instead of special characters as symbols.	stirfish	15.563448	-2.692834	comment	3.0	15.0	1708628258	13.064789
39573278	I thought I have seen this name…malb	I thought I have seen this name…malbolge-lisp: https://github.com/kspalaiologos/malbolge-lispHN discussion: https://news.ycombinator.com/item?id=28048072She’s a genius prodigy.	trymas	15.141382	-3.925972	comment	3.0	11.0	1709394250	-10.456722
39587899	This is not an “early” CADR, it is j	This is not an “early” CADR, it is just a CADR.  By ‘81 they were heavily used at the AI lab and as gumby mentions, they aren’t fragile little machines.No running (real) CADRs exist, unless you consider the two FPGAs on my desk.For a CADR simulator you can check https://tumbleweed.nu/lm-3 — I managed to restore the last system version for it last year or so, and we are continuing hacking adding and fixing things.E.g. you can run the simulator against the Global Chaosnet and talk to other LispMs and ITS machines (simulated or not). And some of us do run it 24/7 as a file server for other LispMs.	amszmidt	15.078564	-3.9101276	comment	3.0	13.0	1709537249	6.5711846
39611031	> There is no benefit to having thes	"> There is no benefit to having these symbolsHard disagree. Which do you find more readable?    -b/(2a) + 1/(2a) √(b²-4ac)

or    (plus (minus (div b (times 2 a)) (times (div 1 (times 2 a)) (sqrt (minus (pow b 2) (times 4 a c))))))

or    plus(minus(div(b, times(2,a)), times(div(1, times(2,a)), sqrt(minus(pow(b,2), times(4, a, c))))))


APL just has a small handful of symbols with really simple definitions and, heck, you already know what +, -, ×, and ÷ mean. Scheme actually has a ginormous dictionary by comparison, and in practice you do need to read the manual anyway, so discovery is a moot point.APL is actually simpler in that regard in practice, and the gains you get in readability from the symbols are just like above. Better yet, though, which of the above do you immediately think, ""t"	xelxebar	15.565649	-2.6946714	comment	3.0	22.0	1709686784	13.073483
32724639	And so the knowledge of a poor devel	And so the knowledge of a poor development experience for Common Lisp keeps spreading.	pjmlp	15.150292	-3.9276638	comment	3.0	17.0	1662387893	-10.484434
32726626	I’ve never used Racket, but reading 	I’ve never used Racket, but reading your description of the documentation (and Scribble) makes me want to check out that aspect of it. I wonder how it compares with rustdoc? I do mostly Rust these days and its generated documentation is usually really good.	db48x	15.360494	-3.6595318	comment	3.0	16.0	1662397917	13.655881
32727325	Unfortunately, I think perhaps might	"Unfortunately, I think perhaps might have come to a different conclusion if you'd tried Racket's so-called ""hygienic"" macros in anger. I've found them difficult to properly understand, not very usable in practice, and overly complex for non-trivial cases.This is not what you'll usually read in forums, I think DEFMACRO is the better design here."	pyb	15.202866	-3.8663378	comment	3.0	16.0	1662401519	-10.3998575
32746113	Is the Common Lisp community really 	Is the Common Lisp community really still so dysfunctional? I notice your link there dates back to 2006. Surely communities can improve over 15 years..	akkartik	15.146607	-3.9260635	comment	3.0	12.0	1662522461	-10.402333
16447912	Man, that digression into unexec rem	Man, that digression into unexec reminds me of how ugly Emacs is under the covers.  I do really appreciate having elisp available to creatively enhance my editor but... ugh.So then comes the perennial reminder of Guile/Emacs.  There'd be no unexec (in theory) and while this appears to be design-intent from a Common Lisp, maybe it could be cleaned up in bytecode.  The last Guile/Emacs push was, I think, a Google SoC project with some community followup from someone who knows far more about Emacs and Lisp than I.  Guile 2.2 is out and is really sweet (fast, feels modern, kind of exciting).  I wonder if it's time for another push to completion?  Has anyone gave the experimental branch a spin lately?	Steltek	15.178076	-3.812661	comment	3.0	11.0	1519407987	-10.32955
16456032	Thank you for the link.  Reading the	Thank you for the link.  Reading the example on the creation of stacker.rkt (a toy reverse polish language) was dramatically more enlightening than the main article.  As I understand, Racket = source-to-source interpreter with a lot of helpful shorthand for defining syntax of {insert language here} or arbitrary language you make on the spot.  Do they already have libraries for major languages like c++, JS, python?  Would be nice to write in a syntax I like (perl) and turn it into c++ that compiled.	araes	15.356428	-3.6704252	comment	3.0	14.0	1519513828	13.61847
16455450	>  Racket eliminates the hard bounda	>  Racket eliminates the hard boundary between library and language, overcoming a seemingly intractable conflictI don't buy it.A language extension means the syntax wouldn't ever be valid in the base language. The fact that Racket defines its 'for' construct using macros/functions/whatever is cute, but I see no reason to pretend it's a language extension.	MaxBarraclough	15.378186	-3.6460018	comment	3.0	15.0	1519506878	13.644995
16542779	Interesting, how do blind developers	Interesting, how do blind developers feel about minimalist languages like lisp? On one hand it seems like it would read very well in some circumstances (+ 1 2), but the scoping could be a real pain. Cobol seems like another language that might be well suited to them.	flukus	15.1432705	-3.9085336	comment	3.0	13.0	1520491564	-9.088946
16584226	> Honestly curious why Lisp has so m	> Honestly curious why Lisp has so much admiration and praise on HN.Paul Graham and Robert Tappan Morris, two of the founders of YCombinator, love Lisp/Scheme. They got rich by selling their company Viaweb to Yahoo. You guessed it: Viaweb was written in LISP and Paul Graham believes that this was their secret weapon:> http://www.paulgraham.com/avg.htmlAlso the software that drives Hacker News is written in Arc, a Lisp dialect that was invented by Paul Graham.So Hacker News and YCombinator are indeed at least historically very attached to Lisp/Scheme.	wolfgke	15.144353	-3.9292693	comment	3.0	15.0	1521030245	-10.488437
16584082	Your confusion will go away once you	Your confusion will go away once you recognize that Scheme is not Lisp. For most purposes, Lisp means Common Lisp, or one of the Lisps that ended up merging into Common Lisp. That means that Lisp does all of these things and more, which you might not expect if you've only seen Scheme/SICP:* Multi-paradigm programming (functional programming in the immutable sense is not dominant, the Lisp OOP system is top class, mutable state can be everywhere)* Rich looping mechanisms that don't require tail call contortions* Explicit typing that leads to optimized code and compile time warnings! (https://news.ycombinator.com/item?id=13389287)* Warnings at compile time (not run time!) about things like undefined functions/vars/wrong args/unused vars (https://news.ycombinator.com/item?id=14780381)* A pret	Jach	15.157417	-3.929996	comment	3.0	23.0	1521028730	-10.452163
16612925	I was about to write something encou	I was about to write something encouraging people to learn FORTH, but after some consideration, I started having second thoughts.I really like FORTH, but I think it promotes some subversive/extreme views which can sow seeds of discontent (or at least it did for me).Much of my dissolution with the business of programming can be traced back to learning FORTH. It showed me just how much is possible if you optimize for simplicity, and it encouraged me to ask the question: maybe the trade-offs in programming aren't necessary i.e. we don't need to trade complexity for functionality? Now that I have some distance, I was/am probably wrong, and they are necessary, but this question still bugs me.After learning FORTH I enjoyed my job less. I no longer had the patience I once had for the build tool b	alatz	15.037985	-3.8089356	comment	3.0	12.0	1521392989	6.0828466
16804632	There’s also <-, most commonly seen 	There’s also <-, most commonly seen in R but draws it’s heritage from the APL keyboard	jghn	15.548999	-2.6958191	comment	3.0	24.0	1523389866	13.045138
19313850	Common Lisp Koans	Common Lisp Koans	bibyte	15.155555	-3.9271252	story	3.0	151.0	1551817165	-10.488966
19325720	For anyone interested in apl, take a	"For anyone interested in apl, take a look at k which is essentially apl restricted to the ascii character set.
There's also q (aka kdb) which adds some additional database-like functionality (among other things) however it's proprietary and ""free""."	breenhead	15.563854	-2.6940618	comment	3.0	18.0	1551936227	13.074146
19326888	I would say that pandas and R can pr	I would say that pandas and R can pretty much express everything that APL/J/Q can. They are a lot slower though (than Q atleast, I haven’t used J or APL)	mruts	15.548104	-2.7057672	comment	3.0	16.0	1551953497	13.044806
19327193	It seems to me APL and family are mo	It seems to me APL and family are mostly useful for numerical work on data that is possibly queried (efficiently at that) from a database. A very naïve way would be to say it's a glorified Excel. Is there something I'm missing ? Are there other domains one could use it for ?	rakoo	15.561133	-2.6965308	comment	3.0	10.0	1551957632	13.094558
19420742	K7 like it's ancestor APL is extreme	"K7 like it's ancestor APL is extremely powerful language, whit great signal to noise ratios.  However it is kind of ""write-only"" language..  When trying to read a code not written by you (or written by you couple of monthes ago) you struggle to understand it..."	vadiml	15.5539875	-2.7026436	comment	3.0	10.0	1552915028	13.05834
19430151	I wanted to learn a LISP-like langua	I wanted to learn a LISP-like language and tried Chicken for a bit and then switched to Racket. Reason: Documentation. I constantly got stuck with Chicken, often because the documentation available is for a previous version. No such problems with Racket and their, imho, excellent guide.No doubt Chicken is a great language with cool features, it's just not very beginner friendly.	apples_oranges	15.30815	-3.740343	comment	3.0	10.0	1552999025	13.624318
19907107	I ..just... learning s-expressions i	I ..just... learning s-expressions isn't hard. At all. Its a made up thing and I think people cling to it because it gives them an out, they don't want to feel dumb or uninteresting in their work (understandable).  As far as who learns lisp these days, while Clojure may not be doing Python numbers in terms of adherents, it is absolutely used in increasing numbers in business software, has multiple decent sized conferences and forms the back bone for a number of large open source projects.  Its also used as a foundation for a lot of devops and build-tools type work.  Racket scheme is used by at least a dozen universities for everything from intro to programming classes, to advanced semantics and compilers classes.  On top of that there are a suite of new tools written recently (last few yea	dtornabene	15.180064	-3.9266229	comment	3.0	10.0	1557813534	-10.697656
19934574	Racket also has the GIL though. It's	Racket also has the GIL though. It's a problem in every dynamic language I've looked at. Last I checked it was true for Ruby too.	dataangel	15.360797	-3.6619346	comment	3.0	10.0	1558049899	13.638608
24893553	> a well-structured way to define an	> a well-structured way to define and enforce APIsI don't see the issue here? What do you think is stopping you from doing this in, for example, Common Lisp?> and oh wow, typing facilitiesCommon Lisp isn't typed, but there's no reason a Lisp dialect can't be. In fact, Typed Racket is just such a language.	Reelin	15.29429	-3.7504647	comment	3.0	11.0	1603696534	13.634995
24977294	Racket v7.9, with parallel garbage c	Racket v7.9, with parallel garbage collection	poga	15.380955	-3.6246274	story	3.0	45.0	1604388609	8.850622
25182850	That's like supporting a protection 	That's like supporting a protection racket... Wow.	varispeed	15.366028	-3.605023	comment	3.0	27.0	1606096260	13.632563
25250224	Yes. There are some deep insights in	Yes. There are some deep insights in this exposition. The irony is (in my opinion) APL is the worst Array/Matrix based programming language. In fairness it was also the first, but compared to Matlab or Julia it is not as expressive and feels much harder to use.	blululu	15.55902	-2.700715	comment	3.0	24.0	1606703819	13.026179
25319404	I prefer the syntax of CL over Schem	I prefer the syntax of CL over Scheme, but the latter is definitely a wonderful language and goes hand in hand with the wizard book, SICP.At the end of the day, language choice, much like choice of editors or mechanical keyboards, is not that important — what is important is actually coding and building useful software. This can be done in any language, although I do not want to sound ignorant, as certain languages are better suited for certain tasks (eg swift for iOS dev).As a Mac/Windows user, I’d be keen to know how popular Guile is for GNU Projects?For those who want to learn Common Lisp quickly, this is a great guide: https://github.com/ashok-khanna/common-lisp-by-example	abhinav22	15.157118	-3.8986173	comment	3.0	21.0	1607210392	-10.370645
25687609	The article was paywalled for me, bu	The article was paywalled for me, but if you made your cars in lisp, you'd run out of braces way before you ran out of semiconductors.	snickms	15.155973	-3.9277089	comment	3.0	10.0	1610128967	-10.485737
35550337	I’m on the verge of trying Racket to	I’m on the verge of trying Racket to write my own DSLs. I wonder if Janet is better for this task?	behnamoh	15.337906	-3.6849597	comment	3.0	12.0	1681354724	13.65556
35857072	Suggestivity and Idioms in APL	Suggestivity and Idioms in APL	mr_tyzic	15.565503	-2.6865015	story	3.0	74.0	1683508246	13.088609
28714390	I can’t believe anyone made Adventur	I can’t believe anyone made Adventure Construction Set in Forth.  That was a great C64 game.  I’ve never programmed in Forth, but I can’t imagine writing something so complex in it.	kenjackson	15.025295	-3.8020356	comment	3.0	18.0	1633061150	6.05946
28930242	APL is alive and well and widely use	APL is alive and well and widely used. It’s just evolved into more verbose forms known as NumPy, R, and other Iverson Ghosts [0].Turns out people love array programming but hate terse syntax.[0] https://dev.to/bakerjd99/numpy-another-iverson-ghost-9mc	MontyCarloHall	15.562066	-2.695971	comment	3.0	20.0	1634735597	13.07955
28970412	Prominent APLers think it doesn't ne	Prominent APLers think it doesn't need one. I agree, because APL tries to be close to math, and you don't write types when doing math. You use alternate and overloaded operators.A video on the topichttps://youtu.be/z8MVKianh54	rscho	15.562786	-2.6944542	comment	3.0	12.0	1635009511	13.077274
34181027	I have never heard of Wizard’s Bane,	I have never heard of Wizard’s Bane, but that name being associated with why someone would learn Forth made me curious. So I search and find a result that says ‘where magic is volatile and he tames it with Forth.’So, is the book ‘Wizard’s Bane’ actually focused on using Forth (or some ersatz programming language concept) to do magic? If so, that basically describes a huge part of an hypothetical RPG I’ve been designing on paper since college. Also, would you recommend the book to a fan of genre fiction?	throwaway17_17	15.027903	-3.7913764	comment	3.0	11.0	1672366957	6.0672417
34183868	My only gripe with Forth is that whe	"My only gripe with Forth is that whenever I ask Forth people ""what software do you build in Forth?"" they say ""Forths"". I guess that means they are making their own specific Forth for their purposes. I tried to make some basic TODO list style app that reads and writes to a file as a basic exercise and came up against some pretty major hurdles. Specifically, managing a dynamically changing list was basically a nightmare. When I asked a group of Forth programmers why it is so difficult they just said ""Forth is not suited for that problem"". So I suppose Forth is not seen as a general purpose programming language by Forth fans, but then what do they use it for?"	bowsamic	15.036054	-3.8100183	comment	3.0	15.0	1672397586	6.1089406
34342028	Maybe not common lisp, but look up c	Maybe not common lisp, but look up crash bandicoot by naughty dog software for the playstation.That was an exclusive playstation title, probably the third biggest title in terms of sales on the playstation, and it was written in Lisp.	lelanthran	15.146637	-3.9301486	comment	3.0	11.0	1673460544	-10.440782
34376138	I didn't really understand forth til	I didn't really understand forth till I tried implementing eforth in c.https://github.com/tehologist/forthkitManaged to write a compiler/interpreter that could understand enough forth to implement the entire system. Less than 500 lines and only uses stdio.h and compiles using TCChttps://bellard.org/tcc/That was so much fun I built a second one in under 300 lines of javascript for experimenting with canvas api in web browser. Single file doesn't require a server, you can drag and drop code onto text window.https://github.com/tehologist/ecma6-forthRuns standalone, I want to get back to it again.	tehologist	14.988794	-3.852903	comment	3.0	13.0	1673658489	6.1304264
34389237	Not to be confused with Forthon.	Not to be confused with Forthon.	DonHopkins	15.045679	-3.8139515	comment	3.0	12.0	1673789273	6.0759544
23414690	> APLers hate the successors, becaus	"> APLers hate the successors, because ""notation is tool for thought"" and ASCII is a poor representation.I'm perplexed by this one. I'll concede that the APL symbols are prettier but why does it magically stop being a notation just because you use combinations of ASCII symbols. Especially when many APL symbols are composed of units themselves.⍲ vs *:  One is 'notation' because it has the two units stacked on top of each other and the other is not because they are stacked horizontally?"	Rampoina	15.565741	-2.6928155	comment	3.0	21.0	1591265247	13.081624
23450925	There has never been one Forth. In a	There has never been one Forth. In a world with N Forth programmers, one can expect roughly N implementations of Forth. Perhaps closer to 2*N. An ANS spec exists, but most Forth programmers would say it misses the point.Forth is a collection of ideas and philosophies toward programming as much as it is a language. Two stacks and a dictionary. Threaded code (direct, indirect, token, subroutine, etc...). Collapsed abstractions. No sealed black boxes. Tight factoring.C has changed. Forth is everchanging.	RodgerTheGreat	15.0421915	-3.8147156	comment	3.0	12.0	1591564715	6.0679936
23451690	I've read that page and I'm still wo	I've read that page and I'm still wondering why they're using FORTH.C has excellent portability and performance. The article agrees with the general consensus that C is also generally a better language for the programmer. So why use FORTH? What does it matter that it can do cute things with self-hosting? What does 'compactness' matter?If the goal is to build a portable means of writing programs for Z80 and AVR, why not develop a C-like language, or an IR, or put work into developing a serious optimising C compiler targeting the Z80? I get the impression that's a relatively unexplored area for (rather niche) compiler research.	MaxBarraclough	15.011759	-3.7967536	comment	3.0	18.0	1591569891	-6.8233156
23453073	I rather disagree with your first se	I rather disagree with your first sentence. Forth is not Lisp, nor is Prolog or APL Lisp, and none of these languages are one short conceptual leap away from the others. Even a very rudimentary Forth can express concepts which have only hazy correspondences in a Lisp, like words which twiddle the return stack or yield a variable number of results on the parameter stack.I find it misleading at best to casually intimate that Lisp is some kind of ur-language which exemplifies simplicity and thus lies at the root of any design space. Fans of Lisp are overly eager to stake claim upon ideas which do not belong to their language.I don't mean to bite your head off about it; this is just a trope I find tremendously frustrating.	RodgerTheGreat	15.111184	-3.8983555	comment	3.0	11.0	1591583890	5.958702
23676869	C and Lisp are pretty well-known!I'd	C and Lisp are pretty well-known!I'd shill APL/J/etc.	vmchale	15.163604	-3.8931437	comment	3.0	10.0	1593433134	13.094352
23722432	Implementing Ishido, a game from the	Implementing Ishido, a game from the 90s, using the Racket graphical facilities	soegaard	15.362869	-3.6471794	story	3.0	45.0	1593768104	13.64516
19990507	Love seeing a Lisp Cookbook pop up o	Love seeing a Lisp Cookbook pop up on HN.Had a general question about CL. What advantages does it have over things like Racket and Chicken? And how could I potentially pitch the language to a non-dev?	RaycatRakittra	15.186769	-3.8886828	comment	3.0	10.0	1558609164	-10.434225
19998252	Write-only, because only the functio	Write-only, because only the functions (‘WORDS’) are named - no parameter names.  There are also no local variables in standard Forth, you have to push (and pop!) them from the separate return stack. Accessing parameters is done by manipulating the stack, which makes the code opaque after a year or so. Named constants and variables are all global. So, it is very difficult for a team to use, since most of the legibility of software comes from insightfully selected names. Two thirds of those names, at least, are missing in Forth.Like assembler, Forth is untyped.These failings could be at least partly forgiven if Forth was fast. But it isn’t, because most words are short and all the stack manipulations are done with subroutine calls. It’s possible to write an inlining, optimizing compiler, bu	wrycoder	15.001921	-3.846023	comment	3.0	20.0	1558669034	6.13526
19997873	As someone who has written a conside	"As someone who has written a considerable amount of Forth as a hobbyist, studied APL, and been paid to write K, it's fascinating to me how aesthetically similar the Forth and APL communities are, despite their languages approaching minimalism from completely different sides of the spectrum. I definitely credit learning to read Forth as helping to open my mind to the unconventionality of APLs. Spend enough time out there on the edge and you don't get as hung up on whether syntax resembles C or is ""unreadable""."	RodgerTheGreat	15.092681	-3.731656	comment	3.0	13.0	1558663587	12.963631
20107647	This is such a great observation.It 	"This is such a great observation.It makes me wonder if this can be solved technically by published curated language subsets. Racket does this by supporting a bunch of different dialects, specifically to make it easier to teach [0].One good do something similar for other languages. Step one is probably just writing a doc that says ""Here's a standard subset of C++ we call Blah. These are the features it uses and these are the ones it doesn't: ...""Then you could add tooling so that it will warn you if you use a prohibited feature.Of course, this just pushes the problem up a level: now a new user has to know which curated sublanguage to use. But that's arguably simpler than doing it on a per-feature basis. At least they can just order a combo instead of having to pick a la carte.[0]: https://d"	munificent	15.3593445	-3.6669402	comment	3.0	14.0	1559759397	13.645578
20197770	I think your dark age and gold rush 	I think your dark age and gold rush theory has some truth to it.  The whole industry culture and practices changed during that period, but we're starting to see things like people interested in Rust, even though it's not pitched as a faster way to make slicker generic Web sites and phone apps.I'm also hoping that Racket (which is is like a secret oasis community) will get more attention, and someone will dust off some old Paul Graham writings about startups and Lisp, and some startups (probably ones who're not just doing another cookie-cutter madlibs startup) will decide to use Racket initially.  (Disclosure: I have an interest in promoting Racket, because I'd love to help build startups in Racket, and also recruit top programmers with Racket as a carrot.)	neilv	15.351793	-3.6742542	comment	3.0	19.0	1560717812	13.626461
20208768	Curious how people who use this find	Curious how people who use this find it compares to an environment like Racket?	opnitro	15.372672	-3.6433682	comment	3.0	12.0	1560818295	13.657191
20217122	There was the Lisp-machines, Symboli	There was the Lisp-machines, Symbolics etc. I was lucky to be able to work on one. Then they went out of favor because of cheaper hardware that could run anything.But I wonder, what happened to the Lisp-machine software? Should it not be possible to run it on current day general purpose hardware even more snappily?	galaxyLogic	15.151243	-3.9250607	comment	3.0	12.0	1560885067	-10.357094
20221660	Naughty Dog games (up to Uncharted) 	Naughty Dog games (up to Uncharted) used to be written in a Lisp without garbage collection. The same guy then wrote the ITA flight search system. I think he may be the only productive Lisp programmer in the world.	astrange	15.146045	-3.8994045	comment	3.0	12.0	1560932404	2.14227
20231329	Reading PG's ANSI Common Lisp was a 	Reading PG's ANSI Common Lisp was a pivotal event on my career as a programmer. I wrote a high-resolution star map generation tool in CL about 14 years ago, and have been working on it and selling the maps it produces for many years.Now I am moving away from the things I don't do well (ranking in Google and promoting) to what I think I do best (making beautiful maps) with this new site, where I open the engine to people who want to add custom star maps to their own products.	juanre	15.142268	-3.9174452	comment	3.0	25.0	1561024893	4.670961
20255929	I'd like to play with this as it is 	I'd like to play with this as it is a free APL that I could use for work without paying a license (like Dyalog APL requires). J is another free array language, but it doesn't use the APL characters that I enjoy.I've had a little trouble in the past getting it to install (this was version 1.7) on Ubuntu. Granted I've never been an expert at installing from source, but a more in-depth installation guide or YouTube tutorial would help some.Thanks for doing this btw! I hope to eventually get to check this out!	6thaccount2	15.565792	-2.6942017	comment	3.0	23.0	1561301692	13.048046
20256468	When I was a young lad, the ink on m	When I was a young lad, the ink on my EE degree still wet, I worked with an older gentleman with a PhD, who used APL on an exotic computer with what looked to me like Sanskrit symbols (or space alien, for all I knew) on the keys. He gave me a couple tutorials but I never could wrap my brain around it. I lost interest and hadn't heard anything about APL for decades until now.I am curious how the symbols used in the language are mapped onto a standard keyboard. Also, does anyone use APL in battle or is it mostly an academic toy?	sizzzzlerz	15.560939	-2.6916368	comment	3.0	23.0	1561305864	13.079445
13628967	I happened to be at the 40th LISP an	"I happened to be at the 40th LISP anniversary conference 1998, with John McCarthy. Erann's JPL talk about the Remote Agent was by far the most interesting talk there, and I still consider it one of the best conference talks ever.
I'd really like to see the slides being published.I also attended this famous ""dinner with eric"" at the same conference, actually sitting next to Eric and Erann was sitting on the other side: http://blog.rongarret.info/2009/06/my-dinner-with-erik.html
I liked Eric a lot, and really enjoyed his troll interactions with Xah Lee, one of the most famous trolls ever. Unfortunately he didn't know exactly who to pick a fight with. Erann was clearly the wrong target. Erann hated it.
But as outsiders who stayed out of those silly fights we learned a lot, what boils in a LIS"	rurban	15.147254	-3.9191904	comment	3.0	11.0	1486915884	-10.386378
13658886	I tend to think of Racket as an alte	I tend to think of Racket as an alternative to Python, rather than a complement to it. C and Rust fit better the latter description.Racket is faster than CPython, but that isn't anywhere near the top of my list of reasons to use Racket instead of Python. When speed is a priority, Rust and MLton (Standard ML) are both much faster than Racket. But:(0) Racket is much more malleable than either Rust or SML. Rather than bash your head trying to model your problem domain in the existing language, you can redefine the language until it's the ideal tool for your problem domain.(1) Unlike other languages that also advertise malleability (Common Lisp, Smalltalk, etc.), Racket is malleable in principled ways, so you can define abstractions without figuratively stomping on abstractions defined by othe	catnaroek	15.360123	-3.662642	comment	3.0	36.0	1487241049	13.649693
13660594	And in terms of speed, Racket is gen	And in terms of speed, Racket is generally quite a lot faster than Python. I remember the days when rhetorically people almost assumed that poor execution speed meant higher-level abstractions that translated to greater developer productivity. Slow execution practically became a fitness function (I'm looking at the commentary during the early days of Ruby and Rails here).But with Racket you've got high-level, comparable-to-Python abstraction combined with way better performance today, and even better performance tomorrow. Plus as a bonus, the typed story is good.EDIT: In summary, even if performance wasn't your objective, you're still punching well above comparably high-level languages like Python.	peatmoss	15.356104	-3.6648386	comment	3.0	10.0	1487258921	13.651117
13695415	agree with you, apl is great for ML,	"agree with you, apl is great for ML, see this 6 lines Neural Network Example by apl with no deps:  https://github.com/ghosthamlet/ann.aplall code here:      l0 ← 4 3 ⍴ 0 0 1  0 1 1  1 0 1  1 1 1

      y ← 4 1 ⍴ 0 0 1 1

      syn0 ← 3 1 ⍴ 0.5069797399 0.5703818579 0.9265880619

      i ← 0

      e ← 2.718281828459045

      :While i < 10000 ⋄ i ← i + 1 ⋄ d ← l0 +.× syn0 ⋄ l1 ← 1 ÷ 1 + e * 0 - d ⋄ l1_err ← y - l1 ⋄ l1_delta ← l1_err × l1 × 1 - l1 ⋄ syn0 ← syn0 + (⍉ l0) +.× l1_delta ⋄ :EndWhile

      l1"	ghosthamlet	15.561614	-2.6938913	comment	3.0	16.0	1487685483	13.075354
13695098	APL in R	APL in R	ghosthamlet	15.566747	-2.6884658	story	3.0	84.0	1487682056	13.088782
13798508	I had some exposure to APL program f	I had some exposure to APL program for statistics few years back, but never really dived in. Largest problem being that the tools I encountered then didn't yield themselves well to intermittent exploration (indeed, Dyalog APL had Linux version that required Wine, which was very buggy). If somebody would like to give pointers on how to start with APL in 2017? I mean things pertaining to developer experience: such as what APL implementation is easier to start with on MacOS/Linux, how to find libraries and frameworks, good example app on Github etc.Though don't want to hijack this thread from questions specifically about the compiler + runtime. On the earlier thread (https://news.ycombinator.com/item?id=13565743) you mentioned two things I'd like to know more about:- function trains: any exam	jarpineh	15.562372	-2.7090957	comment	3.0	22.0	1488746843	13.089536
13857014	"Is ""hold forth"" an older or less com"	"Is ""hold forth"" an older or less common phrase? I don't know if I've ever run into it, and I wouldn't have guessed initially that is its definition."	yladiz	15.038809	-3.8061175	comment	3.0	11.0	1489406752	6.098259
13919365	Sarabander's edition is definitely a	Sarabander's edition is definitely a huge credit to it's author: It isn't just a reprint of SICP; The text and it's font has been updated, many of the diagrams have been redone for clarity and the document and footnotes are hyperlinked.If it's your ambition to follow in the footsteps of others or otherwise just prefer the classic Lisp-haqr experience, you can use a TexInfo version of SICP and have both the text and your REPL in Emacs: http://zv.github.io/note/sicp-in-texinfoAlso, just to pimp my own ride: I put together a SICP guide for new explorers of this great text: https://github.com/zv/SICP-guileIt contains both meta-information about which dialects of Lisps and languages are most suited to SICP, overviews of subchapters, helpful hints for those who are following along at home as wel	ZephyrP	15.18452	-3.754999	comment	3.0	11.0	1490063132	12.938353
13953108	Speaking of the lisp family... I don	Speaking of the lisp family... I don't know how it's implemented, but Racket has a cross-platform GUI story that, based on some of my cursory explorations, seems to be good. DrRacket is presumably built on it, and that's a non-trivial cross-platform app.http://docs.racket-lang.org/gui/index.html	peatmoss	15.288822	-3.7558086	comment	3.0	11.0	1490398363	13.650919
13959137	Really what does this have to do wit	"Really what does this have to do with APL ( Ken Iverson )??*This is NOT APL.Futhark is a functional language, we will start with the obligatory factorial program:fun fact (n: i32): i32 = reduce () 1 (map (1+) (iota n))This has nothing to do with APL.Perhaps a more apt title would be ""Python for the GPU"".j*There is a paper on this subject, where an APL interpreter is written in FUTARK, but then most compilers are written in C. In reality the technology in question is Futark on GPU.https://futhark-lang.org/publications/fhpc16.pdf"	bike4beer	15.557649	-2.6994379	comment	3.0	11.0	1490502369	13.09219
13977419	"""APL, and its successor J [...] prov"	"""APL, and its successor J [...] provide a notational interface to an interesting model of computation: loop-free, recursion-free array processing.""  How is APL loop-free, exactly?Later they say: ""Under this implicit lifting, the iteration
space is the argument frame rather than a sequence of loop indices.""  So if I understand correctly, we have iteration, but no loop.  But that doesn't seem like a really important distinction...what am I missing?"	jtraffic	15.563372	-2.698158	comment	3.0	17.0	1490714989	13.032916
13981707	How does Common Lisp compares to Rac	How does Common Lisp compares to Racket nowadays? I've seen a lot of activity but I can't decide which one to try out. I only have time for one of them ATM.	edem	15.312119	-3.7341065	comment	3.0	14.0	1490742343	-7.437584
13982370	1. Racket is a multi-paradigm progra	"1. Racket is a multi-paradigm programming language. It has Java-style class/object system, a CLOS-like object system(swindle) and a  prototype object system (like self and JavaScript).
2. The macro system is arguably the most sophisticated available. 
3. Functionsl programming! including '(purely)Functional Data Structures'. 
4. Parallelism (futures)
5. concurrency
6. Contracts
7. Typed Racket
8. Pattern matching
9. Modules
10. Units
12. Pattern Matching
13. Exception, continuations
14. Reflection
15. arguably the most sophisticated tools for creating full languages and DSLs
16. Datalog language (like in datomic)
17.an amazing IDE - it has a tool to debug macros! (but you can also use Emacs)
18. Typed Racket
19. Functional pictures (pict)
20. OpenGL 
21 cross platform (win, mac, Unix, Linu"	spdegabrielle	15.332978	-3.694324	comment	3.0	10.0	1490749302	13.641695
30727627	Before APL, There was Notes on the S	"Before APL, There was Notes on the Synthesis of Form in 1964.
https://en.wikipedia.org/wiki/Notes_on_the_Synthesis_of_Form"	getpost	15.567904	-2.685459	comment	3.0	10.0	1647638187	13.128031
30813916	Anyone interested in the computing h	Anyone interested in the computing holes that can be filled by lisp machines should check out Urbit. There is an vibrant and growing community of people building a network of personal servers running a lisp-like functional OS. It uses an identity system secured by the Ethereum blockchain and it has created a bottom up economic incentive for developers to participate. They are starting to solve unique problems that couldn't be addressed on currently prevalent platforms. Urbit is an affirmation; we can ditch the nihilism.	GregorMendel	15.212433	-3.8622713	comment	3.0	13.0	1648317875	-10.507258
30907806	Thank you for this.What do you make 	"Thank you for this.What do you make of BQN? 
https://aplwiki.com/wiki/BQNI get enamored with apl/k/j every time I see it and was looking for excuses to use it despite everything.I understand that due to the much smaller community the tooling and ecosystem is much weaker but there must be a reason why some people keep reaching for it, especially the guys in finance. I don't get the Cobol vibes from it like it is some sort of legacy burden. While the use case is narrow there must be an edge.This is HN after all. You wouldn't tell people not to mess with lisp and just reach for python now would you? *puppy eyes stare*"	recuter	15.556293	-2.7121527	comment	3.0	22.0	1649086253	13.055547
31016976	">If you're ""doing it right"" your cod"	">If you're ""doing it right"" your code is evolving towards something like the Kolmogorov complexity of the domain/problem.Any pointers to where this is elaborated on more precisely?Specifically, I'm skeptical about the universality of the claim, Forth allows you to approximate the essential complexity of _any_ problem ? I'm not an enemy of Forth but every language must surely make some things awkward right?"	Banana699	15.02449	-3.8242717	comment	3.0	10.0	1649868541	6.0803366
35028261	Notation is important and incredibly	Notation is important and incredibly valuable.  If you are abandoning notation, as J did, that’s a mistake.If you search for APL and my username in HN you should be able to find opinions on this going back several years.	robomartin	15.563826	-2.6968246	comment	3.0	16.0	1678010664	13.081267
35085617	European Lisp Symposium 2023	European Lisp Symposium 2023	gjvc	15.15449	-3.9284866	story	3.0	114.0	1678390826	-10.466931
37153890	I know nothing about APL. But I thin	I know nothing about APL. But I think I would write it the same way as the OP. I also think use len is better to convey counting operation:len(age for age in ages if age > 17)	aynyc	15.5655575	-2.6903322	comment	3.0	16.0	1692220252	13.087847
37499679	So basically Emacs with Elisp replac	So basically Emacs with Elisp replaced with Fennel and a more responsive UI...	ducktective	15.108114	-3.887722	comment	3.0	15.0	1694628349	-10.365997
37514943	This has been available in Lisp sinc	This has been available in Lisp since at least 2004.https://github.com/edicl/cl-ppcre/	nemoniac	15.107722	-3.9014761	comment	3.0	12.0	1694726076	-10.372931
29057773	> A lot of people go through guides 	"> A lot of people go through guides of writing a lisp, I'd love to urge people to try writing a simple Forth interpreter instead, or even something somewhat related such as TCL.See, that's the problem. Writing a Forth interpreter, to be blunt, is not writing in Forth. You should be writing applications in Forth, not interpreters. It's great to marvel at the simplicity of a Forth interpreter, until you have to use it in anger for an actual application.I've made several semi-serious ""hobby"" stabs at working with Forth, and, for me, it's a tough row to hoe. I look at something like F83 and marvel that someone was able to pull that off in that environment. I simply don't think I've used it enough and cross the line where I'm not constantly fighting...something to get anything done and thus my "	whartung	15.102808	-3.89539	comment	3.0	11.0	1635694971	-10.474918
29106109	APL Since 1978 [video]	APL Since 1978 [video]	tosh	15.567861	-2.68783	story	3.0	58.0	1636027875	13.101025
29134864	I've been able to use Racket to buil	"I've been able to use Racket to build an option trading application (https://github.com/evdubs/renegade-way). The included GUI and Plot libraries have been really nice to use.With Racket, I miss having real threads and rich ""batteries included"" data structures as you'd find in Java and C#."	evdubs	15.348206	-3.6582515	comment	3.0	18.0	1636241375	13.654842
29256334	"  > Learning Lisp is on my ""bucket l"	"  > Learning Lisp is on my ""bucket list"", I know where to go to learn it but I need the time :) 

Where?"	dotancohen	15.164014	-3.926958	comment	3.0	10.0	1637171462	11.079798
29259070	It's about as fun and easy to implem	It's about as fun and easy to implement a simple thing that looks like a forth as it is to implement a simple thing that looks like a lisp. But that's where the ease of forth ends for me.I find forth basically impossible to read even when, at best, authors leave a comment on basically every 1-2 words. Writing it is pretty hard too.In contrast it's about as easy to be productive in a lisp (CL or Scheme) as it is in Python or JavaScript (give or take useful 3rd party libraries).Even if they're from the same time period and are interesting for being not very Algol-like, I don't think it makes a lot of sense to discuss Forth and Lisp in the same conversation. They were both improvements on very different things.	eatonphil	15.091406	-3.8722315	comment	3.0	63.0	1637184591	6.0909333
29261053	Good programming in Forth is all abo	Good programming in Forth is all about scope. As soon as you make a word do too much you will end up with all of the problems you listed. But if you keep your scope down, not for elegance but simply to avoid cognitive overload and the potential for errors then you can get very far before any of this becomes an issue, and the amount of bang for the buck is very large.Forth programs tend to have a pretty distinct style, closely related to whoever wrote them. Some see this as an advantage, for others it is a huge drawback because they can't or won't put themselves into a mental model that is non-obvious at first reading. This is however not a defect, it is pretty much the intention: Forth is a language to create DSLs, the words you define make up that new language and that is the language tha	jacquesm	15.045984	-3.8187191	comment	3.0	24.0	1637198534	6.1287208
29348924	Paper is acm-walled but code repo is	Paper is acm-walled but code repo is https://github.com/udem-dlteam/ribbit .  I would like to have seen Hedgehog Lisp ( https://github.com/sbp/hedgehog ) in the comparison chart, since it has actually been used for practical projects.  Its VM is around 20KB of object code.  4KB is impressively tiny, but any machine where 4k vs 20k makes a big difference is unlikely to have enough ram to run garbage collected applications.  That seems to call more something more like Forth rather than Scheme.Hedgehog is a somewhat weird functional dialect of Lisp and I've been wanting for a while to convert it to a Scheme subset (mostly just using Scheme syntax instead of defun, etc) so people would be more familiar with it.Added: paper is here  http://www.iro.umontreal.ca/~feeley/papers/YvonFeeleyVMIL21...	throwaway81523	15.194227	-3.879419	comment	3.0	16.0	1637921637	13.633435
29404488	APL is the language I only ever see 	"APL is the language I only ever see around AoC. But it's so impressive too. Like the first part of today's solution is ""+/¯1↓x<1⊖x"" (stolen from someone on Reddit) and I'm like.. ok, I need to learn this language one day.(Since their solution is now being discussed, it's from here: https://www.reddit.com/r/adventofcode/comments/r66vow/2021_d...)"	petercooper	15.564257	-2.6954832	comment	3.0	11.0	1638372028	13.1356535
29529077	I really wanted to love this article	I really wanted to love this article and the author's ideas but couldn't help feeling like it was a rediscovery of some LISP principles while keeping some contemporary development practices. Food for thought, for sure.	Werewolf255	15.152483	-3.930145	comment	3.0	10.0	1639312630	-10.481204
35917181	Unfortunately (missed opportunity): 	"Unfortunately (missed opportunity):        ""APL""+1
    ""BQM"""	ithkuil	15.564646	-2.6898103	comment	3.0	17.0	1683903260	13.092483
36241731	Oh boy.> Guile is also the default e	"Oh boy.> Guile is also the default extension language for the GNU project.AFAIK Guix is the only project that uses Guile and has any actual users (I'm not counting Shepherd because outside GuixSD it is nothing).  Guile is like 30 years old, and has been envisioned as ""the default extension language for the GNU project"" all that time (I was an active contributor for a while, so I should know).  Guile is not even used by Emacs; Guile extensibility support in GDB is not even commonly built by distros.  Guile is a nice and very competent Scheme implementation and I'd love for it to be useful outside Guix, but that's just not the case, and repeating that slogan won't change it.  Seriously, just stop.> It is the old freedom and responsibility problemNo, it is not.  Software development is a soci"	cmm	15.19331	-3.7817235	comment	3.0	26.0	1686231673	-10.233918
36439453	IMHO the mathematical language is an	"IMHO the mathematical language is an impediment for learning math for exactly this reason.  It's chock full of cryptic symbols with no obvious meaning that make it incomprehensible to anyone who has not taken years to learn it and also surprisingly difficult to enter into a computer.  Math is hard to read because quill pens were difficult to use and much of the syntax was made up on the spot by people who were better at thinking mathematically than communicating ideas.  But so many people have spent the effort to learn it that nobody wants to create a ""dumbed down"" version that a layman might understand.It is kind of like everyone in the 60s decided that APL was the one true computer language and all interest in other languages died off entirely and when anybody complains about the syntax "	jandrese	15.565004	-2.694083	comment	3.0	15.0	1687470102	13.066976
36542339	It's disappointing that this is the 	"It's disappointing that this is the state of things from a ""working programmer"" perspective.Racket is, as far as I understand, a research and teaching language, as well as a viable scheme.I've used it for some [command line tools and side projects][1], but I never tried to deploy anything with it.Maybe a new [Chez][2]-based (as Racket now is) scheme is needed: one with much of Racket's nice syntax system, but focused on dependency management, targeted solely at ""production"" use, and other Serious Business Purposes.Not it!I'm not saying that Racket isn't a serious platform -- far from it. But the author's concerns, while expressed as a hot take, might be why Racket doesn't see wider industry adoption.Or maybe it's a chicken and egg problem.[1]: https://github.com/dgoffredo?tab=repositories&"	MathMonkeyMan	15.357147	-3.6617184	comment	3.0	19.0	1688159476	13.639238
25896219	What is Racket primarily used for? I	What is Racket primarily used for? I'm not sure where it fits in the language landscape in terms of strengths/weaknesses.	sachanganesh	15.361841	-3.6527927	comment	3.0	10.0	1611523439	13.6522045
26015364	I think using Racket should be avoid	I think using Racket should be avoided because of its problematic community. I've had disgusting experiences interacting with people from Racket community in the past, but so far I thought I was the only one. Unfortunately, it doesn't seem that way. Recently, a computer Scientist Leandro Facchinetti described in his video his ugly experiences with top people in Racket community. The experience was such that he completely gave up his PHD and the use of Racket forever. You can view the video here: https://www.youtube.com/watch?v=_wY7FBtr7_c In the video Leandro Facchinetti says: Speaking of people, it's very sad that I had same bad experiences with some people in the Racket community, especially the people up top because they are the kind of people who are smart and they know about it and th	yaleL	15.358762	-3.662779	comment	3.0	11.0	1612370140	13.625352
26029902	If you're interested in recent devel	If you're interested in recent developments in array languages, I recommend checking out:BQN https://mlochbaum.github.io/BQN/ngn/k https://git.sr.ht/~ngn/k/tree/master/item/readme.txt (Previous discussion: https://news.ycombinator.com/item?id=22009241)aplette, which is a modernization of Ken Thompson's APL (with a LOT of projects in between them; Ken's APL interpreter -> ? -> OpenAPL -> aplette) https://github.com/gregfjohnson/aplette (Previous discussion: https://news.ycombinator.com/item?id=21740536)I'd also recommend checking out J, which isn't a recent dev	kick	15.559318	-2.7042842	comment	3.0	15.0	1612473400	13.043242
26166640	I'm amazed that it worked so well, i	I'm amazed that it worked so well, it did confuse me that each repl didn't know the previously defined functions, is that just me?Forth is almost the postfix inverse of lisp. Instead of arity errors, you have stack over and underflow.  And it only has one list, instead of lists of lists.Oh, and it's not garbage collectedOh, it it's not homoiconic{edit]I guess it's really not the same thing at allAmazing how a day's exposure to Racket shifted my opinion	mikewarot	15.319554	-3.7224329	comment	3.0	13.0	1613572334	13.648251
31055611	New Racket Build System	New Racket Build System	todsacerdoti	15.368468	-3.6397338	story	3.0	61.0	1650139274	-9.553276
31203563	LISPer looks at this and rolls his e	LISPer looks at this and rolls his eyes. Pfft. Muggles.	twjerh34234	15.142108	-3.9103985	comment	3.0	16.0	1651229190	-10.49024
31230891	I'm fascinated by Racket-lang team's	I'm fascinated by Racket-lang team's constant updates. It feels like there is always some activity in that space. Does anyone know about any companies where it's used in production environments? Is it particularly good for certain use cases? Thank you.	jp0d	15.362855	-3.6539488	comment	3.0	16.0	1651459518	13.648115
31230954	SICP uses Scheme. Racket is a rather	SICP uses Scheme. Racket is a rather different, much larger language.Racket's default #lang isn't even compatible with SICP -- for example its cons cells aren't mutable. (Though it's perfectly fine to use Racket tooling with SICP or other Scheme books -- just set #lang scheme instead of #lang racket).	perihelions	15.362038	-3.6596038	comment	3.0	15.0	1651460140	13.628683
31231730	Is Racket a practical competitor for	Is Racket a practical competitor for Common Lisp yet?	User23	15.3234825	-3.71806	comment	3.0	14.0	1651469233	13.716475
31231055	Absolutely not.SICP is a fun way for	Absolutely not.SICP is a fun way for a mathematically-strong person to learn a huge swath of computer science through experimentation and thinking about the results.You have to not just _do_ the exercises but _understand the results_. It's not an easy on ramp.You would be better off working through the Racket Guide [1] or one of the tutorials on their web site.[1] https://docs.racket-lang.org/guide/index.html	fn-mote	15.352608	-3.629921	comment	3.0	23.0	1651461124	13.422203
31362403	Since other array languages are bein	"Since other array languages are being brought up already, here are two things K does that you won't find anywhere else in the APL family as far as I know:- Dicts (same as hashmaps, associative arrays, etc.) are a native datatype, with `ab`cd!0 1 indicating a dict mapping symbols `ab and `cd to 0 and 1, for example. In K4 and later (ngn/k implements K6), array primitives work on them to do all sorts of fancy things. For example prefix &, ""where"", returns the indices of any 1s in an array. If given a dict, it gives you the keys corresponding to 1s.- Partial application. If you have a function f of two arguments, f[;x] binds the second argument x to f, but leaves the first one unbound. So f[;x][y] is f[x;y]. But that's not nearly all: arrays, dicts, and functions are unified, so if fs is a li"	mlochbaum	15.557222	-2.7025402	comment	3.0	12.0	1652407298	12.980387
31378823	Array notation is great, but only fo	Array notation is great, but only for single array operations and for dense array operations.The moment you need to run complex group bys and store non-contiguous data efficiently, it gets awkward pretty quick.On the other hand, operations on dense data is pretty cumbersome in SQL. You can only do so much with limited support of proper scan algorithms, merge joins or bolted on window functions.Please somebody combine APL with SQL and you win the programming language wars.	snidane	15.558721	-2.7027566	comment	3.0	10.0	1652541759	13.066608
31380292	I was just playing with Nils M Holm'	I was just playing with Nils M Holm's Klong this morning: https://t3x.org/klong/index.html  (Klong rather than the others mostly because the C implementation looks like C so I have a ghost of a chance of actually grokking it.)These folks are really onto something, but I think they get sidetracked in the (admittedly very very fun) minutia of the languages and lose sight of the crucial insight in re: mathematical notation, to wit: it's a means of human communication.For APL or K to get out of their niches would require, I am convinced, something like a tome of documentation of a ratio of about 1.5 paragraphs per line of code.  That would give us mere mortals a fighting chance at grokking these tools.A similar problem plagues the higher-order stuff they're pursuing over in Haskell land.  I kn	carapace	15.560836	-2.6964192	comment	3.0	17.0	1652549533	13.081693
31497496	Author of this blogpost here.  I thi	"Author of this blogpost here.  I think the post is good, though it's mostly aimed at the perspective of ""Racket is a very practical Lisp, for getting things done, akin to how Python is a very practical lisp"" and also ""DrRacket gives an accessible entry-point for Lisp for newcomers.""  Unfortunately I don't think Racket quite took this to be the rallying cry I hoped them to, to embrace Racket's lispiness as ""The Python of Lisps"" (which was the other alternate title I was debating between when I wrote it).But in the comments here and as with most articles about Lisp, the conversation moves to... can newcomers understand Lisp's syntax?  My spouse and I gave a talk about this very topic: ""Lisp but Beautiful; Lisp for Everyone"". https://fosdem.org/2022/schedule/event/lispforeveryone/There's a lo"	paroneayea	15.169237	-3.9232736	comment	3.0	37.0	1653426078	-10.420431
31501118	I think I must be really bad at comm	"I think I must be really bad at communicating, because you aren't responding to any point I was trying to make.  Let me try again :-)I think Racket, Scheme, and some Lisps are conceptually elegant, but they don't read well to people like me (or apparently the poster above).In particular, your snippet of code has 3 different indentation strategies, and you hang your closing parens the way almost all Lisp programmers do.  To me, it all looks so organic and arbitrary.So, for those of us who don't like to read other people's Lisp - is it because of the parens?  Or is it because the conventional Lisp style is alienating to us?I really think it's the style.  I'd rather read your example like:    (defun bottles-verse (n)
        (flet
            ((bottles (:match)
                ((0) ""No bottle"	xscott	15.183732	-3.896844	comment	3.0	27.0	1653458726	-10.378277
31558547	What do you recommend to learn APL a	What do you recommend to learn APL and K?	yakubin	15.563217	-2.6985497	comment	3.0	14.0	1653915848	13.085031
31560564	one really nasty conflating issue is	one really nasty conflating issue is that emacs uses a mess of globals. partially because of the domain but largely because of dynamic binding and the lack of namespaces.emacs really needs to be hoisted onto another language and runtime. everyone says this but no one can really conceive of doing this and rewriting or at least refactoring all the elisp extensions.I guess guile emacs is still alive? I should really try installing it	convolvatron	15.193544	-3.8008125	comment	3.0	10.0	1653927630	-10.340692
31637253	I came here expecting at least some 	I came here expecting at least some mention of Forth. What a nice language that allows you to redefine most of the provided keywords!	jmccorm	15.044096	-3.8051019	comment	3.0	12.0	1654489799	5.988308
14007271	Why not just use one of the Common L	Why not just use one of the Common Lisp flavors then? Racket has been rising in popularity last few years: https://racket-lang.org	aduffy	15.312691	-3.7342706	comment	3.0	14.0	1490988389	13.659784
14121066	Tennis racket theorem – Wikipedia	Tennis racket theorem – Wikipedia	rbanffy	15.377694	-3.626556	story	3.0	14.0	1492269243	13.652512
14170027	Doesn't Typed Racket work on the sam	Doesn't Typed Racket work on the same basis?	moomin	15.358702	-3.6651196	comment	3.0	12.0	1492814703	13.657912
14242481	Meta-syntactic programming with Rack	Meta-syntactic programming with Racket: string interpolation	klibertp	15.326425	-3.7094092	story	3.0	67.0	1493679119	13.638817
14248419	Lively Linear Lisp – 'Look Ma, No Ga	Lively Linear Lisp – 'Look Ma, No Garbage' (1991)	breck	15.156036	-3.926496	story	3.0	131.0	1493745875	-10.445836
14436269	I'm probably wrong here, but I wonde	I'm probably wrong here, but I wonder. Why go outside the haskell type system, but still use haskell.As I see it, haskell is all about the type system, and macros are all about circumventing the limits of the type system. These things seem at odds.I have to admit I have no idea what racket is, nor did I do much more than scan the article.	rocqua	15.345312	-3.6955416	comment	3.0	16.0	1496008912	13.630673
14516792	I'm curious about Forth, as it's pro	I'm curious about Forth, as it's probably the most important language I've never learned. I've done a fair bit of low-level, micro-optimised coding in C and assembly, but don't get much time for that kind of thing these days.How would you describe Forth in relation to those? What makes it stand out and what are its weaknesses?	robert_tweed	15.034497	-3.8170729	comment	3.0	24.0	1496952196	6.080826
14528319	"""Whither Software Engineering?"", dis"	"""Whither Software Engineering?"", discussed in the OP, sounds like an interesting historical piece about how long it took for mathematics to be integrated into engineering work. The author is John Allen, who wrote Anatomy of Lisp.Can anyone find that paper online? https://news.ycombinator.com/item?id=962733 points to a blog post about it from 2009, but none of the links seem to work."	dang	15.149468	-3.9281523	comment	3.0	10.0	1497117237	-10.472241
20414584	While I prefer my languages statical	While I prefer my languages statically typed, if you're going to use a dynamically typed language, Racket is far superior to Python.	trurl	15.351616	-3.6775577	comment	3.0	22.0	1562872425	13.640396
20414650	While I'm impressed with racket on t	"While I'm impressed with racket on the whole, I can't quite agree to be impressed by the GUI bits. They're extremely limited, and once I got away from ""how do I put a button on the screen"" I didn't find the underlying implementation lent itself to being extended. In particular the drag and drop system only goes as far as file drops, and I quite quickly hit a brick wall trying to add anything more interesting."	regularfry	15.366737	-3.6464984	comment	3.0	31.0	1562872743	13.660614
20414806	Python runs on iOS, Racket does not.	Python runs on iOS, Racket does not. The need for a JIT to make Racket performant also makes it unlikely that it ever will.	nickmain	15.363328	-3.6575944	comment	3.0	11.0	1562873379	13.645828
20414954	A big use case for python is glue fo	"A big use case for python is glue for high performance c/c++ code. How is racket at this? Also, is there a cython alternative for racket? I would also argue that, though racket may have more batteries included, there are definitely not as many externally developed libraries. Especially important are numpy/scipy/pandas/pysam, the list could go on...
That's not to say that I'm against racket, I really like the language and its level of design and documentation."	lkirk	15.358579	-3.6653247	comment	3.0	26.0	1562873954	13.649733
20415708	If racket is an acceptable python an	If racket is an acceptable python and python is an acceptable lisp, then racket must be an acceptable lisp?	taloft	15.285871	-3.7701015	comment	3.0	10.0	1562878328	13.647004
20417425	Racket is great if you are looking f	Racket is great if you are looking for a high quality general purpose language, but if you want to use important python libraries for pythons's popular use cases: numerical/scientific computing, data science/ai, etc., then Hylang is a drop-in replacement with the added benefit of Metaprogramming facilities (Lisp-2 macros) and Clojure-like semantics.Python and Hy have 100% interoperability. Python can call Hy out of the box, and Hy can call Python out of the box.Any Python programmer can pick up Hy basics in minutes, and will be productive in a matter of hours. If you are an intermediate level Python programmer and have experience with Lisp macros, you will be writing macros in no time as well. Writing macro wrappers for numerical/scientific applications can increase your code's signal to n	epr	15.343608	-3.68348	comment	3.0	10.0	1562895846	13.649599
20446956	I've been hearing nothing but good t	I've been hearing nothing but good things about Racket for the last few years. I finally downloaded it last month. It really just puts a silly smile on your face. The language-oriented programming is terrific too. I really want to find ways to integrate Racket into my work.	threepio	15.357712	-3.6638677	comment	3.0	22.0	1563243052	13.64593
20449102	(I am referring to Lisp here as most	"(I am referring to Lisp here as mostly the Common Lisp and the Scheme variety)There is also the issue where are a lot of areas like UX and tooling  requires boring engineering work that no wants to put in. Dependency management, language servers, static analysis etc.Scheme is stuck in academia; its creators are more interested in forcing language constructs like Continuation Passing Style onto end users rather than fixing ecosystem problems. Despite having a multitude of standards, every Scheme has to roll its own dependency manager. Chicken libraries aren't directly compatible with Gambit and good luck with Racket's licensing.Quicklisp is relatively recent and a lot of books that are considered ""standard reading"" are so old that they don't mention it. Simple things like exporting a binary"	sansnomme	15.182298	-3.879603	comment	3.0	10.0	1563276715	13.649839
20604592	"To contrast with most of the ""write "	"To contrast with most of the ""write your own small text editor"" articles out there, I feel compelled to post this:http://kparc.com/$/edit.kThis is a text editor written in K, an APL-family language. Determining how it works is left as an exercise to the reader. I wonder whether an explanation would be longer or shorter than the tutorial in the article..."	userbinator	15.537743	-2.7043116	comment	3.0	21.0	1564896614	13.046801
20630459	The mailing list traffic on this top	The mailing list traffic on this topic took the wind out of my sails for wanting to spend my tinker time in Racket. On the one hand, it’s probably overreacting for me to throw in the towel on Racket at just the suggestion of this change. On the other hand, part of what makes me interested in writing Racket for projects where I have broad latitude is the sense that I’m both using an exciting technology, and a technology with a history of relative stability.By signaling a switch to some bland surface syntax I feel that it’s eroding the exciting part as well as the stability benefits of the language. For data science (the domain I’m most invested in) Julia has attracted a decent mindshare, is lispy (even if not as much as I want), and is fast. Racket with a bland syntax is likely to be about 	peatmoss	15.345727	-3.683455	comment	3.0	14.0	1565131855	13.639833
20646030	And before any says it, yes, I do lo	And before any says it, yes, I do love the idea of students EVENTUALLY learning a Lisp/Racket kind of language before they graduate. I would even be happy with an entire course dedicated to it. But I don't want that to be the CS1. I've just seen it go so wrong for so long now.	acbart	15.144454	-3.9269814	comment	3.0	12.0	1565282151	-10.384371
20646536	The opening does leave a sour taste.	"The opening does leave a sour taste.   You ack that there is little research, and then claim a pragmatic position.Your data section is compelling.  Though, it reads close to the same arguments for why kids shouldn't learn calculus in grade school.So the questions I would have to counter this would be:  * How stable has racket been compared to the alternatives?

Specifically, how many texts in Java and python taught methods that are actually not good for user in industry?  This is ironic, as the argument is they would be using an industry language.  But they aren't, really.  They are likely using an ancient dialect of an industry one.  Heaven help you if you picked JavaScript.  * Is there any data about how well the students do following each language choice?

In particular, this should be "	taeric	15.351425	-3.6666644	comment	3.0	14.0	1565285335	13.645153
20644872	Given the Racket2 possible massive s	Given the Racket2 possible massive syntax changes it seems that using JavaScript was a better choice for a commercial project. That being said I very much prefer Racket to JavaScript for personal/hobby projects.	AlexeyBrin	15.357885	-3.6635137	comment	3.0	16.0	1565274362	13.634816
20755000	The with-solved-problem macro shows 	"The with-solved-problem macro shows how (in this case, I think termed ""unhygienic"") Lisp macros allow fancy stuff with the code-is-data approach.The first argument seems to be a normal Lisp expression, with no special syntax, and the second argument has the solution variable and all the variables mentioned in the expression bound to (the solution object, the values of the variables in the solution it found).This approach is obviously available for everything. You can just use fully-flexible S-Expressions as essentially function arguments, and the function can modify the variables / identifiers in scope during execution of it's arguments.It makes me want to do more with Racket again..."	namibj	15.29225	-3.7556703	comment	3.0	11.0	1566369418	13.644091
23800857	Apparently guile is clearly the stro	Apparently guile is clearly the strongest character in the game, that makes some sense... but apparently at high level Dhalsim is the second strongest by consensus.Now that's a surprise!	syspec	15.185571	-3.765487	comment	3.0	13.0	1594461487	-10.241661
23812437	This nicely provides empircal eviden	This nicely provides empircal evidence on the slowdown of using Forth, which seems to be around 10 to 20 times slower than optimized assembly. I was initially surprised by how poorly Forth performed on all counts of speed, memory usage and development time.  For something as complex as a game the lack of a type system and postfix nature make Forth quite unsuitable.When I use Forth, it's often for high-level applications[0] with the performance critical words written in assembly. So this keeps the complexity relatively low as opposed to writing the whole thing in Forth.[0] https://github.com/siraben/zkeme80/blob/master/src/bootstrap...	siraben	15.027473	-3.8294587	comment	3.0	16.0	1594570896	6.164697
23905062	> Emacs Lisp, or Elisp, is generally	"> Emacs Lisp, or Elisp, is generally hatedThat seems unnecessary; of all the options above, it might be the one seeing the /most/ active development, and (given that ""Guile-macs"" isn't happening anytime soon) will continue to be in active development for a long time to come."	agambrahma	15.136646	-3.8717365	comment	3.0	15.0	1595317427	-10.343363
24283792	I'm relieved they didn't change the 	"I'm relieved they didn't change the documentation. Hard to improve on perfection. https://docs.racket-lang.org/pkg/index.htmlAlso, I chuckled a bit at the ""Jet Fueled"" tagline. Racket's green threads operate with a ""fuel"" which gets consumed over time, at which point it yields to another thread. I think the metaphor was a happy accident rather than an intentional nerdy reference, but still."	sillysaurusx	15.361563	-3.6599026	comment	3.0	27.0	1598458054	13.6526165
24341068	It's been out a long time. I was pla	It's been out a long time. I was playing with it in 2012 and I think it'd already been out a long time at that point. I think there is a blog post somewhere about a university student programming candy crush (or some other game) the night before it was due in NewLisp. Racket might also be worth a look again at some point. It's certainly heavier, but has a much larger community.Picolisp is also really awesome and weird like NewLisp, but is really only for Unix. It is also small, but has plenty of features, and has been in development and supported since the late 80's. It is all written in C or Assembly (can't remember which one it is currently written in) and has built-in support for logic programming and all sorts of other things. It uses web browser for GUI, and can interop with Java and 	7thaccount	15.169589	-3.8847451	comment	3.0	11.0	1598963417	13.635945
33638791	What about using like a Wacom drawin	What about using like a Wacom drawing tablet in order to interact with APL?I've never tried any of the Iverson-verse languages but the non-ascii inputs seem daunting and cumbersome.	adenozine	15.563408	-2.692508	comment	4.0	12.0	1668692869	13.076127
33640275	There are a lot of comments of the t	"There are a lot of comments of the type ""it's unreadable/write-only/unmaintainable"" here. It's a natural reaction; I know, I was there. It looks different. But readability is in the eyes of the beholder, not the language. I made this point in my APL book (https://xpqz.github.io/learnapl) -- just because I can't read Japanese does not make Japanese unreadable. Since I wrote that book, I've spent a few years immersing myself in APL, gradually rewriting thousands of lines of Python into APL, and it's such a productivity boost. My code is an order of magnitude smaller. More, sometimes. Fast, too.For the right use cases, it's unbeatable. Sure, you probably wouldn't want to write an OS kernel in it, but anything that reads a bunch of data, mashes it up, and spits out some result, APL is a hand-i"	skruger	15.561692	-2.6971066	comment	4.0	33.0	1668699077	13.102937
26638812	> [1] Why aren't we all writing in A	"> [1] Why aren't we all writing in APL/K/J if it matters that much?Because most programmers aren't nearly as productive as we could be.And because ""concise"" should be measure in the number of tokens needed to achieve certain functionality, not by excessive use of single character tokens."	jimbokun	15.563531	-2.6952934	comment	4.0	16.0	1617130723	13.077651
26670734	A Critique of Common Lisp (1984) [pd	A Critique of Common Lisp (1984) [pdf]	susam	15.157523	-3.9281013	story	4.0	22.0	1617365092	-10.423135
27074538	As an imperative, stateful and even 	As an imperative, stateful and even sometimes OOP developer, always finding functional programming very elegant but never really using it for real, Racket was the Lisp dialect that finally hooked me in.I think the reason was because it came with batteries included and I could create complex applications using only the standard library or very few packages.	vascocosta	15.348129	-3.6836634	comment	4.0	24.0	1620385182	13.651447
27394223	Is there a modern reincarnation of A	Is there a modern reincarnation of APL with similarly terse but clever syntax?	yewenjie	15.563548	-2.6988673	comment	4.0	14.0	1622818654	13.046657
27461558	I suppose if arrays language get pop	I suppose if arrays language get popular enough, we will get a module to use them as a DSL for libs like numpy, just like we have regex for strings, instead of a whole language dedicated for them.It would be a win / win, you gain the strength of J, K and APL for array processing, without the weakness of them for anything else.And just like with regex, you'll get fat disclaimers in doc telling you to not get carried away too much as it can quickly become unreadable.	BiteCode_dev	15.541666	-2.7215154	comment	4.0	20.0	1623337409	13.004543
27462419	It what ways is J an abomination? AP	It what ways is J an abomination? APL (and to a degree J) are on my bucket list of languages to learn. I’d always read that J was a sort of spiritual successor to APL.	sswezey	15.553281	-2.7029142	comment	4.0	25.0	1623341951	13.0643635
27462733	Does anyone know of an input method 	Does anyone know of an input method for APL that works similar to an IME that you would use for Japanese?Basically you type the name of the operator in latin characters and get the proper symbol autocompleted.I only see direct key to symbol mappings which might be fine for a full time APL dev but offer a bit too much of a learning curve for just trying it out.	cardanome	15.565297	-2.6917837	comment	4.0	12.0	1623343541	13.08063
27484591	APL – A Glimpse of Heaven (2006)	APL – A Glimpse of Heaven (2006)	tosh	15.565318	-2.6861475	story	4.0	19.0	1623506686	13.108192
12553247	What's the state of other language i	What's the state of other language interpreters for guile? It's one of this things I always wanted to have a play with until I remember how much I hate lisp.	flukus	15.145712	-3.886206	comment	4.0	18.0	1474501441	-10.241491
12584584	> Racket is all the promise of devel	> Racket is all the promise of developer-centric power tooling that puts Common Lisp to shame.Have you ever used a commercial Common Lisp like Allegro ?	pjmlp	15.31469	-3.7293808	comment	4.0	17.0	1474916235	13.640852
12787549	About 2 years ago I discovered a pro	"About 2 years ago I discovered a programming language called K. It's a very unusual-looking, extremely terse language in the APL family. It just ""clicked"" for me. I enjoy the ability to experiment with different algorithms and approaches in a few keystrokes, and learning to think in a ""vector-oriented"" fashion has opened my eyes to much more elegant formulations of old problems.There aren't many extensive tutorial materials available for K, so when I decided to learn it I pored over the reference manual carefully and wrote an interpreter to try to match the spec. I built programming environments on top of my interpreter which are probably only suitable for my own use, but they make me deliriously happy to use. I made connections with both seasoned K programmers and other enthusiasts throug"	RodgerTheGreat	15.524683	-2.722681	comment	4.0	18.0	1477400503	12.977598
13096776	Practical Common Lisp is intro + rec	Practical Common Lisp is intro + recipes.I think Paul Grahams ANSI Common Lisp is the best if you are learning Common Lisp and Lisp. The language reference in the end is the extremely handy compact  reference for CL. http://www.paulgraham.com/acl.htmlCommon Lisp Recipes is better as a pure recipe book. http://weitz.de/cl-recipes/	nabla9	15.150695	-3.928421	comment	4.0	22.0	1480789535	-10.429867
13234000	Binding as Sets of Scopes: Notes on 	Binding as Sets of Scopes: Notes on a new model of macro expansion for Racket	wsxiaoys	15.324119	-3.718718	story	4.0	64.0	1482368816	13.638877
13244189	"""Solve problems. Make languages.""Tha"	"""Solve problems. Make languages.""That basically sums up my problem learning Racket. ""What is Racket the language? What language am I supposed to learn? What language am I supposed to use in production code? Will one language be compatible with another?I got lost reading Racket document. One section talk about a class syntax of a language. Another talk about some other stuff that never utilize a class. What am I supposed to do with this?I don't want to learn languages, I want to solve my problem."	joesb	15.36203	-3.6605892	comment	4.0	13.0	1482491406	13.65096
13259582	How many people use APL currently? I	How many people use APL currently? Is it easy to find APL programmers?	gravypod	15.56719	-2.6874478	comment	4.0	13.0	1482783547	13.091157
13423133	As a somewhat different data point, 	As a somewhat different data point, we've been developing pycket, an implementation of Racket on top of rpython, for the past 3 years, and while it faces many of the same challenges, we've been very happy with the results. The JIT can remove almost all of the intermediate data structures caused by the functional nature of the language, and we support tail calls and first class continuations. Overall, pycket is almost as fast as chez scheme on average, and faster than every other scheme system we've compared with.	samth	15.349775	-3.6729984	comment	4.0	16.0	1484701550	13.645394
27724010	Chuck Moore wouldn't consider ANS Fo	Chuck Moore wouldn't consider ANS Forth a .. Forth. There is something to be said about the spirit of Forth as expressed through Moore and his ideas versus the sterilized, industrial or more elaborate offshoots. For us loyal Moore acolytes, things like 8th and even Factor are abominations.	creamytaco	15.011916	-3.785252	comment	4.0	17.0	1625339843	-8.271513
27877203	Racket v8.2	Racket v8.2	todsacerdoti	15.378469	-3.6267867	story	4.0	114.0	1626646890	13.663212
27879043	Can anyone tell me why Racket requir	Can anyone tell me why Racket requires 900Mb of disk space? It's just a Lisp when all's said and done.	cutler	15.326152	-3.6913147	comment	4.0	13.0	1626666312	13.616201
12117295	What exactly is the difference betwe	What exactly is the difference between Racket and Scheme, how are they related?	hellofunk	15.33479	-3.6980224	comment	4.0	12.0	1468868105	13.647526
12201172	I'm of the opinion that there is onl	I'm of the opinion that there is only one lisp right now with some serious potential to dominate in the future, and that is Racket. Why? For one very simple reason: unlike all other lisps, there is serious, ongoing, and lengthy research into correctly bringing a static type-checking process to the language. Clojure's core.typed doesn't count here, as it is full of significant holes that invalidate its entire point -- though, those holes are very possibly getting filled in the coming years as they attempt to refactor core.typed following the Racket model. But the Racket team is doing something with lisp that is true to its core, not just with types, but with many other features as well.Interesting piece of trivia: this website you are reading right now is built on top of Racket.	hellofunk	15.306109	-3.7469108	comment	4.0	38.0	1470045008	13.644539
12254992	I learned C and IBM APL2 around the 	I learned C and IBM APL2 around the same time for financial apps.  For APL, i read the Polivka and Pakin book about 30 times, not this edition, but the red paperback I used is apparently impossible to buy.  Excellent book, it got me to where i could be competitive in obfuscated APL contests: https://www.amazon.com/P-L-Prentice-Hall-automatic-computati...	gtani	15.565451	-2.6913848	comment	4.0	15.0	1470755076	13.099134
12297502	Do people involved in these rackets 	Do people involved in these rackets REALLY think they won't get caught in the end? I don't get it.	overcast	15.378874	-3.6102383	comment	4.0	17.0	1471356107	13.650382
35370573	I think APL is very beautiful as som	"I think APL is very beautiful as someone who has longed to learn it from afar and not yet had the time, would be very curious to get more insight into how it changes the way you approach problems in both APL and programming in general, and how it gets you to think differently.If I recall correctly, the Dyalog branch of APL allows for variable names? I kind of like the idea of zero variable names and all strange symbols. The reasoning that after you learn those, you can read any program and understand what's going on at every step, without needing to check what each function actually does -- that sounded very intriguing to me.And the reason that ""checks out"" (or may) I guess is that the language's primitives are very carefully chosen such that you have a kind of extreme economy of ""words"" -"	youssefabdelm	15.56518	-2.6940742	comment	4.0	16.0	1680172329	13.102903
35375241	> APL shows 74 symbols. I count at l	> APL shows 74 symbols. I count at least 50 math symbols that seem very likely to show up in an undergraduate degree; notably, 26 symbols +-×÷|⌊⌈!~∧∨⍲⍱<≤=≥>≠∊∩∪≡≢∘ in APL are taken from math with similar meanings.I have counted at least 30 symbols that I haven’t seen in an undergraduate degree + master degree, not counting symbols that I know but haven’t seen used directly as symbols (eg , or ?) but as punctuation. Of course I might have forgotten some of them but I think it’s undeniable that APL introduces a lot of new symbols.> The arguments to a primitive are not context! You may as well call addition context-dependent because 1+n increments n while 2+n increments it twice. You're describing overloadingNot the arguments themselves but the amount of arguments. Operator overloading is als	gjulianm	15.565325	-2.6953745	comment	4.0	13.0	1680193588	13.078321
35388076	Racket can supposedly compile standa	Racket can supposedly compile standalone packages with the raco compile command (IIRC). Does anyone have experience with this?	andrewflnr	15.3567705	-3.664092	comment	4.0	16.0	1680274620	13.656915
35393966	Amazingly, APL is more readable. Act	Amazingly, APL is more readable. Actually, it's even pretty intuitive. Which proves again, that restricting code to ASCII when every competent programmer (and PC-user in general) can enter almost any unicode symbols just fine is simply stupid.	krick	15.560395	-2.6967065	comment	4.0	18.0	1680298441	13.083038
28092965	Can I ask, why has APL suddenly beco	Can I ask, why has APL suddenly become the flavour of the month? This isn't a downer on the language, I'm just genuinely curious.	DaedPsyker	15.570106	-2.682151	comment	4.0	15.0	1628285347	13.107159
28093325	I had given myself a project of writ	I had given myself a project of writing my interview phone screen coding question in as many languages as I could, more as a lark, but also in 'prep' for a candidate being 'funny' when I say 'use whatever language you are comfortable in'.I did APL, which was fun, and easy. However in researching the language I came across some IBM accounting source code written in APL. It really clued me into how the language got such a following in HR/Finance applications. You got an array of everyones hours per day. Weekly total hours, pay, tax, medicare, etc, were all broken out in little calculative statements based on the array of hours. So rather than long strings of APL characters, there was just massive amounts of english and these little digraphs or trigraphs of APL for the calculative values.	jboy55	15.562926	-2.692009	comment	4.0	14.0	1628287699	13.085071
28285833	Lignum Nephriticum	Lignum Nephriticum	leto_ii	15.1353855	-3.9004714	story	4.0	42.0	1629787947	10.214377
28400504	I would love to be able to use chick	I would love to be able to use chicken on a regular basis, but unfortunately it is an enormous pain to get it install on a system at the same time as mono because the mono c# compiler and the chicken scheme compiler have the same name [0].0. https://bugs.gentoo.org/645728	tgbugs	15.2208395	-3.7505605	comment	4.0	12.0	1630644394	-9.059964
28662132	Racketscript: Racket to JavaScript C	Racketscript: Racket to JavaScript Compiler	lycopodiopsida	15.352334	-3.6672554	story	4.0	91.0	1632673130	13.670809
22381698	Question from someone who knows bare	Question from someone who knows barely anything about the Scheme ecosystem:It seems that the one of the motivations for starting this effort, besides performance, was to move away from a C code base. Is Chez Scheme primarily written in Scheme?	danieldk	15.310758	-3.7077065	comment	4.0	17.0	1582273427	13.624556
22413663	Assuming that the subtext here is wa	Assuming that the subtext here is wanting to address potential reasons for Lisp's chronic underpopularity, I think that all conversations like this miss the mark. Lisp was never failing to attract many users because people hadn't experienced sufficient evangelism about all its advanced features. It fails to attract many people because it's not a fun language to get started in.A year or so back I picked up a copy of Land of Lisp and burned through it for pleasure reading. And I was struck by how gross Lisp looks in that beginner-oriented treatment. Just this huge slog of car and cdr and let/letrec/let* and the 37 flavors of equals and the function namespace. . . and, all the while, you're being told that persevering in mastering this confusing minefield of subtleties will somehow enable you	mumblemumble	15.165336	-3.9274557	comment	4.0	40.0	1582642689	-10.452694
22456471	In what way is PostScript worse than	"In what way is PostScript worse than Forth? Please answer with specific details, and provide links to code if you can. I programmed a lot of Forth code before learning and moving on to programming a lot of PostScript code, so I've used each of them extensively, and much prefer PostScript, and I'm happy to show you why and explain by showing you code.PostScript is much higher level than Forth, and a lot more like Lisp than Forth, and has much better data structures than Forth, like polymorphic arrays (that can be used as code), dictionaries (that can be used as objects), strings, floating point numbers, and NeWS ""magic dictionaries"" that can represent built-in objects like canvases, processes, events, fonts, etc.Yet Forth doesn't even have dynamically allocated memory, although in a few pag"	DonHopkins	15.005599	-3.8297482	comment	4.0	13.0	1583063515	-9.394933
22552376	What's the most popular modern APL?	What's the most popular modern APL?	threatofrain	15.563367	-2.694455	comment	4.0	19.0	1583974012	13.041273
18997977	APL\iv: an APL interpreter and strea	APL\iv: an APL interpreter and stream processor written in Go	chrispsn	15.5599985	-2.7024252	story	4.0	143.0	1548425674	13.052554
18998613	DisclaimerThe author has never used 	DisclaimerThe author has never used APLI’d like to know more about the underlying motivation! APL is a fascinating language but I’m not sure how you’d implement it efficiently in a language like Go - you would need intrinsics to get at the vector instructions no?	gaius	15.565525	-2.6938944	comment	4.0	13.0	1548429270	13.073774
19028230	Does this mean that Racket is now R7	Does this mean that Racket is now R7RS compatible?	pmoriarty	15.374408	-3.6348705	comment	4.0	18.0	1548783725	13.570502
19159408	Learn UX Design A$AP	Learn UX Design A$AP	svarlamov	15.555435	-2.6853867	story	4.0	10.0	1550115229	13.093958
19232532	About a decade ago, I would have agr	"About a decade ago, I would have agreed with this 100%, and I still am fascinated and, quite frankly, awed by Racket and LOP (and looking forward to Racket Fest 2019 here in Berlin[1]).But.(You knew there was a ""but"").While I don't quite agree with the assertion that with the right tooling (so: this tooling), creating a language is as easy as creating a library, I don't think it would solve our problems even if it were true.Language design is much harder than library design, even if the tooling is perfect and transparent.  In the extreme we're going to end up with what Alan Kay calls inverse vandalism[2] aka the Mount Everest Effect:  making things because we can, not because we should or they're good.In essence, designing a (domain specific) language should be your last resort, not your f"	mpweiher	15.347911	-3.6792216	comment	4.0	17.0	1550914547	13.654285
19304819	One of the reasons why Pre-Scheme wa	One of the reasons why Pre-Scheme was so lovely to use is because when it transpiled to C, the C was highly readable. You could follow the output of the Pre-Scheme compiler and know exactly what it was doing, provided you knew idiomatic C.From a readability standpoint, the C output of Gambit and Chicken is a hot mess in comparison.	bitwize	15.226765	-3.772128	comment	4.0	14.0	1551729970	-7.511563
19546993	As much as I love Forth, I am a bit 	"As much as I love Forth, I am a bit troubled by the list in the article:Some interesting but by no means complete Forth properties:    no errors
    no files
    no operating systems
    no syntax

uhm...  Forth does have errors like Stack Underflow.  When I programmed in Forth we did have the notion of files.  It most certainly does have a syntax also."	protomyth	15.01957	-3.8257174	comment	4.0	29.0	1554145885	6.1034784
19717940	Defeating Racket’s separate compilat	Defeating Racket’s separate compilation guarantee	galfarragem	15.35776	-3.6579506	story	4.0	109.0	1555931449	13.63989
19807685	The only thing that has stopped me f	The only thing that has stopped me from using racket more are the performance issues. Hopefully Racket-CS will make racket competitive performance-wise with CL.In regards to expressiveness, Racket is definately the most powerful lisp on the market, maybe even of any language, lisp or not.Great GUI library, the most powerful metaprogramming the world has ever seen, FP, static typing (still a little rough around the edges), libraries for xml/json/http and a ton of other stuff, nice OOP libraries, contracts, and a truly awesome IDE.Is there any other language that is as flexible, powerful, and elegant?The only thing missing from the equation is a high performance optimizing compiler and industrial GC. If Racket could get JVM-like performance and a GC that could manage terabytes of heap, it wo	mruts	15.355286	-3.672271	comment	4.0	25.0	1556803955	13.653892
19927097	I am really excited by Racket.Unlike	"I am really excited by Racket.Unlike most minimalist LISP languages with a community of individual hackers who each have their own macros and packages, this one is battery included while still being the most flexible with the #lang header.
Seriously, it comes with awesome data structures (actuelly more than Python).The only thing that prevents me from using it as much as Python or C++ is the lack of tools for major editors.
DrRacket is NOT ok, I would like a langserver and vscode extension so badly!
When I have a bit of free time and have finished other projects with a higher priority, I'll definitely give it a try.
(yes I'm aware there are some langservers but none of them is really production ready)"	Labo333	15.3498335	-3.67503	comment	4.0	20.0	1557994458	13.644617
15909001	I used to use KX/kdb/Q/K daily for s	"I used to use KX/kdb/Q/K daily for several years. I wrote a full implementation of reinforcement learning (15 lines), a lightweight MVC framework (to show reports and tables in an internal webapp) and even a Q syntax checker (abusing table as a data structure to hold parse trees). Good or bad, for the longest time, Q was my ""go-to"" programming language.Based on that experience...1) Yes, but that's not huge by modern standard.2) Q is a DSL version of K. As others have commented, K is a pretty clean implementation of APL, and Q makes K more approachable.3) I have to agree here, but Q for Mortals makes up for it.4) It is really fast. As we all know, a vast majority of us actually don't have terabytes and terabytes of data, especially after a reasonably cleanup / ETL / applying common sense. I"	ktamura	15.556307	-2.7014785	comment	4.0	18.0	1513109421	13.05464
15910517	Several things:1. K (and the entire 	"Several things:1. K (and the entire APL family) eschew many of the layers upon layers of abstraction that modern software engineering uses, whether they are justified or not. It turns out, that they are mostly not justified. K gently pushes you toward thinking in a lower level of ""what's really happening here?""; I'm not sure I can give a good example here - but the world looks different after taking the red pill. e.g., it is not uncommon in K to represent a tree as an two arrays, one of data, and one of parent pointers. Once you shake the ""but I must abstract this!"" feeling, you realize it works better.2. K gently encourages doing work on batches of data. That is, it is idiomatic (and easier) to write functions that operate on arrays, and return arrays of processed data, then writing funct"	beagle3	15.561883	-2.6980984	comment	4.0	16.0	1513121243	13.074227
16082567	WOW this just makes it one of the be	WOW this just makes it one of the best implementation of scheme, though i would love to see the chez backend version to produce executable binaries like chicken scheme or current raco compiler does. The current chez scheme supports only fasl binaries which require a scheme interpreter to be distributed. The only hacky way currently is chez-exe.	pankajdoharey	15.314941	-3.7020245	comment	4.0	18.0	1515193457	13.613078
18074148	In my experience the APL family of l	In my experience the APL family of languages are extremely hostile to the kind of exploratory coding that people would do in e.g. Python, JS or even C.You do APL like you do mathematics: sit down with pen & paper and think. And yes, many times it’s hit-n-miss, and someone walking by will tell you how it’s trivial with technique X you were unaware of. But again, this is how people do maths too: Maxwell’s original set of equations for electromagnetism were 20 differential equations, and it was later that Heaviside came by and rewrote it in its concise vector form we all know. (And those four equations can still be simplified to a single equation via geometric algebra! https://en.m.wikipedia.org/wiki/Mathematical_descriptions_of... )	aaaaaaaaaab	15.565546	-2.6936095	comment	4.0	20.0	1537953102	13.076092
18074603	One of the ideas that really informs	"One of the ideas that really informs my thinking about comparative programming languages is ""semantic compression"": https://caseymuratori.com/blog_0015A programmer has an idea of what they want the program to do, expressed in human language and concepts. Programming involves refining this idea in sufficient detail that it can be expressed as a program, replacing the imprecise human thought with precise symbols that will be mechanically interpreted. A programming language offers a set of primitive symbols from which larger concepts can be built.One reason people avoid programming in assembler much is that the primitives are ""too small"": they don't relate well to the concepts the programmer is thinking in and you need a lot of them. I wonder if the problem with APL-style languages is that, u"	pjc50	15.558565	-2.7004368	comment	4.0	13.0	1537959119	13.016914
18183986	And there are related efforts to upg	And there are related efforts to upgrade the lisp used in emacs to a more modern and standardized version.I think it is GuileEmacs I am remembering.I hope to two efforts are compatible.	wscott	15.126199	-3.9284554	comment	4.0	16.0	1539172676	-10.422914
18208362	Really nice writeup. I have been usi	Really nice writeup. I have been using Racket occasionally for many years and never thought about the UI libraries. Off topic, but I am going to retire next year and would like to settle on a single programming language for recreational and research programming: probably either Racket or Common Lisp, less likely Haskell or Pharo Smalltlalk. Racket is a great ecosystem and community but I have been using Common Lisp for 36 years.	mark_l_watson	15.340129	-3.6904056	comment	4.0	16.0	1539444073	13.661052
18227631	Chuck Moore always says he did not i	Chuck Moore always says he did not invent FORTH, but discovered it.It's fascinating the relationship between Lisp and Forth. I am quite sure there is something about these two old simple languages and the concept of duality in mathematics that we are missing.	yiyus	15.077766	-3.8539188	comment	4.0	40.0	1539678056	6.116839
18227697	> It's fascinating the relationship 	"> It's fascinating the relationship between Lisp and Forth.Is there more to the relationship than ""Lisp is written as a preorder tree, and Forth is written as a postorder tree""?"	thaumasiotes	15.093347	-3.890808	comment	4.0	19.0	1539678894	5.9170094
18372175	Not the querient, but my first exper	"Not the querient, but my first experience with Racket was something to the effect of:  > (cons 'foo 'bar)
  ! error: bar is not a list

There were several other condescendingly-reported gross implementation defects like this, most damningly a inability to define macros, which meant that Racket is not in fact a LISP, and the syntactic homogenity that makes LISPs annoying to work with (at the benfit of being able to generate and rewrite arbitrary program fragments on demand) serves no purpose whatsoever.I later found out that this was apparently due to having been provided with a ""teaching"" version of the interpreter intended for beginning students (who presuably don't know any better), which makes it even worse.I would definitely characterize my attitude toward Racket as ""hate"", and if acba"	a1369209993	15.333175	-3.7017105	comment	4.0	12.0	1541275470	-10.460411
18640451	APL is more French than English (197	APL is more French than English (1978)	tosh	15.567051	-2.6910112	story	4.0	35.0	1544356511	13.052882
18801682	I love the story of this and the shi	I love the story of this and the shirt turned out pretty good in my opinion. There's just one problem: I really don't know anything about Forth or its creator. Which is probably a shame, I realize. I simply came into programming as a hobby when C was the hotness, and well, learned C. I wonder greatly if I should ever learn any Forth, and how much. Is it only of historical interest at this point?Even more off-topic:> Maybe you'd like to subscribe?I love that this links to an RSS feed.	jchw	15.023547	-3.8120246	comment	4.0	23.0	1546369940	5.9660044
18903836	I believe that Naughty Dog also scri	I believe that Naughty Dog also scripts game logic in their own Lisp dialect.	vernie	15.124112	-3.9251356	comment	4.0	12.0	1547480933	2.0900698
29988180	Naughty Dog transitioned away from G	Naughty Dog transitioned away from GOAL after they were purchased by Sony. Uncharted and TLOU are mostly written in C++.	dharmab	15.131936	-3.8945272	comment	4.0	19.0	1642551660	-6.845038
29989968	In the cause of Naughty Dog, it was 	In the cause of Naughty Dog, it was Andy Gavin who introduced Lisp and GOAL and was one of the co-founders of Naughty Dog. He came from MIT and was a student of Rodney Brooks.https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisphttps://all-things-andy-gavin.com/2011/03/12/making-crash-ba...If someone hasn't seen it, his episode on Ars Technica's War Stories was awesome. He seems to be a hacker's hacker. It's a fascinating story because it's not really how I personally work (internally), so it's fun hearing someone describe just diving in like that.https://www.youtube.com/watch?v=izxXGuVL21ohttps://www.youtube.com/watch?v=pSHj5UKSylk	bmitc	15.111542	-3.9033225	comment	4.0	28.0	1642566438	2.0942261
30127945	> The Scheme ...They keep using that	> The Scheme ...They keep using that word, I don't think it means what they think it means. /s  Though maybe they just plan to write all their support code in LISP.	zozbot234	15.150807	-3.9284623	comment	4.0	12.0	1643475725	-10.423813
30281092	What makes racket less pure? Have be	What makes racket less pure? Have been looking for a typed lisp to play with for quite some time and the choices have always been either racket or clojure.	epolanski	15.30583	-3.748395	comment	4.0	12.0	1644454687	13.639825
30281177	Does any one know of a great IDE for	"Does any one know of a great IDE for racket? I tried DrRacket and didn't really enjoy the experience. I would prefer something like Intellij.
Thanks."	cchubitunes	15.3573885	-3.6563988	comment	4.0	16.0	1644455256	13.642903
16514435	Noob questions:- Did anybody try to 	Noob questions:- Did anybody try to use APL (or a derivate) in web development?- Is the APL job market under-saturated? Or putting it in a different form: is there job opportunities for the 'average Joe'?I hate verbose, or better, I hate to be distracted by it.	galfarragem	15.565577	-2.6846814	comment	4.0	13.0	1520165671	13.1005
16516936	I'm seeing a lot more APL-related su	I'm seeing a lot more APL-related submissions in the past few months. What's going on?	Volt	15.56387	-2.6868768	comment	4.0	12.0	1520199676	13.11475
16516006	Fear and Loathing in APL (2015)	Fear and Loathing in APL (2015)	jxub	15.567502	-2.6841617	story	4.0	90.0	1520190521	13.095948
16612366	I wonder if Forth is still used toda	"I wonder if Forth is still used today for some applications of if anyone has stumbled over some production Forth code lately.For me, Forth is a language in which you can easily shoot yourself in the foot. One element more or less on the stack and you run into strange problems ten functions later in your code.
But what I especially like is the enhanced naming of ""words"". You can choose ""variable"" or ""function"" names such as ""a->b"" instead of ""a2b()"" or ""a_to_b()"". Or ""@X"" for ""GetX()"" and ""!X"" for ""PutX()""."	s-macke	15.034054	-3.817496	comment	4.0	17.0	1521386829	6.113063
16695002	I'm a forth programmer, I've impleme	I'm a forth programmer, I've implemented an editor in forth, a more(1) clone in forth, a grep(1) in forth and I did a bunch of stuff I've forgotten in forth for the geophysics department at UW Madison.I HATE forth.  It's a miserable language, I just hate it.And then I went to Sun and the boot prom language was forth, still hated it.Then I got to PCs.  The BIOS had no language and then Intel did whatever garbage they did and I was like please, just give me Forth.  It's not what I'd do for debugging a panic but I could make it work.  The Intel stuff was way worse.I suspect that Mitch priced himself out, otherwise we'd all be using Forth as the boot language, I dunno what happened.  But if you had asked me 20 years ago would I be saying anything positive about forth I would have kicked you in	luckydude	15.037913	-3.8181832	comment	4.0	23.0	1522207523	6.103786
16743856	Common Lisp Standard Draft	Common Lisp Standard Draft	tosh	15.182184	-3.9037244	story	4.0	103.0	1522757377	-10.464446
16803109	"I think APL is for ""a programming la"	"I think APL is for ""a programming language"", not ""another programming language""."	FractalLP	15.565892	-2.6919408	comment	4.0	13.0	1523380732	13.094696
16819998	I'm biased but I'd go Common LispThe	I'm biased but I'd go Common LispThe basics:- SBCL: generates fast[0] code. runs well on windows- Quicklisp: The package manager which lets you install the packages mentioned belowI've got a video here that should help with getting set up on windows https://www.youtube.com/watch?v=VnWVu8VVDbI&t=1sThen you could try the SDL2 approach:- cl-sdl2: Bindings over sdl2 https://github.com/lispgames/cl-sdl2- cl-sdl2-mixer: audio playback https://github.com/lispgames/cl-sdl2-mixer- Some basic math library like: 3d-matrices, rtg-math, sb-cgaOr maybe an existing engine:- https://github.com/borodust/trivial-gamekitCome down to #lispgames on freenode if you need a hand as there is usually someone there who has	baggers	15.132394	-3.928093	comment	4.0	15.0	1523535029	-10.422332
17033954	On the matter of learning Racket, I'	"On the matter of learning Racket, I've heard some good things about How to Design Programs (2nd Edition):
http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html."	threatofrain	15.3601675	-3.6576366	comment	4.0	15.0	1525899038	13.63369
17037295	I know the article is about Common L	I know the article is about Common Lisp, but I have a question about Racket, Typed Racket specifically. Can anyone say if types and Lisp play well together? Are there any success stories?	elbear	15.322169	-3.7209482	comment	4.0	18.0	1525943135	13.655155
17150421	Someone smart needs to explain what 	"Someone smart needs to explain what an infinite algebraic lattice is, because it sounds awesome. Potentially.Edit: (I just googled ""algebraic type lattice"" and while ymmv, I don't recommend it unless you're well versed in scary black mathic)I didn't get too in depth with reading the docs, but any language that goes for non ascii symbols a la APL is going to be fighting an uphill battle right from the get go.Maybe it was a bit easier even for apl because there were interfaces more immersive than what we have now for non ascii, especially when mixed with regular ascii.Type type type, oh wait, backslash, dropdown, there's my symbol, enter, type type type. That's not very fun. That's less fun when youre dividing your cognition between what things im actually trying to accomplish and what thing"	qop	15.566699	-2.6904902	comment	4.0	14.0	1527219218	13.0747595
17174101	No, it does not.  I used APL profess	No, it does not.  I used APL professioally for about ten years back in the 80's.  I love the language.  It is incredibly powerful.  Once you internalize it's like playing the piano, you don't think about the mechanics you play music.However, the language did not stand the test of time for far more important issues than the inconvenience of the character set and the keyboard.And, no, J is not a successor to APL, even though Iverson created it.  J is an abomination.  He made a mistake.  He thought that abandoning notation --which is incredibly powerful-- would solve the APL popularity problem.  What he ended-up creating was a royal mess of the first degree.  It's garbage.APL could be very useful today but someone with the time and context needs to organize an effort to evolve it into a moder	rebootthesystem	15.56531	-2.6921923	comment	4.0	20.0	1527533812	13.0863905
17235562	There is a reason for that.  From th	There is a reason for that.  From the BUILDING file in the Chez repository:> Since the Scheme sources can be compiled only by a working version of Chez Scheme, it's not actually possible to build Chez Scheme from source. That's why the boot and header files are packaged with the sources.Chez has a bootstrapping problem.  (See also https://bootstrappable.org)	rekado	15.327927	-3.6896195	comment	4.0	21.0	1528182859	13.6318035
23037745	This is stupid and I love it, but co	This is stupid and I love it, but come on - who sits down with Norvig and does not know his Lispen background?	Keyframe	15.146715	-3.9297943	comment	4.0	12.0	1588291566	-10.43819
23060070	gnu apl is an often overlooked but e	"gnu apl is an often overlooked but extremely solid APL implementation that plays nice w/ unix.slightly verbose example but heres gnu apl as a pipe-like interface. Often this would be abstracted to a library that gets included when you call it:  printf ""1,2,3,4\n5,6,7,8"" | apl --eval ""f←{4⎕CR ⍵}◊s←{⍺~⍨¨⍵⊂⍨1++\⍺⋸⍵}◊f ⊃{⍎⎕UCS ⍵}¨¨44 s¨10 s⊣⎕FIO[41] 0""
  ┏→━━━━━━┓
  ↓1 2 3 4┃
  ┃5 6 7 8┃
  ┗━━━━━━━┛


DESCRIPTION:    --eval ≡ evaluate the text

    f ≡ formatting function for printing nested values

    s ≡ partition a line of text and remove the partition character

    ⎕FIO ≡ read stdin as byte stream (see FILE_IO.apl)

    ⎕UCS ≡ convert bytes to characters

    ⍎ ≡ execute an expression (convert characters to numbers)


SUMMARY:  read stdin as a bytestream

  partition at newlines and comm"	gandercrews	15.565115	-2.6953208	comment	4.0	18.0	1588523786	13.076912
23141453	if Racket was built on top of immuta	if Racket was built on top of immutable data structures, recursion, and the likes - why were imperative-like features such as mutation added to the language?	ausbah	15.351545	-3.6750965	comment	4.0	12.0	1589200982	13.628371
23233897	Well, one of the major points of Gui	Well, one of the major points of Guile (speed) is becoming obsolete as people are working in native-compiling elisp with libgccjit[0]. It provides great speed benefits: an average of x3~4 and up to ~x20 on recursive functions. With type annotations we can speed it up more — no need for a Guile JIT for speed anymore.[0]: https://akrl.sdf.org/gccemacs.html	pcr910303	15.1928835	-3.7820897	comment	4.0	12.0	1589889820	-10.2489605
37897477	Douglas Crockford to Keynote 'From H	Douglas Crockford to Keynote 'From Here to Lambda and Back Again' at RacketCon	spdegabrielle	15.347492	-3.6606596	story	4.0	30.0	1697448690	13.656509
37898848	Im curious - what is it about forth 	Im curious - what is it about forth that makes you consider it to map more closely to the machine?I've done a handful of forth projects as part of a code-dojo years ago. I wouldn't have considered it low-level.	Normal_gaussian	15.04151	-3.8111928	comment	4.0	14.0	1697459051	6.073744
38055544	I know people still use COBOL, but d	I know people still use COBOL, but does any important software use APL nowadays?From Wikipedia:> APL is used for many purposes including financial and insurance applications,[82] artificial intelligence,[83][84] neural networks[85] and robotics.[86] It has been argued that APL is a calculation tool and not a programming language;[87] its symbolic nature and array capabilities have made it popular with domain experts and data scientists[88] who do not have or require the skills of a computer programmer.[citation needed]But the latest citation is from 2018, and some of these are just tutorials or articles.	armchairhacker	15.566293	-2.688864	comment	4.0	15.0	1698548888	13.103341
25901790	Donald Knuth once said, “Premature O	"Donald Knuth once said, “Premature Optimisation is the root of all evil!” But that message has obviously not yet reached the Racket community.
Because how else do you explain this madness: they spent three years developing a new version of Racket that et the end turned slower than the original! [1]Meanwhile, for example, we can still count the number of web applications written in Racket on the fingers of one hand, and the number of Racket users in the racket group is rapidly decreasing from day to day.Turns out the only users of Racket are people who live off Racket in a way that writes scientific articles that nobody cares about.Very rare are those who use Racket for any practical purposes.I wonder if it would have been better if this huge effort had been made to write clear documentatio"	fern2000	15.365021	-3.6510956	comment	4.0	24.0	1611571921	13.658122
26130665	Does anyone have any summaries or ne	Does anyone have any summaries or news about the ongoing Racket team effort to develop modern syntax?	threatofrain	15.357053	-3.6642156	comment	4.0	12.0	1613292115	13.645249
26130761	Congratulations! It's been a long ti	Congratulations! It's been a long time waiting!I've wanted to develop desktop UIs that look professional and are lightweight, and I wonder if Racket, with its built-in UI framework, could be a good choice.I did try it once but the hello world app was already really heavy (200MB of RAM instantly taken , if I remember correctly), but maybe I did something wrong (debug mode perhaps??)Can I package a Racket app with a MacOS installer and sign it? How about Windows and Linux?	brabel	15.372045	-3.6445	comment	4.0	13.0	1613293528	13.650937
37165676	The Scheme community has long held t	The Scheme community has long held tension between people who want to use Scheme as a teaching language, versus those who want to use it for writing real-world programs.The former want the language to stay as minimal as possible with a tiny standard library so that there are fewer concepts and options for students to stumble over. The latter want a full-featured language (but still minimal, it is Scheme after all) with a large standard library of useful types and functions so they can get stuff done.These two perspectives are both reasonable but fairly incompatible.For most of its history, Scheme leaned towards education. Around the type of the sixth edition (RSR6), pulled somewhat the other way and the language and library spec got much bigger. This alienated a lot of folks who wanted to 	munificent	15.317144	-3.7031057	comment	4.0	20.0	1692295420	13.601023
37559095	Show HN: Liz – Collaborative Lisp co	Show HN: Liz – Collaborative Lisp coding on Discord	D4ckard	15.135619	-3.9194565	story	4.0	44.0	1695057772	-10.4195385
24644812	Why people are speaking a lot about 	Why people are speaking a lot about Forth this year? Nothing against (I love Forth), just curious.	emersonrsantos	15.041741	-3.806036	comment	4.0	15.0	1601505139	6.0575833
24647013	On the other hand, according to this	On the other hand, according to this[0] author who ported a game from assembly to C and Forth, Forth seems to drastically  increase development time and perform 10-20 times worse than the equivalent assembly.[0] http://calc6502.com/RobotGame/summary.html	siraben	15.031631	-3.8335142	comment	4.0	14.0	1601522784	-7.319047
25228933	What are the reasons Racket CS is, o	What are the reasons Racket CS is, or at least used to be slower than Racket BS? Was the whole transition towards CS not primaritly to boost performance? Were expectations to high in this regard?	jhoechtl	15.362671	-3.6578224	comment	4.0	12.0	1606487398	13.662809
25228984	"""Chez Scheme is one of the oldest Sc"	"""Chez Scheme is one of the oldest Scheme implementations, and its evolution informed many parts of the Scheme standard through R6RS. (Racket's influence on the Scheme standard, in contrast, is limited to aspects of the R6RS library design.)...""Why did Chez and Racket embrace R6RS, a standard widely rejected by the rest of the Scheme community?Also, why did Racket choose Chez over some other high-performance Schemes, like Chicken?Finally, how many Racket and Chez users are there compared to those of other Schemes?"	pmoriarty	15.351369	-3.6687388	comment	4.0	16.0	1606487780	13.636089
25441971	On Lisp by Paul Graham is a good sta	On Lisp by Paul Graham is a good start: http://www.paulgraham.com/onlisp.htmlEdit: I meant ANSI Common Lisp. Thanks everyone!(I wouldn't even recommend On Lisp as a second text, too much macrology).	Tomte	15.176773	-3.9075108	comment	4.0	12.0	1608123642	-10.449806
38873776	Since we are on the topic, I've thou	"Since we are on the topic, I've thought about APLs a decent amount so here are some other resources/notes. I'm not an expert on this topic - I don't work with or research the language or anything. These probably are not good getting-started resources.There is a VM model for APL languages[1] which can make optimizations comparable to those made by CLP(FD). If you read about CLP(FD) implementations[2], you'll see operations similar to what the ""An APL Machine"" paper calls beating. I'm not sure if any APL-like languages actually implement such optimizations.There are different models of arrays (and their types) used by APL-like languages[3]. Also array frame agreement can be statically typed[4], though it usually isn't.Some other OSS implementations of similar languages include Nial[5], ngn/k"	bbwbsb	15.561346	-2.6993415	comment	4.0	15.0	1704411582	13.031401
38915114	I've just discovered array/ matrix l	"I've just discovered array/ matrix languages, and especially J. It's so a pleasure to use it. I struggle since a long time to use python or r for their mixed scalar/array style. K/J/apl are so clean and well designed in this regard.For instance: Eratosthene's sieve to get all prime under 100 :
""
(-.] * /])2}.i.100
""
Another great property of J is his natural language like structure :without =: -.multiplied_by =: */upto =: 4 : 'x}.i.1+y'Sieve_100 =:
(2 upto 100) without (2 upto 100) multiplied_by (2 upto 100)"	Pompidou	15.555123	-2.7080193	comment	4.0	12.0	1704734339	13.036879
38915656	From experience, my take is that mos	From experience, my take is that most laymen devs are unwilling and/or uninterested in taking the dive into apl/k/array langs due to the, in their own words, deliberately abstruse and obscurantist syntax/glyphs/typing; it's just too theoretical and/or cognitively/neurologically daunting for average engineers that just want to get paid.	jd3	15.562399	-2.6967263	comment	4.0	35.0	1704736821	13.076057
38916159	> abstruse and obscurantist syntax/g	> abstruse and obscurantist syntax/glyphs/typingI've often wondered what are the real blocks to having it both ways? Have the source saved as some lowest common denominator - IL, tagged AST, or somesuch - and then read and written in whatever pleases the individual. It would be hard to make it work between languages with drastically different semantics that don't map to anything in another language, I suppose would be the real reason... but I always think about the fact that it makes it down to machine code eventually, so it seems intuitive that the process could be reversed.Or less drastically, an IDE for APL beginners: symbols have human language helpers or UI overlays, but the source is still APL.	uticus	15.560224	-2.6994638	comment	4.0	28.0	1704739157	13.076994
32600726	I learned about Chez when Racket sta	I learned about Chez when Racket started their rewrite from C to Chez. Made me think why they don't just build Racket entirely in its self!	jesushax	15.359654	-3.656366	comment	4.0	15.0	1661466311	13.644996
32627723	My Road to Lisp (2007)	My Road to Lisp (2007)	AlexeyBrin	15.155199	-3.929484	story	4.0	50.0	1661688167	-10.47643
32726497	The GUI situation in Common Lisp is 	"The GUI situation in Common Lisp is pretty pitiful. AFAIK the best you get is ECL+QT5 or cffi-cl-gtk (which is GTK 3).
I don't see a very favorable comparison for Racket at all in anything else though. When people talk about the benefits of Lisp, they are usually talking about the benefits of /Common/ Lisp. Other languages often misunderstand what makes Common Lisp so great, like in the case of Scheme's overly complex pseudo-macro system."	yyyk2	15.322643	-3.718062	comment	4.0	19.0	1662397285	13.650464
38159611	I always thought of FORTH as the #1 	I always thought of FORTH as the #1 hardest to think of uses for, out of all the non-esoteric and non-obsolete languages.  That's a really neat application!	eternityforest	15.039709	-3.8150554	comment	4.0	31.0	1699253735	6.042195
38162668	I don't have notes of what I said (r	I don't have notes of what I said (recording will be up soon) but that isn't what I was trying to say at all. We value use in industry and have made significant effort to enable it (like relicensing everything). It is true, of course, that we're academics, and so we need to learn from others about how to better enable industrial use of Racket, but that is not because we don't care about it.	samth	15.375905	-3.6358726	comment	4.0	14.0	1699279308	13.650924
38400658	I would be able to speak to the alle	"I would be able to speak to the allegedly “impractical” nature of Scheme if only I knew why Cisco hired Kent Dybvig, the principal developer of Chez Scheme.
I would also like to know why Beckman Coulter Life Sciences supported the development of Swish, an extension of Chez Scheme that provides Erlang-inspired message passing.Gambit and Scheme have been used for health applications. Here's one paper on that subject, from 2013: https://ecem.ece.ubc.ca/~cpetersen/lambdanative_icfp13.pdfI would mention the use of GNU Guile to build Guix, which has had considerable uptake. Guile has been used to build other Linux programs.Admittedly, Scheme isn't widely used. But impractical? No!"	vincent-manis	15.213599	-3.7558455	comment	4.0	12.0	1700800386	-10.194907
38505645	I find it sad that APL nowadays mean	I find it sad that APL nowadays means Dyalog. They appear to do amazing work. Unfortunately, the license isn't open. Why would I invest time learning it only to be locked in? I wonder how much licensing plays in APL not being more popular and used in the present day. There are open variants, like GNU APL2 and J. However, GNU APL2 has none of the advancements made in the past 40 years and J is J, not APL. The notation is simply different.	spit2wind	15.56695	-2.692724	comment	4.0	22.0	1701590816	13.094672
15078158	That Racket module functionality whe	"That Racket module functionality where you can add unit tests right with your code (""module+""), but will get stripped when compiled - that thing is quite magical. Is there another system that has this?"	i_feel_great	15.35592	-3.6561348	comment	4.0	13.0	1503456307	-5.4800544
15078511	Anyone using Racket in the wild? (Be	Anyone using Racket in the wild? (Besides the Racket team)	zerr	15.37385	-3.6321929	comment	4.0	17.0	1503462278	-9.885685
15100707	Reimplementation of Racket to run on	Reimplementation of Racket to run on top of Chez Scheme	igravious	15.362342	-3.6484234	story	4.0	99.0	1503684033	13.645345
15335691	Is the ‘lozenge’ a Racket-ism or is 	Is the ‘lozenge’ a Racket-ism or is it unique to this project? I understand the logic around using a character that’s hardly used in regular writing – to avoid escaping – but it seems as though it would be hard to use in practice.	whalesalad	15.35784	-3.6635592	comment	4.0	17.0	1506392597	13.655922
15365727	I understand that R7RS got rid of sy	"I understand that R7RS got rid of syntax-case and standard Scheme is back to syntax-rules only (which is another thing I like about Common Lisp: the standard has been in existence for 23 years).I'm reminded of this article (https://fare.livejournal.com/189741.html), where this Common Lisp macro:    (defmacro nest (&rest r) (reduce (lambda (o i) `(,@o ,i)) r :from-end t))

Has to turn into this in Racket (which isn't quite Scheme):    (define-syntax (nest stx)
      (syntax-case stx ()
        ((nest outer ... inner)
         (foldr (lambda (o i)
                  (with-syntax (((outer ...) o)
                                (inner i))
                    #'(outer ... inner)))
                #'inner (syntax->list #'(outer ...))))))

And was incredibly difficult to reason about.  And that a"	zeveb	15.172645	-3.9151	comment	4.0	12.0	1506696355	-10.437619
15419205	I was greatly disappointed with this	I was greatly disappointed with this book because none of the 'Game' examples had a graphical interface to them. They are all text based.Reading further in this thread people are suggesting Realm of Racket as an alternative and it looks like that book has much more visual game examples: https://realmofracket.com/games.html	Vekz	15.354577	-3.6241431	comment	4.0	17.0	1507314987	13.633521
15426018	I get that this is important to the 	I get that this is important to the Lisp crew, but is this at all relevant to the general audience of HN?What's the takeaway: avoid Closure because of one drama? Rich is right about everything? Copmuters are terrible?	falsedan	15.126084	-3.8960588	comment	4.0	18.0	1507414884	2.2876966
15571832	There are also plenty of Lisp progra	There are also plenty of Lisp programmers that think that it's a real tool to solve real problems, not just an educational oddity.  There are a bunch of Lisps out there, and plenty of them are by no means toys.  My laptop's initial RAM disk and init system are Scheme programs.	davexunit	15.156598	-3.9272957	comment	4.0	25.0	1509135202	-10.459649
15710781	Was / is Forth good and useful? Bonu	Was / is Forth good and useful? Bonus; is it fun?	unixhero	15.044177	-3.8099127	comment	4.0	19.0	1510817103	6.116473
17761696	IMHO switching to Guile from C is mo	IMHO switching to Guile from C is moving in the wrong direction: rather than going from a poor-but-performant systems programming language like C to a pedagogic language like Scheme, it’d be a better idea to move to an rich-and-performant language meant for industrial systems programming like Common Lisp.  Scheme’s a pretty little language, but it’s not meant for building large applications.  Indeed, elisp’s weaknesses are IMHO mainly where it’s most akin to Scheme (e.g. its flat namespace).I also think it’d be a bad idea to make it too easy to write emacs extensions in anything but a Lisp, because that would fragment the ecosystem.  If we’re going to replace elisp, it should be with a better Lisp, not with a lesser language (e.g. Lua, Python, Ruby … whatever).The great thing about a JIT i	rauhl	15.156987	-3.8779898	comment	4.0	27.0	1534279239	-10.339237
17761698	"> I hate to be ""that guy,"" but what "	"> I hate to be ""that guy,"" but what happened to the Guile-Emacs project? Guile performs way better than Elisp tooI’m sorry to be that guy, but did you ever try it out for yourself?Just starting Emacs took as long as a full regular Emacs elc-build, if not longer.So not exactly faster by a universal standard."	josteink	15.1870775	-3.801261	comment	4.0	15.0	1534279268	-10.317625
17846522	History of Lisp (1979) [pdf]	History of Lisp (1979) [pdf]	taylodl	15.153443	-3.9258604	story	4.0	98.0	1535300373	-10.417012
21134929	>Making languages is the thing that 	>Making languages is the thing that Racket does better than any other languageHave you tried Rebol/Red?	mapcars	15.370698	-3.6461396	comment	4.0	19.0	1570012237	13.645528
21134666	There is definitely room for a schem	There is definitely room for a scheme compiler. But the scheme ecosystem felt extremely fractured the last time I took a look. Chicken had a decent but aging repo. Chez had a great compiler (I prefer not compiling to C) but it's package ecosystem was not something well advertised if it did have one. Racket has too many dialects which might appeal to some but found the number of sub languages overwhelming for a casual schemer.	scriptdevil	15.300085	-3.7201734	comment	4.0	40.0	1570008572	13.632182
21290066	For me, COBOL is so over-presented i	For me, COBOL is so over-presented in the media among the old (mainframe) lagnuages, but I recently was surprised to see a production mainframe LPAR offering an APL2 interface,and it seems the language is still maintained on zOS[1]. But I never heard of business application written in APL.1 https://www.ibm.com/support/pages/apl2-whats-new	pgtan	15.564008	-2.6826186	comment	4.0	12.0	1571393619	13.100642
21509396	APLcart – Find Your Way in APL	APLcart – Find Your Way in APL	lelf	15.568414	-2.6860895	story	4.0	54.0	1573509856	13.097201
21586190	Question : is racket still useful if	Question : is racket still useful if you plan on building a DSL not based on lisp syntax ?	bsaul	15.330832	-3.7051473	comment	4.0	13.0	1574271470	13.629512
21642670	Getting Started with APL (2017)	Getting Started with APL (2017)	lelf	15.564303	-2.6991436	story	4.0	97.0	1574802205	13.096274
21675461	The thing that's wrong with Forth is	The thing that's wrong with Forth is it promotes eschewing verbal identification of variables for the sake of positional. This is promoted as good mental exercise, but is just bad language design. As Rich Hickey said, we humans prefer to identify things in terms of keywords, not positions. For any method with more than a couple parameters, kwargs are  more convenient than positional arguments or, worse, implicit args on the stack. This is why concatenative languages are doomed to be just a forgotten cul-de-sac off the highway of the history of programming languages.	LessDmesg	15.018033	-3.8055882	comment	4.0	20.0	1575208112	6.1163216
21730429	Looking at Advent of Code solutions,	"Looking at Advent of Code solutions, I'm not sure if APL is really so much shorter or if it is rather a styling of programming.Some day2 solutions from reddit [0]:APL:    0{⍺⋄s←⍵⋄c←s[f+⍳4]⋄99=0⌷c:0⌷s⋄i a b l←s[c]⋄s[3⌷c]←(0⌷c-1)⌷a(+,×)b⋄(⍺+4)∇s}{j←⍵⋄j[1 2]←12 2⋄j}⍎¨','(≠⊆⊢)(⎕NGET 'data')

Python:    def R(I,x=12,y=2,O=__import__('operator')):
        q=p=[*map(int,I.split(','))];p[1:3]=x,y
        while p[0]!=99:o,a,b,c,*p=p;q[c]={1:O.add,2:O.mul}[o](q[a],q[b])
        return q[0]
    R(inp),next(100*x+y for x in range(100)for y in range(100)if R(I,x,y)==19690720)

K (APL derivative)    f:** ({~99=x@y}/) {i:x@y+!4;n:@[x;i@3;$[1=*i;+;*]/x@i@1 2];(n;y+4)}//
    d1:@[.-1_1:`2.txt;1 2;:;12 2]
    f(d1;0)
    d2:{@[d1;1 2;:;x]}'z:+!2#100
    {y+100*x}/*z@&19690720=f'+(d2;0)

Another APL one:    "	qznc	15.553363	-2.7057376	comment	4.0	13.0	1575729089	13.061328
39430710	Were APL, K, J, etc. ever used in pr	Were APL, K, J, etc. ever used in production? Array programming seems like a cool idea (albeit being counterintuitive sometimes), and it's maybe one of the tersest syntaxes I've ever seen.	behnamoh	15.551777	-2.711479	comment	4.0	14.0	1708356097	13.039116
39471374	TIL APL...neat!  Found this for othe	"TIL APL...neat!  Found this for others who want to play along.https://tryapl.org/(Note: took a while but the special characters for producing lists, etc... are from ""virtual keys"" you can see at the very top of the web page)"	whitej125	15.559418	-2.6896634	comment	4.0	30.0	1708627992	13.076248
39474255	425,000 lines of APL code boggles th	425,000 lines of APL code boggles the mind. It's like 10,000 pages filled with APL symbols. I guess that for normal non-APL programmers it's as close to an inscrutable alien artifact as you can find on Earth.	kryptiskt	15.564747	-2.6910489	comment	4.0	15.0	1708641208	13.107131
39610371	Is there a reason why APL languages 	Is there a reason why APL languages all fold right? I mean other than genealogical, as in they fold right because APL does. Does it offer compelling advantages?As an outsider it looks like wasted novelty budget. There's already a lot of new things to learn and get used to in an APL school array language, and then on top of that you have to learn to read them right to left.	samatman	15.565559	-2.6942637	comment	4.0	13.0	1709680907	13.086205
32082274	"  input = 1

  out1: input + 1
  #ou"	"  input = 1

  out1: input + 1
  #out1 is now 2

  input = 4
  #out1 is now 5

  out2: out1.replace(+, -)
  #out2 is now 3

  # let's pull an APL
  input = 4 2
  #out1 is 5 3
  #out2 is 3 1

The reactive programming idea a la Excel but text-based looks really neat. I'd love to play around with that kind of thing."	eatonphil	15.561919	-2.69818	comment	4.0	21.0	1657718410	-12.047074
32384320	Lively Linear Lisp – 'Look Ma, No Ga	Lively Linear Lisp – 'Look Ma, No Garbage!' (1992) [pdf]	Tomte	15.155227	-3.9298303	story	4.0	83.0	1659958406	-10.492027
32453997	If I recall correctly, the common li	If I recall correctly, the common lisp community doesn't like nor recommend the book at all.I remember going through the first 6 chapters and often going on the CommonLisp channel on free node to ask questions and eventually found out it was either wrong or misleading in many of the fundamentals. I tried to keep going through it but eventually gave up and picked the much better practical common lisp.	epolanski	15.150869	-3.9269593	comment	4.0	13.0	1660426404	-10.4642515
32505975	Brave warriors use Forth. I came to 	Brave warriors use Forth. I came to find out about it in the Computer History Museum.I think that the information provided is a bit messy. There is a link to a German language website which feature a lot of projects the society is currently working on, with stuff hosted on GitHub instead of SourceForge.	_the_inflator	15.033758	-3.8145096	comment	4.0	16.0	1660803727	6.0498824
22043186	“[..] to present to the eye some pic	"“[..] to present to the eye some picture by which the course of their reasonings might be traced: it was however necessary to fill up this outline by a tedious description, which in some instances even of no peculiar difficulty became nearly unintelligible, simply from its extreme length”
- Babbage on Java, 1821.My stumblings in APL involve a continuous adjustment of functions and data to fit each other, an impedance matching, a continuous going up and down lochs, now to enclose this, now to align this vector with that nested vector, now to mix that nested vector into a matrix to feed into a function with a first axis rank adjustment.. and it feels like a system built of ill-fitting parts because of it.Perhaps it’s not APL inherently being an elegant notation, but smart people’s ability to"	jodrellblank	15.563747	-2.6933017	comment	4.0	13.0	1578994059	13.079255
22148835	Is anyone familiar with the stand-al	Is anyone familiar with the stand-alone executable export[1] for Racket?I did a Ludum Dare and browsed a submission where a child had spent a lot of time and effort making a project in PyGame, but found it hard to distribute because he didn’t have the technical know how of converting it to something like a windows `.exe` file at the time. If this helps youngsters learn and explore programming the way the Commodore 64 had a nice BASIC->6502 ramp alongside distribution via floppy/cassette, I’d be super excited about this.[1] https://docs.racket-lang.org/raco/exe.html	danbolt	15.353287	-3.6575437	comment	4.0	12.0	1579988968	13.654273
35867240	I walked in, realized just how advan	I walked in, realized just how advanced this was and then proceeded to read through the same way I pan through the Abstract Art section of the museum.I freaking love APL and would love to learn it, but it is so incredibly jarring not knowing anything about the syntax.	mikercampbell	15.561599	-2.6909251	comment	4.0	14.0	1683580995	13.086731
36284644	Yes good call, I changed the broken 	"Yes good call, I changed the broken Wikipedia links to the archive page - https://web.archive.org/web/20230228105200/https://people.cs...Looks like it broke earlier this year, but the rest of his site is still up.It's very weird that there's already a ""canonical"" format for s-expressions, and then Racket apparently implemented something incompatible -- BUT WITH THE SAME NAME.They are both called ""csexp"".---Rivest's draft is filled with a lot of words, but this looks like a clear incompatibility:A verbatim encoding of an octet string consists of four parts:-- the length (number of octets) of the octet-string, 
    given in decimal most significant digit first, with
    no leading zeros.-- a colon "":""-- the octet string itself, verbatim.That's a length prefix.  Also, unless my head is explod"	chubot	15.335204	-3.6900887	comment	4.0	17.0	1686511135	13.66007
36372274	> Statistically speaking, 99.9% of s	"> Statistically speaking, 99.9% of succesful startups were written not in any Lisp, and 0.1% of them in Lisp.I think the point that PG was making wasn't that P(lisp|success) > P(blub|success) is what's key but that P(success|lisp) > P(success|blub)> What's more, Yahoo! even scrapped all their Lisp code soon after.I'm hardly a PG fanboy, but I have to say this is exactly what's expected in PG's original post on the subject[0]. It's precisely because big companies will only stick to blub languages that Lisp becomes an advantage for a startup.The point of ""Beating the Averages"" isn't that you must use Lisp but that small groups of elite hackers can use more powerful tools than larger organizations can't get away with because they generally have lower skilled, only comfortable with blub, progr"	PheonixPharts	15.145634	-3.8994968	comment	4.0	12.0	1687022739	-10.442307
36519953	> The primary goal is not speed.But 	"> The primary goal is not speed.But the authors states that Racket is ""the finest example of a modern day lisp bar none"".  In the modern day energy efficiency and climate change are major issues, the German government, for example, has set up the Blue Angel Ecolabel program: <https://www.blauer-engel.de/en>.  Using modern day to mean VSCode and Discord is a worthless use of the phrase."	tmtvl	15.345519	-3.685735	comment	4.0	31.0	1688044656	13.651695
23444871	If I use APL and Lisp, does that cou	If I use APL and Lisp, does that count as spending innovation tokens? Is boring technology old, or is it widely used? Most people I know don't consider J, kdb+/q, Haskell, or OCaml boring, but they are all awesome industrial strength languages/technologies.	smabie	15.166843	-3.9164696	comment	4.0	12.0	1591505872	-10.476216
23451077	this might be a dumb question but ca	this might be a dumb question but can someone briefly explain why Forth is more suitable over C or other languages in general on post-apocalyptic OS?	mshockwave	15.039505	-3.808706	comment	4.0	16.0	1591565796	6.0481176
23453784	For me, the main problem with forth 	"For me, the main problem with forth is a lack of names -- most languages (functional or imperative or even declarative) assign names to things -- things like function parameters, temporary values and so on.Even Prolog, which is as far from traditional structural program as one can go, usually has descriptive names for unbound variables.Compared to this, Forth is very name-terse. You get ""function names"" at best, and nothing else. This really makes programs much harder to understand, as it requires one to remember much more things while reading the code."	theamk	15.033169	-3.819034	comment	4.0	15.0	1591593439	6.1263804
23520936	More like Excel killed APL. APL was 	"More like Excel killed APL. APL was mainly used by ""domain experts"", i.e., people who were not software engineers. According to Dyalog's YouTube videos, APL is still there for these people who started doing spreadsheets way before anything like Excel was available."	Jhsto	15.562874	-2.696567	comment	4.0	12.0	1592165794	13.091884
24048776	The BEAM needs an APL-y language (20	The BEAM needs an APL-y language (2018)	lelf	15.564145	-2.7001638	story	4.0	27.0	1596539672	13.08615
24167138	I like how APL made it into Common L	"I like how APL made it into Common Lisp wholesale. There's a library that compiles APL to Common Lisp, allowing you to mix APL and Lisp code, working on the same data structures with both languages.https://github.com/phantomics/aprilExample session I just did, copying APL code from https://aplwiki.com/wiki/John_Scholes%27_Conway%27s_Game_of_...:  CL-USER> (april:with-april-context ((:space *lifespace*))
             (april:april ""Show←{'·⌺'[⎕IO+⍵]}"")
             (april:april ""glider←3 3⍴1 1 1 1 0 0 0 1 0"")
             (april:april-f ""Show glider"")
             (print (april:april ""glider"")) ; to prove it's a Lisp array
             (terpri)
             (april:april ""grid←¯10 ¯10↑glider"")
             (april:april-f ""Show grid"")
             (terpri)
             (april:april ""life ← {⊃1"	TeMPOraL	15.234794	-3.6830087	comment	4.0	12.0	1597480697	13.076678
24228682	As a newbie im getting a bit confuse	As a newbie im getting a bit confused. What is the difference between guile and chicken scheme? There's also chez. Im even more confused	grugagag	15.247483	-3.7281544	comment	4.0	17.0	1597956098	11.339931
24258228	I would like to know as well. I woul	"I would like to know as well. I would also be interested in opinions about ""Lisp system implementation by Nils M Holm"".
I tried to read ""Lisp in small pieces"" at least 3 times but never managed to go further than the 1st chapter. I find the prose pedantic and  often it doesn't go straight to the point that is the objective of the chapter. Maybe this is an issue due to the translation from French. In any case I find it a very heavy read. I have the feeling that the contents of the book could be easily condensed in half the pages."	register	15.153983	-3.9274483	comment	4.0	15.0	1598253840	-10.455996
24287054	Looking good!potential off-topic but	Looking good!potential off-topic but this make me think of this:Can one work through SICP using Racket?	valbaca	15.360693	-3.6567578	comment	4.0	13.0	1598474645	13.608454
19999295	A long time ago I wrote a tutorial f	"A long time ago I wrote a tutorial for FORTH.  It's in two parts, a part written in i386 assembly: https://github.com/nornagon/jonesforth/blob/master/jonesfort...followed by a part written in FORTH: https://github.com/nornagon/jonesforth/blob/master/jonesfort...It builds gradually from asm primitives into a somewhat sophisticated language with features like exceptions, function inlining and a decompiler.The major strength, probably unique amongst programming languages, is that you can keep the entire system in your head (by ""system"", I mean both language and the simple operating system that it implements).  The downside is that the code is write-only."	rwmj	15.0251875	-3.8254068	comment	4.0	12.0	1558683219	6.0878863
20110820	One of the Racket tutorials actually	One of the Racket tutorials actually goes into an example of using continuations to save application state for a web app (https://docs.racket-lang.org/more/index.html#%28part._.Conti...).One issue with this approach is that it doesn't really scale easily beyond a single server. You need something like the JVM which allows for closures to be sent between machines sharing the same code base. Plus, even in the JVM case, you must have the class files required by the closure available on the JVM which tries to run it.I really think it is a better idea to just use a database and pass state explicitly rather than trying to do something fancy with continuations. However, continuations can be extremely useful for making the server asynchronous without making it look asynchronous.While Promises are 	slaymaker1907	15.337829	-3.6851537	comment	4.0	16.0	1559785363	13.587035
20244941	Last I checked, Racket literally has	"Last I checked, Racket literally has sublanguages defined for teaching and learning: ""Beginning Student"", ""Beginning Student with List Abbreviations"", etc.https://docs.racket-lang.org/htdp-langs/index.html"	gmfawcett	15.359383	-3.6645334	comment	4.0	14.0	1561140478	13.648044
20312710	I’ve always thought it unfortunate t	I’ve always thought it unfortunate that fexprs were dropped for macros in lisp. For a language that touts homoiconicity and first class functions/objects, it feels strange that macros aren’t first class.My understanding is that fexprs have some perfomance problems over macros, but I’m not really sure why or if the state of the art has advanced since then.A really interesting evolution of lisp is Shen. The license is terrible and I seriously doubt it will ever achieve widespread use. And while the idea of a kernel lisp sounds great, in practice I doubt that it actually works.The performance trade-offs that you’re going to need to make become very unclear when you have a language that can run on A python, CL, js, or whatever runtime. The JVM is successful because it unifies language and impl	mruts	15.1654	-3.9241903	comment	4.0	16.0	1561817852	-10.407185
20445739	Rebuilding Racket on Chez Scheme Exp	Rebuilding Racket on Chez Scheme Experience Report [pdf]	hencq	15.363674	-3.6488464	story	4.0	98.0	1563228355	13.65287
20551031	Forth is pretty amazing. It really d	Forth is pretty amazing. It really delivers on that old promise of “a language that will make you a better programmer in other languages”.However, from my experience, since there is basically no syntax, all Forth programs tend to be a DSL for the problem at hand. It’s almost like having to learn a new language ok each new project. It’s like a complete opposite of what makes Go great.	haolez	15.040834	-3.8174856	comment	4.0	32.0	1564366773	6.073859
20711121	“This is “how I tricked my co-worker	“This is “how I tricked my co-workers” into using Racket.”	spdegabrielle	15.374491	-3.635366	story	4.0	9.0	1565915948	13.643022
20820161	Previous discussions from last year:	"Previous discussions from last year:
https://news.ycombinator.com/item?id=16860646
https://news.ycombinator.com/item?id=16679963(Common) Lisp usually gets more use than exposure, so it's nice to see large-scale Lisp success stories.  Makes me feel warm and fuzzy inside, as it's one of my two favourite languages (the other one being, of course, C).Edit: APL is a close third, but let's be realistic."	gilesgate	15.160865	-3.9063168	comment	4.0	21.0	1567002819	-10.471099
13628600	Author here.  I'm on the road today 	Author here.  I'm on the road today so latency will be high but I'm happy to answer any questions people have.  Also, a shameless plug: I'm still coding in and writing about Lisp.  Some currently active projects:https://github.com/rongarret/ergolibhttps://github.com/rongarret/BWFPhttps://github.com/rongarret/tweetnacl/blob/master/tweetnacl...And I just finished (but have not yet published) a Lisp implementation of the Signal double-ratchet.  If anyone is interested let me know and I'll publish that too.	lisper	15.152472	-3.9294705	comment	4.0	21.0	1486911550	-10.479231
13656397	Chez Scheme as the Racket VM	Chez Scheme as the Racket VM	nickmain	15.352229	-3.6626563	story	4.0	218.0	1487200409	13.645401
13656943	The benchmarks for Chez Scheme are p	The benchmarks for Chez Scheme are pretty impressive. Provided Racket-on-Chez is able to captitalize on that, this is pretty exciting.Also, that makes it hypothetically possible that HN could end up running on Chez's VM because HN is written in Arc, which is I believe written in Racket, which may in the next year be written for Chez Scheme's VM.	peatmoss	15.356906	-3.6605868	comment	4.0	35.0	1487205366	13.64239
13658225	I thought Racket was a scheme implem	I thought Racket was a scheme implementation?	timClicks	15.354493	-3.668662	comment	4.0	12.0	1487229035	13.646307
13663394	Give me a compelling reason to desig	Give me a compelling reason to design programs in an object-oriented way. Just to be clear, I don't find the ability to subvert existing definitions particularly attractive, because it undermines my ultimate goal to actually prove things about my programs.---@lispm, I have reply here because I'm temporarily unable to make new posts.> A large share of contemporary software is written in an object-oriented way.Sure, but how does that contradict my original assertion that Racket's mechanisms for extending and redefining the language are more principled than either Common Lisp's or Smalltalk's?---> Could it be that you just don't like/use/need/want the object-oriented ways to extend those languages and thus these mechanisms are not 'principled'?You're right that there's an aesthetic component:	catnaroek	15.340189	-3.6854792	comment	4.0	24.0	1487277774	13.632122
13683313	As someone who has to use Guice at w	As someone who has to use Guice at work, and not by choice, the following critique best sums up my thoughts on Guice.http://omaritech.blogspot.com/2014/03/why-google-guice-is-ev...Am I in the minority here? Do most people really think that the Guice framework approach is a good idea?	whack	15.208916	-3.7478693	comment	4.0	20.0	1487551754	-10.181894
13888438	0) Guile is a GNU project1) Guile ha	0) Guile is a GNU project1) Guile has no Global Interpreter Lock.2) Guile is a scheme, so it is homo-iconic cf. https://en.wikipedia.org/wiki/Homoiconicity3) Scheme (and lisp in general) are nice to write Domain Specific Languages.4) Guile doesn't have a particular overhead for calling simple functions which makes it possibly as fast as C.5) Guile has a very powerful object oriented programming framework beating by far Python and Ruby OO systems.6) Guile is optimised for immutability which makes it for safer code.7) Guile has Guix which has 'guix pack' command which is awesome cf. http://git.savannah.gnu.org/cgit/guix.git/tree/doc/guix.texi...8) Guile has a lot of supporters cf. https://lists.gnu.org/mailman/listinfo/guile-user9) Guile has 	amirouche	15.191742	-3.783652	comment	4.0	21.0	1489693275	-10.22538
13974653	The main problem with (GNU) APL for 	The main problem with (GNU) APL for me is the line editor: I can't feel comfortable using a REPL to write a program without keybindings like ctrl-a, ctrl-w. Everytime I try to learn APL I eventually give up.	rnhmjoj	15.566995	-2.69301	comment	4.0	13.0	1490684411	13.088877
14173956	Has there been any update to the sta	"Has there been any update to the status of GuileEmacs? I have read that it aims to be ""the future of Emacs"", but I rarely see mention of Guile from the Emacs community."	nagvx	15.194065	-3.7874074	comment	4.0	13.0	1492885991	-10.287466
14249908	Keyword: dialect. But Erik Naggum, 2	"Keyword: dialect. But Erik Naggum, 2002 [0]:> The ""Lisp"" Scheme is a dialect of is no longer the current meaning of
  ""Lisp"".  It is somewhat like calling English a dialect of German because
  of ancient history that has since between invalidated by each of their
  separate evolution, Fahrvergnügen, Weltanschauung, Kindergarten, and
  Pennsylvania to the contrary notwithstanding.  There is also a very
  limited value in talking about ""Germanic languages"" in terms of your
  actual ability to use any of the Germanic languags.  You do not order the
  ""vertebrate"" in a restaurant, but generally choose between fish or bird
  or meat.  In other words, there is a time when an abstraction and a
  commonality has completely ceased to be valuable.[0] http://www.xach.com/naggum/articles/3224964049435"	Jach	15.138594	-3.927311	comment	4.0	20.0	1493754481	-4.763329
14287943	A History of CLU – Barbara Liskov (1	A History of CLU – Barbara Liskov (1992) [pdf]	tjalfi	15.140153	-3.9250019	story	4.0	75.0	1494194515	-10.397837
14516856	Forth is probably the smallest true 	Forth is probably the smallest true high level language there is. It is entirely self-contained, needs just about nothing in terms of hardware support and can run in as little as 2K of memory.It is well suited to things like real-time control, you'll probably have a hard time getting used to stack manipulation (especially in the beginning) and it tends to keep you up all night (not sure if that is a strength or a weakness ;) ).It will also be the most fun you've had with a computer in a long time and it will likely make you look at the rest of what we do with computers as clunky in the extreme.What Forth is not really suitable for is large projects and things built with a team. It is more of an artisanal thing, something closer to watchmaking or jewelery than major construction.If you want	jacquesm	15.038132	-3.823715	comment	4.0	16.0	1496952728	6.1510777
14582462	I used Emacs Lisp for scripting task	I used Emacs Lisp for scripting tasks like code and data generation. It is great to have an ability to evaluate form right inside the spot you want results to be inserted. This kind of code does not require AST manipulations or macro.Also, some of my projects that become bigger than 1000 LoC could benefit from static typing and (subjectively) better tooling.By the way, I think extending Emacs in Racket would be great; just do not have an idea on how to implement that integration smoothly.	quasilyte	15.340926	-3.687301	comment	4.0	12.0	1497814895	13.657436
14662078	Started looking at getting into Rack	Started looking at getting into Racket and CL after reading up on lisp and there is something about it that really bugs me, in a good way. Sadly the train seems to have left the station regarding positions where you use lisp where I live. All is java and C-flavors.	laxentasken	15.300145	-3.7521477	comment	4.0	50.0	1498731841	13.650462
14670909	Dyalog APL 16.0	Dyalog APL 16.0	sndean	15.568579	-2.6877434	story	4.0	65.0	1498832555	13.092667
14688189	If they allowed FORTH it would be ev	If they allowed FORTH it would be even worse -- everything in FORTH is redefinable -- you could make 1 equal to 2 if you want.	jhbadger	15.037714	-3.808411	comment	4.0	19.0	1499089708	6.1043925
30777090	Is there any progress made on modern	"Is there any progress made on modernizing Emacs internals? Like* disentangling it from GTK to make Emacs a proper GUI citizen or
* the shift from Emacs Lisp towards ... is it Guile?"	jhoechtl	15.169835	-3.8156042	comment	4.0	21.0	1648032681	-10.294012
30978934	For those who may not be familiar wi	"For those who may not be familiar with Erik's thinking and style, here is a sample post[1] from Erik on Paul Graham's Arc dialect of Lisp, which, I recall, still powers HN:I have briefly looked at Arc. It is yet another demonstration of the
problem of too strong an ego that cannot live with what somebody else has
made. Be it the standard conditionals, nil versus false versus the empty
list, or whatever else this purportedly strong ego is too weak to accept,
it is nothing more than proof of the core problem of the IT world -- the
hardness of its pillars makes them brittle, not strong, so they cannot be
used to build upon. What was it that stood so much in the way that Paul
Graham could not have accomplished it without creating a new language?
Why was creating a new language and starting fro"	jonjacky	15.152008	-3.9239688	comment	4.0	18.0	1649609541	13.122806
31231520	Why would you want to learn racket a	"Why would you want to learn racket after having learned sml? racket is great, no question about that, but it is mostly an educational tool and a ""first language"". I personally would rather choose a language with a broader real world user base. if you're interested mainly in functional programming, haskell would be a reasonable choice after sml. if not, there are plenty of other possibly more rewarding choices (on the long term)."	stewbrew	15.356714	-3.6656294	comment	4.0	13.0	1651466247	13.606498
31593681	Great work!  You write,> …wasm has a	Great work!  You write,> …wasm has a few poor decisions in its design that make it less-than-conducive to being a target for Common Lisp…Could you say a bit more about those design decisions?	gumby	15.154588	-3.928263	comment	4.0	22.0	1654170101	7.6898084
28875071	Anyone who had used or tried Carp an	Anyone who had used or tried Carp and Janet (that was on frontpage the other day)?What are some strong points on Carp vs. Janet?	fuzzythinker	15.061399	-3.887201	comment	4.0	22.0	1634280764	9.9349165
28930045	I will note that the article doesn't	"I will note that the article doesn't contain the word ""readability"". APL is the classic example of a ""write-only"" language."	_rgek	15.562054	-2.6902936	comment	4.0	23.0	1634734397	13.088016
28930296	"""Language X is a write-only language"	"""Language X is a write-only language"" seems to be code for ""it doesn't look like C.""I've also heard Forth and Lisp described this way. And yet I find both readable since I have experience using them. I wonder if APL is similar: It's only unreadable to people who don't know the language. Well of course it is."	dreamcompiler	15.559389	-2.6991243	comment	4.0	17.0	1634735958	13.088819
28930842	I don't know which would be more pai	I don't know which would be more painful, trying to program on a touchscreen, or trying to program in APL.	thrower123	15.550906	-2.688429	comment	4.0	13.0	1634739046	13.08061
28990878	History of Lisp (1979) [pdf]	History of Lisp (1979) [pdf]	iamcurious	15.153091	-3.9256647	story	4.0	153.0	1635184084	-10.405552
29056026	I'll always vote up submissions refe	I'll always vote up submissions referencing anything FORTH related.  For me FORTH is as much fun as lisp appears to be for others.  I've never really done much with it, but I always like the simplicity and the ability to reason about it.Sure FORTH has problems of its own, but it's always nice to use.  I've hacked up a couple of simple FORTH-like systems over the years, most recently this one which was inspired by a thread on this site:https://github.com/skx/fothA lot of people go through guides of writing a lisp, I'd love to urge people to try writing a simple FORTH interpreter instead, or even something somewhat related such as TCL.	stevekemp	15.093974	-3.875838	comment	4.0	18.0	1635677022	6.154295
29260683	The specific issue with reading Fort	"The specific issue with reading Forth is that unlike other languages, you, the reader, need to be intimately familiar with the call semantics of every word that you're trying to read. In most other languages, this is not a problem as (most) are explicit in what's being passed and returned. And Forth is unlike BASIC where most most everything is implicitly global.This issue with Forth is because you have the ""invisible"" stack as a first class parameter passing system. So, given a string of Forth words, while the stack may be apparent at the start (perhaps as a comment at the entry of a high level word), what happens to that stack during processing is opaque to the reader. Then you have have issue within individual words of stack gymnastics to get everything lined up for the interior process"	whartung	15.034156	-3.8306837	comment	4.0	18.0	1637194854	6.120679
29261538	It's too bad APL never enjoyed ubiqu	It's too bad APL never enjoyed ubiquity on Unix-like platforms. The world would have been a better place. Maybe if Stallman or some early GNU participant had championed APL we'd all be either using APL or constantly excusing ourselves. Like Emacs did for Lisp.I'm decent with sed. I wouldn't call myself an expert, but know how to employ addressing and hold spaces, which are sadly aracana to most people who employ sed. I ended up learning sed because it was there, proved useful, and it fit into the command-line toolkit really well. (In order of importance.) APL would never slot into that toolkit as well as other tools, but it's value-add would more than compensate. Unfortunately, the value-add isn't enough to compensate for the fact that it's not there and in your face every time you're expl	wahern	15.564854	-2.695783	comment	4.0	14.0	1637204319	-10.180167
29520481	I was watching the youtube series on	I was watching the youtube series on solving advent of code in APL and was blown away. I immediately checked this site to see if X == APL just to get a sense of what the hell is going on, but unfortunately it's not yet there yet.Anyone got a favorite obscure language they could recommend?https://www.youtube.com/results?search_query=apl%20advent%20...	bko	15.563032	-2.695826	comment	4.0	13.0	1639226430	13.089991
34181446	The reason Forth is not used in prod	The reason Forth is not used in production is that its philosophy goes against that of commercial software. The goal of commercial software is to create complex and over-engineered solutions that will force people to pay in one way or another. Languages like C++, Java, Python, and Go are ideal for this. Forth is about creating very simple solutions in as little code as possible. It is better suited for embedded systems and prototype projects.	coliveira	15.036798	-3.808542	comment	4.0	26.0	1672370964	6.07774
16848348	I have used Fortran 90+, Python with	I have used Fortran 90+, Python with Numpy, R, and (rarely) Matlab/Octave, all of which allow operations on whole arrays and array sections. Would they be considered array languages? What is qualitatively different about APL, J, and K?	poster123	15.550355	-2.7130914	comment	5.0	38.0	1523880389	13.015737
16952385	I have no idea of what APL is, and t	I have no idea of what APL is, and the thing doesn't even bother explaining it.	wfwefwef32	15.564815	-2.6892397	comment	5.0	25.0	1525015615	13.089148
16953540	You can assign a name to each of tho	"You can assign a name to each of those symbols if you want and have something equivalent to what you just wrote.tranpose=:⍉take:=↑index=:⍳each=:¨done, now I can write (⍉↑x⍳¨x) as (transpose take x index each x)But the entire idea of APL is notation as a tool of thought.Would you write read your maths as
five plus twenty is equals to twenty five
or 5 + 20 = 25?Would you rather read music with it's musical notiationor quarter note at middle C, quarter note at middle E, etc?The entire idea of APL is that we read and write algorithms the way we read mathematical and musical notes."	segmondy	15.565354	-2.6929617	comment	5.0	21.0	1525030740	13.084821
17404379	Oh, DOS.It's always sad to read hist	Oh, DOS.It's always sad to read histories of computing during the 80s. It was a lost decade in many ways. Much more powerful and competent paradigms were alive and vital at the start, but by the end, they were all collapsing. A few different choices, a little bit better business sense, and we'd have a computer world profoundly alien to the one we have now.It's still possible, of course. But it'd be wearing the hair shirt and being a lone hacker as you built up your system.I refer, of course, to both Lisp and Unix machines, along with the various developments in parallel architectures. The Unix machines as sources of power and use lay quiescent for many years, until maybe the early 00s, and IMO the Lisp machines path has never been genuinely walked.There's an elegy to be written for the los	pnathan	15.142795	-3.921724	comment	5.0	40.0	1530051143	-10.342269
17534245	APL at Its Core	APL at Its Core	panic	15.566677	-2.6893106	story	5.0	77.0	1531640894	13.086674
17833139	"Wow, just read that bit about ""HtDP "	"Wow, just read that bit about ""HtDP and Colleagues"". What a pretentious bit of writing with no actual arguments. The strawman they propose is just one argument, and is not the one I would reach for when arguing against Racket in CS1. I am open to being persuaded about these silly language wars, but the argument there is completely uncompelling. I hope they have the real back-and-forth laid out somewhere else."	acbart	15.355998	-3.6653624	comment	5.0	19.0	1535091584	1.3416958
19842238	Alan Kay on “What Made APL Programmi	Alan Kay on “What Made APL Programming So Revolutionary?”	fniephaus	15.564793	-2.6901052	story	5.0	53.0	1557166908	13.072312
37682270	APL people often point to the defini	"APL people often point to the definition of ""average"" as evidence for its economy of expression: +/÷≢They make the argument ""the word 'average' has more symbols than its definition, so why not just use the definition inline as a tacit function?""There's some elegant beauty in this that I'm sympathetic to.  However, I think it's fundamentally flawed for one big reason, which in my opinion is the core of the unreadability of APL (and other array languages that rely on custom symbology):Humans think in words, not letters.  There is never semantic content in individual letters; a word is not defined by its letters.  Sometimes a word's definition can be deduced from its syllables (""un-happi-ness"") but the number of prefixes/suffixes is miniscule compared with the number of root words.We naturall"	saulpw	15.563492	-2.6920047	comment	5.0	17.0	1695853628	13.080549
37689537	Well APL is great but it is write-on	"Well APL is great but it is write-only. Also naming is hard, but in APL it is very easy: you just don't do it. What does the following do?    program ← {⊃1 ⍵ ∨.∧ 3 4 = +/ +⌿ ¯1 0 1 ∘.⊖ ¯1 0 1 ⌽¨ ⊂⍵}

Libraries in other languages deal with arrays just fine, and can solve actual problems at internet scale. Like numpy/jax, or pytorch, which will compile your code to clusters of TPU/GPUs. Most of the useful primitives of APL are present in these libraries (iota, reshape, reduce, etc[1]). The function composition primitives in APL are fine from a theoretical viewpoint, but I can't help feeling like I'm dealing with some obfuscation language crafted by academia to protect some fiefdom. Is it really that interesting to have a primitive for swapping arguments? Isn't that in the domain of conventio"	BenoitP	15.564241	-2.6976075	comment	5.0	25.0	1695908761	13.072881
38122267	Ask HN: Looking for statically typed	Ask HN: Looking for statically typed, No-GC and compiled Lisp/scheme	soulbadguy	15.071562	-3.9015224	story	5.0	3.0	1698969945	-5.6000624
38505690	There's also April APL: https://gith	There's also April APL: https://github.com/phantomics/aprilAlso the array language family seems to be stronger than ever with foss: ngn/k, BQN, uiua, and of course J but as you mentioned they're all different languages.	liveranga	15.545749	-2.7212403	comment	5.0	15.0	1701591703	13.046771
33121976	RacketCon 2022	RacketCon 2022	jessealama	15.382284	-3.6284184	story	5.0	66.0	1665153475	13.650658
33361538	Ask HN: Anarki or Racket?	Ask HN: Anarki or Racket?	hawkeyedan	15.309123	-3.7394533	story	5.0	5.0	1666894043	13.656446
33639085	APL died for the same reason Perl is	APL died for the same reason Perl is fading: it is a write-only language.Those symbols look cool. But they're not very far away from Brainfuck.	diego_moita	15.562097	-2.6929276	comment	5.0	30.0	1668694265	13.100014
33639665	APL is from an era where impressivel	"APL is from an era where impressively functional code that looks like line noise (another obsolete concept) was considered heroic.  Other examples of such code are text editing and text formatting macro languages.  Recall that EMACS stands for ""Editor Macros"" because that was its original implementation.Back then, computers were so limited relative to human capability that this was still a good thing. Those days have gone.  The bizarre syntax of APL has had its day.  Its powerful array manipulation primitives can easily be brought forward into a language with modern syntax, and haven't they?  In my company there is a lot of Matlab usage but I'm personally not knowledgeable."	MarkusWandel	15.561435	-2.6998284	comment	5.0	25.0	1668696902	13.079931
33640132	> Its powerful array manipulation pr	"> Its powerful array manipulation primitives can easily be brought forward into a language with modern syntax, and haven't they?Kind of. The languages that one might expect to do this (Julia, R, NumPy) have picked out a few things from APL in an inconsistent way, leaving a lot as well. For example most are missing the generalization of prefix sum that APL calls ""scan"". So in [0], Conor was able to translate some code to every language in the APL family but not yet any outside of it. Another one, I don't think I've ever seen Replicate[1] outside the APL family. It's a generalization of filter to take an arbitrary count instead of 0 or 1 that's often useful if you know about it.[0] https://github.com/codereport/array-language-comparisons/blo...[1] https://mlochbaum.github.io/BQN/doc/replicat"	mlochbaum	15.559754	-2.7021284	comment	5.0	17.0	1668698625	13.067128
33680178	Beside embedded system or firmware, 	Beside embedded system or firmware, what are Forth's popular use cases these days?Personally I never see backend development or mobile frontend job vacancies that require Forth skill, for example.	anta40	15.0238085	-3.8153427	comment	5.0	24.0	1668944632	6.1406226
35396696	APLcart – Find your way in APL	APLcart – Find your way in APL	whereistimbo	15.568608	-2.6851342	story	5.0	109.0	1680318656	13.102516
28092453	Don't flame me, but I think APL is t	Don't flame me, but I think APL is the perfect language to introduce coding to kids. I've had great success with it personally. The symbols are suprisingly intuitive to them, and APL's strengths match the domain of what kids typically do with computers at first.	queuebert	15.566446	-2.6906755	comment	5.0	24.0	1628282202	13.080732
28179824	I'd be a loyal user of Racket, if it	I'd be a loyal user of Racket, if it was reasonably easy to use with an IDE similar to VS Code.Emacs is too involved for a casual hobbyist like me, while Dr Racket feels a bit toyish.	teh_g	15.361349	-3.6551204	comment	5.0	30.0	1628940644	13.657572
28512406	Racket GUI Screenshots	Racket GUI Screenshots	xojoc	15.367729	-3.6315641	story	5.0	82.0	1631545565	13.647808
12552288	Fibers in Guile Scheme	Fibers in Guile Scheme	srean	15.173565	-3.7675858	story	5.0	74.0	1474492351	9.307093
13342054	Lispy sets	Lispy sets	codr4life	15.156459	-3.9291127	story	5.0	66.0	1483756322	-10.478252
27516817	This it the end of an era. Although 	This it the end of an era. Although most people will have never seen it, APL was a pretty influential programming language. It is the main reason that Kenneth Iverson received the Turing award.It uses its own character set, which makes it possible to write very programs that performed quite complicated calculations. The down-side is that programs are generally hard to understand by outsiders (like yourself next year). All people that complain that Perl is difficult to read, should certainly try APL.When IBM stops supporting some technology, you can be certain that it is absolutely commercially dead. RIP.	aliasEli	15.564531	-2.6958547	comment	5.0	22.0	1623770645	13.09716
27639731	> This, however, I disagree with. I 	"> This, however, I disagree with. I mean in a general sense, not specific to how your brain is wired. It all depends on the first couple of language that one learns and how they are learnt and taught. 10-15 years ago people would find it hard to grok Python's functional concepts. But as it began to be taught as the first language in universities and those graduates join the working population you see how it's super natural for them to grok Python.That must be the reason why Edsger W Dijksta once stated [0]:> ""It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration.""... and ...> ""The use of COBOL cripples the mind; its teaching should, therefore, be regarded a"	wsc981	15.552964	-2.7048762	comment	5.0	35.0	1624690052	13.065972
27805491	Speaking impersonally, and not direc	Speaking impersonally, and not directly to OP, you can program in Common Lisp in industry, you just don’t want to that badly, and then you justify why you can’t by making up reasons about not being able to hire, not being mainstream, not finding jobs, etc. etc.Somehow, I’ve been able to keep stable employment as a programmer that writes Lisp for over a decade. I’ve written Lisp at startups. I’ve written Lisp at Facebook. No, I haven’t been a consultant on some weird legacy Lisp project either. The difference between me and someone who doesn’t have a career in Lisp is:- I choose Lisp for projects that benefit from Lisp;- I make the case to technical and non-technical people that I can solve their problem cheaply and efficiently, often with a concrete demo and without any of the vague promis	reikonomusha	15.200615	-3.8871346	comment	5.0	35.0	1626047231	-10.514595
12117177	FYI, Racket's syntax macros is from 	"FYI, Racket's syntax macros is from its Scheme roots. For further information on what Scheme provides, by standard revision:R5RS: [0]R6RS: [1]R7RS: [2] (Page 22)And many Schemes provide non-standard extensions; for instance, Chicken supports non-hygienic macros[3].FWIW, I prefer to think of the two stages as ""syntax expansion"" and ""evaluation"", and not ""compile time"" and ""run time"". Compilation and running are loaded terms that don't appropriately capture the totality of situations where this behaviour applies, in Scheme.0: http://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-8...1: http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_se...2: http:"	dleslie	15.211372	-3.860169	comment	5.0	38.0	1468867138	-10.263864
12312467	Tutorial: Zero to Sixty in Racket	Tutorial: Zero to Sixty in Racket	Learn2win	15.380207	-3.6267705	story	5.0	91.0	1471528497	13.642974
12499276	As of GSoC 2014, I believe Guile Ema	As of GSoC 2014, I believe Guile Emacs works with only some performance regressions (I believe due to overuse of dynamic scope?). In any case, you can run it today if you wanted to, just follow the process outlined on the wiki [0]. That said, I don't think the Emacs project has fully committed to porting over for various reasons, probably in part because running Guile on some platforms (Windows) is really difficult, and thus would be a problem for users. I'm sure the people in #guile on FreeNode could give a much more detailed answer though, I don't follow the Guile/Emacs thing so closely as I'm mostly a CHICKEN Scheme / Vim user.[0] https://www.emacswiki.org/emacs/GuileEmacs	ThatGeoGuy	15.180683	-3.7909882	comment	5.0	20.0	1473874174	-10.26865
22370649	I met Larry in about 1992 when I wen	"I met Larry in about 1992 when I went to work on the Newton project. I had seen him around Apple before, and I knew who he was and what he was known for, but I didn't actually meet him until I joined the Newton team. I found him friendly, modest, smart, shrewd, compassionate, full of interesting knowledge and ideas, and interested in other people and their ideas.I got to know him better when John Sculley ordered him to have the Newton team ditch its Lisp OS and write one in C++. Larry approached me and a couple of other Lisp hackers and asked us to make a fresh start with Lisp and see what we could do on Newton. We wrote an experimental OS that Matt Maclaurin named ""bauhaus"".Larry had a sabbatical coming up right about then. He took it with us. He crammed into a conference room with three "	mikelevins	15.095664	-3.9058452	comment	5.0	21.0	1582150316	-10.323458
22380986	Racket-on-Chez Status	Racket-on-Chez Status	ausimian	15.374573	-3.6303334	story	5.0	137.0	1582260125	13.651784
22833478	Since this flurry of APL/J/K/A+/Q ar	"Since this flurry of APL/J/K/A+/Q articles started, I've been wondering about the relationship between APLs and literate programming.They say that APL was developed to mimic mathematical notation, and I see the resemblance. But real works of mathematics consist of one or two lines of expressions separated by sentences and paragraphs explaining the goal of those expressions.So far in K ""advertising"" I only see the expressions and not the explanations. The explanation is there, but it's not a comment in the codebase; it's in a blog post that explains it. The code has many lines of expressions on top of each other, and nobody writes math that way.I feel like I'm missing something, basically. It's clear how to write K, but what are the best practices for making a large codebase readable? I sho"	scythe	15.564538	-2.6941535	comment	5.0	27.0	1586529719	13.070273
22878110	One idea I've always wanted to try o	One idea I've always wanted to try out if I had the knowledge and time is creating a text editor in Racket that effectively worked like Emacs, but instead of elisp you leveraged the language creation features of Racket. So your init.el could be #lang Python and then you would configure it using Python, or #lang Java or even #lang elisp. Of course all of those languages are just being translated back into Racket but that's not the point. The idea would be that you could customize the editor using the syntax you preferred.There are definitely some cons to this approach. But the goals would be accessibility and customizability for the end user especially people without a programming background.Oh and you could choose Emacs or Vim keybinding and all editor functionality would be supported usin	Decabytes	15.346186	-3.6808	comment	5.0	21.0	1586960955	13.651424
23058909	I don't really understand these arra	I don't really understand these array based J/K/APL languages but from a distance it would seem like they would primarily be useful for numerical based work such as finance or calculating patterns on 2d arrays (game of life). The languages seem more mathematical than software engineering based.It reminds me about when I was learning my first programming language. The book had a ton of example with simple numerical computations (e.g., calculate leap years) and I soon became competent with the language's facility for basic mathematical operations. But as a programmer now I have very little use for these operations so when I learn a new language I have only a rudimentary understanding of how to do math in that language.Is this correct or am I misunderstanding the usefulness of array based lan	zests	15.55836	-2.70341	comment	5.0	36.0	1588513216	13.060094
23059592	Having used APL professionally for t	"Having used APL professionally for ten years from the early 80's to early 90's I am a big fan.  I used it for a wide range of applications, from business systems to DNA sequencing.  I even published a paper at a conference eons ago.So, yeah, I am an ""APL guy"".  And, yeah, I think it's dead.Well, not really, but, yes really at the same time.Let's start with the most glaring issue:https://www.dyalog.com/prices-and-licences.htm#devlicpriceYeah, $1,600 USD for a language license?  No. Thanks.  Go away.In addition to this:""In addition to a current Developer Licence, a Run Time Licence is necessary if:""Yeah, no.  Go away.And then...""When several users use one or more applications on a shared server, a Server Licence is required.""No.  Definitely no.  Please, pretty please, with sugar on top...go "	robomartin	15.563155	-2.687754	comment	5.0	17.0	1588519983	13.099445
23133099	Taking an SICP-like class in Racket 	Taking an SICP-like class in Racket and playing with recursive constructs for the first time was one of the highlights of my CS education. This language gave more unalloyed joy than anything else I've done as a programmer, though I've yet to build anything practically useful in it.	sohamsankaran	15.3479185	-3.6494448	comment	5.0	47.0	1589122687	13.533286
23201888	History of Lisp (1979) [pdf]	History of Lisp (1979) [pdf]	alokrai	15.153713	-3.9260323	story	5.0	101.0	1589621294	-10.436979
34067071	I like APL (and k/j). Problem is, ou	I like APL (and k/j). Problem is, outside trading (and even there it's a niche), it is just not popular enough. This also because most people dismiss it as line noise / write only programming language; that's usually only people who never used it or used it briefly saying that. But it's hard to promote anything that has a reputation like that.What is a fairly interesting observation (more people have made it, including Arthur Whitney); being able to reason about a program for which you can see all the code on one A4 without having to clickthrough into functions, search, browse through files, classes or even having to scroll is incredibly powerful. All you need is the cheatsheet (provided in your article) (which you know by heart in no time flat) and the program, which, often fits on 1 A4 o	tluyben2	15.56284	-2.6940432	comment	5.0	31.0	1671549640	13.098777
27039136	FORTH is very different from LISP bu	FORTH is very different from LISP but it's very similar in that you can use the quote operator to write control structures the same way you write any other function.Common LISP had CLOS that implemented object-oriented programming in a style not too different from Python,  but as a library without compiler support and that was also true for late 1980s FORTH.	PaulHoule	15.092925	-3.8853836	comment	5.0	16.0	1620144505	6.001176
14896010	Release Announcement for Racket 6.10	Release Announcement for Racket 6.10	nickmain	15.379692	-3.6281366	story	5.0	100.0	1501536300	13.649366
14902948	~12 years ago, it was Patrick Collis	~12 years ago, it was Patrick Collison that was named young scientist of the year for developing a dialect of Lisp called Croma:http://lemonodor.com/archives/001038.htmlI'm glad to see he has continued to do well.	mschaef	15.159606	-3.8955622	comment	5.0	27.0	1501607427	-10.424801
14924141	The Development of Chez Scheme (2006	The Development of Chez Scheme (2006) [pdf]	tosh	15.332721	-3.6763587	story	5.0	98.0	1501796365	13.6401005
14943127	Getting Started in Star Lisp (1991) 	Getting Started in Star Lisp (1991) [pdf]	tosh	15.156034	-3.922682	story	5.0	63.0	1502049349	-10.448204
28815724	Lisp in a Weekend	Lisp in a Weekend	kelseyfrog	15.152504	-3.9291596	story	5.0	173.0	1633839608	-10.451235
29134609	Racket v8.3	Racket v8.3	nikivi	15.377308	-3.625987	story	5.0	154.0	1636239236	13.655734
29631643	Femtolisp – A lightweight, robust, s	Femtolisp – A lightweight, robust, scheme-like Lisp implementation	thetwentyone	15.157931	-3.921171	story	5.0	133.0	1640041374	-10.4477825
25603559	ToriLisp – an ersatz Lisp for tiny b	ToriLisp – an ersatz Lisp for tiny birds	grzm	15.151079	-3.9018762	story	5.0	71.0	1609512268	10.557899
25895481	I used Racket in an intro to CS cour	I used Racket in an intro to CS course a few years ago and was told it’s designed to be a teaching language. Is there any reason to use racket over a more popular functional language? Does anyone use it in production?	DC1350	15.358159	-3.6637561	comment	5.0	22.0	1611519513	13.648115
26172880	The difference is that Forth compile	The difference is that Forth compilers can be bootstrapped from not-very-much assembler on an embedded system. That's not really true for Lisp and Smalltalk. Forth impresses me because of the degree of leverage that bootstrapping process affords for small computers.	dreamcompiler	15.03289	-3.8349717	comment	5.0	26.0	1613602172	6.09221
13882006	Cool. I'm always game for a good dis	"Cool. I'm always game for a good discussion of DSL's and Lisp (Racket).But what struck me immediately was the quality of the ""Why Lisp Why Racket"" essay. This is probably the most compelling that I've seen as it gets specific and cites near-term benefits – not just the elitist ""it's good for you"" or ""it'll make you smarter"" stuff. Nicely done."	untangle	15.323688	-3.714508	comment	5.0	18.0	1489632313	13.643125
13884838	For me this is the most exciting par	"For me this is the most exciting part: Complete Emacs-compatible Elisp implementation    Thanks to the work of Robin Templeton, Guile's Elisp implementation is now fully Emacs-compatible,
     implementing all of Elisp's features and quirks in the same way as the editor we know and love.

This means we can finally have a proper GuileEmacs!"	pkd	15.180395	-3.803649	comment	5.0	27.0	1489671242	-10.326862
13888351	"Every few months I think to myself """	"Every few months I think to myself ""maybe I should learn Lisp,"" but then I see things like this, and my suspicion that Lisp has been fetishized beyond all reason starts seeming more likely, and I decide to put that exercise off a while more.At this point, I suspect I'm never going to choose to learn Lisp."	nolemurs	15.171456	-3.914596	comment	5.0	32.0	1489692743	-10.468661
13905066	APL is a language that confuses the 	APL is a language that confuses the hell out of me, and I hate that.  I wish there was more guidance online to using it, since I find the paradigm to be very interesting.	tombert	15.564605	-2.6946657	comment	5.0	25.0	1489895429	13.081757
13920747	I've just skimmed through the first 	I've just skimmed through the first couple of pages, but didnt find anything about which lisp to use/howto. Any ideas?	laxentasken	15.145421	-3.9297473	comment	5.0	21.0	1490087784	-10.45914
13974505	Is APL still used for anything now? 	Is APL still used for anything now?  It seems like it could be a useful language for _something_.	ColanR	15.563248	-2.6984396	comment	5.0	28.0	1490681689	13.085978
14520100	Can anyone point me to a Forth imple	Can anyone point me to a Forth implementation where the absolute bare minimum is written in (C/assembly/whatever) and everything possible is then bootstrapped in Forth itself?I recall reading what the minimal word set needed to be able to write the rest of standard Forth (Fig Forth if I recall) but I seem to remember that most implementations don't push the purity quite that far for performance reasons.	andybak	15.034381	-3.821924	comment	5.0	15.0	1496998311	6.0898237
23452252	I think I've had my own moment of cl	I think I've had my own moment of clarity that spans both Forth(s) and Lisp(s) and explains why neither is as common as other languages.In most common languages, there is a complicated base spec that covers many cases and defines a broad range of affordances, plus libraries and libraries that expand on an already fleshed out collection of tools and etc.Forths and Lisps give you the core of an environment, and let/expect you to build on the foundation to create your own implementation.  Like someone else in this thread said, N programmers, N dialects. Or, more accurately, every Forth program is its own DSL for accomplishing its work.	zentiggr	15.084372	-3.870757	comment	5.0	23.0	1591574818	6.0309577
23699164	I've said this before, but I've come	"I've said this before, but I've come to think of Lisp and Forth as the left-handed scissors of software: for 10% of the population they're significantly easier to use, to such an extent that it can feel like a revelation. The remaining 90% of the population tries it, finds it harder to use, and doesn't get why others are raving about it.This would be down to very fundamental differences in thinking and conceptualisation that are difficult or impossible to ""just"" teach over. It requires those arguing over ""ease of use"" to recognise that it's not a property of the tool itself, but a function of both the tool and the user and how well the tool fits the particular, individual, user."	pjc50	15.134742	-3.9267142	comment	5.0	32.0	1593591628	-10.383659
24168392	That's me! It's a pretty exciting ti	That's me! It's a pretty exciting time for BQN because I've just put the self-hosted version online where you can try it out. In addition to exploring a lot of new APL ideas[0], BQN is also a test of the Co-dfns[1] approach to compilation, meaning that with an appropriate runtime the entire bytecode compiler could be run in parallel on a GPU. It's still in proof-of-concept stage, so that the online compiler is very slow and one running on dzaima/BQN, another implementation, compiles only about as fast as Go despite having a lot less features. However, having written several thousand lines of BQN I'm very happy with the language's fundamentals, and I feel it's a big advance over APL or J.[0] https://mlochbaum.github.io/BQN/doc/index.html[1] https://mlochbaum.github.io/BQN/implementation/cod	mlochbaum	15.551724	-2.7100203	comment	5.0	22.0	1597494424	13.069387
24287685	My son was required to use Racket in	My son was required to use Racket in his course work for Computer Engineering at CalPoly. I had never heard of it before. I recall one of the profs was involved. We joked that it all sounded like a racket.He's now a rising-star (proud/biased papa here) as an SDE at Amazon. So maybe it's a good teaching language after all.	cek	15.358244	-3.6635208	comment	5.0	16.0	1598478569	13.644734
20645844	Racket is a mixed bag for me.I've fo	Racket is a mixed bag for me.I've found a little quirks in the standard library, with simple fixes, but annoying. Stuff like decimal->string (?) producing odd output. (It was a tiny fix on my end, but it's a little subjective, maybe the behavior was intended) Not a big deal, but maybe a little impediment for learners compared to python.The article mentions Scribble, which I use as a static site generator for a a page with a leader board for EDH games (and maybe adding 9 ball lol). Some small CSS changes made it OK for cell phones (basic changes to make it responsive so it's ugly but readable), but as is it sucks, and the maintainers have no interest in changing that.Dr. Racket is unfortunate. If I remember correctly it has a tabbed interface, but right clicking on the tabs does not bring u	uxp100	15.361241	-3.6616309	comment	5.0	20.0	1565280850	13.648992
30777176	Dyalog APL 18.2	Dyalog APL 18.2	tosh	15.568734	-2.687556	story	5.0	82.0	1648033547	13.069373
30794124	What does the integration ecosystem 	What does the integration ecosystem look like for array-based languages? e.g. writing and consuming network services, database interoperability, C FFI, text encodings, etc.Given this release of APL introduces support for shebang scripts I'm thinking the ecosystem of integration isn't great but I'm happy to be wrong.	joncfoo	15.558939	-2.7054002	comment	5.0	15.0	1648148999	13.039671
31646769	Has anyone used the “Land of Lisp” b	Has anyone used the “Land of Lisp” book, or Exercism.org to learn Common Lisp? Any other fun alternatives for learning lisp?	worder0	15.151583	-3.9300332	comment	5.0	17.0	1654551975	-10.457586
31648123	I've recently started on the road to	I've recently started on the road to Lisp but am getting there via Racket. What am I missing out on versus Common Lisp?	greymalik	15.29256	-3.7640529	comment	5.0	16.0	1654559873	13.649353
36533947	Systems Programming with Racket	Systems Programming with Racket	r_sz	15.359554	-3.6524236	story	5.0	164.0	1688129468	13.646289
36542353	I don't use Racket much, but Python 	I don't use Racket much, but Python certainly frustrates me. So what I want to know is where people land when all these languages frustrate them. Builds taking too long seems like a perennial problem, for example.(Currently I work in LÖVE, but programs there use at least 100MB, so it probably won't be to OP's taste.)	akkartik	15.362005	-3.6595905	comment	5.0	28.0	1688159558	13.650817
34455442	Why would you use Racket when it bar	Why would you use Racket when it barely resembles Scheme anymore?Also, Akkuscm exists now, so you can get free r{6,7}rs libraries for most scheme implementations from there, in a sane, pragmatic Scheme environment.	adenozine	15.354478	-3.6662834	comment	5.0	18.0	1674232161	13.648629
34658293	Sadly, no. For one thing, despite se	"Sadly, no. For one thing, despite several attempts, there's not really any good mobile deployment story for Racket at the moment (especially for iOS).The Racket team appears to be more interested in (primarily) education and (secondarily) tinkering with programming language internals than making something that can be used to produce polished, packaged, distributable binaries (and let me stress here that this is perfectly fine... it's not a criticism, just an observation. Different people are interested in different things, and there's not anything at all wrong with that).Things that would have to change in order for for me to consider Racket fully ""batteries included"":1) Capable of building binaries for all major platforms (including iOS), including stuff like code signing.2) A standard GU"	Turing_Machine	15.355021	-3.6580634	comment	5.0	21.0	1675544805	-6.692974
34863065	Where would you recommend one starts	Where would you recommend one starts?With Racket?	sshine	15.371364	-3.630055	comment	5.0	20.0	1676849999	13.652506
39500260	Tinkering with APL (Dyalog) gave me 	"Tinkering with APL (Dyalog) gave me one of my most mind-bending programming moments.  dismal ← 10⊥(⌈/10⊥⍣¯1⊢)

This is the complete solution to addition in the framework of Dismal Arithmetic [1].The pivotal idea there was the inverse of a function, and ""trains"". Until that moment of insight, I was fiddling about with dfns, which looks janky in comparison.  dismal ← {10(⊤⍣¯1)⍵}∘{⌈/⍵}∘{10(⊥⍣¯1)⍵}⊢

⍣¯1 is APL for ""inverse"". Aaron Hsu helped me understand [2] what was going on.I feel like this kind of conceptual power is tacit programming at is finest. It blows my mind that this alien gobbledygook code still makes sense to me after not touching APL for years now. And I've only toyed around with the language.[1] I was playing with the problem to compare Clojure and APL, just because. https://w"	adityaathalye	15.563071	-2.6976142	comment	5.0	18.0	1708864275	13.068134
39576154	So, I have a kind of dumb question.A	"So, I have a kind of dumb question.As someone born after C and its derivatives took over the world, Forth has always been this ""weird cool old language"".  It seems like Forth was this very beloved language by a small set of enthusiasts, but I'm not entirely sure why.I also cannot quite tell if it's a high-level or low-level language, though maybe that's the point?  It definitely seems like it might be worth learning for the retro computing development world. Is my understanding correct?"	tombert	15.040575	-3.8176074	comment	5.0	26.0	1709416902	6.0527134
38913119	I've been knee deep in APL for the p	I've been knee deep in APL for the past year, working on a YAML parser: https://github.com/xelxebar/dayaml. It's still very prototypy, but for ~30 lines of code it's surprisingly complete.The process of getting that project to where it is now really revolutionized how I think of software development in general and how I manage my dev teams at work. Our best practices and wisdom around software dev really are much more strongly tied to historical habits and tooling whims than we'd like to believe. I believe we as a community have a lot of unpicked fruits laying around if we shift focus onto the human side of Human-Computer Interfacing for a while.About K, though, Arthur Whitney sounds like such a beast, and I would love to mingle with the K community. Within the array programming circles, A	xelxebar	15.561254	-2.700234	comment	5.0	77.0	1704727008	13.081646
32600000	Chez Scheme	Chez Scheme	qsort	15.329358	-3.681341	story	5.0	150.0	1661461853	13.626486
16247139	I’m constantly amazed there isn’t a 	I’m constantly amazed there isn’t a more standardized “transliteration” of APL into a slightly more verbose form that can be written easily on a conventional QWERTY keyboard (yes, I get it, APL devotees love the information density, but as this letter points out wacky keyboard requirements pose a pretty significant adoption barrier).Is there some major “modern” language or library that I’m unaware is actually an APL in QWERTY clothing? I’d love to give it a try.	yodon	15.564158	-2.6949854	comment	5.0	25.0	1517075698	13.078901
16398527	I've read a bit about APLs and I've 	"I've read a bit about APLs and I've seen them popping up in HN a few times. They do seem incredibly awesome and the products around it (K/KDB+ etc) amazing.However, in case I ever felt like learning one of these, I'd always wanted to know: the syntax crazyness, ""a la brainfuck"", is it a feature? a bug? Is it really needed? Can't they make an APL ""look like Python"" but using the same concepts, etc? Or is it ""a thing"" / something ultra-core to these languages, to be extremely terse / cryptic and intensely dense (each line packs a ton of punch!)?e.g. just read http://www.jsoftware.com/help/dictionary/didot.htm and some of the stuff in there can be translated quite well:i. 5 --> list(range(0, 5))i. _5 --> list(range(0, 5))[::-1] or list(range(4, -1, -1))i. 2 _5 --> [list(0 + j, 5 + j)[::-1] fo"	jjmaestro	15.563472	-2.6970797	comment	5.0	19.0	1518834304	13.076315
16583871	The APL / J / K family of languages 	The APL / J / K family of languages seems to be very strong with this effect. If it fits your problem domain, it's (apparently) so powerful that using anything else feels like a frustrating waste of time.	pavlov	15.563045	-2.6978211	comment	5.0	17.0	1521026346	13.096352
16695285	[I'm sticking this here because ther	[I'm sticking this here because there was a dude who said this was a good reply and I tried to reply to him and HN say s his post was deleted.  I don't know why, his post seemed pretty reasonable to me, he was asking if forth was a good boot loader.  Shrug.]I don't for a minute think that forth is the best answer, it's an awful answer.  Even lisp, which I hate with a passion, would be a better answer because more people have experience in lisp than forth.Forth is just less shitty than what Intel came up with, I think it was part of EFI, it's amazingly bad.  I've designed  a few programming languages and I'm not good at it, but holy crap, I could be drunk and come up with a better answer than  Intel did.  Forth is just a crappy language but it's less crappy than what Intel did.The idea that	luckydude	15.039718	-3.8331413	comment	5.0	21.0	1522211241	6.104598
39075940	I'm learning programming at age fift	I'm learning programming at age fifty-four and have chosen Common Lisp as my one language for life. If you want something easy to learn with a ton of support pick Python, Elixir, and/or JS. CL sucks for mini-projects since the learning curve requires serious commitment and is SO different from what people are used to.  CL requires a long-term commitment and demands the programmer challenge pop programming trends and deeply entrenched styles. You have to think beyond today to what could be and what once was. But if you're willing to do that, there is no better language. Not Haskell, not OCamel, not Rust/Go/Julia/Clojure/Scheme, or the current lang du jour. Whatever limitations Common Lisp had in the past are long gone.SBCL is blazingly fast, CL abstractions are profound yet practical. The t	corinroyal	15.166054	-3.9215233	comment	5.0	20.0	1705815848	-10.511559
39297862	"""In fact, you shouldn’t write any se"	"""In fact, you shouldn’t write any serious application in Forth; as a lan-
guage it’s simply not powerful enough. What you should do is write your own
language in Forth (lexicons) to model your understanding of the problem, in
which you can elegantly describe its solution.""I've enjoyed reading about FORTH and LISP over the years and I think LISP advocates have a similar philosophy.  What Leo Brodie states so nicely is very hard for me to actually do.  I think that's what separates the people who ""get"" computing from those (like me) who glue bits of various libraries together to get past the problem of the moment.As an HP calculator lover (I wore the ENTER > = t-shirt 40 years ago) I understand the stack and RPN but have no idea how I'd write a trig or stat function if it weren't already bui"	OldGuyInTheClub	15.055063	-3.8398108	comment	5.0	31.0	1707364452	6.10102
18124275	As someone who felt that C was the p	"As someone who felt that C was the path to knowledge for how modern computer systems ""work"", Forth and QEMU have become my ""stretch challenge"" for those with the motivation to tinker.For me, working thru the resources on the OSDev wiki by taking jonesforth and linking it with the bootstrap from the ""Writing an OS in Rust"" tutorial (https://os.phil-opp.com/) really showed me how far C is from the hardware, and how much closer Forth connects to the idiosyncrasies of a computer system. Further, the immediacy of the Forth REPL can help with little experiments and building up the understanding of how much a machine's architecture influences code/data structures, opcode choice, privilege management, etc.Plus, understanding Forth will bend your brain in a very strange but positive way :)"	sharkbot	15.028625	-3.8229287	comment	5.0	19.0	1538504553	-4.8804784
18188154	I like the idea a lot, although the 	I like the idea a lot, although the kind of people who don't like shell scripts for init would likely flip completely out at packages using guile lisp rather than some obscure DSL, and then parenthesis-ophobes are going to react very poorly to the libgit2 extended example ending in four closing parenthesis.  A little diversity in thought might be a good thing of course.An init system written entirely in Guile LISP is interesting to think about.  I'm old enough to (barely) remember the 80s lisp machines and since all modern CS/IT progress is re-implementing stuff from four decades ago, we're about due for something like linux ported from C to clojure or another lisp with a new init and the guix packaging system written in guile-scheme-lisp.  The idea of an OS written to run on a JVM instead	VLM	15.14724	-3.8984911	comment	5.0	27.0	1539200105	-10.144346
18370268	Great initiative. I often wonder why	Great initiative. I often wonder why Racket isn't used more in the industry, especially when you see much more niche languages being used...One note about your site: You are subscribing people to a mailing list without sending a confirmation email?	dorfsmay	15.364154	-3.6542919	comment	5.0	22.0	1541255020	13.642229
18689771	Now that I feel the bite from my sed	Now that I feel the bite from my sedentary lifestyle on my bum, I'm more and more attracted by the idea of a language taking 1/10th the typing compared to what's typical today. However, afaict languages following APL's suit specialize in math, so I wonder if the approach could be adapted to more general kind of coding.Even though the set of short symbols has to be limited, don't we currently have a few dozen often-repeated operations in language keywords and standard libraries? (Especially in the approach of e.g. Clojure, relying heavily on combining standard transformations on strictures.)	aasasd	15.56563	-2.6930034	comment	5.0	29.0	1544900459	13.085694
18756545	Creating a Non-Trivial Lisp Game in 	Creating a Non-Trivial Lisp Game in 2018	oumua_don17	15.1437	-3.9299078	story	5.0	149.0	1545725812	-10.444277
18898571	Creating Languages in Racket (2012)	Creating Languages in Racket (2012)	headalgorithm	15.359181	-3.6659791	story	5.0	85.0	1547412336	13.646201
32842037	Is Lisp Regaining Popularity?	Is Lisp Regaining Popularity?	whispersnow	15.17394	-3.911809	story	5.0	12.0	1663183430	-10.429157
24434717	April, an APL Compiler for Common Li	April, an APL Compiler for Common Lisp [video]	tosh	15.223559	-3.7197464	story	5.0	103.0	1599759954	-10.493386
24530672	I really like this quote:> some stil	"I really like this quote:> some still seem to equate ""the ease of programming"" with the ease of making undetected mistakesConversely you could say that ease of programming is equal (or at least correlated) with ease of getting confidence of your programs correctness.On the wider subject of the essay, I do note that languages like APL that really embraced symbolics for expression do not seem to have gained much ground, and on the other hand languages that are light on syntax and use more verbiage like for example Python have been massively popular.Overall I think the essay also relates to the common idea that naming things is difficult. The names we give our elements of code imbue the ""all sorts of nonsense that, when we use our native tongues, are almost impossible to avoid"". And how many "	zokier	15.557318	-2.7039945	comment	5.0	37.0	1600553840	13.0804615
24569167	Direct link to one of the early adop	Direct link to one of the early adopter wikis: https://fr.wikipedia.org/wiki/Wikip%C3%A9dia:Accueil_princip...	wormslayer666	15.1439295	-3.8957949	comment	5.0	16.0	1600880268	-10.452493
25228079	Rebuilding the Racket Compiler with 	Rebuilding the Racket Compiler with Chez Scheme	AlexeyBrin	15.349074	-3.668409	story	5.0	106.0	1606479556	13.654429
25320063	Urgent appeal to Paul Graham, etc.: 	Urgent appeal to Paul Graham, etc.: Please help kickstart Common Lisp revolution	Hexstream	15.153303	-3.9286911	story	5.0	7.0	1607217704	-10.445236
25442005	Racket Scheme & SICP is a fun way to	"Racket Scheme & SICP is a fun way to start playing, especially if you are into theoretical concepts of CS and programming, like higher order programming and abstraction.The documentation for Racket is excellent, see e.g.https://docs.racket-lang.org/quick/index.html... and many people have created online resources to adapt SICP to Racket, as well as other learning texts. I like Beautiful Racket, e.g.https://beautifulracket.com/explainer/lists.htmlYou can use #lang sicp and start playing around with the free online reformatted SICP text here:http://sarabander.github.io/sicp/I recommend getting a print copy of SICP, though, and working through the examples in a real DrRacket environment on your computer.IMO, if you end up going deep in the ""lispy"" direction after playing with Racket, you'll p"	pixelmonkey	15.356178	-3.6610255	comment	5.0	27.0	1608123901	13.60795
32030324	APL seems like a great language for 	APL seems like a great language for computer graphics! Has anyone tried their hands at the same?	z3phyr	15.56245	-2.6907597	comment	5.0	16.0	1657329807	13.107989
32043026	Technical overview of Kandria, a gam	Technical overview of Kandria, a game and game engine developed in Common Lisp	trocado	15.127141	-3.9213204	story	5.0	343.0	1657444127	-10.434448
22042623	Chez scheme is just as dynamic as py	Chez scheme is just as dynamic as python and is about as fast as C# running on mono IIRC. My scheme was probably worse than my C# was when I did project Euler though.Chez does unboxed integer arithmetic (but not floats) and does not have to do any OO-like dispatch, and is also probably one of the best language implementations there are.	bjoli	15.309503	-3.7033694	comment	5.0	25.0	1578986806	13.62348
22082657	Ruins of forgotten empires: APL lang	Ruins of forgotten empires: APL languages (2013)	lelf	15.561683	-2.6941617	story	5.0	31.0	1579327417	13.088233
23415169	APL-likes have been a fascination of	"APL-likes have been a fascination of mine for some years, but sadly at a distance.  For those of you working in these languages, what do you use them /for/?  What industries and/or kinds of applications do you write?  Why are these languages used for them vs others?I'm looking for some inspiration.  (I think) I'd love to use one ""for real""/""in anger"" for something but are they too niche to use as CV/Resume enhancement?"	michaelcampbell	15.565006	-2.695321	comment	6.0	18.0	1591269786	13.041718
23451804	If I had to put my finger on why For	"If I had to put my finger on why Forth is hard for most programmers, it's like this: the structured program theorem suggests using sequence, selection, and iteration to control program logic. Assembly code on hardware architectures will assign all meaning sequence-relative, late-binding the selection and iteration. Forth doubles down on this sequence-first  approach through a more versatile assignment mode(the stack) while only minimally  accommodating the other two. That makes it easy to implement, while not explicitly addressing expressability.Forth written ""flat"" with shallow data stack usage is assembly by another name, a wrapper for load-and-store; Forth that does everything with intricate stack manipulation is a source of endless puzzles since it quickly goes write-only.But, like any"	megameter	15.024736	-3.8296044	comment	6.0	25.0	1591570668	6.060068
24167804	BQN: An APL Variant from Marshall Lo	BQN: An APL Variant from Marshall Lochbaum	chrispsn	15.565736	-2.6928132	story	6.0	60.0	1597487441	13.091434
19987804	The Common Lisp Cookbook	The Common Lisp Cookbook	ghosthamlet	15.16279	-3.8874037	story	6.0	248.0	1558578676	-10.441257
18972298	"""Cheesing"" as it's called, is classi"	"""Cheesing"" as it's called, is classic SC2 strategy. People absolutely hate it, but it occasionally works, even though it feels cheap. It's kinda like Blitzkreig in chess..."	chrisco255	15.336988	-3.6554432	comment	6.0	22.0	1548190171	-6.4100914
19043816	Racket v7.2	Racket v7.2	ethelward	15.378759	-3.6294277	story	6.0	225.0	1548930730	13.658317
19232560	If you create whole new languages, i	"If you create whole new languages, i.e. external languages, not really embedded DSLs, with their own syntax, how is Racket better than other languages at implementing those?Neither the sntax object, nor hygiene are of concern when you build external DSLs, which the author's examples seem to be.I have not yet seen a compelling argument for Racket there vs. for instance a parser generator framework.I might just be missing the point. Either way the author's convincing seemed to have failed 
for me."	quelltext	15.358907	-3.663648	comment	6.0	27.0	1550915408	13.661721
19701279	Fairylog: A Racket language aiming t	Fairylog: A Racket language aiming to be like Verilog	setori88	15.34925	-3.6690795	story	6.0	60.0	1555694674	13.634194
19925832	Racket 7.3	Racket 7.3	jessealama	15.381836	-3.626583	story	6.0	287.0	1557976145	13.653468
18076490	For anyone interested in guile, guil	For anyone interested in guile, guile 3.0 will have a JIT, making it even faster than 2.2 (by quite a large margin).Guile is becoming really nice, and I find myself reaching for other lisps less and less.	bjoli	15.172	-3.8045728	comment	6.0	28.0	1537973363	-10.267536
18647562	Making Games in Lisp with Hypergiant	Making Games in Lisp with Hypergiant and Chicken Scheme	bananicorn	15.133475	-3.872675	story	6.0	155.0	1544447011	11.508244
29964871	Does anyone have any stories to shar	Does anyone have any stories to share involving apktool?Random note: It's curious how the homepage and the linked repo are on GitHub but the binary downloads are served from bitbucket.	3np	15.539385	-2.684335	comment	6.0	19.0	1642412281	13.107806
30280584	Racket 8.4	Racket 8.4	bwidlar	15.378005	-3.6280987	story	6.0	112.0	1644450934	13.649094
30453919	Mastering Dyalog APL (2009) [pdf]	Mastering Dyalog APL (2009) [pdf]	Tomte	15.567779	-2.6910512	story	6.0	69.0	1645705955	13.108251
30655664	Has anyone here read LISP in small p	Has anyone here read LISP in small pieces? I've never used LISP but would still like to read it. Would you recommend it? (it's not cheap, otherwise I'd just buy it without the due diligence)	nomilk	15.154042	-3.9281666	comment	6.0	18.0	1647124762	-10.487847
16821292	Can anyone recommend a Lisp dialect 	Can anyone recommend a Lisp dialect / environment which is suitable for web-based publication, and game multimedia (graphics, audio, control, etc.)?	gnode	15.162308	-3.9249952	comment	6.0	22.0	1523543564	-10.41464
17174365	Neat little tribute article.APL will	Neat little tribute article.APL will not be reborn. If that was going to happen, this century's embrace of analytics and linear-algebra-rich machine learning would have propelled the upswell. It didn't and it won't.Why? It's not the symbols. Not the keyboard. Nor the learning curve. Nor the lack of standardization, libraries, or GPU support. These are collateral damage, not primary drivers.APL will not flourish because it is effectively a DSL with archaic I/O capability. It is a nearly-pure functional programming language. It's primary domain is mathematics. Native GUIs, networking, the web -- all uncompetitive add-ons.In this sense, APL and Haskell share some DNA.For dynamic systems modeling for my thesis, I reached for APL and Matlab. I still code Dyalog APL for recreation. Love it. But 	untangle	15.565154	-2.694382	comment	6.0	37.0	1527536284	13.082384
17653362	I still don't understand why after s	"I still don't understand why after so many years people are still trying to write a ""SICP, but with language X"".""The language doesn't really matter"", as such it's imperative Scheme is used.I strongly feel that if you've worked your way through SICP, and, once finished, you think ""Neat. I'll rewrite this but with language X,"" you've really missed out on value of SICP.It's challenging enough to follow for people who know a Lisp going in, but using a language more mainstream and familiar to make it easier is largely counter-productive."	craigsmansion	15.13799	-3.9236379	comment	6.0	37.0	1533047040	-10.514946
17660583	Rackjure	Rackjure	tosh	15.375894	-3.630084	story	6.0	147.0	1533112444	13.656941
17714459	Hyperpolyglot: Lisp	Hyperpolyglot: Lisp	tosh	15.147685	-3.9296741	story	6.0	127.0	1533722173	-10.459339
17761261	"I hate to be ""that guy,"" but what ha"	"I hate to be ""that guy,"" but what happened to the Guile-Emacs project? Guile performs way better than Elisp too, but (perhaps more importantly) raises the possibility of writing configuration and extensions in Lua and Scheme."	fusiongyro	15.1808	-3.8141215	comment	6.0	44.0	1534276166	-10.341562
21565391	Completing Racket's relicensing effo	Completing Racket's relicensing effort	samth	15.373713	-3.6270587	story	6.0	169.0	1574093377	13.645631
21717666	Sixteen APL Amuse-Bouches (2016)	Sixteen APL Amuse-Bouches (2016)	kick	15.569089	-2.6882741	story	6.0	62.0	1575587344	13.103976
12710437	Question: I've looked at Forth a num	"Question: I've looked at Forth a number of times and I think it's a fascinating looking language but I've never bothered picking it up. I've also never had a chance to talk to a Forth programmer. Can you tell me what type of application you're working on, if it's legacy or new development, and your thoughts on when to choose Forth over something else?From what I understand, Forth is mostly used as an embedded ""OS"" when a traditional OS wouldn't cut it. Is that accurate?Sorry, it's just not a terribly common language, but it certainly is interesting."	freehunter	15.038007	-3.814032	comment	6.0	25.0	1476472821	6.055828
12090985	Advanced Forth Programming Topics	Advanced Forth Programming Topics	eatonphil	15.012311	-3.8108904	story	6.0	105.0	1468457830	6.0679164
12119228	I have a hard time imagining how som	I have a hard time imagining how some tasks could be managed while using the disciplines that make Forth useful.What are some examples of highly complex tasks that have had Forth programs written for?Something like Starcraft in Forth.  Or perhaps the most complicated Paint Program written in Forth.	Lerc	15.035743	-3.8099954	comment	6.0	18.0	1468896446	6.0494013
35392132	It’s awe-inspiring to see a K progra	"It’s awe-inspiring to see a K program where the comments are in another APL variant (I can’t pretend to know which):  {d:~1=':s:^x             / s‿e←1⊸»⊸(>⋈<)' '=𝕩
   c:^""aeiou""?_x@&d&~s     / c←¬(s/𝕩)∊""aeiou""
   x,:,/$`pig`dog c        / ins←⥊c⊏[""pig"",""dog""]
   x@<(+\d),{3}#c+2*!#c}   / ((+`s+e)∾3/c+2×↕≠c) ⍋⊸⊏ 𝕩∾ins

This program implements a Pigdog Latin translator, bien sûr."	pavlov	15.555773	-2.694979	comment	6.0	52.0	1680290693	13.060273
28498287	I think every sentence in this post 	I think every sentence in this post is more or less wrong. Also, we do not want to introduce non-ascii glyphs into programming languages - APL is about the only time this has been tried and (merits of the language aside) it was hardly a success.	zabzonk	15.560114	-2.694342	comment	6.0	20.0	1631415959	13.065119
22539783	APL a Day	APL a Day	lelf	15.568378	-2.6865969	story	6.0	83.0	1583874926	13.102022
22585733	Lisp: Good News, Bad News, How to Wi	Lisp: Good News, Bad News, How to Win Big (1991)	simonpure	15.158788	-3.9253433	story	6.0	120.0	1584298830	-10.457502
23058489	I investigated APL pretty seriously 	I investigated APL pretty seriously at the end of 2019, after a very inspiring conversation with Aaron.  I discovered that everything in this post is true, and (dyalog) APL is a pretty great language.However, I also decided that it is still a bit too dead, at least for me.  Specifically, it does not work well with other programs, at least on *nix.  This is reflected not only in the lack of external libraries, but even in some basic areas – both FFI and even reading/writing to standard input and output are surprisingly challenging.  Summing all this up, writing a basic Linux CLI app (read from stdin, take and parse arguments, print to stdout) is still a pretty large challenge.As great as APL is, for me, it's hard to overcome the ability to work with the whole existing Linux/FOSS ecosystem. 	codesections	15.564668	-2.6929026	comment	6.0	32.0	1588507132	13.0986595
26637619	> There is no other language that pl	"> There is no other language that places such an emphasis on programming directly with plain and naked data literals.Counterexamples: Erlang and Elixir. Arguably also Prolog. Also Lua. Many Schemes, and Racket. Of course, REBOL and Red. TCL probably, too.I can't help but think that people making claims of ""no other language has X"" are in most cases wrong, and should study a bit more before making them.There's a lot of hype in the article, I don't want to diminish the value of REPL-based workflows or conciseness[1] of the language, but the overall message that any fresh graduate can become a 10x programmer in under a month... Well, there's at least nothing humble about it, despite the article touting ""humility"" as a virtue of prospective Clojurists.[1] Why aren't we all writing in APL/K/J i"	klibertp	15.542244	-2.7320933	comment	6.0	57.0	1617125646	13.046039
27391259	I would be genuinely interested of t	I would be genuinely interested of the advantages of APL over languages like Julia or Python with numpy who have also quite flexible array types. For instance in Julia, I could write:data = [1,2,3]# . means element-wise operationsum(exp.(filter(isodd,data)))# or, where x |> f is f(x)data |> x -> filter(isodd,x) .|> exp |>  sumWhich looks quite clean to me. But Julia does not have partial function evaluation (just using filter(isodd) above would not work). Is this one of the main differences?	kwertzzz	15.559541	-2.7025928	comment	6.0	24.0	1622789366	13.052454
27461338	Would APL work as well with the unus	Would APL work as well with the unusual symbols replaced by keywords? Any with APL experience know?	pradn	15.561644	-2.6975093	comment	6.0	39.0	1623336205	13.072624
20433021	In May 2009 O'Reilly agreed to publi	In May 2009 O'Reilly agreed to publish a book about Common Lisp (2011)	tosh	15.154411	-3.9279375	story	6.0	133.0	1563106915	-10.565033
20645787	Who are the current major users of R	Who are the current major users of Racket? Are there any large commercial codebases written in it?	gaze	15.365012	-3.6559756	comment	6.0	23.0	1565280523	13.644636
13904688	GNU APL 1.7 Released	GNU APL 1.7 Released	Avshalom	15.566658	-2.6882198	story	6.0	127.0	1489888125	13.093556
13975059	I am blown away to see how frequentl	I am blown away to see how frequently APL seems to come up on HN these days, a language I used professionally for over ten years.As much as I love it I have to say one of the issues with APL is that it was way ahead of it's time.  Because of that it struggled to run on computers of that era.I was introduced to the language in 1982~ish.  Like I said, I used it extensively, attended and presented at APL conferences and even have a picture of my younger and dorkier self with Ken Iverson (creator of APL).This struggle to run on hardware that could not handle the huge expansions and contractions of memory utilization inherent in the way APL works multidimensional data sets like putty meant it could not compete where other languages had no issues at all.  On PC's you were limited to 640K of RAM.	rebootthesystem	15.562528	-2.6994267	comment	6.0	36.0	1490690649	13.088521
13979547	I wish an experienced LISPer would e	I wish an experienced LISPer would explain why should one use Common Lisp over a language like Golang. Golang now has https://github.com/glycerine/zygomys for scripting. For that matter, why would one choose Common Lisp over GNU guile ? (guile now supports fibers). What does Common Lisp offer for the working programmer that is an advantage over other languages ?	lenkite	15.160368	-3.8871772	comment	6.0	29.0	1490727533	-10.391257
14125651	A Source Book in APL (1981)	A Source Book in APL (1981)	alexcweiner	15.564923	-2.687258	story	6.0	51.0	1492348252	13.105668
14481355	Rosette – A solver-aided programming	Rosette – A solver-aided programming language that extends Racket	tosh	15.343181	-3.6845398	story	6.0	142.0	1496581553	13.634823
14661239	The Common Lisp Cookbook	The Common Lisp Cookbook	macco	15.15714	-3.8898733	story	6.0	264.0	1498718363	11.362668
30870868	Why APL is worth knowing	Why APL is worth knowing	tosh	15.565936	-2.688335	story	6.0	121.0	1648752443	13.110248
30871639	I would like to see something about 	"I would like to see something about ""Why Python is worth knowing"" from someone who knows APL.  For whatever reason I can spend time playing around APL but I cannot force myself to spend time playing around with Python."	1vuio0pswjnm7	15.56127	-2.7045856	comment	6.0	33.0	1648756961	13.096383
31044510	The History of Franz and Lisp	The History of Franz and Lisp	lisper	15.151039	-3.922152	story	6.0	109.0	1650050201	-10.46998
31230504	Racket v8.5	Racket v8.5	bwidlar	15.379917	-3.6263778	story	6.0	201.0	1651455357	13.656564
31230916	Is SICP the best way to learn Racket	Is SICP the best way to learn Racket?https://mitpress.mit.edu/sites/default/files/sicp/full-text/...	jp0d	15.353545	-3.6553998	comment	6.0	45.0	1651459781	13.671992
31356537	Beautiful Racket (2016)	Beautiful Racket (2016)	gurjeet	15.372973	-3.63187	story	6.0	158.0	1652373692	13.649927
26013341	Is it common to use the Racket IDE o	Is it common to use the Racket IDE or is Emacs equally suitable? So anyone using Emacs to program in Racket Scheme?	submeta	15.356863	-3.6629946	comment	6.0	18.0	1612358431	13.656758
26067320	Out of topic, but as somebody who in	Out of topic, but as somebody who interested in lisp generally, I have a question, from which dialect would you suggest to start? I am a little bit lost. I am considering clojure, racket and common lisp. I am reading at the moment sicp book and do exercises in `racket sicp package` which is again another dialect. After that want to start with something modern. What was you way to lisp?	vasergen	15.175782	-3.924034	comment	6.0	55.0	1612804620	-10.657944
26130740	Anyone using Racket in production?	Anyone using Racket in production?	ph2082	15.368991	-3.643282	comment	6.0	19.0	1613293278	13.6454315
26170206	A different Forth I enjoy to hobby c	A different Forth I enjoy to hobby code puzzles in is [Factor](https://factorcode.org/) and is probably an easier place for people to start. Forths are wonderful languages that everyone should have some exposure to, they are like a cross of Lisp and Smalltalk. You should definitely try it at least once.	Pet_Ant	15.046089	-3.8221698	comment	6.0	42.0	1613588987	6.0756702
36249546	The TI (Lisp) Explorer Project	The TI (Lisp) Explorer Project	mepian	15.149449	-3.9017034	story	6.0	76.0	1686260373	-10.507008
36283721	Doesn't say anything about cycles or	"Doesn't say anything about cycles or what datatypes can be serialised. In general lisps _can't_ print arbitrary objects in a form that can be read back in. E.g.    Welcome to Racket v7.9 [bc].
    > (lambda (x) x)
    #<procedure>

7.9 doesn't have csexp, was curious what it would do with a function object but not quite curious enough to install a racket from outside the package manager. It seems relatively likely that racket would have some serialisation feature that can round trip arbitrary objects through a bytestring though initial guesses haven't worked out for me    > (require racket/serialize)
    > (serializable? (lambda (x) x))
    #f

Still, being able to take some arbitrary closure and kick it over the network to another racket instance would be great. It's not immediately obvio"	JonChesterfield	15.34786	-3.682329	comment	6.0	31.0	1686506004	13.644032
36542411	I had a professor at college who man	I had a professor at college who mandated Racket as the mode of learning for a software engineering course. I remember how Racket just ended up taking centre stage, figuring language-specific concepts and hacks out let the larger engineering concepts fade into the background.I did not learn much in that course.	kaushalvivek	15.359135	-3.65757	comment	6.0	21.0	1688159803	13.641681
28834034	For anyone not in the loop, Norvig w	For anyone not in the loop, Norvig was the author of Paradigms of Artificial Intelligence Programming. This was a substantial contribution to the field of educational computer science literature, and helped to kickstart the idea that the way to learn is to read, not just write.It's also one of the few AI books that isn't rooted squarely in Algol. It's written with fairly decent though not always portable Common Lisp, just like most Common Lisp books of the era.It can be read here, in mobi or zipped HTML format: https://github.com/norvig/paip-lisp/releases/tag/1.1Or here, in PDF: https://github.com/norvig/paip-lisp/releases/tag/v1.0For a native web copy, abuse Safari Online's free trial. It's what I assume everyone else does when they want to read a niche technical book that O'Reilly put ou	metagame	15.127465	-3.9194221	comment	6.0	59.0	1633992871	-10.411166
28965788	APL Compiler Based on Tail (Typed Ar	APL Compiler Based on Tail (Typed Array Intermediate Language)	xvilka	15.563731	-2.6967301	story	6.0	62.0	1634964158	13.063589
29056035	Forth fans live in what seems to be 	"Forth fans live in what seems to be a world of delusion. They rail against modern software, claiming to have an enlightened ""system"", and yet cannot communicate anything about the real capabilities of their system. If you ask most Forth users ""what do you do in Forth?"" the answer is almost always ""writing a Forth"". There seem to be very few people who are interested in using it for any other problem domain. I can't shake the feeling it is mainly hype."	joeberon	15.038791	-3.8083398	comment	6.0	36.0	1635677090	6.1313744
29536703	Weird: Generative Art in Common Lisp	Weird: Generative Art in Common Lisp	alaq	15.148465	-3.927933	story	6.0	267.0	1639370655	-10.438824
29576470	We are getting closer and closer to 	We are getting closer and closer to differentiable APL running on GPU. I like this direction :)	mlajtos	15.567191	-2.6897569	comment	6.0	25.0	1639646083	13.077792
34373472	I believe that any programmer should	"I believe that any programmer should at least know a little about Forth. It's like Lisp. Just knowing about them is extremely enlightening, even if you don't use them in your daily life.Obligatory link:
https://github.com/nornagon/jonesforth/blob/master/jonesfort...This well-written tutorial will have you implement a Forth in 500 lines of assembly and another 500 lines of Forth.You will feel like a different person after having done this. People will like you more. Food will taste better. You'll never be alone again, always knowing that you can re-create a fully-functional programming language from assembly within half an hour, if you needed to. It is said that people who know Forth die happy."	amalgamated_inc	15.03111	-3.8139262	comment	6.0	47.0	1673641861	6.0896273
24467534	I’ve been in a “retro computing” dee	I’ve been in a “retro computing” deep dive lately and it’s been fascinating to discover Forth. I was surprised that an entirely novel paradigm was hidden despite much digging over many years. All of the sudden I am seeing it everywhere now too - confirmation bias from growing up skill wise in the age of dot com boom vs right before?I like the feeling of concatenative languages. I especially seem to like the postfix notation over prefix and largely this creates the paradigm of lisp vs forth at first step - in my opinion.I’ve recently dug in to Factor and it’s quite an amazing piece of art that is highly usable and up to date despite such a small community. It almost feels like a secret weapon and too good to be true. I’m having a ton of fun hacking on it. It’s like Smalltalk and forth had a	dfischer	15.048341	-3.8195322	comment	6.0	37.0	1600066417	6.077859
24604482	Author here! This was a super fun pr	"Author here! This was a super fun project that consumed over a month of evenings and weekends. In the past couple of days I finished the examples, and I'm glad to finally put it out there.I don't quite remember how I fell into the Forth rabbit hole, but I think I first heard about Collapse OS. Then I read yosefk's ""My history with Forth & stack machines"" [0], which is actually very critical of Forth. But when I saw if/then/else being defined in Forth itself, I was hooked.I've always been fascinated by the idea of having a minimal kernel of primitives from which ""everything"" can be built. Before Forth, I had only seen that in the form of Lisp's ""Maxwell equations of software"", which is cool, but always left me a little disappointed because it is too abstract to build something that you can "	cblum	15.038354	-3.82537	comment	6.0	29.0	1601185470	6.091373
24770982	Interesting that COMP.LANG.LISP has 	Interesting that COMP.LANG.LISP has posts dating last month. I guess the network isn't dead. I wonder if there are groups with interesting recent activity.	jolmg	15.12409	-3.9255595	comment	6.0	21.0	1602627714	-10.344614
39032874	I have a longstanding fascination wi	"I have a longstanding fascination with K and other ""modern"" APL derivatives.There are a few intersecting truisms about coding that I believe: one is that people's working memory varies: some have an immense amount, some less. Humans definitely process spatially better than in time series (e.g. comparing side by side rather than turning over a page.)This implies you should prefer succinct code and languages because they are less memory load for engineers working on them.At the same time, a corollary is that a smaller standard library / language is generally better, in that less needs to be learned by an engineer for full coverage of the language.Another truism is that some people's processing speed is higher than others, and in general I think of the combination of working memory + speed as"	vessenes	15.555206	-2.7048333	comment	6.0	34.0	1705522745	13.009753
32478797	World Building and Alternate Reality	World Building and Alternate Reality Common Lisp	kaveh808	15.154941	-3.9301496	story	6.0	64.0	1660619547	-10.472532
22255695	Why?  If you really want to do scrip	Why?  If you really want to do scripting in lisp, why would you not just use guile?This is just embracing complexity when scheme is a perfect fit, and already exists in multiple ways in the domain.Did Gauche stop existing?http://practical-scheme.net/gauche/	arnautdaniel	15.1770315	-3.8358257	comment	6.0	27.0	1580994609	-10.311579
23510433	APL Since 1978 [pdf]	APL Since 1978 [pdf]	7thaccount	15.567151	-2.6873462	story	7.0	69.0	1592064711	13.101225
24287976	Would Racket be an appropriate first	Would Racket be an appropriate first language for a thoughtful 11 year old who has the gift of abstract thought (relatively; we are not talking Haskell here) ?	chromatin	15.359365	-3.6616914	comment	7.0	21.0	1598480476	13.647239
20644925	I really like Racket, but the potent	I really like Racket, but the potential breaking massive syntax change in Racket2 makes me really uncomfortable in using or recommending Racket to other people, at least until the situation is clarified.	AlexeyBrin	15.361308	-3.660097	comment	7.0	25.0	1565274665	13.6532755
20792486	Racket for E-Commerce	Racket for E-Commerce	soegaard	15.377544	-3.631833	story	7.0	138.0	1566734681	13.653103
35552789	I'm eager to jump into a Lisp.Janet 	I'm eager to jump into a Lisp.Janet seems really tempting for tiny footprint, distributability etc.But I'm currently leaning towards to Racket just because it would be more or less compatible with a whole host of Scheme books that I'd like to read (The Little Schemer/Typer/Learner, SICP, Functional Differential Geometry).Does anyone familiar with Janet know if those books can be easily worked through with Janet for a newbie Lisper?	phonebucket	15.161591	-3.9160585	comment	7.0	21.0	1681376368	-10.514975
36267083	A comment about Christian Queinnec's	A comment about Christian Queinnec's book Lisp in Small Pieces (1996)	vector_spaces	15.153302	-3.926351	story	7.0	55.0	1686365224	-10.445282
29047853	These sorts of minimalist bare metal	These sorts of minimalist bare metal abstract PL articles are so thrilling to me. APL comes to mind.I wonder how high you can go with only 1MB say.	agumonkey	15.555597	-2.6884542	comment	7.0	47.0	1635592120	6.578141
13156206	Seeing as you know something about F	Seeing as you know something about Forth. Is it used somewhere in production outside of purely academic setting?	Senji	15.04118	-3.810547	comment	7.0	22.0	1481526413	6.0997877
13477107	Racket v6.8	Racket v6.8	nickmain	15.38096	-3.6263022	story	7.0	201.0	1485302947	13.640334
18950137	I don't really know forth, but it se	I don't really know forth, but it seems like people who learn it really like it; can someone give me a high-level explanation to while it's easier to write Forth instead of C for low-level programming?	tombert	15.027264	-3.830703	comment	7.0	23.0	1547943789	-7.050813
19044309	Racket is such a cool project. I kee	Racket is such a cool project. I keep telling myself I'll find the time to do something serious with it, but I never get around to it.One minor bit of criticism - would be it be so hard/expensive to hire a designer to do some minor touching up of the DrRacket GUI? It looks like a toy, and the icons didn't even look good in 1998.I'll balance this criticism with the remark that any language/platform that manages to a) add, ex-post, a type system, b) fix the Gordian knot of modules and macros, and c) has the audacity (combined, curiously, with humility) to just swap out the entire backend to eek out more performance, deserves my respect. In addition both Flatt and Tobin-Hochstadt give excellent presentations where it's impossible not to notice their passion for Racket. They're definitely amon	seertaak	15.361746	-3.6583767	comment	7.0	37.0	1548938610	-6.96812
19276774	It’s interesting that they chose to 	It’s interesting that they chose to use Common Lisp for their entire quantum stack. Maybe it hit the sweet spot between expressiveness and performance? Choosing a Lisp makes sense, but I’m not sure I would choose CL. The macro system is primitive and the whole language stinks of a compromised design. Also, at this point, the language feels old and somewhat archaic.If performance isn’t a dealbreaker, Racket would be sensible choice. Though personally, I think OCaml would be great for this sort of project. Native code, syntax extensions with ppx, a bulletproof type system, and a highly optimized compiler that produces blazing fast code.	mruts	15.156583	-3.928988	comment	7.0	51.0	1551399117	-10.434423
19325972	I once got talking with an anesthesi	I once got talking with an anesthesiologist who was taking care of a family member. Upon hearing I was a developer, he told me he was an APL programmer who spent most of his computer time developing Bible software. He regaled me with a few APL war stories, about how he could get so much more done with so much less code...I was intrigued, and still am. But one thing I didn't catch -- how do you write all those non-ASCII symbols using a standard OS and text editor? Or does it require special tools?	TimTheTinker	15.559871	-2.6947365	comment	7.0	31.0	1551940099	13.060604
15882061	Every time, I see one of these links	Every time, I see one of these links or videos, I feel the urge to learn Lisp. But after some time, I lose the motivation. I think that is because I don't know what benefit learning lisp will provide me concretely. Anyone has any suggestion?	nafizh	15.183187	-3.9032352	comment	7.0	96.0	1512767377	-10.465374
16081067	Racket-On-Chez Status	Racket-On-Chez Status	soegaard	15.379352	-3.6289217	story	7.0	147.0	1515181550	13.664354
16403099	Node-APL: APL interpreter written in	Node-APL: APL interpreter written in JavaScript	bryanrasmussen	15.546372	-2.7187185	story	7.0	35.0	1518906221	13.076232
16819425	This looks like it could be fun. I d	This looks like it could be fun. I don't know Lisp, but I might be willing to learn one just for this jam. Can someone recommend a Lisp version that works on Windows and is easy to setup? Simple 2D graphics like SDL will be enough for me.	skocznymroczny	15.150456	-3.9200509	comment	7.0	32.0	1523528692	-10.417048
17532943	Lisp, Jazz, Aikido – Three Expressio	Lisp, Jazz, Aikido – Three Expressions of a Single Essence	kuwze	15.159619	-3.9243948	story	7.0	28.0	1531611302	-10.457919
17743747	History of editors for Lisp	History of editors for Lisp	tosh	15.145545	-3.929954	story	7.0	105.0	1534068683	-10.427402
21104698	APL Demonstration (1975) [video]	APL Demonstration (1975) [video]	emersonrsantos	15.568155	-2.6860697	story	7.0	78.0	1569725176	13.101354
21652218	A big hurdle for me is that there's 	A big hurdle for me is that there's no APL interpreter available in my Linux distribution's (Gentoo's) package manager.  So I can't easily install it as I can most other languages, using my distro's package manager.  That means I'm going to have to search out how to get an APL interpreter -- something not even mentioned on in the Getting Started article linked to in this HN post, nor on the Getting Started article on dyalog.tv that the former article links to.  That alone is just way too much trouble already.Then there's the issue of typing in all the weird APL symbols.  I've reconfigured my keyboard to type special symbols a long time ago, but I don't even remember how to do that now so it'd be nice if there was some straightforward documentation on how to do that for APL on a typical Lin	pmoriarty	15.564925	-2.6936905	comment	7.0	31.0	1574889455	13.07839
17944800	APL matrix product operator	APL matrix product operator	panic	15.567108	-2.6912289	story	7.0	61.0	1536478272	13.064344
29850694	Ask HN: What is a good resource to l	Ask HN: What is a good resource to learn Lisp in 2022?	bikramgig	15.153019	-3.9283454	story	7.0	25.0	1641641616	-10.4463215
33463022	Recently I tried to jump into scheme	"Recently I tried to jump into scheme (I'm okish in clojure) man what a mission to install scheme on linux.I first tried todo gerbil scheme, then Ubuntu seems to have the wrong version of gambit (gerbil-scheme runs optop of gambit-scheme for those that don't know).
That took a few hours of compiling, reading, trying diff versions always ended in some deadlock-issue ??Then I tried Guile,was a little better and easier, but soon got stumped when I wanted to access mysql-db yes there are packages but those packages I couldn't install for the life of me !In the end chicken-scheme was surprisingly easy and complete solution for a hit-the-ground-running scheme.Now I'm prob a noob as it comes to scheme, but not to fiddle and massage packages and programs on linux. Trying to learn scheme but spendin"	rawoke083600	15.273395	-3.7294362	comment	7.0	27.0	1667544811	13.394225
33639114	I disagree. The terseness of APL is 	I disagree. The terseness of APL is the worst part about it. Its arcane symbols are a close second.I don't want my programming language to be as terse as possible. I want it to be easy to read and maintain. I don't see how APL is a step in the right direction at all, and IMO should just be relegated to the dustbin of history as a failed experiment.	ninkendo	15.562886	-2.696084	comment	7.0	51.0	1668694434	13.083367
34005913	Common Lisp (1986)	Common Lisp (1986)	luu	15.157831	-3.9225852	story	7.0	101.0	1671139158	-10.437343
34097682	Common Lisp – Myths and Legends (200	Common Lisp – Myths and Legends (2002)	susam	15.152167	-3.9295914	story	7.0	107.0	1671738504	-10.470335
26677630	Starting Forth: An Introduction to t	Starting Forth: An Introduction to the Forth Programming Language	optimalsolver	15.020471	-3.8195076	story	7.0	96.0	1617412874	6.064783
27007893	I've found the lack of resources to 	I've found the lack of resources to learning Elisp a challenge. I haven't finished it, but Robert J. Chassell's 'An introduction to programming in Emacs Lisp' seems to run through basic concepts but doesn't really get to the meat of actually putting everything together. (Could be wrong) And the Elisp manual reads like the output of an Elsip macro - so terse, so few examples, so much over my head. I've found Xah Lee's website helpful, but also completely overwhelming in all its detail. I'm after a guide. So I'm looking forward to this book by Marcin Borkowski.Maybe others have suggestions of other ways to pick up Elisp?	nanna	15.154823	-3.9270966	comment	7.0	37.0	1619889106	-10.428114
27074471	I think Racket is the only modern li	I think Racket is the only modern lisp which has a sufficiently large community. What, if any, do you think should be the flagship project for introducing Racket?	yewenjie	15.338382	-3.6934197	comment	7.0	55.0	1620384391	13.651226
27074544	There are some very valid reasons [1	There are some very valid reasons [1] why we should stay away from Racket: toxic community, toxic people... And come on: no one has ever really used Racket to write some decent nontrivial web application, documentation is awful (and, please, don't count HN here, cause HN is written in Arc).[1] https://www.youtube.com/watch?v=_wY7FBtr7_c	dermal	15.366999	-3.6480227	comment	7.0	36.0	1620385243	13.650497
27380431	From Competitive Programming to APL	From Competitive Programming to APL	todsacerdoti	15.568679	-2.6881938	story	7.0	89.0	1622724420	13.088638
38036534	Ask HN: Do I need a special keyboard	Ask HN: Do I need a special keyboard layout to learn array programming?	distcs	15.562904	-2.696815	story	7.0	4.0	1698400464	13.02865
38159514	I'll always have a soft spot for Rac	I'll always have a soft spot for Racket, because of how the IDE literally draws arrows for you, overlaid on top of the code, linking the various occurrences of a (hovered) variable together.[1][2] Seriously, how cool is that? Alas, it's unclear how to begin to implement such a feature in a performant way in a DOM-based editor like vscode (I'm not a web developer, so maybe I'm wrong about this.)[1] Example gif: https://docs.racket-lang.org/define-attributes/examplecodear...[2] > Lexical Structure: The lexical structure is shown with arrows overlaid on the program text. When the mouse cursor passes over a variable, DrRacket draws an arrow from the binding location to the variable, or from the binding location to every bound occurrence of the variable.	aragonite	15.358136	-3.6673193	comment	7.0	54.0	1699252294	13.645668
14896670	Anybody use Racket in production? Ev	Anybody use Racket in production? Every time I think about it, the lack of libraries holds me back.	147	15.3625	-3.6504881	comment	7.0	28.0	1501542788	13.654476
12498049	GNU Guile 2.1.4 released	GNU Guile 2.1.4 released	rekado	15.190197	-3.774607	story	7.0	113.0	1473867525	-10.235729
12498351	"Anyone here know of any ""real"" progr"	"Anyone here know of any ""real"" programs and projects using Guile? Would be curious to hear of any blazing success-stories."	s_kilk	15.185596	-3.7872274	comment	7.0	37.0	1473869216	-10.229031
35370992	I always wondered how one can start 	I always wondered how one can start learning APL or similar array oriented language. Any suggestions? I'd like to give it a try!	finalfire	15.563494	-2.6985786	comment	7.0	21.0	1680175456	13.075689
28093198	Author here. I wrote this because I 	Author here. I wrote this because I thought APL deserved an up to date introductory text. It's basically the notes I kept when learning it myself. Stoked to see it on HN.	skruger	15.563237	-2.6819048	comment	7.0	29.0	1628286813	13.094256
22381995	A bit of Googling landed me here: ht	A bit of Googling landed me here: https://groups.google.com/forum/#!msg/racket-users/-x_M5wIht...From there:Phase 1: Brainstorming (months)Phase 2: Iterative Design (years)Phase 3: Conversion (months or years)Phase 4: Transition (years)I am a nobody in front of people like Matthew Flatt, but this feels like Seconds Systems Effect taken to its extreme definition: https://en.wikipedia.org/wiki/Second-system_effectPlus as a former Perl programmer having watched Perl 5 lost almost everything, chasing a never to have come to reality Perl 6. I can say, given all this, the future of Racket as a language, for its core uses and users is pretty much dead in the years to come. Like dead totally. Racket doesn't even have as much the share of dev mind share or a resource like CPAN at its disposal. Lang	kamaal	15.356228	-3.6637168	comment	7.0	39.0	1582277931	13.646817
22748352	I find that Practical Common Lisp ha	"I find that Practical Common Lisp has not aged well. Maybe it's the ""practical"" part with the specific examples the author used -that are now terribly dated- that is mainly responsible, but the end result is that I no longer recommend it.My goto recommendation for newcomers is Norvig's PAIP which is full of insightful moments and unbelievably good code and for people with more experience ""Let over Lambda"" by Doug Hoyte, which is a mind-blowing book mainly because of the time-transcendent nature of the examples Doug chose."	metroholografix	15.168818	-3.920461	comment	7.0	32.0	1585748258	-10.457658
22887226	The Guile in TeXmacs (2019) [pdf]	The Guile in TeXmacs (2019) [pdf]	mgubi	15.203437	-3.7484612	story	7.0	73.0	1587024627	-10.188039
23232982	Racket News – Issue 31	Racket News – Issue 31	pmatos	15.379904	-3.6306944	story	7.0	68.0	1589880775	13.654701
34301284	Many people who read about Lisp Mach	"Many people who read about Lisp Machines are not aware that the InterLisp-D world and the MIT world (CADR, LMI, Symbolics etc) had significantly different approaches to how the systems should work, so even if you have read or used the MIT-style systems you will learn a lot by using Medley.  I came from MIT out to PARC for a year, and later moved CYC from D machines to Symbolics machines (a complete reimplementation using a different fundamental architecture) so have good experiences with them both.At heart, the InterLisp language itself isn't that different from MIT lisps, as Interlisp started down the road at BBN and there was a lot of cross fertilization in both directions.  And CommonLisp, while heavily based on the ""MIT"" model has a lot of Interlisp influence in it.But as far as the in"	gumby	15.106379	-3.9205043	comment	7.0	45.0	1673200351	-10.440306
34419998	Show HN: Metapict – TikZ like figure	Show HN: Metapict – TikZ like figures using Racket	soegaard	15.352603	-3.655271	story	7.0	71.0	1673992858	13.644518
34940466	My biggest problem with forth has al	My biggest problem with forth has always been the curmudgeonly-ness of the community, it's like they feel compelled to do things at exactly 180⁰ to how the rest of the computer industry works, even this webpage throws out every norm about how web pages must be navigated, and feels like something from the 1970s while still looking modern.I love the language, at least part of it, but the community and that 180⁰ shift always feels like any attempt to utilise forth is swimming upstream in monsoon season.	NikkiA	15.041895	-3.8095767	comment	7.0	27.0	1677359117	6.1165113
13779218	50 Years of APL Datatypes (2016) [pd	50 Years of APL Datatypes (2016) [pdf]	breck	15.566339	-2.6887324	story	7.0	59.0	1488496219	13.114826
13887097	Can anyone tell me if Guile is relev	Can anyone tell me if Guile is relevant? The list of example programs written in Guile is small. EmacsLisp and not Scheme seems to be the Gnu lisp of choice. The VM is not the fastest and not the most portable. Is there any driver behind it?	didibus	15.185673	-3.7985468	comment	7.0	50.0	1489686270	-10.247964
30792421	Who is using APL in production out o	Who is using APL in production out of curiosity?	alfalfasprout	15.562885	-2.6876466	comment	7.0	28.0	1648140641	13.058013
31017057	Zuo: A Tiny Racket for Scripting	Zuo: A Tiny Racket for Scripting	homarp	15.356557	-3.661742	story	7.0	106.0	1649869004	13.649318
37021173	Lisp in Space	Lisp in Space	dargscisyhp	15.153543	-3.9268813	story	7.0	147.0	1691324291	-10.470652
24430241	Emacs Lisp is slow.  There has been 	Emacs Lisp is slow.  There has been a multi-decade effort to make Guile support ELisp, and using Guile to make Emacs more performant.Cross platform UI, with a faster Lisp, would allow Emacs to be even more special.	melling	15.154372	-3.860522	comment	7.0	40.0	1599728011	-10.31157
24799739	> Not necessary as per the APLv2 lic	> Not necessary as per the APLv2 licenseThe conversation ends there, doesn't it?	curiousgal	15.566927	-2.6859443	comment	7.0	37.0	1602848143	13.100949
25236822	Lisp Koans	Lisp Koans	phoe-krk	15.151359	-3.9301314	story	7.0	156.0	1606560203	-10.523111
32725988	I'm a heavy user of Common Lisp, and	"I'm a heavy user of Common Lisp, and I only dabble in Racket from time to time. While Common Lisp is my tool of choice for a lot of reasons stated in the post, since the post largely skews favorably toward Common Lisp, I'll offer two things that Racket shines at:1. DocumentationRacket has a beautiful documentation system called Scribble [0]. Almost all documentation written for Common Lisp is ugly, inconsistent, and doesn't follow any sort of standard. Common Lisp has a gazillion ""documentation generators"" which do little more than slurp up all the documentation strings and barf them back out as e.g. HTML. Common Lisp users tend to just rely on READMEs + jump-to-definition to learn how a project works. A few Lisp programmers (e.g., Shinmera, Edi Weitz) have made their own documentation sys"	reikonomusha	15.274818	-3.776449	comment	7.0	63.0	1662394590	-10.460112
31838013	That's all government has ever been 	That's all government has ever been and will always be: a protection racket.	prometheus76	15.354165	-3.5267966	comment	7.0	34.0	1655914734	13.61707
32055565	Slightly off-topic, but what would b	Slightly off-topic, but what would be a good book to learn guile (scheme, lisp) for someone with solid programming background (C, ruby, php, golang but no lisp at all)? I always wanted to give it a try but not sure where to start.	_wolfie_	15.183896	-3.8331559	comment	7.0	27.0	1657544249	-10.328033
22049381	Can someone who knows more about For	"Can someone who knows more about Forth clarify this for me: what ""level"" is something like Forth? Is it higher or lower-level than something like C?The reason I'm confused is that I see Forth in a lot of areas that look like they're typically for ""C and lower"", but looking at the syntax, Forth looks like a high-level language."	tombert	15.038373	-3.8118255	comment	7.0	31.0	1579037045	6.0795703
23413183	Can someone who knows all those one 	"Can someone who knows all those one letter languages well succinctly describe the differences between J, K, Q and APL?What I think I've got so far (this is all hearsay, and none should be taken as fact):APL: The original. Non-ASCII. APLers hate the successors, because ""notation is tool for thought"" and ASCII is a poor representation. Main implementations GNU APL (slowish), Dyalog (fast and expensive, free version available, good documentation)K: ASCII, used in finance (among other sibling languages, dependent on the concrete company and concrete group within a company), comes with kdb+ (columnar data store, integrated with K), very fast (main interpreter loop in processor cache), one real implementation (very very expensive, limited free version available), several cvariations on the langu"	Tomte	15.5583315	-2.7007446	comment	8.0	46.0	1591251495	13.042677
24038084	Racket 7.8	Racket 7.8	samth	15.382643	-3.6287994	story	8.0	171.0	1596464514	13.64903
24198323	I think the J examples at the bottom	I think the J examples at the bottom illustrate perfectly _why_ it’s preferable to force this type of array syntax into a language like Python, rather than jumping ship for APL:The J is inscrutable! But the Python is intuitive. Analytics code I’m writing for work needs to not only operate on arrays, but also get the hell out of the way! Understanding and communicating numerical routines is hard enough without obfuscating basic procedures.	michaericalribo	15.556423	-2.705217	comment	8.0	32.0	1597757696	13.041152
24398726	Apart from the Steindorfer and Vinju	Apart from the Steindorfer and Vinju paper [0], does anybody have any resources for implementing the CHAMP variant of HAMT tries?Better yet, has anybody here implemented one before, and might I pick your brain?[0] https://michael.steindorfer.name/publications/oopsla15.pdf	omginternets	15.342777	-3.6259778	comment	8.0	37.0	1599479111	9.070841
19997515	I’m not too familiar with Forth, but	I’m not too familiar with Forth, but I see posts about it and variants like this on HN from time to time.High-level, what makes Forth interesting? What are it’s major strengths and weaknesses?	burlesona	15.040358	-3.8111649	comment	8.0	57.0	1558659395	6.100993
20366920	Learn you a Lisp in 0 minutes	Learn you a Lisp in 0 minutes	goranmoomin	15.170103	-3.9132047	story	8.0	32.0	1562372702	-10.485954
20447479	> I really want to find ways to inte	> I really want to find ways to integrate Racket into my work.Normally engineers search for tools to solve their problems. Somehow, when it comes to programming languages, software engineers start a search for problems for their cute tools. Please don't get me wrong, I'm not making a snarky comment against lisp. I'm very much in love with lisp, but I do understand how people see us lisp people like bunch of gray wizards in some remote castle. What needs to be shown is a set of problems that can adequately be solved by racket that cannot be solved as well with competing languages. We should really stop treating programming languages anything other than tools. I use GNU grep for 20 years, one day I realize ripgrep is better, I switch.Again, I want to underscore that I'm not saying that parti	gnulinux	15.292932	-3.7558537	comment	8.0	29.0	1563251494	-10.460373
20732058	Thoughts on Racket2	Thoughts on Racket2	spraak	15.372241	-3.6412973	story	8.0	95.0	1566154104	13.656978
32374317	Ivy – An interpreter for an APL-like	Ivy – An interpreter for an APL-like language	georgia_peach	15.559573	-2.7038457	story	8.0	135.0	1659853159	13.0686245
25541005	Dev-cpp, mingw, and allegro where my	Dev-cpp, mingw, and allegro where my gateway drug back in 2000 or so, nice to hear it’s still around.	marktangotango	15.141086	-3.9278347	comment	8.0	28.0	1608951642	-10.449428
25744186	A Brief Introduction to Forth (1993)	A Brief Introduction to Forth (1993)	Cieplak	15.039651	-3.8039465	story	8.0	62.0	1610442513	6.020168
26008869	Creating Languages in Racket (2011)	Creating Languages in Racket (2011)	b-man	15.356803	-3.6655576	story	8.0	127.0	1612310736	13.646228
26025156	The APL Orchard	The APL Orchard	lelf	15.566387	-2.685295	story	8.0	78.0	1612445648	-0.45881623
28929843	Anyone using APL or J for work on HN	Anyone using APL or J for work on HN? I've used it as a hobby and think it's really cool, but haven't ever used it professionally.Edit: this has been posted on HN before.	7thaccount	15.5537195	-2.6882527	comment	8.0	32.0	1634732995	13.081185
29134703	Racket looks interesting. I am havin	Racket looks interesting. I am having trouble choosing between Racket and GNU Guile.	astrophysics	15.335698	-3.6819174	comment	8.0	50.0	1636240032	13.653441
29294320	Racket had to do this to go from lGP	Racket had to do this to go from lGPL to Mit, it was a long process. But they did it to make the language more accessible to developers. Developers are scared away by lGPL.Not all contributions were relicensed (resulting in code being rewritten), and we lost some code in the standard library (the csv parser).Now Racket is trying to make it more friendly to people by created a new language (called Rhombus for now) that is Racket without the parenthesis.They are playing the long game. But I hope these changes attract new Racketeers in the future	Decabytes	15.355287	-3.6686623	comment	8.0	98.0	1637471109	13.651777
19027400	Racket-On-Chez Status: January 2019	Racket-On-Chez Status: January 2019	bwidlar	15.374559	-3.6342454	story	8.0	175.0	1548777812	13.650565
19804893	Racket News – Issue 7	Racket News – Issue 7	soegaard	15.381804	-3.6265137	story	8.0	119.0	1556773158	13.656046
29987965	GOAL / games written in Lisp have be	GOAL / games written in Lisp have been a lifelong obsession. I used to search for hours for any scrap of information about the language. I would have traded a lot for this repo when I was 19.Thank you to the authors for fulfilling a teenage dream. Please consider doing Last Of Us next —- I once downloaded it and tore it apart for any signs of lisp, but it was all compiled bytecode. That’s where I gave up, but it looks like you took it one millennium further by reverse engineering the bytecode from Jak and Dexter to make your own port that compiles to the same bytecode. If you have infinite time, you could theoretically do this for last of us too, and also last of us 2.	sillysaurusx	15.145884	-3.9210455	comment	8.0	41.0	1642550321	-10.449402
30419581	The point about simple evaluation mo	"The point about simple evaluation models, while true for basic Racket, is actually the furthest from the truth in idiomatic Racket.The idiomatic way to solve a problem in Racket is to develop new syntax (and evaluation orders) which are suited to the problem.In fact, Racket has pythonic list comprehension syntax too:    (for/list ([x '(2 4 8)]) (sqr x))

It also has lazy evaluation langs, static typecheck pre-eval step langs, DFA compilers, OOP...Basically the floodgates are open, even if the river is still a bit barren. Every confusing language feature in existence can be added to Racket. The only saving grace is that anyone, including you, can replace it with less confusing syntax / evaluation orders if they so desire.I wrote a Macro which adds identifiers to your program based on a SQLi"	srcreigh	15.356672	-3.664866	comment	8.0	28.0	1645471511	13.64846
12552513	Anyone using Guile for their project	"Anyone using Guile for their projects? Any feedback on their experience with it?I only know Scheme from reading SICP and enjoyed Clojure but hated the java/JVM part of it. I currently use Erlang for when I need concurrency/performant backends. But I'm not totally satisfied with it (for ex: the weak type system and records).Edit: oh looks two programs I use all the time are written in Guile: GNU Make and WeeChat
https://en.wikipedia.org/wiki/GNU_Guile#Programs_using_Guile"	dmix	15.187866	-3.788448	comment	8.0	24.0	1474494048	-10.20296
27532180	Sounds like the Racket project badly	Sounds like the Racket project badly needs a Code of Conduct and a governing body to enforce it. Many FOSS projects have already done this, I believe.	chmaynard	15.373288	-3.6324637	comment	8.0	78.0	1623870076	13.642859
27623198	I think Lisp is wonderful, and I wou	I think Lisp is wonderful, and I would love to develop games using Lisp. However, I was under the impression that, by all accounts, developing games in Lisp is completely unrealistic due to the garbage collector.I'm not familiar with Common Lisp, but in Racket, “GC pauses [...] typically run from 50ms to 100ms” [0]. On a 16ms maximum frame budget, that doesn't really work. Am I missing something?[0]: https://docs.racket-lang.org/portaudio/index.html#%28part._....EDIT: I'm aware of GOAL at Naughty Dog — Andy Gavin who wrote it described the GC as being a problem in a HN comment. [1][1]: https://news.ycombinator.com/item?id=1998321	vladharbuz	15.233859	-3.825335	comment	8.0	38.0	1624565666	13.591973
27877723	As someone who did my first CS cours	As someone who did my first CS course in HtDP, it's nice to see new versions like this. Looks like the community is active and lively too.Which makes me curious...outside of teaching and PL research, is anyone else using Racket? Has it been used in other CS research fields perhaps? Some of the items in this changeset makes me think it might be used in numeric computation/stats modelling. Is it seeing some use in the industry as well? It seems to have a pretty extensive ecosystem but are the libraries mature?Would love to hear what/how people have been using Racket.	skytreader	15.360551	-3.6529765	comment	8.0	26.0	1626651500	13.649117
12017078	Dyalog APL v15.0 Free for Non-Commer	Dyalog APL v15.0 Free for Non-Commercial Use	jxy	15.568127	-2.6875498	story	8.0	73.0	1467387987	13.088845
12019063	So what's the trick to using APL if 	So what's the trick to using APL if you don't have the keyboard? Do most people use the custom keyboard? What about with laptops? Is there some sort of mnemonic for what symbols correspond to what letters? Do people put stickers over their keycaps?EDIT: Guys I mean literally the keyboard. Once it's software it's easy. I wanna know the best way to remember what key maps to what character.	gaze	15.56476	-2.6898806	comment	8.0	32.0	1467401691	13.07387
22643760	Best place/resource to learn Lisp?	Best place/resource to learn Lisp?	____Sash---701_	15.154365	-3.929101	comment	8.0	26.0	1584757944	-10.447973
22770163	There are too many incomplete lisp-o	There are too many incomplete lisp-on-js solutions. No, CLJS doesn't count. It would be so awesome if one ever made it to actual usable maturity.Is it too hard?  Is there something that makes everyone give up?  Or is lisp just too academic for most people to care?	hashkb	15.194241	-3.901686	comment	8.0	51.0	1585927521	-10.585022
23217094	State of Emacs Lisp on Guile	State of Emacs Lisp on Guile	todsacerdoti	15.210132	-3.773594	story	8.0	93.0	1589763687	-10.303691
33176482	Both forth and lisp seem similar to 	"Both forth and lisp seem similar to me. They have a ""three sentences to explain how everything works"" vibe. Forth uses a stack and so ""reverses"" the order of things. Lisp uses trees and so ""indents"" everything. I wonder if there is some kind of underlying rule. If you want ""one syntax to rule them all"" then it has to be recursive and so there's only a few options: stack, tree, etc. Hmm well recursive isn't the right term here. Maybe somebody who actually has thought about this can correct me."	JohnDeHope	15.093533	-3.9201972	comment	8.0	29.0	1665580604	-10.396375
27041008	Forth – The Early Years (1991)	Forth – The Early Years (1991)	susam	15.023718	-3.7829084	story	8.0	68.0	1620153081	5.916465
27480194	FORTH is a fun little class of langu	"FORTH is a fun little class of languages. These are easy to implement; in a few KB you can have a working development environment, with a screen editor, debugger and whatnot.In my experience, FORTH doesn't really scale to big projects, or things that need a lot of dynamic allocation. It's great at low-level stuff like hardware bringup (we used it on the Atari ST, back in the day, and even the hardware engineers were writing code to exercise their designs), but doing anything at scale is going to be tough. You probably don't want to write a modern web server platform in it, for instance. But it's probably great on an Arduino with a serial port.There were a lot of games started at Atari in FORTH (""Hey, this is simple! Who needs to hire expensive assembly language programmers?"") but the only "	kabdib	15.031887	-3.8217483	comment	8.0	39.0	1623458109	6.1064487
38059356	Pleasantly surprised to see this on 	Pleasantly surprised to see this on HN! This is an old (and incomplete) project of mine to reformat Structure and Interpretation of Computer Programs into a browser-friendly format, with a built-in code editor and interpreter [1].I think today, you can use Racket in its special SICP mode to get a much better experience. But maybe the HTML (Bootstrap) formatting is a little nicer to read (and with the bonus that it probably works on phones).The interpreter was incomplete and written from scratch, as a learning project [2]. This was done in the pre-WebAssembly days, so I couldn't just recompile, say, a Scheme written in C for use in the browser.If I recall correctly, I took the SICP source files, ran a bunch of regular expressions on them to convert the content into XML [3], and then used XS	schemescape	15.329645	-3.6758583	comment	8.0	39.0	1698592659	13.649984
38569129	TXR Lisp	TXR Lisp	tosh	15.160812	-3.899877	story	8.0	152.0	1702044126	9.209319
15301151	Server: Racket – An ebook about web 	Server: Racket – An ebook about web development with the Racket HTTP server	macco	15.348293	-3.6591485	story	8.0	139.0	1505978035	13.650646
15395680	Can anyone explain why there are so 	"Can anyone explain why there are so many implementations of Scheme written in Scheme? 
What is the point of doing that (apart from learning purposes)?I know, for example that people want Racket VM to be implemented in Chez Scheme because Chez is super fast. But what about all other implementations?Also, as I'm currently writing R5RS/Clojure hybrid in Kotlin, can anyone please share any _simple_ standard algorithm of implementing r5rs macro system and macro expander?The only thing I could find is https://www.cs.indiana.edu/chezscheme/syntax-case/"	kovrik	15.322763	-3.6964433	comment	8.0	30.0	1507061266	13.622301
20644038	Racket: Lisp for Learning	Racket: Lisp for Learning	chmaynard	15.308785	-3.7436194	story	9.0	221.0	1565268941	13.6265955
20728715	J can look like APL or English	J can look like APL or English	paliilap	15.563273	-2.6998472	story	9.0	153.0	1566112100	13.052277
13657462	I'm curious why people don't prefer 	I'm curious why people don't prefer Chez Scheme to Racket if it is so fast and can make real binaries (I think anyway). Maybe because until recent it was proprietary. Racket is cool, but I already have Python which is similar from a performance perspective. Chez with the Racket ecosystem might be worth a switch.	throwaway7645	15.358471	-3.6610858	comment	9.0	83.0	1487213276	13.647552
13967401	Make your own Lisp	Make your own Lisp	macco	15.145186	-3.9285429	story	9.0	187.0	1490620433	-10.478745
19233314	I'm currently browsing the list of l	I'm currently browsing the list of languages made with racket (here http://docs.racket-lang.org/search/index.html?q=H%3A) and it seems like most languages are just lisp variants. I suppose they were made for educational or fun purposes, but i wonder if i haven't missed something more deep as to why someone would want to reimplement a lisp in a lisp language.	bsaul	15.314613	-3.730067	comment	9.0	37.0	1550929927	13.652985
16993330	Lisp, Jazz, Aikido	Lisp, Jazz, Aikido	mpweiher	15.152595	-3.9257162	story	9.0	114.0	1525427265	-10.47409
17506789	APL\3000 – HP Journal – July 1977 [p	APL\3000 – HP Journal – July 1977 [pdf]	i_don_t_know	15.568287	-2.686745	story	9.0	75.0	1531316774	13.112199
21584319	Racket v7.5	Racket v7.5	inickt	15.383229	-3.6261876	story	9.0	122.0	1574261248	13.6325035
21587601	A History of APL in Fifty Functions 	A History of APL in Fifty Functions (2016)	lelf	15.562958	-2.7027183	story	9.0	109.0	1574278669	13.08797
21728991	I think I’m officially never going t	I think I’m officially never going to be smart enough to get APL.  Perhaps that day will come, but until then I find it hard to tell between these two viewpoints:(1) APL is another form of Perl golf, showing off basically.  The fact that so few people would be able to read it makes code essentially write-only and any enthusiasm for it as a serious language for communicating ideas between people is quackery; or(2) APL truly is readable, and if only I had received the right upbringing from an early enough age then I would have a mind capable of becoming APL enlightened, but it’s ok that I don’t because the virtue is that the next generation, at least, will all be able to revel in the language’s brevity.  Just because I can’t look at (+\%^,)•[x,}]• and instantly recognize it is a JPEG parser,	gorgoiler	15.563195	-2.6993456	comment	9.0	46.0	1575703938	13.092346
29801769	We Hate Lisp	We Hate Lisp	math-dev	15.184741	-3.904487	story	9.0	25.0	1641335862	-10.426247
12153052	Racket v6.6	Racket v6.6	kakashi19	15.37868	-3.6270788	story	9.0	134.0	1469360283	13.647224
22745503	Writing HTML with Racket and X-Expre	Writing HTML with Racket and X-Expressions (2019)	xy2_	15.345934	-3.6721327	story	9.0	86.0	1585713470	13.667074
33409159	Racketscript	Racketscript	bwidlar	15.3638315	-3.646708	story	9.0	167.0	1667236854	13.664275
26924344	Mal – Make a Lisp	Mal – Make a Lisp	AlexeyBrin	15.14419	-3.928885	story	9.0	170.0	1619266511	-10.435445
27073879	Racket 8.1	Racket 8.1	lycopodiopsida	15.374846	-3.6337917	story	9.0	164.0	1620378021	13.652032
38172760	Ask HN: Do You Program on Paper?	Ask HN: Do You Program on Paper?	mcmicah	15.562779	-2.6951964	story	9.0	5.0	1699326805	13.073745
31372204	The only thing anyone ever seems to 	The only thing anyone ever seems to do with forths is write another forth. Why is this?Unrelatedly (perhaps) I tried writing some basic software in forth and it was pretty horrific. Even something as simple as representing a variable length array feels like fighting the language	bowsamic	15.031372	-3.814054	comment	9.0	38.0	1652473714	6.1143155
26013151	I really wish the Racket team would 	I really wish the Racket team would write a book on Racket’s language making capabilities, or create a MOOC. I attended Racket School 2019, and it was awesome. The material was well put together and walked us through macros to #langs. But the only published material to walk a person through macros and building languages are Fear of Macros and Beautiful Racket.I have many ideas for little DSLs in Racket, but I am too slow and am slogging my way through learning how to create them.	bmitc	15.356877	-3.666763	comment	9.0	41.0	1612356481	13.650483
26129480	Racket v8.0	Racket v8.0	azhenley	15.374384	-3.6229553	story	9.0	276.0	1613274371	13.650216
26165090	This is great! Forth is such an inte	This is great! Forth is such an interesting language.Does anyone know of uses in industry?	Munksgaard	15.041292	-3.808156	comment	9.0	29.0	1613560017	6.1418967
32026647	APL and Array Programming	APL and Array Programming	tosh	15.56348	-2.6974742	story	9.0	93.0	1657312631	13.059837
32084556	One of the best essays of my youth. 	One of the best essays of my youth. Launched a decade long quest to understand and use lisp. The most surprising thing is there people still dismiss it. Irony of ironies is that the dismissal comes on a site powered by lisp. Indeed, HN wouldn’t have been possible without it.I went back and read it again, and unsurprisingly pg addressed this point too:> But I don't expect to convince anyone (over 25) to go out and learn Lisp. The purpose of this article is not to change anyone's mind, but to reassure people already interested in using Lisp-- people who know that Lisp is a powerful language, but worry because it isn't widely used. In a competitive situation, that's an advantage. Lisp's power is multiplied by the fact that your competitors don't get it.Every time you feel like discounting Lis	sillysaurusx	15.17386	-3.9170668	comment	9.0	42.0	1657728085	-10.463705
22062799	The Roots of Lisp (2001)	The Roots of Lisp (2001)	afurrysolver	15.155407	-3.9265943	story	9.0	124.0	1579165328	-10.461918
22083507	ANSI Common Lisp (1995)	ANSI Common Lisp (1995)	todsacerdoti	15.16752	-3.911919	story	9.0	129.0	1579341679	-10.442811
22118434	I asked a question on HN but didn't 	I asked a question on HN but didn't get any answers - this might be an easier forum to get one.I'm working on a hobbyist rocketry project where I'm helping build the flight computer - basically an Arduino Nano connected to modules like a GPS system, accelerator, gyroscope, etc. Are there any Lisp dialects that someone would recommend for an Arduino? The Nano is technically replaceable so if there are better boards that can use Lisp I'd be interested too!	exdsq	15.157931	-3.9272704	comment	9.0	41.0	1579707697	-10.610505
24196025	APL386 Unicode – An APL Font	APL386 Unicode – An APL Font	chrispsn	15.566298	-2.6897988	story	10.0	136.0	1597734665	13.09167
20414159	What is the purpose of Racket? Is th	What is the purpose of Racket? Is there any use for web development?	mac_was	15.366974	-3.6523087	comment	10.0	44.0	1562870315	13.648799
34181109	I regularly see Forth related materi	I regularly see Forth related material appear on HN. I love a lot of the concepts that get brought up in these article’s comments, particularly those that discuss the often small and personalized implementations of Forth that appear ubiquitous among those interested in Forth. However there doesn’t seem to be anyone who considers it a viable language for actual programming and a large portion of that seems to come from the personal implementations coupled with the proliferation of custom DSL’s that are reputed to spring up in any Forth program.As a person working on a programming language design that is a little forth-like in presentation (it’s not stack-based), is it just the anecdotal experience of Forth that leads to the seeming incompatibility with producing complex software? Or does th	throwaway17_17	15.03677	-3.8122988	comment	10.0	57.0	1672367755	6.044131
34415889	Common Lisp and Music Composition	Common Lisp and Music Composition	wglb	15.140084	-3.9239788	story	10.0	131.0	1673978066	-10.46944
19926522	And yet I'm still too stupid to unde	And yet I'm still too stupid to understand the macro system. Oh well.I also didn't know there was a Chez version. Racket already has a native AOT compiler, right? What would the advantage be to run on Chez, faster or smaller compiled code?	nerdponx	15.349151	-3.6736548	comment	10.0	33.0	1557986277	13.65885
19953833	I think one of the most amazing part	I think one of the most amazing parts of Racket, and one of the reasons someone should try it out if they haven't, is that the source code and evaluator support images and not just text.  The following link shows one aspect of this:https://docs.racket-lang.org/quick/Just being able to put an image in a comment explaining your algorithm into your code would be huge improvement over the traditional syntax colored ascii you get with most languages and editors.  There are many times I've written an algorithm which is difficult to understand without the associated diagram I drew on the whiteboard or in an image editor.  Racket lets you insert that image or photo directly into your source, and I think this is a significant improvement over putting a link to that image in a comment.Racket also go	civility	15.359054	-3.6589096	comment	10.0	38.0	1558280678	13.645324
17033533	Beautiful Racket	Beautiful Racket	tosh	15.379715	-3.6265829	story	10.0	287.0	1525896585	13.649864
21339750	Beating C with Dyalog APL	Beating C with Dyalog APL	lelf	15.557888	-2.7112837	story	10.0	102.0	1571869775	-7.1474
18253596	This Old Lisp	This Old Lisp	lispm	15.157952	-3.93015	story	10.0	238.0	1539910823	-10.477134
12202163	Guile-lips: Scheme as a generic macr	Guile-lips: Scheme as a generic macro language	ruste	15.184398	-3.7997987	story	10.0	40.0	1470057920	-10.215263
12351187	Dinosaur and Lisp	Dinosaur and Lisp	VitoVan	15.156231	-3.9284627	story	10.0	237.0	1472037805	-10.535416
35392909	Isn't the original APL the only lang	Isn't the original APL the only lang that uses actual Unicode symbols for operators?	semi-extrinsic	15.56264	-2.6943932	comment	10.0	36.0	1680293609	13.073031
22591194	GNU Make Guile Integration	GNU Make Guile Integration	gebt	15.1697445	-3.7787526	story	10.0	117.0	1584350465	-9.901603
33572019	The German School of Lisp (2011)	The German School of Lisp (2011)	tosh	15.150848	-3.922403	story	10.0	148.0	1668251310	-10.445588
26882117	Lisp in Forth	Lisp in Forth	tosh	15.143108	-3.9238296	story	10.0	155.0	1618954746	-10.439726
20255567	GNU APL 1.8	GNU APL 1.8	lelf	15.567468	-2.6912227	story	11.0	121.0	1561298622	13.103919
20550656	Levels of code in Forth programming 	Levels of code in Forth programming (2002)	pointfree	15.015522	-3.7989342	story	11.0	163.0	1564360912	6.045933
16799551	The BEAM needs an APL-y language	The BEAM needs an APL-y language	mpweiher	15.561037	-2.7038918	story	11.0	110.0	1523343349	13.075376
16952973	I wonder if array languages will fin	"I wonder if array languages will find wider popularity some day with a bit more verbose notation. Take “Array Indexing” (#29):    {(,⍺)[(⊂⍴⍺)⊥¨⊃∘.,/⍵]}

Or “Inverted Table Index-Of” (#31):    (⍉↑x⍳¨x) ⍳ (⍉↑x⍳¨y)

These could be written:    {(reshape lhs)[(enclose shape lhs)
      polynomial each disclose
      outer product reshape reduce rhs]}

    (transpose take x index each x)
      index (transpose take x index each y)

Same terms, just with searchable words instead of symbols. (Don’t mind the specific words—I’m not much of an APL user!) It definitely sacrifices some important aspects of APL, but in exchange I think it gains something in terms of accessibility by explicitly writing the pronunciations you might have in your head anyway when reading & writing the symbolic notation. It a"	evincarofautumn	15.564666	-2.6945662	comment	11.0	64.0	1525023320	13.07346
21675297	Understanding What It's Like to Prog	Understanding What It's Like to Program in Forth (2008)	goranmoomin	15.025177	-3.8024893	story	11.0	84.0	1575205721	6.0794034
18369822	Ask HN: Companies using Racket?	Ask HN: Companies using Racket?	ctas	15.363139	-3.6562622	story	11.0	188.0	1541246888	13.652393
18663298	Response to 'Reasons why Lisp games 	Response to 'Reasons why Lisp games suffer'	etiam	15.157465	-3.9301128	story	11.0	106.0	1544617537	-10.467268
30682953	International Racquetball Federation	International Racquetball Federation Officially Sanctions Racket:Next	victorbond	15.376066	-3.6296213	story	11.0	32.0	1647333568	13.65038
12254574	APL Tutorial	APL Tutorial	ktRolster	15.567118	-2.6899993	story	11.0	123.0	1470751847	13.086173
28093062	Here's what I don't get about APL. W	"Here's what I don't get about APL. Why is it so important that everything be a single symbol? Why not give the symbols more descriptive names and let people use those names, instead of being forced to work with only the symbols? Heck, it wouldn't be much work to make a text editor that lets you switch back and forth.APL seems to be designed for people who place an extremely, extremely high weight on code golf-level terseness. IMHO, terseness isn't the be-all, end-all of comprehensibility. I'd rather just use the words ""max"" and ""min"" than learn redundant special symbols for the same that save me a couple characters."	civilized	15.565329	-2.690986	comment	11.0	58.0	1628285971	13.075204
22578824	Lisp Comes of Age (1980)	Lisp Comes of Age (1980)	lproven	15.157181	-3.9257677	story	11.0	147.0	1584221078	-10.467839
23055793	Is APL Dead? Not anymore	Is APL Dead? Not anymore	lelf	15.563678	-2.6863964	story	11.0	127.0	1588463372	13.105327
23304457	Guilemacs – Emacs with Guile Scheme	Guilemacs – Emacs with Guile Scheme	MintelIE	15.188646	-3.7845187	story	11.0	120.0	1590437494	-10.23716
33560492	Zuo: A tiny Racket for scripting	Zuo: A tiny Racket for scripting	soegaard	15.357692	-3.6560786	story	11.0	105.0	1668172796	13.648872
37615783	Chez Scheme: Lisp with native code s	Chez Scheme: Lisp with native code speed	simonpure	15.247481	-3.797176	story	11.0	101.0	1695407337	13.580508
15055966	Lispers	Lispers	tosh	15.148071	-3.9109359	story	11.0	113.0	1503181396	-10.475364
15077519	Why I haven't jumped ship from Commo	Why I haven't jumped ship from Common Lisp to Racket just yet	networked	15.314606	-3.7323241	story	11.0	270.0	1503448204	13.652226
25895807	I am interested in LISP-type languag	I am interested in LISP-type languages, but I have a serious case of decision paralysis.GNU Guile? Common Lisp? Clojure (JVM)? Racket? Judging by my understanding of the difference between Common Lisp and Scheme, I think I am more of a Scheme type (I prefer C over C++, I like Go more than Java, etc).	gypsyharlot	15.160071	-3.92247	comment	12.0	58.0	1611521179	-10.516259
36323457	Rash – The Reckless Racket Shell	Rash – The Reckless Racket Shell	nrabulinski	15.374083	-3.6385505	story	12.0	132.0	1686734856	13.647883
28967485	APL is a write-only language. [1]Thi	APL is a write-only language. [1]This will be a controversial statement to devotees, but there's a simple argument that should clarify why this is true:1. APL's inventor claims that APL is a tool of thought. Specifically, it is designed to facilitate the development of algorithms.2. Tools of thought, like mathematical notation or writing in general, are used wherever people think.3. When people think about algorithms, they write code or pseudo-code.4. Thus, if APL were truly a tool of thought, it would be adopted as a pseudo-code. Academics would use it to more easily, concisely, and precisely express algorithms and programs. Software engineers would use it in their whiteboard planning. Etc.5. In reality, essentially no one uses APL as a pseudo-code. Even by its devotees, it used exclusive	civilized	15.564669	-2.6928463	comment	12.0	67.0	1634989014	13.078831
39183328	I believe this article is selling Gu	"I believe this article is selling Guile short. I think it is the most pragmatic Lisp around.I love Lisp's ideas but I find all modern implementations terrible. I would go so far as to say Lisp aren't popular because what we have today is not good enough. Common Lisp is the most advanced one, but it is like C++: it does everything and the kitchen sink. Design by committee. You want functional programming AND imperative? You want documentation that reads like an IBM mainframe manual? You want a standard library with names as cryptic as ANSI C? We got all that.  But frankly, it is the one to build serious production software with.Racket is the best for a beginner, but it keeps having that academic, ""we made it for the kids"" feel of being easy to understand but not very pragmatic for a seasone"	sph	15.266775	-3.7871873	comment	12.0	62.0	1706565682	13.648076
18192614	A new version of Common-Lisp.net has	A new version of Common-Lisp.net has been launched	kamaal	15.16265	-3.923226	story	12.0	165.0	1539257886	-10.478903
18226738	> McCarthy built Lisp out of parts s	"> McCarthy built Lisp out of parts so fundamental that it is hard to say whether he invented it or discovered it.I loved that sentence! I'm guessing epistemology or a similar field has pondered the ""invented or discovered"" question already, and if so, I want to read about it.> [on SICP:] Those concepts were general enough that any language could have been usedWhat?? In chapter 4, you write your own Lisp interpreter. If they had chosen C++, would you be writing a C++ compiler? Or a Lisp interpreter in C++? Either way, it would be ugly. And most languages would encounter problems even before they got to chapter 4. What made SICP great was building abstractions out of primitives. Most languages give you some abstractions, and others simply can't be built (at least not elegantly). I can't imag"	default-kramer	15.160855	-3.9063783	comment	12.0	84.0	1539666940	9.269671
29703014	Rack 2 (Virtual Eurorack)	Rack 2 (Virtual Eurorack)	tosh	15.352756	-3.6112716	story	12.0	146.0	1640617508	13.632271
22840867	Why We Should Teach Python instead o	Why We Should Teach Python instead of Racket	albertoCaroM	15.358435	-3.6637945	story	12.0	36.0	1586600154	13.641505
27282814	SICL: A New Common Lisp Implementati	SICL: A New Common Lisp Implementation	tosh	15.152655	-3.9219968	story	12.0	147.0	1621977540	-10.37881
38505138	A Personal History of APL (1982)	A Personal History of APL (1982)	lupin_sansei	15.569924	-2.6854975	story	12.0	122.0	1701582378	13.097573
20623303	Future of Racket	Future of Racket	tosh	15.379514	-3.629703	story	13.0	72.0	1565080032	13.691765
20714367	Taming OpenAPI using Racket to creat	Taming OpenAPI using Racket to create a DSL	spdegabrielle	15.3552	-3.6672282	story	13.0	74.0	1565957985	-9.523548
31603536	Racket for e-commerce (2019)	Racket for e-commerce (2019)	behnamoh	15.372583	-3.6367538	story	13.0	104.0	1654223346	13.648468
28929709	APL in its modern state (2020)	APL in its modern state (2020)	akbarnama	15.566739	-2.6862917	story	13.0	95.0	1634731920	13.100692
35369084	APL: An Array Oriented Programming L	APL: An Array Oriented Programming Language (2018)	tailrecursion	15.560908	-2.7001843	story	13.0	105.0	1680159635	13.053777
28092097	Learning APL	Learning APL	todsacerdoti	15.563609	-2.696331	story	13.0	199.0	1628280117	13.085755
28179463	Thoughts On Lisp And Racket (2019)	Thoughts On Lisp And Racket (2019)	chalst	15.32085	-3.724623	story	13.0	124.0	1628935192	13.643934
33180842	BQN: Finally, an APL for your flying	BQN: Finally, an APL for your flying saucer	tosh	15.563261	-2.6935346	story	13.0	88.0	1665598662	13.082743
13973812	A deep dive into APL	A deep dive into APL	sndean	15.564647	-2.6991272	story	14.0	168.0	1490671776	13.097444
32723784	Common Lisp vs Racket	Common Lisp vs Racket	ducktective	15.309438	-3.7365525	story	14.0	250.0	1662382608	13.656336
22063772	GNU Guile 3.0	GNU Guile 3.0	Fice	15.179575	-3.7804158	story	14.0	193.0	1579176758	-10.233936
22087583	I really feel like they should teach	I really feel like they should teach LISP in elementary school. It has extremely simple rules to get started and helps people intuitively understand programming concepts. Maybe an updated The Little Schemer style curriculum:https://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0...	proximitysauce	15.164353	-3.917547	comment	14.0	139.0	1579384828	-10.472944
19677292	Land of Lisp (2010)	Land of Lisp (2010)	tosh	15.156274	-3.9289653	story	14.0	247.0	1555448568	-10.462457
16952045	A History of APL in 50 Functions	A History of APL in 50 Functions	jim-jim-jim	15.563284	-2.6961272	story	14.0	250.0	1525010888	13.097062
21231515	It amuses and pleases me to see that	It amuses and pleases me to see that pg will continue to play around with lisp presumably forever, regardless of how wealthy he becomes.I hope I'll never stop coding passion projects myself.John Carmack talked about this on Joe Rogan's show recently, about how he still codes and how Elon Musk would like to do more engineering but hasn't much time.I wonder if Bill Gates ever codes anything anymore, I emailed to him ask once but never got a reply.Tim Sweeney is a billionaire and still knee deep in code.It's Saturday night here, and I'm going to go write some code. Unproductive, unprofitable, beautiful game engine code.Hope all you other hackers get up to something interesting this weekend.	PostOnce	15.1230345	-3.9297013	comment	14.0	100.0	1570869203	1.8958551
18073649	The Problem With APLs	The Problem With APLs	mr_golyadkin	15.565123	-2.6888313	story	14.0	82.0	1537947848	13.068553
29855453	Land of Lisp (2010)	Land of Lisp (2010)	rg111	15.154223	-3.9282033	story	14.0	183.0	1641671425	-10.482027
14782470	This looks like a lot of work for wh	This looks like a lot of work for what amounts to very little end-user benefit.Honestly, I'd rather see more progress on the Emacs Lisp/Guile migration than on a putative C/Rust migration. At least with the Guile switch, it's something that will have an obvious (and probably positive) impact on the people that use the editor.	mschaef	15.168707	-3.8245091	comment	14.0	136.0	1500220078	-10.238883
31493207	Racket Is an Acceptable Python (2019	Racket Is an Acceptable Python (2019)	behnamoh	15.355342	-3.6627693	story	15.0	181.0	1653405377	13.64711
36195173	Same for FORTH. I don't think I've e	Same for FORTH. I don't think I've ever seen a FORTH programmer and a LISP programmer in the same room; I can't imagine the discussion terminating.Over the years, as a left-handed person, I've come to see this as evidence of underlying diversity in thought patterns that can't simply be learned/trained around. Certain people find certain metaphors and modes of computing much easier to work with than others. Few people on either side can see this. The result is that you have people who, having feeling like they were fighting scissors all their lives suddenly discovering that a different sort of scissor exists that gives better results, start evangelizing it to everyone. The rest of the world tries it, finds it impossible to use, and concludes the weird scissor advocates are mad.Neither the L	pjc50	15.099054	-3.8903217	comment	15.0	70.0	1685967206	-10.482555
32839542	Why Racket? Why Lisp? (2014)	Why Racket? Why Lisp? (2014)	davikr	15.330064	-3.7112274	story	15.0	202.0	1663173003	13.649749
17636843	A Pamphlet against R: Computational 	A Pamphlet against R: Computational Intelligence in Guile Scheme (2016)	tosh	15.180013	-3.7889445	story	15.0	48.0	1532846225	-10.225867
21285543	Conflicts in the GNU project now aff	Conflicts in the GNU project now affect Guile	iso-8859-1	15.190107	-3.7739913	story	15.0	60.0	1571340489	-10.235595
30402408	Why learn Racket? A student's perspe	Why learn Racket? A student's perspective	hydroxideOH-	15.363579	-3.6483133	story	15.0	129.0	1645321297	13.642676
13242590	Racket Language – New website design	Racket Language – New website design	Learn2win	15.359975	-3.6595805	story	15.0	123.0	1482463633	13.645149
38158529	Racket branch of Chez Scheme merging	Racket branch of Chez Scheme merging with mainline Chez Scheme	Decabytes	15.388181	-3.6354237	story	15.0	229.0	1699241700	13.644134
25894233	Racket Compiler and Runtime Status	Racket Compiler and Runtime Status	gleb_the_human	15.35728	-3.6594334	story	16.0	180.0	1611512174	-5.4256425
18346961	How I lost my faith in Lisp (2002)	How I lost my faith in Lisp (2002)	Scarbutt	15.157645	-3.9262679	story	16.0	96.0	1541002476	-10.541722
18370531	I just finished teaching Racket for 	I just finished teaching Racket for 2/3 of the semester. I have never had a group of students hate their introductory programming experience the way that they did with Racket. 0/10 will never teach Racket again the rest of my life, no matter how much I enjoy functional programming.	acbart	15.353007	-3.6606631	comment	16.0	71.0	1541257570	13.63829
13881535	Beautiful Racket v1.0	Beautiful Racket v1.0	Curiositry	15.379318	-3.6282046	story	17.0	537.0	1489627002	13.651806
13884322	GNU Guile 2.2.0	GNU Guile 2.2.0	amirouche	15.184785	-3.7763789	story	17.0	331.0	1489666087	-10.218435
25622756	How to open a file in Emacs: a story	How to open a file in Emacs: a story about Lisp, technology, and human progress	mpereira	15.153191	-3.9271789	story	17.0	262.0	1609691548	-10.385368
29243476	Forth vs Lisp	Forth vs Lisp	monological	15.120976	-3.9097588	story	17.0	120.0	1637083889	-10.443363
39452211	APL at Volvo	APL at Volvo	tosh	15.568853	-2.6861646	story	17.0	152.0	1708511964	13.092203
37132510	What learning APL taught me about Py	What learning APL taught me about Python	RojerGS	15.552263	-2.7130992	story	17.0	90.0	1692098205	13.080729
23132621	Racket is 25	Racket is 25	azhenley	15.378508	-3.6232505	story	17.0	358.0	1589119236	13.646983
34064480	The APL Source Code (2012)	The APL Source Code (2012)	pncnmnp	15.565531	-2.6894586	story	17.0	106.0	1671535887	13.0931
36519359	Racket: Lisp for the modern day	Racket: Lisp for the modern day	Decabytes	15.316873	-3.7204983	story	18.0	268.0	1688040609	13.6429
22301595	Li Wenliang	Li Wenliang	Anon84	15.154699	-3.8757508	story	18.0	350.0	1581448445	-10.488473
37274882	Show HN: Going into freshman year, f	Show HN: Going into freshman year, figured I should build an interpreter	liamilan	15.354797	-3.664058	story	19.0	138.0	1693070890	13.635121
19325361	APL – A Glimpse of Heaven (2006)	APL – A Glimpse of Heaven (2006)	lelf	15.564714	-2.6855836	story	19.0	196.0	1551930021	13.108801
13420092	Pixie – A small, fast, native Lisp	Pixie – A small, fast, native Lisp	throwaway7645	15.154489	-3.9083333	story	19.0	315.0	1484679633	-10.431578
27139356	The Lisperati1000 is a cyberdeck ter	The Lisperati1000 is a cyberdeck terminal dedicated to Lisp programming	benwen	15.146481	-3.929735	story	19.0	171.0	1620890748	-10.4028845
34326311	Learn Lisp the Hard Way	Learn Lisp the Hard Way	Tomte	15.155339	-3.9283845	story	20.0	294.0	1673364705	-10.479125
19232068	Why Language-Oriented Programming? W	Why Language-Oriented Programming? Why Racket?	jessealama	15.356411	-3.667749	story	20.0	281.0	1550903948	13.631835
15031855	Ask HN: Lispers: Which dialect of Li	Ask HN: Lispers: Which dialect of Lisp do you use and why?	acalderaro	15.181011	-3.8985307	story	20.0	39.0	1502921970	-10.463669
20490423	Racket2 Possibilities	Racket2 Possibilities	mpweiher	15.377491	-3.6308641	story	21.0	109.0	1563696084	13.64447
36541758	Racket frustrates me	Racket frustrates me	lycopodiopsida	15.378798	-3.6284273	story	21.0	122.0	1688156874	13.65328
17173283	APL deserves its renaissance too	APL deserves its renaissance too	okaleniuk	15.567412	-2.688126	story	21.0	182.0	1527525047	13.111775
24283478	New Racket Language Website	New Racket Language Website	kamaal	15.362369	-3.6591713	story	22.0	326.0	1598456586	13.6394615
13797797	AMA: Explaining my 750 line compiler	AMA: Explaining my 750 line compiler+runtime designed to GPU self-host APL	arcfide	15.540496	-2.7189384	story	22.0	335.0	1488740463	13.0731945
18402567	Chicken Scheme 5.0	Chicken Scheme 5.0	mario-goulart	15.225386	-3.750085	story	22.0	303.0	1541626081	11.540825
13096576	Practical Common Lisp (2005)	Practical Common Lisp (2005)	tosh	15.147999	-3.9274633	story	23.0	296.0	1480786742	-10.439301
20392448	Racket Is an Acceptable Python	Racket Is an Acceptable Python	paroneayea	15.35806	-3.6636581	story	25.0	280.0	1562684555	13.633258
32359655	Byte Magazine: LISP (1979)	Byte Magazine: LISP (1979)	PaulHoule	15.143685	-3.925474	story	25.0	259.0	1659722598	-5.494454
19952714	Why Racket? Why Lisp?	Why Racket? Why Lisp?	alokrai	15.326177	-3.7177374	story	25.0	327.0	1558264470	13.656271
17036497	Common Lisp homepage	Common Lisp homepage	t-sin	15.154093	-3.9295852	story	25.0	292.0	1525928195	-10.475556
15417735	The Land of Lisp	The Land of Lisp	adgasf	15.153659	-3.9290283	story	25.0	477.0	1507305016	-10.464658
35852321	Why Lisp?	Why Lisp?	mepian	15.154659	-3.927981	story	27.0	244.0	1683472544	-10.462789
15033439	BYTE Magazine's Lisp issue (1979) [p	BYTE Magazine's Lisp issue (1979) [pdf]	pmoriarty	15.143564	-3.9280448	story	29.0	250.0	1502938557	-10.420768
