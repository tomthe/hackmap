id	label	hovertext	author	x	y	type	relevance	size	year	umap1d
33105312	> However, if you're actually a tale	> However, if you're actually a talented engineer these languages will hamstring you and your art.Early in my career I thought of software as art. I was wrong.The very last thing I want in any production software team is an artist looking to express themselves. I want the worlds most talented engineers who want to use consistent proven methods to create solid maintainable code with zero surprises.Code as art has its place, granted, but that place is in the privacy of your own time in a repository with one single contributor. I occasionally still go back to writing lisp for fun, but it has no place in production.	jjav	15.125758	-3.9674473	comment	3.0	10.0	1665039786	-10.4154625
33108507	> It's easier in some languages than	> It's easier in some languages than others.Yes, it seems Lisp wouldn't be appropriate for this.	behnamoh	15.13028	-3.9623785	comment	3.0	11.0	1665066074	-10.454945
33150026	I think the OP is referring to the p	"I think the OP is referring to the pseudo-variables, true, false, nil, self, super, and thisContext:https://en.wikipedia.org/wiki/Smalltalk#SyntaxI don’t think they count.If we’re counting small numbers, Lisp also has a small number of “keywords”, nine:    quote atom eq 
    cons car cdr 
    lambda label define

Others put this number at five or seven. I guess you can express define as a function of label and lambda, so you drop to eight, but I don’t know how you get to seven, let alone five."	MonkeyClub	15.100717	-3.9931295	comment	3.0	10.0	1665400746	-10.385871
33148860	LSP will not become obsolete, it wil	"LSP will not become obsolete, it will evolve. The entire industry is rallying around LSP, and Microsoft is constantly improving the protocol. In ""ten or twenty years"" LSP will have become a required feature for every programming language and every text editor. It will be essentially impossible to replace it with any other technology because of the massive investment already made in the ecosystem.I can imagine Tree-Sitter slowly losing importance because LSP is integrating semantic highlighting, but Tree-Sitter will still be an easy option for writing grammars in the absence of a full-featured language server."	p-e-w	15.042809	-3.96627	comment	3.0	11.0	1665388239	-10.423352
33198054	I want to look at it to understand. 	I want to look at it to understand. But my guess is that this happens at runtime, doesn't it. If this happens at runtime, this means runtime evaluates the macro, lisp function is generated, generated lisp function is compiled and used.	terminalcommand	15.0831	-4.0147243	comment	3.0	14.0	1665705564	-10.339867
33225525	What would you say the value is in l	What would you say the value is in learning some sort of lisp? I see the value in all the others, but lisp dialects tend to be pretty vanilla aside from their syntax. I can't think of anything you'd learn from lisp that you wouldn't from Haskell.	tomtheelder	15.1209955	-3.9810867	comment	3.0	10.0	1665942115	-10.456553
33317984	The ratio of people talking about ho	"The ratio of people talking about how great functional programming is compared to real accomplishments is poor.I imagine a bizzaro world where Common LISP became a dominant programming language and everybody is resentful about various details CL got wrong and the cool kids are talking about ""what a genius Noam Chomsky was"",  ""recursive descent parsers are so cool"",  ""I switched to PHP and became so much more productive"", ..."	PaulHoule	15.123421	-3.9656332	comment	3.0	13.0	1666625295	-10.426014
33330221	This survey is just thinly veiled te	This survey is just thinly veiled telemetry for big lisp.	worthless-trash	15.149389	-3.932071	comment	3.0	14.0	1666704658	-10.45093
26496339	> Some people argue Janet is not rea	> Some people argue Janet is not really a lisp.Out of curiosity: on what basis?Janet is definitely a Lisp, although it's not the (Common) Lisp.	klibertp	15.14721	-3.9408617	comment	3.0	23.0	1616012688	-10.523881
26510066	Crashes, as in actually exits withou	Crashes, as in actually exits without you triggering it? That's definitely very unusual; most lisp shouldn't be able to do that. Is there anything particularly unusual about your config? Are you maybe using a loadable module? If you do investigate it, you might find a reportable bug.	catern	15.127853	-3.9540997	comment	3.0	11.0	1616126617	-10.342887
26652520	http://homepage.divms.uiowa.edu/~luk	http://homepage.divms.uiowa.edu/~luke/xls/xlsinfo/xlsinfo.ht...This is Lisp-Stat.This website looks like a (sad, tasteless) April Fools' joke.	bluefox	15.154199	-3.9328215	comment	3.0	11.0	1617221732	-10.41262
26653412	Lisp totally works for scientific/st	Lisp totally works for scientific/statistical computing! Julia, for example, is commonly called a Lisp. And S/R/&c. are also very lispy. As is APL, to a lesser extent.	snicker7	15.140617	-3.9456306	comment	3.0	17.0	1617226239	-10.422919
26707569	SBCL's great. So is CLISP. GNU has t	SBCL's great. So is CLISP. GNU has the best Lisp going in 2021.	Klwohu	15.128006	-3.954295	comment	3.0	16.0	1617678472	-10.410493
26720995	Feels like we're 5-10 years away fro	"Feels like we're 5-10 years away from ""Lisp as an alternative to Go""."	neolog	15.154791	-3.9316428	comment	3.0	11.0	1617774837	-10.421428
26804484	"In ""On Lisp,"" there's a chapter wher"	"In ""On Lisp,"" there's a chapter where pg explains how to write continuation-style passing macros without sacrificing readability. I used it to implement nondeterministic backtracking in python, and it worked. No coroutines, no language support, just macros and locally-captured continuations.(I'm a bit too tired to figure out how this relates to your question, but I'm pretty certain it's related.)Here's the whole chapter as an imgur album: https://imgur.com/a/ccv4Q9oIt's hard to see from that chapter alone why it's so powerful, but later chapters implement a variety of wonderful things with these abstractions: a process scheduler, language analysis, and other nondeterministic things.It was neat playing with it on real algorithms in python, rather than being consigned to obscure-lisp-impelme"	sillysaurusx	15.095758	-4.0082736	comment	3.0	10.0	1618389615	-10.401466
37578231	I know there are much earlier exampl	"I know there are much earlier examples, but the earliest warning about this behavior I could find in 60 seconds of searching is from the comp.lang.lisp FAQ, posted more than 30 years ago, in 1992:    Mar 21, 1992, 1:00:47 AM
    Last-Modified: Tue Feb 25 17:34:30 1992 by Mark Kantrowitz
    ;;; ****************************************************************
    ;;; Answers to Frequently Asked Questions about Lisp ***************
    ;;; ****************************************************************
    ;;; Written by Mark Kantrowitz and Barry Margolin
    ;;; lisp-faq-3.text -- 16886 bytes
    
    [...]

    ----------------------------------------------------------------
    [3-9] Closures don't seem to work properly when referring to the
    iteration variable in DOLIST, DOTIMES and "	jjwiseman	15.153857	-3.9329605	comment	3.0	10.0	1695164362	-10.486995
14719453	"Here's a link to Bob's book, ""An Int"	"Here's a link to Bob's book, ""An Introduction to Programming in Emacs Lisp"": https://www.gnu.org/software/emacs/manual/eintr.htmlYou can buy it here for $25 from the FSF: https://shop.fsf.org/books/signed-introduction-programming-e...This has been a valuable resource on my own road toward learning elisp, and I'm very grateful he wrote it and made it freely available."	sillysaurus3	15.137135	-3.9363723	comment	3.0	10.0	1499443319	-10.418116
14726429	> Can somebody comment on the status	> Can somebody comment on the status of Lisp in 2017?Sadly the only Lisp environments that resemble in any way the old Lisp Machine or Xerox PARC ones are comercial.Emacs is kind of ok with SLIME, but it still isn't the same as using Allegro Common Lisp[0] or LispWorks [1].[0] - https://franz.com/products/allegro-common-lisp/[1] - http://www.lispworks.com/	pjmlp	15.134629	-3.941868	comment	3.0	28.0	1499536958	-10.431902
14782700	A large part of Emacs is the Lisp so	A large part of Emacs is the Lisp source. It would be great to have another interpreter written in Rust that reads the same Lisp files.What’s the breakout of C vs Elisp?Ideally more of Emacs could be rewritten in Lisp with a smaller interpreter.	melling	15.110954	-3.9596689	comment	3.0	11.0	1500222579	-10.3634815
14817720	>My point was that I have never seen	">My point was that I have never seen any evidence that such an idea was ever called Lisp.I'm not the only one who has this view.From Paul Graham, http://www.paulgraham.com/rootsoflisp.html""There were already models of computation, of course - most notably the Turing Machine. But Turing Machine programs are not very edifying to read. If you want a language for describing algorithms, you might want something more abstract, and that was one of McCarthy's aims in defining Lisp.
The language he defined in 1960 was missing a lot. It has no side-effects, no sequential execution (which is useful only with side effects anyway), no practical numbers, and dynamic scope. But these limitations can be remedied with surprisingly little additional code.
If you understand McCarthy's eval you understand mor"	doall	15.135487	-3.9568465	comment	3.0	31.0	1500605418	-10.382219
14861619	>In the paper McCarthy mentions also	">In the paper McCarthy mentions also:
>'6. A ``program feature'' allows programs containing assignment and go to statements in the style of ALGOL.'
>'7. Computation with floating point numbers is possible in the system'This part is about the status of LISP I and not what Graham is referring to. Did you look at the article by Graham?http://www.paulgraham.com/rootsoflisp.htmlHe is talking about the core of LISP that he found in the 1960 paper that is pure.>Basically the paper is more a collections of ideas around various ways to describe parts of LISPThere is clearly a gem in the paper that is viewed as a pure LISP."	doall	15.125554	-3.9628437	comment	3.0	24.0	1501114988	-10.399349
14863981	>McCarthy's earlier work on Lisp was	">McCarthy's earlier work on Lisp wasn't Lisp.I didn't say this. I have already explained about the difference between the first LISP implementation and the core language written in the 1960 paper. There is no one true definition of LISP and I have already talked about this. People have different views of what LISP is.You said black and white and it is not true from the paper I have shown.>In the 1958 paper, he was already describing a language with mutable objects.I am not talking about the 1958 paper. I am not also talking about which idea is first or not. Since it is not written clearly in the papers shown so far which idea is first, but I have showed that it is not black or white. Graham and my claim is based on the so called ""original LISP paper"" in 1960 and the pure version of LISP is"	doall	15.151249	-3.942476	comment	3.0	13.0	1501150814	-10.454324
14937424	The Evolution of Lisp (1993) [pdf]	The Evolution of Lisp (1993) [pdf]	tosh	15.151763	-3.9332871	story	3.0	103.0	1501961292	-10.4510565
14997223	There is no language definition or i	"There is no language definition or implementation called ""LISP"". Both Scheme and OCaml lexically capture variables by value, as if they have been passed in as arguments. This is not how it works in e.g. Python."	willtim	15.13433	-3.9586039	comment	3.0	18.0	1502530674	-10.434538
15033817	Perhaps, but there's no hard evidenc	Perhaps, but there's no hard evidence that lack of syntax leads to better results. All else being equal, most programmers seem to prefer at least some syntax. Is a long s-expression containing multiple nested parentheses easy to think about?	nradov	15.086547	-4.0139422	comment	3.0	14.0	1502944129	-10.314534
15034328	IMHO Lisp-like languages are good fo	"IMHO Lisp-like languages are good for showing off the ""back-end"" of a compiler/interpreter, because tokenisation/parsing is completely trivial. On the other hand, you miss out a lot of the fun of parsing a ""real"" language, with precedences and a more nontrivial grammar.One of the most enlightening points about interpreters/compilers is that, to a first approximation, the only difference between an interpreter and compiler is what it does when it walks the tree --- an interpreter executes the actions immediately, while a compiler generates code which executes those actions.An amazing demonstration of this is at https://news.ycombinator.com/item?id=8558822 and https://news.ycombinator.com/item?id=8746054 . It doesn't actually build an AST, but implicitly creates one and walks it since it doe"	userbinator	15.083713	-4.004459	comment	3.0	11.0	1502952604	-10.272357
15057309	Lisp is a beautiful language (or, to	Lisp is a beautiful language (or, to be more precise, set of languages). It is absolutely essential to a computer science education.It also gets unwieldy when programs get complex.	Fej	15.1435585	-3.9472542	comment	3.0	30.0	1503212653	-10.44297
15057531	Those amazing Lisp machines were far	Those amazing Lisp machines were far ahead of their time. Unfortunately the hardware was very expensive, and it lacked power. Today we have the right cheap hardware. Actually, there is a Lisp revival going on in the OSS community. Consider McClim [1] for instance which attempts to port the amazing GUI of the Lisp Machines to PCs. It already works.[1] https://common-lisp.net/project/mcclim/	progman	15.13484	-3.944609	comment	3.0	10.0	1503218128	-10.373573
15057849	No, it shouldn't be. Lisp is not pra	No, it shouldn't be. Lisp is not practical(try to prove it otherwise, there's no evidence) and it's only a thing now because some ppl likes its esoteric syntax. It's way too overhyped.	sds2	15.133767	-3.9581075	comment	3.0	16.0	1503225637	-10.456466
15058468	I just started learning Common Lisp 	I just started learning Common Lisp a few days ago, actually, and I agree that this isn't a good way to present this project.  I've never used Emacs (I'm been using vi for 13 years now), and regarding Lisp machines, I'm very curious about them but in 2017 I have the slightest idea where I could try one out; unlike Smalltalk where there are open-source Smalltalk VMs such as Squeak, there are no open-source Lisp OSes; plus, Lisp machines themselves are expensive collectors items.  (I wish there were some type of computer lab available where one could try out old machines that had a tremendous impact on computing history such as the Xerox Alto and Symbolics Lisp machines running Genera, but I digress.)  It would be nice if the IP issues regarding Symbolics Genera were resolved and if the IP o	linguae	15.130873	-3.9468453	comment	3.0	10.0	1503238484	-10.351366
15058523	if you're talking about https://web.	if you're talking about https://web.archive.org/web/20170820092504im_/https://common..., then it literally did not say that.  let me quote literally:Given that you lisp, you're probably familiar with Emacs or the symbolics lisp machine.  This environment shares some of its modality with these systems and is modeled (rather imperfectly), in their image.that's too optimistic for sure, but how is it a turn-off without you putting different words into author's mouth?	contras1970	15.14875	-3.9420416	comment	3.0	12.0	1503239524	-10.436985
15079618	You are correct, but why is this a p	"You are correct, but why is this a problem in the case mentioned by the author?    $ cat > hello-world.lisp
    (defun main () (format t ""Hello, World!~%""))
    $ sbcl 
    * (load ""hello-world.lisp"")
    T
    * (save-lisp-and-die ""hello-world"" :toplevel #'main :executable t)
    [undoing binding stack and other enclosing state... done]
    [defragmenting immobile space... 1110+19908+28500+22601 objects... done]
    [saving current Lisp image into hello-world:
    writing 4816 bytes from the read-only space at 0x20000000
    writing 2320 bytes from the static space at 0x20100000
    writing 2383872 bytes from the immobile space at 0x20300000
    writing 15190112 bytes from the immobile space at 0x21b00000
    writing 39911424 bytes from the dynamic space at 0x1000000000
    done]
    $ ./"	aerique	15.118626	-3.9501204	comment	3.0	13.0	1503476833	-10.402263
15081187	> You don't need database providers 	> You don't need database providers to be integrated in the language spec. Not in CL and not in many other successful languages.Many people underestimate how useful Perl DBI, JDBC, ODBC, Python DB-API, ADO.NET are.Which is why, in spite of all design flaws, even Go has a database interface defined on their core library.> Lisp is still pretty much one of the most modern and advanced languages aroundI agree with this part, and we are still far from the whole Symbolics experience.Yet using threading as an example, since it is left for each implementation, it means one cannot guarantee portable semantics across implementations.Exactly the issue we had with writing threads in C before p_threads came to be, and even as portable library there are semantic issues (e.g. signal handling) until C11 f	pjmlp	15.071415	-4.0148215	comment	3.0	15.0	1503493673	10.036692
15083327	It's been my understanding that Lisp	It's been my understanding that Lisp and its relatives aren't designed to compete against C for speed either. Is this wrong?	sythe2o0	15.128006	-3.960858	comment	3.0	14.0	1503508881	7.951417
12584347	That's not very Lisp-like.Personally	That's not very Lisp-like.Personally I really don't like it when files are modules. For me that's orthogonal.	lispm	15.107908	-3.9629	comment	3.0	16.0	1474914548	-10.434772
12617408	Now see, that's much clearer. From t	"Now see, that's much clearer. From the perspective of someone who knows Lisp, perhaps. I find it very confusing. Moreover, you are using an example from a tutorial, which is meant to explain how things work, not to show what the best way to write some macro is.You can write the same macro with less verbosity:    macro debug(n: varargs[typed]): typed =
      result = newNimNode(nnkStmtList, n)
      for x in n:
        let xRepr = toStrLit(x)
        result.add(quote do: writeLine(stdout, `xRepr` & "": "" & $`x`))"	flyx86	15.0878315	-4.012922	comment	3.0	23.0	1475320977	-10.35518
12654835	They were also really expensive, and	They were also really expensive, and there have always been people who hated Lisp for the syntax.	qwertyuiop924	15.143086	-3.941991	comment	3.0	31.0	1475778570	-10.4604225
12657896	Including Bayes in the standard libr	Including Bayes in the standard library is cool, but newLISP must be one of the slowest LISP interpreters out there.Its certainly useable - usually on par with Python... But picolisp, Gambit, SBCL are more on par with D or Rebol.So when newLISP claims to be great for embedding, I feel cautious.	shakna	15.125615	-3.9493887	comment	3.0	22.0	1475810256	-10.387178
12660150	> why should we suddenly start writi	"> why should we suddenly start writing Lisp? The language is older than C, for god's sake.If so many ""modern"" languages still copy features from Lisp (hello C++) then why not use the real thing?All those nice ""new"" features which Python and C++ are praised for (lambdas, closures, list comprehensions) have been available for almost 50 years. Lisp was way ahead of its time. It just lacked the hardware power which we have today. It is still ahead of our time. Consider Lisp macros, Genera and MCCLIM. MCCLIM is an interactive GUI for shells which has been neglected for decades. It is being revived right now to make it available for modern Lisp distributions. Modern Lisp just lacks one thing to be the real deal: a native Lisp Machine.https://common-lisp.net/project/mcclim/"	progman	15.119176	-3.964876	comment	3.0	18.0	1475843965	-10.389418
12660860	I wish every programming language ho	I wish every programming language homepage had a small code example. I know this is a LISP-like language and I can expect it to look like any other LISP. But I still appreciate getting a glimpse of the language without having to hunt through documentation for a tutorial.A small code example can tell you way more than a language description. An example is the PL equivalent of the picture is worth a thousand words adage.Additionally, it is not a given that a LISP will use S-expressions. It could use M-expressions, or even G-expressions (form a LISP like language I helped develop that nobody has ever heard of).Go, Rust, Ruby, Python all have examples on their homepage. Oddly, Swift does not.	eddieh	15.110801	-3.9743783	comment	3.0	10.0	1475850255	-6.4861426
12704555	> The language is not beautiful, it 	> The language is not beautiful, it is full of signature and func naming inconsistencies [1] it inherited from C.It was consistent with the thing it inherited most of it's syntax from so that makes it inconsistent?> The devs are ultra-conservative and stubborn to cause BC even at major version bumps (like the forever-incorrect ternary associativity [2][3])You shouldn't be judging the way operators work in one language with the way they work in others. Is lisp inherently bad since it's operators are prefix and not infix? No I'd say not, it's just different.On the other hand, the PHP devs changing the ternary would cause major problems for anything that uses it. The most the PHP devs have done is deprecate methods and add features. That's great. I think that changing something, that has been	gravypod	15.118289	-3.978155	comment	3.0	15.0	1476396961	10.279374
12737963	If you don't mind sharing, does ITA/	If you don't mind sharing, does ITA/Google Flights still use Common Lisp for the backend?	auvi	15.150258	-3.9382093	comment	3.0	10.0	1476819694	-10.432771
12799836	My favorite quote:    We feel that t	"My favorite quote:    We feel that the time for such radical changes 
    to Common Lisp passed, and it would be the job 
    of future Lisp designers to take lessons from 
    Common Lisp and Scheme to produce an improved 
    Lisp. 

I don't know if it is truly indicative of a general outlook, but the implication I read is that future Lisps are expected and encouraged.An open question I have, and if this is covered somewhere already, I'd love to see it.  It is interesting to me that while Lisp was looking to condense namespaces dramatically, it seems many other languages went the opposite route.  Is that a trend I just don't understand, or is there something inherent in Lisp that favors fewer namespaces?"	taeric	15.141398	-3.9531276	comment	3.0	30.0	1477511419	-10.485275
12801627	>You can implement almost anything w	>You can implement almost anything within CL because you have control over every part of the code-processing process.Almost. There is one big missing piece.  Standard code walker. If CL had standard code walker that could correctly walk trough any piece of standard CL code, it would implement fully the promise of Lisp and you could build almost anything on top of it with ease.	nabla9	15.12401	-3.9613435	comment	3.0	10.0	1477523804	-10.421107
27600578	Every Lisp programmer I've ever met 	"Every Lisp programmer I've ever met is like this. I don't know why, but it's probably Erik Naggum's fault. They used to be called ""Lisp weenies"" and now would be called ""abusers"".(The Clojure and Racket people are supposedly nice.)"	astrange	15.142286	-3.951848	comment	3.0	12.0	1624420033	-10.701873
27623025	I generally recommend people avoid L	I generally recommend people avoid Land of Lisp as an introduction to CL book. It's simultainisouly too easy and too hard for most people approaching the language in that it goes way too briefly over core concepts then all of a sudden shifts gears into much more involved programming.That being said, it's probably the best second book on CL ever. It showcases a variety of lisp techniques on some very real and fun example projects working itself all the way up to a web base game rendered via SVG which is quite fun.	blacktriangle	15.147563	-3.9397442	comment	3.0	12.0	1624564749	-10.437979
27621706	There’s a small, somewhat quiet, but	There’s a small, somewhat quiet, but very welcoming and very vibrant community of Common Lisp games developers. #lispgames on Libera is where many of them hang out.There are a few people who are trying their darndest to build and support libraries for graphics and other game-necessary things. It’s a tall order, since computers and operating systems have become so wildly complex and incompatible. (It’s no wonder people go straight for the browser to do little graphics things now.) Often it means finding a way to robustly interop with C++, graphics cards, etc.Borodust, Baggers, dto, mfiano, and Shinmera are but a few Internet pseudonyms of people working hard along these lines. Shinmera in particular just released a demo of his team’s game Kandria [1]. It’s a cool and modern game with neat m	reikonomusha	15.151668	-3.9309158	comment	3.0	16.0	1624558461	-10.435077
27638167	* Getting Things Done by David Allen	* Getting Things Done by David AllenThis book taught me so much about how to manage my life, and taught me how to review my own systems.* SICP, On Lisp, and Let over LambdaIt's hard to pick one exactly, because really it's about opening your mind to radically different programming paradigms than what's popular.Learning lisp well enough gives you confidence to attempt to create new programming languages, through code generation, or even mentally thinking about an API as a language rather than just a series of functions.	codemac	15.128423	-3.9497035	comment	3.0	10.0	1624670558	-10.445046
27678001	The lisp dialect (*Lisp) did get off	The lisp dialect (*Lisp) did get off the ground.  I programmed in it.	jrd259	15.140664	-3.9451559	comment	3.0	11.0	1624983347	-10.413316
27682645	> Written in a memory-safe-ish langu	"> Written in a memory-safe-ish language that a plebeian like me can understand, review and contribute to, like rust and go or even lua or V, but please no lisp, elisp or haskell.Would ""a plebeian like them"" care to explain why they don't like Lisp? Lisp as I see it is just the ultimate syntax of ""(function argument argument)"" and there is nothing more to learn unless you take a specific Lisp and compare it to others. I hardly even understand why do people keep inventing languages which are not lisps (and why does everybody seemingly find C-like syntax more intuitive)."	qwerty456127	15.133343	-3.981098	comment	3.0	16.0	1625006158	-10.454776
27694570	For a while, I've been meaning to wr	For a while, I've been meaning to write about how Catherine is an absolutely amazing game. The raw mechanics of it give me a sense of intellectual delight comparable to Go (the game, not the language) and the core ideas of Lisp or Scheme. All of them share a relatively small ruleset that results in surprising power or complexity. But what sets Catherine apart is that is has a metaphor (a human traversing and manipulating large blocks) that totally works! (There's also a storyline that is pretty good but irrelevant to the primary metaphor.)If we ever meet intelligent aliens, I won't be surprised if they have their own Lisp-like language or Go-like game, but they probably won't have Catherine. But to me, Catherine feels just as fundamental as Lisp or Go. And I call that very impressive game 	default-kramer	15.142727	-3.9428225	comment	3.0	10.0	1625094303	-10.459302
27715781	They were (are) slow, though. By 199	They were (are) slow, though. By 1990, workstations a tenth the price were just as fast, and while Symbolics was trying to scale Ivory past 14 MHz, RISC CPUs were rapidly approaching 100 MHz and CISC CPUs were heading that way too. And Coral, Gold Hill, and Lucid all showed that modern general purpose CPUs could run good Lisp environments well.My Symbolics systems are elegant, don’t get me wrong. But Genera wouldn’t have been any less elegant if they’d taken their 80386+DOS deployment environment (CLOE) and used it as the basis for a true 80386 port of Genera. They were too stuck on being better than everyone else at designing hardware for Lisp that they missed not needing special hardware for it.	eschaton	15.130145	-3.9451697	comment	3.0	12.0	1625254206	-10.33086
27805701	>Lisp doesn’t really have many, if a	>Lisp doesn’t really have many, if at all, super weird concepts that need months of thinking about in order to understand.I dunno, using a DSL for linked lists as the only syntax construct is pretty radical. CAR/CDR and CONS pair dot notation must feel pretty esoteric. The concept of macros that transform the syntax tree is unusual, and knowing when to use them requires a restraint that comes only with experience. I could see it taking months if not years to fully grasp the zen of Lisp.	dTal	15.121559	-3.9726615	comment	3.0	29.0	1626049933	-10.395181
27810912	Does anyone actually program like th	Does anyone actually program like that besides for in lisp tutorials?	oh_sigh	15.140906	-3.9455972	comment	3.0	13.0	1626101774	-10.4245205
35167293	>> live coding capabilitySince i was	>> live coding capabilitySince i was introduced to lisp, this is my number 1 desire everytime i write code. The js ecosystem gets a lot of hate but the power of some of the browser tooling coupled with some kinds of hot reloading (specifically the kind that maintains state), it can be super nice to work with.EDIT: To be clear this isn't as powerful as the lisp version of this - i.e. the condition system and just the nature of how cheap/fast/quick changing code is in lisp while it's running, not the approximation way this is done in JS by stopping, swapping and potentially reinitialising>> Smalltalk’s image also makes software deployment a breezeWhen i started playing with lisp this was one of my first concerns, how do i deploy this? I was dreaming up all these rube goldberg scenarios with 	CraigJPerry	15.060788	-3.990146	comment	3.0	12.0	1678883706	-10.418099
35388063	I don't think Janet and Scheme have 	I don't think Janet and Scheme have very much in common. If you're looking for a huge, batteries-included language, you will not have a good time with Janet :)Janet is much closer to Lua, in scope and applications, than it is to any Scheme or Common Lisp or Clojure implementations.	ianthehenry	15.098999	-4.0163627	comment	3.0	10.0	1680274556	-10.763128
35445547	Review of 8 Common Lisp IDEs Which O	Review of 8 Common Lisp IDEs Which One to Choose? [EN Subs]	svetlyak40wt	15.14633	-3.9404345	story	3.0	13.0	1680640525	-10.44519
22315693	Hmm. I think Viaweb was the first we	Hmm. I think Viaweb was the first web application (or at least, no one's disputed that claim) and they kept their choice to use lisp a secret until acquisition. If someone else was using lisp to make websites, it seems like they must have independently rediscovered the idea.It was started in 1995 and acquired in 1998, so that wasn't a very long time for lisp to come into the public consciousness. It seems like at best it was considered an AI research language.	sillysaurusx	15.141328	-3.9438636	comment	3.0	10.0	1581574619	-10.451778
22315948	>Garbage collection was developed fo	">Garbage collection was developed for Lisp. That way, any language with GC borrows directly from Lisp.The English language borrows a lot of things directly from other languages. That doesn't mean it is ""a dialect of"" any of them, which was the claim being objected to–that ""most mainstream languages are dialects of Lisp""."	yesenadam	15.141252	-3.9513705	comment	3.0	27.0	1581578364	-10.45884
22412544	Very nice overview, I failed to see 	Very nice overview, I failed to see references to LispWorks and Allegro, though.	pjmlp	15.135498	-3.9390438	comment	3.0	11.0	1582633177	-10.455855
22414582	The above post didn't say unpopular,	"The above post didn't say unpopular, they said 'underpopular'.  While that's a bit of a neologism, it just implies that it's less popular than it should be.Also: ""Lisp is the most fun you can have programming, yeah from the start,"" while subjective, is by most accounts, wrong. Especially when referring to Common Lisp; there could hardly be a more convoluted Lisp than Common Lisp."	kick	15.145404	-3.9451048	comment	3.0	16.0	1582648712	-10.493889
22414155	First off, Lisp is chronically POPUL	First off, Lisp is chronically POPULAR not unpopular. (It is critically unpopular.) Secondly, Lisp is the most fun you can have programming, yeah from the start. You apparently had either a very poor teacher, or taught yourself Lisp ... same thing.	abrax3141	15.147132	-3.9427834	comment	3.0	20.0	1582646147	-10.500056
22500143	Congratulations to repl.io team on r	Congratulations to repl.io team on rediscovering Symbolics Lisp Machine's Dynamic Windows / Common Lisp Interface Manager's presentation and listener systems!Not being sarcastic, even - it's a pretty powerful approach that deserves better, unfortunately distribution of knowledge in Computing Science, especially historical knowledge if you never encountered it yourself, is pretty hard.	p_l	15.136569	-3.9399896	comment	3.0	12.0	1583456409	-10.360542
22523842	Single-letter identifiers are a natu	Single-letter identifiers are a natural thing to object to when coming from other language paradigms, i.e. nearly every programming background out there, but this is a category error. What seems ridiculous in one context can be sensible in another. The objection turns out to be parochial.It reminds me of how people think that parentheses are a significant aspect of Lisp, when in practice they're not. The parens look grotesque at first, but once past the novice stage they fade completely into the background and impose no cognitive overhead. Because of their regularity, the parens free you to program without thinking about syntax, allowing you to think more about the problem at hand—a highly liberating experience—yet to someone who hasn't worked with the language long enough to get that expe	dang	15.089124	-4.0033617	comment	3.0	10.0	1583742311	-10.368357
22582754	C is not good. At least, not in the 	C is not good. At least, not in the way parent means “good”.C is this brilliant awful crazy-successful hack, yak-shaved into existence just to bootstrap an entire brand new OS (UNIX) in record time; subsequently Peter-Principled into domains it really has no business being in (basically anything userland). This is why, fifty years on, we’re still fighting memory corruption and security holes and generally doing an awful job of parallel computation and everything else C is not very good at.Everyone should learn C, if only to understand where we’ve come from, where we are now, and where we should be trying to go in future.Languages like Lisp and Forth and Smalltalk are fundamentally different beasts to Algol’s descendents.Most developers, having being raised in a pure C/Algol culture, give n	hhas01	15.12441	-3.9656022	comment	3.0	37.0	1584270507	-10.410225
22583511	It’s not a recognized term, hence th	It’s not a recognized term, hence the air-quotes. The terms “Lisp 1” and “Lisp 2” do describe concrete implementations of Lisp (1 keeps functions and data in separate namespaces; 2 puts everything in a single namespace). Many consider Lisp-2 an improvement over Lisp-1, in that it eliminates complexity and improves consistency and uniformity of behavior.However, as even some Lispers will admit, Lisp itself is not a good Lisp.Just like the Algols, Lisp 1s & 2s are riddled with special forms (they just hide them better). e.g. You can’t implement your own conditional operator in Lisp that replicates the behavior of Lisp’s built-in `if` operator, because `if` requires that its second and third operands be lazily evaluated, and Lisp itself always evaluates operands eagerly. Thus that special-cas	hhas01	15.1269655	-3.9675024	comment	3.0	12.0	1584280786	-10.425758
22587549	Yes indeed, I really like this almos	Yes indeed, I really like this almost twenty year old article. It seems like I re-read it every several years.Lisp is in even better shape now than twenty years ago:Application delivery is a solved problem. On the commercial side LispWorks and Franz have portable UI frameworks and application delivery mechanisms that are excellent.On the open source side, SBCL and Clozure are excellent, with different strength. Both have robust application deployment capabilities.In the non-Common Lisp world, Racket (Scheme) just keeps getting better, and also has a good application delivery mechanism and portable UI that looks great in macOS and not so good on Linux.	mark_l_watson	15.124547	-3.9380653	comment	3.0	14.0	1584312565	-10.379693
22588645	Is this the same Symbolics that came	Is this the same Symbolics that came out of the MIT AI lab? With the LISP machines?	CountSessine	15.1407	-3.9354613	comment	3.0	14.0	1584321504	-10.3376665
22627733	You're saying the fact that Stephen 	"You're saying the fact that Stephen Wolfram comes off as a narcissist is unrelated to the fact that he names everything after himself?Python isn't called ""the van Rossum Language"". C isn't called ""the Ritchie Language"" (or ""the Bell language"", for that matter). Lisp isn't called the ""the McCarthy language"". We should judge Wolfram Research's products in spite of their unfortunate names, but denying that they're the result of Wolfram's narcissism is silly at this point."	OskarS	15.132171	-3.9455256	comment	3.0	12.0	1584627823	5.9302125
15116842	Lispyville: a lisp-editing environme	Lispyville: a lisp-editing environment suited towards evil users	pmoriarty	15.127154	-3.946718	story	3.0	67.0	1503931594	-10.401864
15174032	Every Programmer Should Know LISP	Every Programmer Should Know LISP	intellectronica	15.139362	-3.9502265	comment	3.0	11.0	1504609491	-10.474525
15186618	That was probably Stallman's doing. 	That was probably Stallman's doing. He wrote most of the LISP machine code.	Animats	15.142482	-3.9382155	comment	3.0	12.0	1504727664	-8.939862
15187653	I don't have to explain why Lisp fai	I don't have to explain why Lisp failed to take off. I just have to explain why C did, because network effects are more significant than language advantages. This is my central thesis.I don't think awareness of Lisp was evenly distributed among people developing on PCs in the time period when the network advantage was obtained. Even if it was, if there were already a decent C compiler, I don't think most practical engineers would immediately embark on a compiler development project. During this era, those who did know about Lisp certainly would have regarded it as being too resource-intensive for work in a resource-constrained environment like the PC.I think it's specious to say it's easy to develop a simple Lisp compiler, so why didn't anything get ported. The code you may have wanted to 	fusiongyro	15.128874	-3.9563937	comment	3.0	31.0	1504737002	-10.375165
15208041	Numbers and tagged pointers in early	Numbers and tagged pointers in early Lisp implementations	jsnell	15.131641	-3.9538217	story	3.0	89.0	1504977905	-10.398509
15211704	"""you've been stacked""-- HP calc owne"	"""you've been stacked""-- HP calc ownerLast year I finally read the whole manual (as a teen I only used the symbolic differentiator, most useful and magical to my brain at the time). Since I learned about Lisp, so RPN programming features appealed to me. I realized that:1) RPN has lambda << 2 + >> means (lambda (...) (+ 2 ...))2) RPN has a short syntax for them << a -> a 2 + >>Yes, 1990 HP RPN had arrow notation out of the box. Take that ES6 !"	agumonkey	15.062362	-3.9638886	comment	3.0	19.0	1505041763	7.224562
15257610	> }))}`] } }Yet only things called L	"> }))}`] } }Yet only things called Lisp ever get flamed for this.If it is just )))))) you only have to just auto-repeat ) until the editor indicates a match to the one you are trying to close. It's only ""how many you owe"", not ""what kinds do you owe, in what order""."	kazinator	15.124404	-3.9664338	comment	3.0	16.0	1505487146	-10.363669
15278894	SBCL is a very interesting compiler.	"SBCL is a very interesting compiler. I can only encourage anyone, who is interested in Lisp or dynamic languages in general to check it out. It always compiles to native code, and as the article has shown, you can see what it compiles to. That gives you direct feedback how good the resulting code is.By default, SBCL always generates ""correct"" code. That of course means for a dynamically typed language, that it has to assume any type. Also, for integer operations, it means, still producing a correct result, even if the integers exceed the values which can be represented by machine-sized integers. As a result, the generated code isn't overly impressive in the beginning. But SBCL has very high abilities to reason about the code, including type inferencing. So, when you add a few type declarat"	_ph_	15.127452	-3.9533582	comment	3.0	13.0	1505764015	-10.392904
15359678	Ever since I found out about Lisp ma	"Ever since I found out about Lisp machines I've been a bit obsessed with them. When I got the leaked distribution of Symbolics Genera going in Linux I felt like I was in possession of a crashed UFO. The user experience of the Listener, with its rich output (almost a ""scrolling desktop"") was exactly what I wanted from a command line. As I imagined what that system would be like if development had continued I started getting so many ideas, it was thrilling.And at that time I hardly knew Lisp! What excited me was the user experience of the Listener, the notion of programming being a way to use the computer, not just to construct software -  and the way each piece of software in the system was practically an API for my own use. This was sci-fi stuff to me, extremely inspiring.I don't know how "	richardjdare	15.1190815	-3.9490597	comment	3.0	15.0	1506623811	-10.325029
15387549	TXR Lisp, a dialect I created:  $ tx	"TXR Lisp, a dialect I created:  $ txr
  This is the TXR Lisp interactive listener of TXR 185.
  Quit with :quit or Ctrl-D on empty line. Ctrl-X ? for cheatsheet.
  1> (set a.b 3)
  ** warning: (expr-1:1) qref: symbol b isn't the name of a struct slot
  ** warning: (expr-1:1) unbound variable a
  ** (expr-1:1) unbound variable a
  ** during evaluation of form (slotset a 'b 3)
  ** ... an expansion of (set a.b 3)
  ** which is located at expr-1:1

Both warnings are static. If we put that into a function body and put that function into a file, and then load the file, we get the warnings.The diagnostics after the warnings are then from evaluation.Those are nothing; TXR Lisp will get better diagnostics over time. I'm just starting the background work for a compiler.There is dynamic and then the"	kazinator	15.101402	-3.9940186	comment	3.0	18.0	1506975554	-10.354286
15407571	How can you call lisp an inaccessibl	How can you call lisp an inaccessible language? It has less syntax than anything else. It is as simple as a language gets.	edem	15.139891	-3.9494052	comment	3.0	17.0	1507193022	-10.457267
15417949	I've read this book, and what I love	I've read this book, and what I love about it is that it really brings to mind the programming books of my youth, when nobody would argue that programming should be fun.It's goofy, has bad jokes, and you learn something.Having said that, the code style seemed quite idiomatic compared to some of the other Lisp I've seen (although I'm no expert), so I wasn't sure how valuable the lessons were.	midgetjones	15.1494	-3.9306152	comment	3.0	47.0	1507306578	-10.3963
15418057	I've read most of it too, but not su	I've read most of it too, but not sure it shows a lot of lisp's strengths. A lot of the programs I read them over and thought that I could do the same thing in significantly less Python code. I'm not sure what should be fixed if anything though.	throwaway7645	15.1467	-3.9381645	comment	3.0	10.0	1507307360	-10.446661
15418396	A common complaint about Lisp code i	"A common complaint about Lisp code in general is that programmers tend to write code that is idiosyncratic [ED: I previously used the word ""idiomatic"" here in reply to the OP but was conflating terms, making this post rather irrelevant but at least it provoked a discussion] (i.e. rather than looking like templated design patterns with standard names, the program is heirarchically built of modules in a domain-specific language of the programmer's own design).  This is both one of Lisp's greatest strengths to those who like it, and (I think, based on comments I've seen here and elsewhere) one of the greatest reasons it doesn't have more widespread adoption."	dwringer	15.137405	-3.9567504	comment	3.0	26.0	1507309842	-10.463618
15419668	This book comes up in #lisp on freen	This book comes up in #lisp on freenode every so often, and the channel is generally split on whether or not to recommend it.  I generally do.It's fun and lighthearted.  Using games as a medium to teach the language is something some people enjoy, and is a lot less dry than most programming books.It avoids taking sides on the editor war, by just ignoring it altogether and teaching Lisp.  This is refreshing compared to most books, which hit you with the Emacs cinderblock to the face right in the preface.It also stays away from ASDF and Quicklisp and even the entire package system in general, which is a lot of extra complexity that can be overwhelming to beginners at first (though they'll eventually need to learn about this if they want to continue using Common Lisp).The main issue people ha	stevelosh	15.147028	-3.9362102	comment	3.0	21.0	1507317989	-10.425191
15420134	>The main issue people have with the	">The main issue people have with the book is that it uses CLISP-specific code in a few places.This makes sense for a tutorial book, since CLISP is easy to install, very small to download (compared to SBCL), and is a fully featured (ANSI compliant) implementation. So i don't think it was a mistake to choose CLISP.The recommendation in #lisp for SBCL over CLISP might be because SBCL is nicer to the programmer, offering more features. Also, code runs very fast under SBCL; although i suspect that CLISP compiles code faster.(If any is interested, here is a quick overview on some of the Lisp implementations available and their salient features. 
(Most implementations are free)    ECL - Embeddable Common Lisp
        allows you to compile Lisp into any 
        other system by compiling to C

   "	flavio81	15.126856	-3.9575286	comment	3.0	16.0	1507321491	-10.423527
15466940	Does this roughly offer the same ben	Does this roughly offer the same benefits that the old lisp machines provided?I've never used one, but have heard people rave about how productive they were on them.	tyingq	15.144942	-3.9391403	comment	3.0	46.0	1507911396	-10.466103
15525638	Parentheses aren't an issue if you w	Parentheses aren't an issue if you write Lisp in Emacs.	sn9	15.097959	-3.9982445	comment	3.0	20.0	1508657831	-10.333834
15560418	"I disagree with the ""single ... lang"	"I disagree with the ""single ... language"" right off the bat before any deeper considerations.Lisp is a great collection of design patterns for making languages.> The key was not so much “Lisp” but the kinds of thinking that this kind of representational approach allowed and opened up regarding all kinds of programming language schemes.> A fun thing about it this is that once you’ve grokked it, you can think right away of better programming languages than Lisp, and you can think right away of better ways to write the meta descriptions than John did.Once you've grokked it, those programming languages are more advanced dialects of Lisp.Or else, you didn't really grok it."	kazinator	15.136417	-3.9572587	comment	3.0	19.0	1509035673	-10.458065
15571391	Agreed, and well said.I'm very much 	Agreed, and well said.I'm very much a pragmatic kind of person, and my unpopular opinion about code is that Lisp is the greatest single language ever designed, if your goal in designing a language is to produce articles proclaiming it as such.And I am sooo sympathetic to the promises Lispers make.  I want to believe.  But ultimately, show me the code.  Why are the stellar Lisp success stories so few and far between that one of the big ones is Paul Graham's from the 90s?If it's so powerful that almost no one can use it, and it rules in almost no problem domains, ... how is it so powerful again?	Frondo	15.140234	-3.9492848	comment	3.0	10.0	1509132035	-10.470972
15572026	And these operating systems in both 	And these operating systems in both Smalltalk and Lisp were both better and easier to write than the standard ones of today.Look, I love Lisp as much as the next hacker, but is Alan Kay for real?  Where's the Lisp equivalent to this C code?https://github.com/dwelch67/raspberrypi/tree/master/blinker0...More importantly, where's the accompanying toolchain?  Seriously, I really want to know because I'd love, Love, LOVE to play around with it.	xenophonf	15.119383	-3.9481118	comment	3.0	19.0	1509136578	-10.3332615
38159801	The coolness of Lisp Machines and In	The coolness of Lisp Machines and Interlisp-D, which is where Raket took its inspiration from.	pjmlp	15.1519785	-3.9357052	comment	3.0	13.0	1699256321	-10.428903
38185771	My impression is that GNU Emacs in g	"My impression is that GNU Emacs in general has awful (default) keybindings. Specifically the keybindings of SLIME are among the worst of any Lisp IDE. Use c-h m to see the keybindings of a Lisp editor buffer. It's what it is and a reason for that are the GNU Emacs keybindings in general.Just check the keybindings of anything eval in SLIME for a Lisp file buffer:  C-x C-e
  C-M-x
  C-c C-p
  C-C C-r
  C-c :

Evaluation of Lisp code is central to Lisp. But the keybindings are just awful. Generally getting rid of one layer of prefix keys would be a start.GNU Emacs also still believes that my Mac has a Meta and a Super key. It hasn't. Every new user has to learn keys which are not labelled on any typical keyboard produced in the last 30 years.My Lisp Machine keyboards from the 1980s have Meta,"	lispm	15.105275	-3.9620717	comment	3.0	12.0	1699408386	-10.34858
38215441	Is there a set of code written in a 	Is there a set of code written in a subset of Common Lisp which implements the parts of Common Lisp not currently part of this Lua+CL ?Since there were many Lisp variants when Common Lisp first came out, there ought to be a lot code created when trying to first get compatibility working. How much of that historic code is available now ?	whitten	15.13358	-3.9499376	comment	3.0	10.0	1699594659	-10.292633
38272806	> I used an S-expression syntax, ins	"> I used an S-expression syntax, instead of designing my own syntax and writing a parser for it.> This meant I was able to experiment with the semantics and virtual machine of the language, instead of worrying over what keyword to use for function definitions.Yeah. I see a lot of people asking why people are so fascinated by lisp and why there are so many lisps out there. I think this is a huge reason. It certainly was for me.I just wanted to get some ideas working as soon as possible. Lisp is the easiest language to parse that I've ever seen, managed to write a parser by hand. And yet it's a fully featured programming language. It just gives you huge power for very low effort. It took a single bit to add metaprogramming to my lisp:  if (function.flags.evaluate_arguments) {
    arguments ="	matheusmoreira	15.114731	-3.9823308	comment	3.0	17.0	1700017278	-10.382649
38304671	> Not everyone likes lisp, not every	> Not everyone likes lisp, not everyone is willing to learn a new strange language for unknown benefits.Im curious why someone would use emacs if they dislike lisp. To me its like writing SPAs without js	medo-bear	15.109363	-3.9639955	comment	3.0	11.0	1700234070	-10.400821
38319676	Emacs Lisp is nobody’s favorite lisp	Emacs Lisp is nobody’s favorite lisp, yet it is the most widely used lisp by a wide margin.Emacs proves that having a free and open source cross platform GUI editor where you can introspect and modify the editor’s state, and where a visual step debugger and lots of documentation are available, far outweigh the niceties that other lisps provide.	BaculumMeumEst	15.07851	-3.9746406	comment	3.0	18.0	1700316066	-10.366225
38333532	From the linked article:> Lisp is th	From the linked article:> Lisp is the language that comes most natural to me, I'm most productive with, and gives me joy and not just funCan you elaborate on why please? It feels relevant to this article.	cantSpellSober	15.143611	-3.9474566	comment	3.0	10.0	1700407819	-10.463948
38365446	> But is there is something inherent	"> But is there is something inherent to Lisp that makes it ""clunky"" to work with matrices?s-exps are basically coding at the level of the AST, which for many programming tasks is a powerful level of both abstraction and control.But this interface tends to work much better on tree-like structures (the most simple of which is the list, which in it's simplest case is a cons cell, Lisp's most fundamental particle).Most programming tasks can boil down to tree manipulation, but large matrices feel a bit out of place with this interface because you are basically to working with arrays (which in it's simplest cases is a pointer to a memory address, which is C's fundamental particle). C like languages (I know, technical ALGO-like), tend to feel more natural for these tasks.But of course if you can "	IKantRead	15.132637	-3.9605753	comment	3.0	12.0	1700582462	-10.457531
38399899	I think people came to the conclusio	I think people came to the conclusion in the mid 1980s that you couldn’t really get ahead with a specialized “LISP machine” compared to an advanced general purpose processor, particularly when you put caching, pipelining and superscalarity into the mix.The genius of Common LISP was it had mechanical sympathy for the forthcoming ‘32-bit’ computers .  Java was very much inspired by the CL spec defining a rich, efficient and implementable memory managed VM you could build over general purpose hardware with a lot of room for optimization and documenting that system very well.	PaulHoule	15.135018	-3.9419117	comment	3.0	18.0	1700790311	-10.375343
38400185	The Conrad Barski lisp book used pic	The Conrad Barski lisp book used pictures of sheep and wolves to describe Scheme, Lisp, and Haskell iirc. Also cavemen to describe Fortran I think lol. I think he was trying to show scheme as being more elegant than common lisp, but also significantly less practical.	7thaccount	15.136183	-3.9473495	comment	3.0	13.0	1700793912	-10.421344
38402513	> Developers from Fuji Xerox wrote a	"> Developers from Fuji Xerox wrote a portable VM in C to run the environment on different host platforms, called Maiko.I'm always confused by the relationship of C and Lisp(s). Here the VM is written in C. Yet elsewhere there seem to be at least one good example of a Lisp compiler written in Lisp [0]. What was the reason for writing Maiko in C, versus Lisp ""all the way""?[0] ""The first complete Lisp compiler, written in Lisp, was implemented in 1962 by Tim Hart and Mike Levin at MIT, and could be compiled by simply having an existing LISP interpreter interpret the compiler code, producing machine code output able to be executed at a 40-fold improvement in speed over that of the interpreter.[19] This compiler introduced the Lisp model of incremental compilation, in which compiled and interpr"	uticus	15.133685	-3.956033	comment	3.0	22.0	1700822312	-10.413321
38449905	We’ve had Lisp for 60 years, but ins	We’ve had Lisp for 60 years, but instead of using that, we’re going to have LLMs write the boilerplate for us.You will still have to read the boilerplate of course.	cgdub	15.148565	-3.9366853	comment	3.0	16.0	1701198708	-10.468839
38509922	I'm not a fan of the parenthesis eit	I'm not a fan of the parenthesis either, but when I learned about s-expressions and how lisp programs are also a data structures that piqued my interest and helped me look past them.I question people's judgement who can't look past the syntax when there is a very good, and interesting technical reason behind them.	CooCooCaCha	15.06996	-4.0181236	comment	3.0	13.0	1701631629	-10.307309
26832789	I used to work at an AI firm that us	I used to work at an AI firm that used it. Large Lisp codebases are a minefield with near impossible security and debugging issues. I still love it as a programming language tho.	fidesomnes	15.13876	-3.9406188	comment	3.0	16.0	1618574355	-10.461056
26833384	> Highly recommend Lisp for Web Deve	> Highly recommend Lisp for Web Development, its much, much better than any of the other frameworks out there!Could you elaborate a bit on this? I've never written a single line of Lisp so I get a bit curious.	manjana	15.134861	-3.950162	comment	3.0	10.0	1618578403	-10.427305
26864217	Serial experiments lain is my favori	Serial experiments lain is my favorite anime of all time. I'm shocked at hoe obscure it continues to be, even in hacker circles.I figured that coding in lisp is all she needed for the show to become a cult classic - but here we are...	Der_Einzige	15.140209	-3.9353518	comment	3.0	14.0	1618847840	3.3272626
27013635	I like Lisp, and I'm not a fan of e.	I like Lisp, and I'm not a fan of e.g. Python's whitespace sensitivity. That said, for niches such as ML and data science, I find you just can't beat the Python ecosystem.	PeterStuer	15.118898	-3.9724038	comment	3.0	47.0	1619947301	-10.391701
27037032	in the 1970s there were two common i	"in the 1970s there were two common interpreted languages on small-RAM (say 4k) microcomputers and those were BASIC and FORTH; the second of which is almost ""take the parenthesis out of your LISP program, reverse the order of the tokens, and... it works!""By 1980 or so I think there was a LISP for CP/M that fit in a large-memory micro (48k) but it was expensive not that popular.  A LISP runtime could have been an answer to the certifiably inzane segmented memory model of the IBM PC and I know people tried it, but other languages pulled ahead...  In particularly Turbo Pascal and other languages with very fast-compilers and IDE user interfaces ripped off from LISP machines that were about as good as Visual Studio, Eclipse, IntelliJ are today -- only the PC versions were much much faster than t"	PaulHoule	15.120518	-3.9570706	comment	3.0	23.0	1620132900	-10.395687
27046991	Note that this is not Lisp interpret	Note that this is not Lisp interpreted in Python, but transpiled into Python AST on the fly. Which is how Lisps should be implemented on top of modern environments.(IIRC the ‘gisp’ project takes that approach even further: it transpiles a Lisp to the AST, and then spits out Go code that would generate the same AST: https://github.com/jcla1/gisp)	aasasd	15.095849	-3.9945674	comment	3.0	15.0	1620198089	-10.183078
27299658	> Turns out S-expressions are just a	> Turns out S-expressions are just a Really Good Idea (tm). That's why people keep reinventing them over and over.In the age of multicore, the perception that everything is a list which lends to sequential processing it makes lists actually less appealing.	jhoechtl	15.087918	-4.0110826	comment	3.0	11.0	1622092806	-10.311292
27309907	"To those who find ""that all those br"	"To those who find ""that all those brackets in Lisp were off-putting and weird"", look no further than C++:    [](){}

is valid syntax for a lambda. (I think in C++20 you can also stick in < > somewhere in between.)Lisp's S-expressions are just acquired taste (like coffee of a particular blend)."	Koshkin	15.082311	-4.018398	comment	3.0	11.0	1622158307	-10.361883
27310209	I maintain that the problem with Lis	I maintain that the problem with Lisp for most programmers coming from C-like languages is not the parentheses.It's the fact that lisp style is heavily oriented around expressions (since almost everything is an expression) which leads to a lot of nesting and a functional style, rather than a block-oriented imperative style.	fungiblecog	15.103675	-3.9924705	comment	3.0	10.0	1622160522	-10.383035
27311096	Is this really about syntax? I think	Is this really about syntax? I think this is about homoiconicity. But homoiconicity is NOT the same thing as parenthesis, (or brackets as here)! Homoiconicity is not a (concrete) syntax issue, it's an AST and semantics issue in my view.Why are we so hung up on the superficial details of the syntax. Can't we just have an AST spec with bijective mappings between different human presentations? Editors already do color coding for us and people use different fonts for their code, but flamewars about what colors and fonts are quite rare. I don't see this as anything fundamentally different.Is it somehow difficult to accept that different syntax may map to identical AST? Lisp is intentionally syntactically very close to its AST and I find this elegant. But why are we so hung up that the human int	jampekka	15.085206	-4.0051255	comment	3.0	18.0	1622168771	-10.332811
27311395	What I like about Lisp's syntax is t	"What I like about Lisp's syntax is that the cursor (point) is always in a complete Lisp program. You move up one set of parenthesis, again a complete program. Move up further .... till you reach the top (file-level).So this gives good opportunity to Editor makers. Compile ""this"" level, 1-level-up, 2-level-up and so on. In an editor you can always check your program while coding.Example is Cider package for Emacs for Clojure programming language."	jangid	15.100837	-3.9823463	comment	3.0	19.0	1622172150	-10.370195
27452967	To me, the specialness of LISPs come	To me, the specialness of LISPs comes from the uniformity of the syntax (which in turn makes code easier to understand and reason about). This is probably highly subjective!That said, SICP is unreasonably excellent :)	amackera	15.136554	-3.950881	comment	3.0	13.0	1623271394	-10.490647
33463478	Why not Lisp? I never understood why	Why not Lisp? I never understood why would people need any other programming/query/markup language syntaxes in the first place. The only part of Lisp that seems ugly are the ending  stacks of closing parentheses at the ends of big code blocks.	qwerty456127	15.106123	-3.9828913	comment	3.0	12.0	1667550317	-10.381303
33463177	Because Lisp gives you all of these 	Because Lisp gives you all of these things.  Functional programming.  Fast development.  Incremental compilation.  Interactive debugging.But the main thing Lisp gives you is almost unlimited malleability.  If there is ever anything in the language you don't like, you can change it.It also gives you generic functions and the ability to redefine classes in a live system.  No other language has those features.	lisper	15.126105	-3.9622583	comment	3.0	19.0	1667546604	-10.422748
33491101	Hello guys, it's my first time posti	"Hello guys, it's my first time posting here !Actually, I'm passionate about Lisp dialects, I always been fascinated by languages, when I was a kid, I used to try to learn new languages (Spanish, Brazilian Portuguese, ...).When I was 15, I found out I had a leukemia, a severe form of blood cancer, I had so much free time that I decided to learn programming languages.
It was really like a revival, the idea that you can express every ideas into code was mind blowing and a cure for me.
I really have a special relationship with programming languages.Now that I finished my studies at 42 school in Paris and that I have more free times, I can concentrate on what I dreamed to do.One day, I read the Unicorn Project by Gene Kim and discovered Clojure, which is a dialect of Lisp. I read a lot on the s"	MielPopssss	15.136347	-3.958347	comment	3.0	12.0	1667730391	-10.58431
33521496	Like any language, Lisp has readabil	Like any language, Lisp has readability issues when you’re not familiar with it. You find it hard to read because it’s alien to you. To my eyes – because Lisp is what I’m used to – every non-Lisp language has readability issues. These days I do a significant amount of work in Python, Rust and Julia, and although there are things I love in all of these languages, I always miss s-expression syntax when using them.	Oreb	15.109694	-3.9886408	comment	3.0	22.0	1667927926	-10.419976
33566804	Yes, there is. We moved from ES to V	Yes, there is. We moved from ES to Vespa (vespa.ai) and never looked back. WE got better results, speed and WAY lower maintenance costs. I really don't understand how underrated this project is.	bratao	15.040012	-3.9699638	comment	3.0	10.0	1668200603	-10.426458
33575087	Wonder where hylang would fit in thi	"Wonder where hylang would fit in this classification: exo-lisp, practical-lisp or fluchtpunkt-lisp? I intend to learn lisp, but keep delaying the time investment, waiting for hylang to get a better beginner-friendly tooling setup. So far it seems step 0 in learning hylang (and most lisps) is to learn emacs first, and how to configure it, what causes unecessary friction for would-be apprentices, as this recently asked stackoverflow question shows: https://stackoverflow.com/q/74409462One thing I enjoyed in the smalltalks is that they share a lot of lisp power, but the tooling is more self-contained and integral to most of them, what makes the first steps really easy to take. As Seymour Papert stated the ideal, ""low threshold, no ceiling."""	Qem	15.142012	-3.9433477	comment	3.0	10.0	1668273877	-10.447636
33577417	(Free) LISPs on Linux today look a b	(Free) LISPs on Linux today look a bit rough, is there any implementation that turns Linux into something that has the look and feel of a LISP machine?Parentheses aside, don't expect people to pick up a language if all they can see is a REPL where the only edit operation that works is DEL(ete), at a time when all other languages have graphical IDEs with syntax coloring, context-sensitive help, single-step debugging etc. (and no, I don't mean Emacs).edit: screen shot to support the argument https://en.wikipedia.org/wiki/Steel_Bank_Common_Lisp#/media/...	jll29	15.123253	-3.945473	comment	3.0	11.0	1668289477	-10.393121
33685120	Okay let me get this straight...Are 	"Okay let me get this straight...Are you saying that I don't need to use parenthesis as much in lisp? Instead I could define a few ""reader macros"" and then immediately have a different syntax?Say if I wanted to change    (if (test-clause) (action1)
    (action2))

To    if (test-clause) do (action1)
    else (action2)


Is this actually possible inline in lisp, meaning I just need to import a library that implements the if-reader-macro?"	vitiral	15.069924	-4.026132	comment	3.0	10.0	1668977329	-10.353079
33722034	Yup, I would love to see a bit more 	Yup, I would love to see a bit more love for Lisp style languages. They're incredibly powerful and it's a shame they're relegated to the fringes of professional programming.	falcolas	15.132278	-3.951384	comment	3.0	35.0	1669224455	-10.467549
33725015	Lisp evolved into ML and Haskell and	Lisp evolved into ML and Haskell and these have influenced professional programming enormously over the last few decades. Or are you advocating we ditch all progress and go back to Lisp? Have you tried an ML such as OCaml? It has built-in cons lists, convenient symbol manipulation and macros.	grumpyprole	15.127326	-3.9712377	comment	3.0	25.0	1669240461	-10.489663
33726718	Frankly, yes, I wouldn't mind going 	"Frankly, yes, I wouldn't mind going back to boring old lisp. Particularly when confronted with Java or Javascript. I also have no real desire to dive into strongly typed functional languages - see the ""dynamic"" part of the original title.And all of those modern functional languages are as fringe (or even more fringe) than Lisp is. I wish this wasn't the case, but let's be honest: programming languages that appeal to mainstream developers and companies will always optimize for development teams of wildly varying skill."	falcolas	15.128046	-3.967829	comment	3.0	15.0	1669252497	-10.455068
33742144	> That ela/apply function is actuall	"> That ela/apply function is actually reduce.I feel it is fair to call out ELisp as the problem here; there are a lot of operations (reduce is a good example) where it is unclear how the programmer is meant to discover the name they want. It is unusual to see a good resource that explains how programmers are meant to use lists, and if someone comes in from an imperative language then the need to find a resource on transforming lists is unclear.Emacs is particularly bad because they have that weird dialect of lisp that didn't catch on anywhere, so you can't use generic tutorials and nobody teaches it. And as I recall there is no neat introductory resource explaining ""how to manipulate lists in Elisp"".So it is true that he has reinvented a bad reduce, but also true that this is a celebration"	roenxi	15.102089	-3.9929583	comment	3.0	12.0	1669382732	12.975473
33852852	Because I want to follow my vision. 	Because I want to follow my vision. There is space for more than one thing in the world. Also, Common Lisp is nice but it's anything but minimal. One of the questions I want to answer is what is the minimum amount of constructs you need to have complete control over your hardware, while able to rewrite the entire kernel at run time. I bet it's not that many.That said, Mezzano is cool and I should play with it more.	sph	15.102666	-3.9384966	comment	3.0	15.0	1670155074	-10.2877445
33918850	Is there something similar for Commo	Is there something similar for Common Lisp?	ducktective	15.145679	-3.9331226	comment	3.0	12.0	1670573031	-10.465145
34025608	Those parentheticals can be rewritte	Those parentheticals can be rewritten with commas, which sent me on an exploratory tangent trying to see if one could use commas instead of parens in Lisp.	sph	15.099508	-3.99281	comment	3.0	10.0	1671261458	-10.298454
22749568	Nitpick:> While Common Lisp calls th	"Nitpick:> While Common Lisp calls them “conditions”, I will stick with “error” in this post, because I don’t think “condition” is very self-explanatory if you’re not familiar with the language already. Please forgive my inaccuracy.This is misleading. It is possible to signal conditions that are not errors, and therefore do not require stack unwinding, like errors do. The condition facility allows one to execute arbitrary code with arbitrary arguments at the SIGNAL site.`SIGNAL` walks the list of condition handlers and executes the type-matching ones in order of their binding. If a handler returns normally, then next ones are executed; if all matching handlers are exhausted, `SIGNAL` returns, and code execution continues.    CL-USER> (handler-bind ((condition (lambda (c) (format t "";; Foo: "	phoe-krk	15.085038	-4.009715	comment	3.0	10.0	1585754420	-10.305566
22821288	Why would a language where it is pos	Why would a language where it is possible to manipulate certain functions to get their derivatives require a new revision control system or IDE?And speaking of Lisp - wasn't symbolic differentiation a fairly common thing in Lisp? (basically as a neat example of what you can do once your code is easy to manipulate as data).	arethuza	15.12845	-3.9633553	comment	3.0	22.0	1586429059	9.468628
22822727	> I don't get this perspective, are 	> I don't get this perspective, are there only three good features invented every decade?To be honest, programming language design has been a solved problem since the 1950s when LISP came out.	mseepgood	15.122827	-3.966711	comment	3.0	14.0	1586441768	-10.33855
17866325	See also the FRL (Frame Representati	See also the FRL (Frame Representation Language) Primer from 1977:https://dspace.mit.edu/handle/1721.1/5767There is also a manual:https://dspace.mit.edu/handle/1721.1/5768FRL was probably the first language to explore the Frame ideas in the context for programming.The old Lisp-based implementation of FRL: https://github.com/lispm/FRLIt won't run under a current Lisp, though.	lispm	15.069247	-4.010704	comment	3.0	12.0	1535526946	-10.313064
17959032	Lots of Lisp interest today! Here ar	"Lots of Lisp interest today! Here are a few resources.On Lisp: https://www.lurklurk.org/onlisp/onlisp.pdfLumen - a Lisp for JavaScript and Lua: https://github.com/sctb/lumenThe Art of the Interpeter: https://dspace.mit.edu/bitstream/handle/1721.1/6094/AIM-453....(^ this last one is very practical. If you reach the point of wanting to implement a practical interpreter, this paper will force you to consider many unexpected cases.)Simulating circuits with Lisp: https://mitpress.mit.edu/sites/default/files/sicp/full-text/...My favorite part of SICP: <a href=""https://mit"	shawn	15.100368	-3.9748116	comment	3.0	19.0	1536668591	-10.328278
17961243	‘Most programmers can’t be trusted w	‘Most programmers can’t be trusted with macros’ is a sentiment I read a lot, but at one point in time people might have said the same about functions, and arguably they could say the same about pointers or recursion today.I think that being able to think symbolically about one’s code is a vital skill for a programmer (and, more generally, that the capability of thinking abstractly is a vital skill for a learnéd human being).  Thus, if someone lacks that skill, perhaps he should probably not be a programmer?  That may sound revolutionary, or elitist, but I think most of us would agree that someone who can’t effectively reason about a depth-first tree traversal will have trouble as a professional software developer; mayn’t that also be the same of someone who can’t effectively reason about c	rauhl	15.11353	-3.9867198	comment	3.0	14.0	1536683741	-10.371795
18956215	Lisp is the canary in the mind shaft	"Lisp is the canary in the mind shaft.All programming languages have a bracket problem; Lisp just has a more intense bracket problem. Until the recent advent of 4K and ""retina"" displays, it wasn't practical to have significant weight variations in screen fonts for programming. It's now practical, and it's easy in font editors such as Glyphs Mini to swap in or modify brackets to be a lighter weight.I've made many Lisp coding experiments: with preprocessors that eliminate most parentheses, with alternate symbols, and with various weights and sizes of parentheses. There's something to be said for the theory that parentheses should be lower case, just like identifiers. (I'm reminded of the ""GET OFF MY LAWN"" effect in Common Lisp; one can shut off the upper case defaults but most people don't st"	Syzygies	15.093917	-4.0052004	comment	3.0	23.0	1548025805	-10.278046
18959650	I'd guess that most people who value	I'd guess that most people who value typographic nuance and clarity find Lisp's lack of concessions to syntax makes reading code an extremely clunky experience. I think Lisp's (lack of) syntax adds up to a set of tradeoffs that actively repels visual thinkers/typography folks, compared to Miranda-style syntax.NB Haskell folks are not any more likely than Lispers to think visually. A lot of Haskell code is difficult to read. But it does feel like the Miranda-style syntax (particularly pattern matching) has made the first few steps towards eliminating unnecessary structure-related cognitive load on the programmer.Lisp partisans will probably reject this opinion, but IMO the presence of strings of matching parens in Lisp isn't something that needs to be restyled with a better font, it's somet	theoh	15.122658	-3.9780955	comment	3.0	13.0	1548070825	-10.372812
18960165	Scheme is a stunningly beautiful lan	"Scheme is a stunningly beautiful language with inferred parentheses:    define | edge? g e
      let
        $ es | edges g
          e2 | reverse e
        or (member e es) (member e2 es)

I used to rely on a preprocessor that translates back and forth to standard Scheme:    (define (edge? g e)
      (let
        ( (es (edges g))
          (e2 (reverse e)))
        (or (member e es) (member e2 es))))

One gives up being able to use standard tools. For Emacs or Vim, one can write one's own tools, but it's nice to be able to try out everyone else's work first.The central question for any programming language isn't how comfortably it welcomes casual newcomers; it's how effectively it creates a human:machine interface for the committed. Most criticisms of how Lisp looks can be likened to crit"	Syzygies	15.108943	-3.9903111	comment	3.0	10.0	1548076699	-10.378971
19025024	it's the architecture of the origina	it's the architecture of the original lisp machine from which all other lisp machines (arguably) derive, mit's CADR. there's not many of them built, since it was made by hand wiring, but there's still one or two around in a working state.for reference here's the ai memo write up of the project http://dspace.mit.edu/handle/1721.1/5718 dated 1979, which should place it in a historic context for you	ta12812	15.14585	-3.9371145	comment	3.0	10.0	1548754421	-10.434786
19044040	Shameless smuglispweeniesm: Rigetti 	Shameless smuglispweeniesm: Rigetti is one of the companies using Common Lisp in their research and development.https://www.youtube.com/watch?v=f9vRcSAneiw	phoe-krk	15.151277	-3.9360998	comment	3.0	11.0	1548934074	-10.453767
19102033	I said the same thing in my comment.	I said the same thing in my comment. You get max productivity with selective use. Nine times out of 10 you don't need them. Overuse of them led to LISP code being hard to read like you said. We don't need to repeat mistakes of history. So, I said add them with a warning to minimize them for maintainability if language is trying to be like Go.On the other hand, they should be most of the code if taking a DSL- or MOP-like approach. The people using those will be very familiar with the higher-level language. There's a solid, lower-level language underneath for when the VHLL's don't work out. The macros help there.	nickpsecurity	15.117092	-3.9818819	comment	3.0	14.0	1549502171	-10.358774
19110709	> My belief is that we've been slowl	> My belief is that we've been slowly building up to using general purpose languages, one small step at a time, throughout the infrastructure as code, DevOps, and SRE journeys this past 10 years.I think that you’re right, and I think it’s great, because we have a programming model in which code is data and data is code: Lisp & S-expressions.It’d be downright awesome to have a Lisp-based system which used dynamic scoping to meld geographical & environmental (e.g. production/development) configuration items.  But then, it’d be downright awesome if the world had seriously picked up Lisp in the 80s & 90s, and had spent the last twenty years innovating, rather than reïnventing the wheel, only this time square-shaped.  But then, the same thing could be said about Plan 9 …I’ve not yet had the tim	rauhl	15.130218	-3.953024	comment	3.0	16.0	1549590951	-10.468178
19127128	Was it ever implemented? Are there a	Was it ever implemented? Are there any usable (at least working in a VM with networking) Lisp OSes out there?	d33	15.133517	-3.9416387	comment	3.0	31.0	1549792852	-10.423218
19127466	I install and experiment with Mezzan	I install and experiment with Mezzano once or twice a year. Very cool project.I liked most of the LispOS paper. One point of disagreement is planning for multi-user capability. I don’t think a LispOS based system would ever be more than a personal and highly customizable workspace. I would never expect to fire up a VPS on AWS or GCP and see a LispOS option next to Linux, BSD, etc.I used a Xerox 1108 Lisp Machine from 1982 to about 1986. I stopped using it and gave it to someone else in my company when I was able to port the ISI Grapher to Coral Common Lisp on my Mac and thereby was able to port most of my code over.To be clear, I moved off of the 1108 only because the hardware had become outdated and it ran too slowly. Otherwise I was very happy with a single user all Lisp work environment	mark_l_watson	15.132187	-3.938509	comment	3.0	13.0	1549800342	-10.312223
19172106	I don't think it's Lisp envy. They'r	I don't think it's Lisp envy. They're porting stuff from F#, which as far as I know is from the ML family.	oblio	15.153775	-3.9349174	comment	3.0	12.0	1550247767	-10.477794
19178437	>Nobody would call a python-like lan	">Nobody would call a python-like language ""a python""Unlike Python, Lisp is not ""batteries included"". The original and standard definition of Lisp is the handful of special forms in McCarthy's paper.Dev didn't say they made a Common Lisp -- just a Lisp."	coldtea	15.11784	-3.9750595	comment	3.0	13.0	1550323192	-10.338658
19232946	In LISP-like languages like Racket, 	In LISP-like languages like Racket, the code is a list. That is, a program is just a list of tokens (a b c), the same data structure one would use for storing any other kind of data (the equivalent of Python’s [a b c]). When programs are themselves just lists, they are easy to manipulate with code. So, in LISP-like languages, it is easy to write code that writes code. That makes them especially suitable for domain-specific languages or LOP. You can write functions that write code, making a new language.I think PG has some writings on this topic, but I don’t remember if it is online or in his LISP textbooks. His company Viaweb did this, IIRC, using a DSL written in LISP to generate HTML.	pge	15.109089	-3.9799821	comment	3.0	12.0	1550923685	-10.416799
19244622	> Another thing that's driving me cr	"> Another thing that's driving me crazy is case insensitivity. I would never
  willfully choose a language with case insensitive identifiers. It's driving
  me nuts.What about it annoys you? Do you often define a lot of variables whose names
differ only by case, in languages that let you? Common Lisp normally behaves
as though it were case insensitive, and I've never found that to be a pain
point."	kbp	15.1139	-3.9816957	comment	3.0	17.0	1551091654	-10.411575
19271668	I'm currently working through the im	I'm currently working through the implementation of my own personal Lisp, following the awesome MAL process [0]. It's instructive to compare the result with the language as defined in the early 60s and available to programmers then (e.g. as defined by the Lisp manual referenced in the video). One thing that immediately stood out was the use of GOTO ('GO' actually) in the early Lisp rather than some sort of loop or tail recursion.Incidentally, I've been wondering what app I should write to test my Lisp. The obvious end-state mentioned in the MAL guide is to self-host a Lisp, but I'm thinking it would be more appropriate (and fun) to re-implement one of the early chatbots like ELIZA [1].[0] https://github.com/kanaka/mal/blob/master/process/guide.md[1] https://en.wikipedia.org/wiki/ELIZA	KineticLensman	15.145476	-3.941485	comment	3.0	16.0	1551365708	-10.376269
19277542	Much of Emacs is written in its own 	Much of Emacs is written in its own version of Lisp. There has been some effort to use Scheme, using GNU Guilehttps://www.emacswiki.org/emacs/GuileEmacsEmacs with a better Lisp option would be a big improvement. With a faster Lisp, perhaps less of Emacs would need to be written in C/Rust.	melling	15.1158085	-3.9569445	comment	3.0	23.0	1551408510	-10.396619
19277760	What would make most sense is just t	What would make most sense is just to have it Lisp all the way down. SBCL, top to bottom!	girzel	15.157611	-3.9302156	comment	3.0	17.0	1551411932	-10.466502
15757121	No true Scotsman would ever write ma	"No true Scotsman would ever write macros in such a confusing manner!But really, this is a recognized problem of Lisp, and has been called the Lisp Curse. [0] One is never programming in ""just Lisp"", but rather in Lisp plus some half-baked DSL haphazardly created by whoever wrote the program in the first place.Also, don't confuse readability with understanding. Yes, DSLs are typically easier to read, but only after you come to understand the primitives of the language. When every program has its own DSL with its own primitives, even programs that do similar things... That becomes quite a burden.[0] http://www.winestockwebdesign.com/Essays/Lisp_Curse.html"	jdmichal	15.094813	-3.994652	comment	3.0	14.0	1511362228	-10.222646
15757131	Isn't loop essentially a macro (prob	Isn't loop essentially a macro (probably special op) that a lot of people hate, specifically because it is a sprawling dsl? Because lisp has an expressive macro system, it can lead people to that. The existence of macros requires an at least above average dev community, because it's one thing when a decently-designed but controversial dsl like loop is default to the language, it's another when every project can roll out their own poorly considered and implemented dsls using macros when simpler abstractions would have sufficed.Most lisp docs will tell you to use macros only when necessary, because as great as they are, they have inherent issues that aren't fixed just by having a good macro system.This is bad use of macros, or an ugly macro system.No true scotsman?	aaron-lebo	15.083861	-4.0138392	comment	3.0	12.0	1511362275	-10.359989
15782493	The author isn't responsible if peop	The author isn't responsible if people read it and think it's how they should be writing C, especially when the objective of writing lisp in as little C as possible is communicated.So why is it fair to label it irresponsible?	ac2u	15.139286	-3.955042	comment	3.0	10.0	1511724159	-10.417853
15788623	Regarding lisp, he made a post about	"Regarding lisp, he made a post about language choice here: https://news.ycombinator.com/item?id=1803815I think Lisp still has an edge for larger projects and for applications where the speed of the compiled code is important. But Python has the edge (with a large number of students) when the main goal is communication, not programming per se.
In terms of programming-in-the-large, at Google and elsewhere, I think that language choice is not as important as all the other choices: if you have the right overall architecture, the right team of programmers, the right development process that allows for rapid development with continuous improvement, then many languages will work for you; if you don't have those things you're in trouble regardless of your language choice. "	strong_silent_t	15.123827	-3.9697003	comment	3.0	13.0	1511800831	-10.377175
15882455	>Lisp seems to take the exact opposi	>Lisp seems to take the exact opposite approach as Go. The power of languages like Lisp appeal to me, so I have a hard time understanding why people want a language that intentionally limits itself.Me too.I don't understand how people in HN vouch for restrictive languages.	flavio81	15.12976	-3.9648616	comment	3.0	15.0	1512770561	10.210574
15882605	Code as data is such a big deal that	Code as data is such a big deal that - whatever you say - I will never ever understand why we don't all do Lisps.	patkai	15.116458	-3.975252	comment	3.0	38.0	1512771797	-10.40562
15882846	The problem for me is that I've lear	"The problem for me is that I've learned to avoid macros in other languages. It seems to me that when you've got a fairly complex program, you need a fairly complex mental model of what the program ""is"" to understand it. But if you introduce macros, or code writing code, then you have a much more complex mental model since now even what the code ""is"" can change. What is it about lisp that makes this an easier sell?"	tunesmith	15.116424	-3.9802837	comment	3.0	10.0	1512773727	-10.38599
16006960	Lisps are arbitrarily powerful, yes,	"Lisps are arbitrarily powerful, yes, sure. Once I too was a Lisp head, I am familiar with the advocacy.They also read awfully even with an editor designed for them. They aren't human-first languages. S-expressions are easy for a computer, they are hard for a human. So, yeah, that can be improved, too. ""But you can do it with macros""--other people won't, and so you are thus devolved to the minimum set everyone can agree upon, and it's gonna be awful.And so there is room to grow outside of one's parentheses, too."	eropple	15.10442	-3.9917037	comment	3.0	11.0	1514260086	-10.350362
16069490	> And one of the very best: Lisp.Got	> And one of the very best: Lisp.Got any hard numbers to back up that bold claim?	oblio	15.153579	-3.9320312	comment	3.0	13.0	1515064954	-10.448299
16080081	> Note that Common Lisp has type dec	> Note that Common Lisp has type declarations, which can move type errors from run-time to compile-time.This is a dangerous assumption. The standard does not require that Common Lisp type declarations cause the compiler to detect type inconsistencies (although some implementations might be smart enough to do so in some cases). CL type declarations tell the compiler it can remove runtime checks. They are performance optimizations. If anything they decrease type safety.	dreamcompiler	15.099337	-3.993734	comment	3.0	13.0	1515173940	-10.217817
16860646	Running Lisp in Production (2015)	Running Lisp in Production (2015)	tosh	15.1383095	-3.9420078	story	3.0	138.0	1523987541	6.493825
16899175	Not a very unique style as claimed t	Not a very unique style as claimed though. Common Lisp implementations often have a very full featured debugger coupled with conditional restarts the experience is awesome and really should be a preresquite for any dynamic language to be called fit for serious application. Unfortunately it is often absent	Guthur	15.090865	-3.9825735	comment	3.0	21.0	1524438156	-10.375102
16899412	Not related to your point, but I do 	"Not related to your point, but I do think it's entertaining that every time I post something about programming languages, there is always at least one person who says ""Lisp already solved it!"" [1] [2][1] https://news.ycombinator.com/item?id=16726379[2] https://news.ycombinator.com/item?id=12221818"	wcrichton	15.134937	-3.9529607	comment	3.0	18.0	1524441321	-10.46654
16922915	Yeah, this applies to all that old L	Yeah, this applies to all that old Lisp features.	stiGGG	15.147346	-3.9387121	comment	3.0	13.0	1524672457	-10.472629
16934388	Reading some of the replies that int	"Reading some of the replies that interpret pg's essay as talking about ""libraries"" or ""frameworks"" or ""metaprogramming"" doesn't look quite right to me.I argue that instead of those 3, the most applicable terminology to map to pg's idea would be a ""DSL"" (""Domain Specific Language"".)[1]  The ""DSL"" terminology seemed to have gained currency around 2008 so this old 1993 essay wasn't able to use it.  In any case, his point is to program Lisp in such a way as to build a ""DSL"" inside of Lisp and you then program your higher level concepts on that DSL.  His key quotes:>a principle which could be called bottom-up design-- changing the language to suit the problem. In Lisp, you don't just write your program down toward the language, you also build the language up toward your program.>Instead of a si"	jasode	15.120674	-3.968333	comment	3.0	21.0	1524767832	-10.315439
16943933	My biggest complaint about lisp (whi	My biggest complaint about lisp (which I love dearly) is that the overwhelming majority of the lisp community (or lisp communities) have already settled on Emacs as the obvious choice in editors.  And for good reason, the emacs tooling is unparalleled.   And because everybody is using Emacs, non-emacs tools are neglected at best.  It seems quite common for stand-alone REPL's (let alone extensions for other editors) to be neglected and shoddy because everybody influential in the language's development are already using emacs and have no use for a stand alone REPL.It's great for people who already use Emacs.  But a lot of people have deep personal investment in other editors because they got started years ago programming in some non-lisp language for which Emacs was virtually a footnote.  An	JackCh	15.078499	-3.9800353	comment	3.0	13.0	1524860170	-10.420495
17028357	Scheme is a Lisp like language, not 	Scheme is a Lisp like language, not a Lisp.Parenthesis is probably the only thing they have in common.	pjmlp	15.120306	-3.9682064	comment	3.0	19.0	1525856259	-10.416276
17042359	{by whom}Not by me. I'm a skilled Li	"{by whom}Not by me. I'm a skilled Lisp programmer, yet Scheme isn't usable to me a the rudimentary coding level using the core language. There are stumbling blocks at every turn against straightforward Lisp coding. How can it be a Lisp?I can't even rely on Scheme to evaluate the function arguments left to right. Many forms have an ""undefined"" return value; in Lisp, everything returns a defined value, as a fundamental tenet! Remember Alan Perlis: ""Lisp programmers know the value of everything, but the cost of nothing."" Well, Scheme programmers do not in fact know the value of everything; it is often undefined! Might Scheme not be a dialect of C, in fact? The expression f(i++, i++) is directly translatable from C to Scheme, undefinedness of behavior intact!""Lisp"" has to do with the little de"	kazinator	15.13929	-3.9533792	comment	3.0	18.0	1525981724	-10.44311
17117392	Would appreciate if the reverse (Lis	Would appreciate if the reverse (Lisp for python programmer) exists.	a_c	15.102142	-3.989319	comment	3.0	13.0	1526899425	-10.261009
17117664	I like how code in both Python and L	"I like how code in both Python and Lisp can often look similar despite different syntaxes, different conventions, and different philosophies.Here is a toy example of file I/O in Python 3:  with open('foo.txt', 'w') as f:
      print('hello, world', file=f)

  with open('foo.txt') as f:
      print(f.readline())

Here is a similar example in Common Lisp:  (with-open-file (f ""foo.txt"" :direction :output :if-exists :supersede)
    (format f ""hello, world~%""))

  (with-open-file (f ""foo.txt"")
    (format t ""~a~%"" (read-line f)))

This example is a bit contrived to show the similarities. Real and idiomatic code may not look so strikingly similar. But similarities in concepts, constructs, and structure of code emerge in both languages. In fact the article mentions, ""Take a Lisp program, indent i"	susam	15.105841	-3.9914503	comment	3.0	32.0	1526903328	-10.3290825
17121614	One of my favorite languages, pity t	One of my favorite languages, pity that is has had even harder time than Lisp getting mainstream acceptance.	pjmlp	15.135381	-3.9510403	comment	3.0	70.0	1526934947	-10.445343
17143412	A. Using Lisp with a couple of minor	A. Using Lisp with a couple of minor convenience macros can be a very good idea.Z. Writing an entire language and ecosystem just for a game is insane.These are not binary choices:  there is a very smooth continuum between these two, and is one of the major advantages of Lisp.   Naughty Dog just took too many steps from A towards Z.   Each step probably seemed reasonable at the time...	bryanlarsen	15.1284075	-3.9672387	comment	3.0	11.0	1527166164	-10.401846
17165301	I'd be interested in seeing Ruby-FFI	I'd be interested in seeing Ruby-FFI, CPython, CFFI (Common Lisp) and C#'s DllImport.	vortico	15.121945	-3.9556613	comment	3.0	10.0	1527391576	-10.443123
21007578	Common Lisp: The Connection Machine 	Common Lisp: The Connection Machine (Thinking Machines Corp) used a variant called *Lisp.  I wonder if that was an influence?http://www.softwarepreservation.net/projects/LISP/starlisp/s...	imglorp	15.145317	-3.9386322	comment	3.0	10.0	1568826985	-10.435222
21104869	Interesting. I suppose you use it fo	Interesting. I suppose you use it for servers and you don't deploy SBCL to end-user machines?	cheez	15.124072	-3.9397306	comment	3.0	15.0	1569727960	-10.343019
21105394	Still I think it could be much bette	Still I think it could be much better with the graphical tooling of the surviving commercial Lisps.	pjmlp	15.1540785	-3.9336936	comment	3.0	17.0	1569736933	-10.460501
21134724	#Script Lisp	#Script Lisp	mythz	15.1397505	-3.9450898	story	3.0	88.0	1570009193	-10.336198
21147952	Oleg has worked in other non-Lisp la	Oleg has worked in other non-Lisp languages, notably members of the ML family. I know that you want to be all pro-Lisp and such, but it's just another family of languages, really; there's nothing magical or special about them. All compilers use an anamorphic parser, a hylomorphic reducer, a paramorphic optimizer, and a katamorphic instruction selector.It's not about what the language provides, but about what the language doesn't require. Lisps can be low-ceremony, but they're not the only ones. Trees might be universal data structures, but they're not the only ones.	lidHanteyk	15.13685	-3.956948	comment	3.0	12.0	1570115579	-10.460049
21148616	You're still thinking of languages a	"You're still thinking of languages as these huge things that can be offered as products. It's not the way a Lisper thinks about it.> To which I would respond, ""Sounds like you took the long way to implementing a library.""And I'd respond, that library is the language. There's a spectrum of complexity of what you can call ""a language"". General-purpose programming languages like you seem to be considering are one end of that spectrum. The other end of that spectrum are the abstraction layers and APIs you're coding to. Take e.g. OpenGL API - you can view it as a set of functions, but once you consider the rules about calling them, you may as well call that a language.So when you're designing a ""DSL"" in a Lisp, it's literally no different than designing any other module. You have to name things"	TeMPOraL	15.116865	-3.9776337	comment	3.0	17.0	1570119023	-10.233394
22861327	Learn LISP/Scheme and lots of fundam	Learn LISP/Scheme and lots of fundamental concepts you probably have a feel for, but in a far more profound way:1. First watch the SICP series (https://www.youtube.com/watch?v=-J_xL4IGhJA&list=PLE18841CAB...)2. Then work through the book (https://mitpress.mit.edu/sites/default/files/sicp/full-text/...)If you really do the exercises (an hour here and an hour there), you can feel you brain getting wrapped around many core notions in very illuminating ways.	floathub	15.15125	-3.9319394	comment	3.0	11.0	1586820718	-10.487729
22908478	We're talking about putting the clos	"We're talking about putting the closing brace on the same line of an expression, like this:  int double(int x){
    return x * 2;}

instead of like this:  int double(int x) {
    return x * 2;
  }

In Lisp, you would write that like this:  (defun double (x)
    (* 2 x))

and not this:  (defun double (x)
    (* 2 x)
  )

You can read either with syntax highlighting and the appropriate indentation, but it's much harder to get away with putting the closing brace on the same line in C-like languages because of how few people use something like Smartparens or Paredit and how having multiple kinds of brackets (parens, square brackets, curly braces, and angle brackets) introduces ambiguity."	snazz	15.085557	-4.00757	comment	3.0	11.0	1587224664	-10.352419
22957376	The looks of this makes me want to g	The looks of this makes me want to go back to Lisp.	Koshkin	15.151196	-3.9364967	comment	3.0	10.0	1587657601	-10.456351
23042441	Not OP, but Lisp isn’t really a func	Not OP, but Lisp isn’t really a functional language — it’s a usual language that also has some functional ideas inside. Mutation is common, don’t think Lisp will be a language like Haskell.For resources, I would recommend Practical Common Lisp[0] and PAIP[1].For some modern development practices, the Common Lisp Cookbook[2] is great.[0]: http://www.gigamonkeys.com/book/[1]: https://github.com/norvig/paip-lisp[2]: http://lispcookbook.github.io/cl-cookbook/	pcr910303	15.128403	-3.971107	comment	3.0	16.0	1588344170	-10.465293
23042982	If I may ask, what are the benefits 	If I may ask, what are the benefits of building this app in LispWorks instead of any other implementation (sbcl or else)?	w3mmpp	15.134392	-3.9455745	comment	3.0	16.0	1588346963	-10.426624
23043839	> Lisp isn’t really a functional lan	"> Lisp isn’t really a functional language — it’s a usual language that also has some functional ideas inside.The idea that ""functional language"" means ""purity"" is something that was retconned onto functional programming in the 90s decades after Lisp had defined functional programming to mean programming in terms of expressions that produce values.I like the ML/Miranda/Haskell lineage of languages a lot, but it really bugs me when people in that camp lay claim to some notion of being a ""better"" functional language than the older Lisp family. (Lispers, while smug about many other things, are generally less smug about how ""pure"" their languages' approach to functional programming is.)This is like arguing that Lagavulin isn't ""really"" whiskey because real whiskeys are made in the US from corn "	munificent	15.129861	-3.970883	comment	3.0	10.0	1588351059	-10.47486
23044772	Sounds like lisp is good for a team 	Sounds like lisp is good for a team of size 1, but are there any larger teams using lisp successfully?I've heard theories that lisp teams don't scale well because the language is so customisable that team members have trouble reading each other's code.	klipt	15.13193	-3.951267	comment	3.0	14.0	1588356152	-10.495903
23054905	> I've almost never seen someone lea	> I've almost never seen someone learning the s-expression syntax and afterwards not liking it.I don't particularly like s-expression syntax - I think s-expressions suit the computer at the expense of the programmer, which I think is backwards. I think they're verbose and noisy and that obscures the meaning I want to see in the text as a person. Yes they're easier to parse, but I want to make my life easier, not the computers. And yes they're convenient for metaprogramming but I don't want to optimise for the meta case.A concrete example - I'm very happy working with precedence. I've been doing it since I started school. My five-year-old can understand precedence. Using precedence I can reduce ceremony and noise in my code and allows me to more naturally look at an expression and take in i	chrisseaton	15.090515	-4.0076866	comment	3.0	11.0	1588453649	-10.319374
23068453	You don't need to rewrite packages i	"You don't need to rewrite packages if you have a layer where Emacs Lisp is compiled/interpreted as Common Lisp.You can easily hack the readtable in Lisp, and rewrite Emacs Lisp sexps as Common Lisp sexps.Some interesting things to consider are file-local variables, buffer-local variables, dynamic-scope/lexical-scope, how to handle floating point (-0.0e+NaN in Emacs Lisp, custom floating point rouding modes/traps in SBCL for example), but this looks like a reasonable approach overall.For example (just a draft, this might be incorrect):    USER> (defun make-local-variable (symbol)
            (eval `(define-symbol-macro ,symbol (bvar (quote ,symbol)))))
    MAKE-LOCAL-VARIABLE

    USER> (make-local-variable 'foo)
    FOO

    USER> (macroexpand-all '(list foo))
    (LIST (BVAR 'FOO))
    T
"	junke	15.122031	-3.9691188	comment	3.0	24.0	1588602460	-10.444753
23068496	Emacs contains a quarter million lin	"Emacs contains a quarter million lines of C. What do you do with all the elisp that calls into it? Maybe that could be turned into a ""libemacs"" and used from FFI."	kazinator	15.1119175	-3.9583218	comment	3.0	15.0	1588602663	2.9602077
23087046	It can do absolutely everything lisp	It can do absolutely everything lisp macros can do, with more flexible input syntax, and zero runtime overhead, while being both strongly typed and giving the macro body access to the types(PS: Lisp fanboys downvoting this, how about attempting to make a counterargument instead of just hitting the downvote button?)	TylerE	15.10195	-3.998765	comment	3.0	18.0	1588728395	-10.300824
23133021	There was a tradition of such self-d	There was a tradition of such self-deprecating names for lisp dialects specifically -- an early system called PLANNER had an offshoot which was named CONNIVER, and SCHEME itself was another branch off this tree (originally named SCHEMER, and truncated because the MIT AI lab's homebrew ITS timesharing system limited filenames to six characters). https://en.wikipedia.org/wiki/Scheme_(programming_language)	rst	15.134144	-3.9468703	comment	3.0	17.0	1589122088	-10.432145
23164915	I'm surprised that this didn't bring	"I'm surprised that this didn't bring up Paul Graham's ""Blub"" concept, in which non-Lisp languages are thought to be objectively less powerful than the universal language of Lisp. That's been a lot to blame for the mystical reverence of Lisp in the 21st century. While I'm a Lisp fan myself, and agree that it is more powerful than a lot of mainstream languages, the idea that it is the ""most powerful"" blinds a lot of hard-core Lisp devotees to things like Haskell that are worth exploring as well."	jhbadger	15.142303	-3.9472833	comment	3.0	26.0	1589360114	-10.476536
23164962	1) How is this different from other 	1) How is this different from other Lisps or Schemes?2) When promoting a new programming language, always provide a nontrivial example. Couple of pages of code. Mandelbrot generator, desk calculator, notekeeping app, that sort of thing.	pjc50	15.139089	-3.9524932	comment	3.0	11.0	1589360663	-10.4384
23164973	> but when I try to reason about com	"> but when I try to reason about common subproblems I really have no idea how to map them to something like Lisp. For example how to efficiently implement a message bus with observers that can register for certain events.I think that's a badly posed question. The main benefits of using Lisp are its introspection and interactivity. You can use the REPL to inspect your message bus at runtime, you can modify parts of it as it runs, you can interactively debug errors as they happen, but none of that is directly related to ""how to implement a message bus"".I think that is more of an ADS question that it is a Lisp question; an efficient message bus, no matter whether you implement it in Lisp or in C or in Haskell, needs some synchronization primitives from the programming language core that are l"	phoe-krk	15.135356	-3.9559994	comment	3.0	16.0	1589360780	-10.408172
23166474	I have never minded using a so-calle	I have never minded using a so-called niche language. Since 1982 I have been very fortunate enough to be paid a good fraction of my time for using Common Lisp - I consider this to be largely good luck and I am grateful for how things turned out. I also like Scheme but literally no one has ever paid me for Scheme development. In the USA, we have a saying that “you dance with the person you go to the party with.” My dance partner has been Common Lisp.I still feel like I am still a student. I started to read Let Over Lambda (a reference to closures) a few months ago which has reinforced my realization that there is so much about a programming language that I have used for 38 years that I still want to explore.All that said, I have often totally enjoyed building systems with C/C++, Java, Pytho	mark_l_watson	15.142511	-3.942152	comment	3.0	10.0	1589375041	-10.468227
23166838	I have heard for decades how Lisp is	I have heard for decades how Lisp is transformative, how just having learned it, even if you leave, you will never look at things the same way again.  Like having served in the Armed Forces.Every so often I get interested in Lisp, but I always run up against the same conflicts.  I look for something that I can run in Windows that has a reasonable set of libraries and then immediately stumble upon the Crusades.  You know, the religious wars you saw with emacs vs vi, wars that used to be fought over various Linux distros and window managers, that you will now see about different flavors of agile or whatever.  I am quite sure that there are religious wars being fought in the territories of Javascript frameworks that I've never heard of.  These wars so often seem to leave the territories barre	at_a_remove	15.12942	-3.961404	comment	3.0	29.0	1589377688	-10.471465
23165914	A lot of people, including some prom	"A lot of people, including some prominent faces in the programming world in general, have been writing about Lisp as secret sauce, silver bullet, God's language, source of programming enlightenment, yadda yadda; basically a set of mystic-sounding buzzwords that, other than causing some people to indeed try Lisp, have left a lot of people confused and amused by the wording - or just plain angry and disappointed at the false marketing that I consider the above hyperboles to be.I can see the benefits of the comments that follow the ""any publicity is good publicity"" rule. In addition, the more-functional-in-approach Lisp dialects certainly follow the ""breaking the long-built mental model"" scheme that you mention, and so does Common Lisp, since it mixes programming paradigms (including function"	phoe-krk	15.144953	-3.9459918	comment	3.0	22.0	1589371008	-10.468449
23169404	I never thought I'd see a Lisp witho	I never thought I'd see a Lisp without lists. Oh wait, I didn't because this isn't a Lisp.I know naming is hard, but this is getting out of hand. Don't say you're a Lisp when you're clearly not. Say Lisp-inspired. Don't use the term 'modern Lisp', 9/10 it's signaling the wrong thing.	armitron	15.115901	-3.977311	comment	3.0	16.0	1589391491	-10.499831
23202076	I would really like to see an update	I would really like to see an updated history that takes up where this left off. Highlights of the past 40 years: the formation of the Common Lisp specification, the role of Lisps in AI, Symbolics vs Lisp Machines Inc, their eventual demise in the AI winter, continued use in DSLs like Autocad and Emacs, and the small but growing resurgence in interest.	mtreis86	15.144597	-3.9389331	comment	3.0	10.0	1589623104	-10.437793
23212974	Lisp has a long history in computer 	"Lisp has a long history in computer graphics. It was particularly popular in the 1980s.There was Symbolics, a manufacturer of Lisp workstations (sometimes also remembered as the first company to register a .com domain).Symbolics had a Lisp-programmable 3D graphics suite that seems to have been fairly successful at the end of the decade. Here’s a video from 1989:
https://youtu.be/gV5obrYaogUThe video doesn’t seem to show any Lisp though.On the 2D side, the immensely popular AutoCAD adopted Lisp as its expansion language in 1985.Autodesk founder John Walker explains the decision in this contemporary memo “Why Lisp”:
https://www.fourmilab.ch/autofile/e5/"	pavlov	15.134145	-3.9520993	comment	3.0	14.0	1589732469	-10.450226
23234018	Usually using Lisp in production mea	Usually using Lisp in production means making use of either LispWorks or Allegro Common Lisp, and not the FOSS offerings.	pjmlp	15.144968	-3.9389632	comment	3.0	16.0	1589890834	-10.44095
23234095	these days many newer languages have	these days many newer languages have macros: lisp is not alone	alehander42	15.109009	-3.9871423	comment	3.0	33.0	1589891420	-10.313428
23234105	I sometimes feel that someone needs 	"I sometimes feel that someone needs to declare ""elisp bankruptcy"" in the same vein as one declares inbox bankruptcy, accept that implementing all of elisp in another superior lisp is too much work, write a better emacs-alike from the ground up in a proper, performant lisp, and let the package authors do the work of porting their packages."	na85	15.108349	-3.9569805	comment	3.0	20.0	1589891507	-10.430029
23234663	I would like to consider Python a co	I would like to consider Python a common lisp alternative. But it's one or two orders of magnitude slower and is not really standardized. I think there is a lot more that's attractive than just macros.	justinmeiners	15.129131	-3.9618444	comment	3.0	12.0	1589895052	-10.386526
23236432	Rigetti Computing is a company that 	Rigetti Computing is a company that builds quantum computers.We have used Common Lisp in production at Rigetti Computing for 4 years both in cloud deployment as well as for a downloadable SDK. Common Lisp is used to build what is currently the best free optimizing compiler for quantum computing [1, 2] as well as one of the most flexible quantum computer simulators [3]. They’re both open source, so you can actually see for yourself how we version, deploy as binaries, and deploy in Docker containers.> If you are using lisp in production for non-trivial cases, do these issues still exist?Before getting into the specifics, any large, non-trivial product that customers use will need tweaking. Especially languages that have runtimes, including languages like C. This is usually a result of leaky 	reikonomusha	15.142101	-3.94468	comment	3.0	10.0	1589904484	-10.462814
23236455	When Ralph was new, it was essential	When Ralph was new, it was essentially a hybrid of Common Lisp and Scheme. It was very much a Lisp--not just technically, or in matters of surface syntax, but down in its bones.The surface language was basically Scheme, with some special forms removed and others added or renamed. The type system was basically a simplified Common Lisp Object System; all values were instances of CLOS classes.The compiler, runtime, and development environment were built on Macintosh Common Lisp. Ralph inherited MCL's design and aesthetics.Like Common Lisp, it was designed for writing software by interacting with it and modifying it as it ran. That's the essential point.The project I worked on, bauhaus, was running basically all the time we worked on it. We worked on it by interrogating and hot-modifying the r	mikelevins	15.133918	-3.9497278	comment	3.0	26.0	1589904580	-10.438437
23234665	I don't think another language's mac	I don't think another language's macros can match lisp macros unless the other language is also homoiconic.	tolsen718	15.11827	-3.9760194	comment	3.0	13.0	1589895065	-10.38672
23236675	I think it's safe to say at this poi	I think it's safe to say at this point -more than 10 years later- that Andy Wingo was very optimistic.Absolutely nothing of what he described in that email materialized. And it's no wonder it didn't, since a lot of it is simply wishful thinking. In addition, he didn't address the fact that there are political and not technical reasons behind the absence of certain features (e.g. FFI). They could be done today, without Guile, assuming a consensus on the political front existed.On the other hand, Emacs Lisp has gotten a lot better and not only knocked out some of the features mentioned by Andy (dynamic modules, native threads) but is also making progress towards new directions (GCCEmacs).And as I described in my other comment, I completely disagree with his premise that having Emacs be exten	metroholografix	15.108185	-3.9345067	comment	3.0	18.0	1589905343	-10.385601
23287241	Completely agree. I worked at a comp	"Completely agree. I worked at a company on a Common Lisp project where the Python crew refused to learn Common Lisp because they thought it would look bad on their resumes. This should be a litmus test for programmer quality: If they don't want to learn something because it's not ""fashionable"", they're probably lousy programmers who lack confidence in their own abilities. Do you really want these people working for you?"	dreamcompiler	15.145411	-3.942106	comment	3.0	14.0	1590273773	-10.461046
23294416	I will explain it for you.Lisp is ha	"I will explain it for you.Lisp is hard to master, like playing the violin, but if you master it you can get enormous rewards.Other languages are more like ""playing guitar hero"", most of the work is done for you and it it way easier to learn.HN is like a musician network but for programmers. It attracts lots of people around the world that master lisp like musicians master an instrument.I will tell you about myself, I had a lisp master that did teach me that what had taken me weeks in c, c++ and python  code he could do it in lisp in minutes.As I saw this man ""play his instrument"" it was obvious that if I wanted to be a good programmer I should master it myself.Because I had this master teaching me, I could learn it fast.The ""secret"" of Lisp is that you can automate your code writing, makin"	pritovido	15.152273	-3.9383004	comment	3.0	25.0	1590352038	-10.46764
28025136	LISP Comes of Age	LISP Comes of Age	tosh	15.154918	-3.9308124	story	3.0	24.0	1627811793	-10.473111
28042874	But you just touched on the reason p	But you just touched on the reason programmers don't like Lisp: they prefer a language that has a lot of little bits of available functionality that they can mix and match, without having to do any real programming. Programming, as we knew it, is a dead art, modern developers only want to reuse some library that was created by someone else. Languages like Python and Java are bad to program, but ideal for this kind of lego-based development.	coliveira	15.117159	-3.9635344	comment	3.0	15.0	1627939527	-10.444187
28077389	Practical? Common Lisp on the JVM: A	Practical? Common Lisp on the JVM: A quick intro to ABCL for modern web apps	eatonphil	15.12758	-3.9608698	story	3.0	69.0	1628187047	-10.496914
28154127	can anyone expound on what he means 	"can anyone expound on what he means when he says that lisp macros defined syntax but not semantics?---  > The folks at Rust tried to do a decent job of fitting macros in the language.

  > Other languages, like all of the Lisp family, managed to fit them in more gracefully, but they had a way of defining syntax where the syntax was almost entirely free of semantics. And in most languages, syntax and semantics kind of go hand in hand."	andrekandre	15.109592	-3.9913013	comment	3.0	15.0	1628761377	-10.391276
28180462	It's the old 'I wanna make something	It's the old 'I wanna make something, gimme libs! vs 'I wanna make something completely new, gimme lisp' dichotomy.BTW the Wolfram language isn't 'a bit like lisp'. It _is_ a lisp with an alternate syntax. This becomes extremely apparent in any kind of symbolic manipulation.	rscho	15.123246	-3.970114	comment	3.0	19.0	1628947816	-10.42531
28189121	Lisp has always seemed like the most	Lisp has always seemed like the most teachable FP language to me. I imagine it would be hard to start elsewhere.	Igelau	15.1465025	-3.9402754	comment	3.0	27.0	1629038550	-10.414849
28189325	FP with dynamic scoping?Lisp is not 	FP with dynamic scoping?Lisp is not a FP language anymore than C.	rightbyte	15.130829	-3.9581082	comment	3.0	16.0	1629039911	10.431103
28255499	That's a weird language. At first gl	That's a weird language. At first glance it looks like a hyper-imperative lisp (except turns out it doesn't Process LISts).	masklinn	15.09235	-3.9907157	comment	3.0	19.0	1629537791	-10.405219
28338256	Hopefully pure-gtk branch will be me	Hopefully pure-gtk branch will be merged prior to Emacs 28, addressing (2).On (1), I'm not much of a programmer, but Emacs-lisp fine, so I'm not sure what benefit changing languages could bring.	clircle	15.09081	-3.9739766	comment	3.0	16.0	1630160167	6.3164134
28338507	I've been using emacs for 35+ years.	"I've been using emacs for 35+ years. It does everything I need to do. If it doesn't, it has lisp. And then it does.I only use fundamental-mode.Emacs, like lisp, is ""clay for the mind"". You can adapt it to any task easily."	daly	15.099244	-3.9620225	comment	3.0	11.0	1630162162	-10.376318
28338911	"Being smart is not equivalent to ""kn"	"Being smart is not equivalent to ""know the locations of a zillion and one hidden land mines"".C and C++ were weird at the beginning and their median user was smart. They just become so mainstream that, for many, programming is programming in C-like languages. 
The majority of developers nowadays won't find new concepts, new ways of thinking by picking up C or C++, they're likely to have met those concepts already.If the majority of developers picked up Lisp or Haskell, they would likely discover new ways of thinking.This is changing, because popular features, abstractions and ways of thinking are trickling down from Lisp and Haskell to more mainstream languages."	jokethrowaway	15.119598	-3.9652247	comment	3.0	11.0	1630165329	-10.435479
28339212	> [Lisp macros] by their nature woul	> [Lisp macros] by their nature would be hard to implement properly in a language without turning it into a dialect of Lisp.Camlp4, Template Haskell, and Rust procedural macros all serve as counterexamples to this claim.	dfranke	15.114351	-3.9820158	comment	3.0	17.0	1630167431	-10.365247
28346231	When I was younger I used to write a	When I was younger I used to write a lot of Common Lisp. A lot. And I also had this idea that Haskell/OCaml/Scheme were strict, ivory tower totalitarian languages, while Common Lisp was this incredibly powerful, expressive, liberating tool. For building organisms, not pyramids, like Sussman said. And the S-expressions were aesthetically appealing to me. But at the time I was working mostly on smaller commercial projects and solo open source projects.Maybe it's cognitive decline from no longer being a teenager, or the experience of working on larger, O(100,000) line codebases with large teams, but nowadays I find a high degree of dynamism just exhausting. I don't want more expressive power, I want fewer nightmares.A common problem I faced with Common Lisp is I'd write some module, then go o	zetalyrae	15.109048	-3.992336	comment	3.0	13.0	1630240817	-10.479505
28346239	The deepest and most radical opinion	The deepest and most radical opinions of Lisp are:- You should be able to implement Lisp-in-Lisp within a few pages of code. This a profound and remarkable design constraint. (See http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf (PDF) for an introduction.)- Syntax would only hide the fact that code is a simple data structure that can be manipulated like any other data structure.Just like Rust's strong opinions buy you stress-free threading and bit-banging, Lisp's opinions ensure that it's an almost ideal environment for inventing domain-specific language extensions.But Rust is poorly suited to object graphs where everything mutates everything else, and Common Lisp is poorly suited to proving that a large program obeys certain strict rules.I love opinionated tools, but I try to choose ones	ekidd	15.09588	-4.002947	comment	3.0	18.0	1630240951	-10.485736
28366448	Glean is focused on storing and quer	"Glean is focused on storing and querying data about the code. The idea is that you have your own program to collect that data, then you use Glean to store that compactly and to have snappy queries.You would create entries like ""this is a declaration of X"", ""this is a use of X"". Then you can query things like ""give me all uses of X"" in sub-millisecond time. You hook that up to an LSP server then you get almost zero-cost find-references, jump-to-definition, etc. The snappy queries also mean it becomes possible to perform whole codebase (and cross-language) analysis. That is, answering questions like ""what code is not referenced from this root?"", ""does this Haskell function use anything that calls malloc?"" (analysis through the ffi barrier).One can also attach all kinds of information from di"	lazamar	15.089033	-3.9920242	comment	3.0	11.0	1630408947	-10.361868
28376231	> I think hardcore Lispers see stuff	"> I think hardcore Lispers see stuff like a Lisp GUI and natively-graphical Lisp editors as pointless bells and whistles – Emacs was good enough for John McCarthy and it still is for me! – but they really are not in 2021.That's almost the last line of the article, but it hasn't established any credible argument about why ""they really are not in 2021"" other than a much longer form of the same assertion.> Summary: You have to get in there and compete with mainstream, play their game by their rules, if you want to compete.1. Why does someone want to ""compete"" ?2. What would you be competing with?Convincing people that they could & should use Lisp instead of Python or Swift is facing stumbling blocks far, far larger than the user-experience in an editor/IDE."	PaulDavisThe1st	15.11385	-3.952332	comment	3.0	26.0	1630467838	5.856053
28376538	I've flirted with Lisp over the year	I've flirted with Lisp over the years. I appreciate its simplicity, I'm always casting curious glances when lispers talk about slinging code around, editing it live, this (alleged) blissful nirvana of pure digital expression. I used to work at a company that used lisp (I worked on other things, but I poked at it occasionally), and I've done a couple of small projects in Clojure, just to try it out. I've even made a couple interpreters/transpilers of my own.But advocates always seem to emphasize how fun and effortless lisp is, how that's one of its biggest strengths. And frankly, that has not been my experience. Mainly because of the tooling.I don't have the dedication to dive into learning emacs for something I'm merely curious about. Clojure's experience was less esoteric in some ways, bu	brundolf	15.128477	-3.9675786	comment	3.0	10.0	1630471743	-10.637791
28376574	Lisp enthusiasts don’t get why Lisp 	Lisp enthusiasts don’t get why Lisp isn’t popular. And they keep repeating the same thing over and over again: that somehow it isn’t Lisp that’s the problem but something else. Nope. The problem is Lisp. I have written my own Lisp interpreters just for fun. An it is nice how you can built a language from very little. However it still doesn’t make me want to use Lisp for real projects. The same way I admire Lambda calculus but would never use it for real programming.	mbrodersen	15.13561	-3.9532385	comment	3.0	17.0	1630472395	-10.451161
28376795	There exists a product that meets mo	There exists a product that meets most of the suggestions in this article called LispWorks. It has an IDE runs on multiple platform and has the features that a majority of Lisp programmers would consider mandatory. There is a listener, editor, debugger, various browsers and more. You can deploy stand-alone binaries for the supported platforms. The user interface library uses native widgets for each platform. There are iOS and Android runtimes for core library code. There is FFI support for calling code outside of Lisp. LispWorks is a high-quality, professional product.So what are the downsides? It isn't open source and you have to pay for it. At some point developers decided that they wouldn't pay for development tools. This has mostly been positive, but languages on the edges have suffere	diskzero	15.050945	-3.9928234	comment	3.0	33.0	1630475791	-10.421592
28376755	If you happen to already be a Vim/Ne	If you happen to already be a Vim/Neovim user, the Vlime plugin + Parinfer (or at least Paredit) is pretty good.If you don't use either Vim or Emacs... that's harder. You can use the Lispworks IDE, although that's limited if you're not paying for it.I don't think the lack of tooling in Common Lisp is for lack of trying, but for lack of person-hours dedicated to open-source.That said, there are a lot of gaps in the overall Lisp experience:- Quicklisp is very unusual, and while it's quite an impressive effort (and definitely a good thing to have in the world), it's a bit odd coming from other programming languages.- Roswell is great, but under-documented in some areas, and appears to be outright missing features that are actually specified in the docs.- Qlot, like Roswell, is under-documente	nerdponx	15.091832	-3.9674175	comment	3.0	17.0	1630475274	-10.41065
28565387	So, if I'm understanding correctly, 	So, if I'm understanding correctly, the author used Lisp in this story?	ask_b123	15.146805	-3.933249	comment	3.0	10.0	1631886239	-10.487474
28654797	> (And yes, despite what the Common 	> (And yes, despite what the Common Lisp community has to say, Janet is a lisp, even if it’s not a Lisp)I love this and understand both the sentiment expressed and (as a recovering member of the Cult Of Lisp) the reason why it was said.	chris_st	15.144752	-3.9387677	comment	3.0	18.0	1632591193	-10.495317
12042012	This is fantastic. AFAIK there are n	This is fantastic. AFAIK there are no Lisps our there that are designed with games in mind which is a huge shame because I often think how perfect it'd be for game dev (Arcadia and Nightmod spring to mind but imo they're shoehorns. Good ones, but still).	acron0	15.142498	-3.9330726	comment	3.0	10.0	1467796390	-10.46276
12113960	Sorry, I can't agree with you on thi	Sorry, I can't agree with you on this one. Lisp has multiple dispatch - how many languages you know have multiple dispatch? Many Lisp implementations compile to machine code that is very efficient for a dynamically typed language, e.g. SBCL is way faster than other equally dynamic languages like Python. CommonLisp is ANSI standardized. How many languages you use are ANSI standardized? Lisps have full garbage collection that can deal correctly with cyclic structures. Many other languages have only reference counting or some RAII management and falsely advertise them as advantages? How many other languages have metaobject protocols and can be extended arbitrarily? And since you mention it (I don't this really deserves mentioning, though), how many other modern languages are homoiconic?The li	jonathanstrange	15.133681	-3.963692	comment	3.0	10.0	1468833076	-10.471582
12123526	You cannot. Because Lisp is homoicon	You cannot. Because Lisp is homoiconic, you don't code in (what I personally believe to be) reasonable syntax, you code in abstract syntax trees. Lisp is so easy to metaprogram because everything is parentheses and the burden is on the user, not the parser, to determine the program's abstract syntactic structure. So, Lisp can only metaprogram its own syntax, you can't introduce a C-like syntax.	wcrichton	15.1122465	-3.9814517	comment	3.0	21.0	1468951354	-10.346054
12183408	>Regarding Lisp many in the FOSS cam	>Regarding Lisp many in the FOSS camp that never experienced commercial Common Lisp IDEs should give a try, the REPL is only the tip of the iceberg.You've said. However, I am unsure as to whether any Lisp implementation outside of the lisp machine truly allowed for programming inside a live environment, such that there is no distinction between the live environment and the code on disk, where the image IS your environment.Although being able to serialize your live environment to disk goes a long way. As a schemer, I'm still drooling over that particular feature.	qwertyuiop924	15.115888	-3.948009	comment	3.0	10.0	1469742149	-10.426882
12200214	Heh, yeah.  Lisp has powerful featur	"Heh, yeah.  Lisp has powerful features, I'm sure, but something that's always stumped me is, if that power mattered for delivering better code, would we have to strain so hard to find examples of why it's better?Paul Graham's viaweb story, well, that's great, but why wasn't there a whole cohort of super-powered startups winning the day with lisp in the original dot com boom?  Why are there so few big wins with lisp?  The ""lisp is powerful"" story just doesn't seem like the whole story, when there are so few successes on the ground compared to C, C++, Python, Perl, PHP, Ruby, VB, you name it."	Frondo	15.130711	-3.954348	comment	3.0	25.0	1470026052	-10.461642
12200346	For UI application programming You c	For UI application programming You can do without FP language features. Hell, you can even do without smart pointers checked arrays or GC.But you cannot do without a decent desktop or web development experience. I got involved with pretty large desktop applications written in delphi. The design-time, the debugger, native compilation without having to install some msvc runtime, deriving and combining visual components, it just gives a smooth experience for desktop apps. If lisp has such well thought-out frameworks, I would jump ship just to get at the language features it offers.	nurettin	15.121389	-3.9634345	comment	3.0	17.0	1470029026	-10.416688
12231113	I still do wonder why reddit was rei	I still do wonder why reddit was reimplemented in Python, but with rewrites in other languages I think that rewriting in itself made it more readable and not using the other language. Plus maybe using a web framework instead of doing most by hand, because I assume lisp had even fewer good web frameworks than python then.	kossmoboleat	15.087913	-3.986965	comment	3.0	13.0	1470391847	-10.149524
12249252	I do wonder if they have ever though	I do wonder if they have ever thought of building a Mathematica  Machine like the old Lisp and Smalltalk machines?	protomyth	15.118788	-3.939221	comment	3.0	16.0	1470676118	-10.354515
12264402	Now cue all the LISP guys talking ab	Now cue all the LISP guys talking about how the code as the compiler represents it and the way they think about it is the same...	infinite8s	15.121063	-3.9724956	comment	3.0	10.0	1470859182	-10.386617
12312218	Switch to Common Lisp.And with lisp,	Switch to Common Lisp.And with lisp, you don't have to repeat yourself: any pattern, or any boilerplate can be abstracted away with a macro.	informatimago	15.11374	-3.9824004	comment	3.0	14.0	1471526124	-10.406233
12327149	It is absolutely more verbose. The L	It is absolutely more verbose. The Lisp form can store N constants into N variables in 2N+3 tokens: two parentheses, plus the variables and constants and one symbol. Assignment statements require 3N tokens: N vars, N constants, N assignment operators. That's assuming they don't need some mandatory separator or terminator like a semicolon. We break even when N = 3. For N > 3, 2N+3 < 3N.Anyway, this is hardly the main point of the article (and probably detracts from it).	kazinator	15.115935	-3.975001	comment	3.0	17.0	1471709294	-10.395783
12327303	That assignment has 9 pieces of extr	"That assignment has 9 pieces of extra syntax above a b c 10 20 30. By contrast,  (setf a 10 b 20 c 30) has only three: two parens and setf. Let's count the crumbs:  [a, b, c] = [10, 20, 30]
  1 2  3  4 5 6  7   8   9

In Common Lisp, you an express that 10 20 30 should go to a b c using values:  (setf (values a b c) (values 10 2 30))

That still has fewer overhead tokens!  (setf (values a b c) (values 10 2 30))
  1 2   3   4          5 6            78

If they are bother make yourself  (vsetf (a b c) (10 20 30))

This is easy to implement in a quick and dirty way:  (defmacro vsetf (places exprs) `(psetf ,@(mapcan #'list places exprs))

  (macroexpand-1 '(vsetf (a b c) (1 2 3)))
  -> (PSETF A 1 B 2 C 3)

psetf is probably a good choice here since it is probably best for the construct to hav"	kazinator	15.084969	-4.0093927	comment	3.0	20.0	1471711764	-10.380997
12327131	Having programmed many substantial p	Having programmed many substantial projects in both worlds, I have to admit that I much prefer S-expressions over any other syntax -- without complicated macros that introduce some sort of keywords or other tricks. With S-expressions, there is basically just one syntax to learn for every construct, so you can focus on the semantics. (I do prefer Scheme's way of dealing with functions, but that's another matter, of course.)Unfortunately, I otherwise prefer strongly typed systems languages with a strong focus on compile-time, zero cost solutions such as Ada or Rust. My ideal language would be a very fast, statically and strictly typed language with a modern incremental garbage collector that can be switched off and without type inference, but with an S-expression syntax.However, if such a la	JohnStrange	15.090781	-4.0069275	comment	3.0	13.0	1471709008	-10.363314
12328261	I'm not much for Common Lisp, but I 	"I'm not much for Common Lisp, but I do think Scheme is the prettiest language in which people write ugly code.  As such, while I am sympathetic to the virtues of s-expressions, this example is not going to win any hearts or minds.  I don't much care for Python's performance or newer features, but your snippet screams for a comparison:    if condition:
        a, b, c = c, a, b
        a, c, b = b, a, c

That really seems much more clear than the gymnastics my mind has to do manually pairing the assignments inside of psetf.  I won't argue that it's objectively better syntax, but I still think it is."	PrettyButUgly	15.104425	-3.9877017	comment	3.0	11.0	1471726160	9.101631
12355273	I've made this comment before, and I	I've made this comment before, and I don't intend it to be flippant, but am honestly curious.If Common Lisp is a failure, how is it that there are multiple commercial offerings for it?[0][1]I would take the continued presence of these commercial offerings as a sign of health in the Common Lisp ecosystem.[0] http://franz.com/products/allegro-common-lisp/[1] http://www.lispworks.com/	greggyb	15.140194	-3.9336715	comment	3.0	10.0	1472072884	-10.404891
12360761	Very impressive.Since the demise Lis	Very impressive.Since the demise Lisp machines, there have been several attempts at developing a Lisp-based operating system which didn't deliver anything: LispOS, Tunes, and Loper; and one successful attempt at getting Lisp to run on the bare metal: Movitz.Lisp was its own operating system on the original Lisp machines developed at MIT, and this evolved into Genera at Symbolics.   Is this the case here?I notice that Mezzano has files.   Files are inherited from operating systems running non image-based languages.   They're alien to Smalltalk, where everything is just stored in the image (or world, in Lisp parlance).   This could also be done in Lisp.   Text files could be replaced by long strings contained in the world.   Hypertext, provided tags are balanced, could be stored as lists.   	DonaldFisk	15.142661	-3.9745564	comment	3.0	12.0	1472145811	-10.351711
12435371	So Lisp is not a functional language	So Lisp is not a functional language...	jerven	15.1334	-3.9525537	comment	3.0	21.0	1473164151	-10.45188
12437483	I was hoping Shel would talk about u	I was hoping Shel would talk about using Lisp in the early days of Amazon.https://sites.google.com/site/steveyegge2/tour-de-babel#TOC-...	strangetimes	15.150019	-3.9354901	comment	3.0	22.0	1473181696	-10.438399
12471099	>But, for the sake of argument, I'd 	">But, for the sake of argument, I'd like to boil them down to two things:>    LISP is a dense functional language.
>    LISP has programmatic macros.First of these is wrong and second is just picking something from feature list without any concern of practicality.When someone writes Lisp as LISP and speaks about functional programming, I get the feeling that the author has not programmed with Lisp outside school (or knows only Scheme). Using toy examples don't help.There is also problem with treating Lisp as a single entity. It's like Treating C++ and JavaScript as the same language because their syntax looks similar to someone who is not actually programming with them.There are at least two major ""schools"" of lisp.  Traditional Lisp style with Common Lisp as it's main representative, anot"	nabla9	15.131151	-3.9659448	comment	3.0	12.0	1473545522	-10.4608965
12939377	This is far from ideal (and a bad id	"This is far from ideal (and a bad idea in general):  (load ""~/quicklisp/setup.lisp"")
   
  (ql:quickload '(:datafly        ;; for database access
  
                  ;; WEB SERVER:
                  :hunchentoot    ;; for providing a web server
                  :cl-who         ;; for building the HTML output
                  :parenscript    ;; for the avoiding of the horrible JS syntax
                  :smackjack      ;; for AJAX requests
                  :lass           ;; for building the (S)CSS styles


You should not use Quicklisp to silently install dependencies as part of your normal
operation sequence, because:+ It imposes its own view on how libraries are retrieved, stored, managed and updated.+ It is vulnerable to man-in-the-middle attacks.+ Used in this fashion, it effective"	armitron	15.097945	-3.9564023	comment	3.0	23.0	1478975939	-10.406892
12989134	by relaxing constrains, constant exp	by relaxing constrains, constant expressions became so powerful that a C compiler can be implemented in!I wonder how long it will take before C++ accidentally becomes a Lisp.	wsmith	15.110559	-3.973858	comment	3.0	19.0	1479495290	-10.261344
12999074	Once you look at enough of it, your 	Once you look at enough of it, your brain starts to see lisps differently. The parens fade away, and you mostly just see the indentation. It looks a little like Python once you adjust.	actsasbuffoon	15.112233	-3.9752836	comment	3.0	28.0	1479653303	-10.329622
13019162	I could never do this. Because I wou	I could never do this. Because I would want a real Lisp. And that means things like GC.Do you want to implement GC in 64k?Also, I don't know compilers super well. And you have to know compilers to actually write an efficient lisp. I plan on learning that, at some point, but while I'm also writing an OS (or at least a monitor) for a Z80? Nope, forth it is.	qwertyuiop924	15.135518	-3.9471865	comment	3.0	13.0	1479864034	-10.453245
13026487	Well sure, but you could say the sam	Well sure, but you could say the same thing about Lisp.	skybrian	15.149326	-3.9366856	comment	3.0	12.0	1479942031	-10.468106
13073987	Why is the core of Emacs still writt	Why is the core of Emacs still written in C? Is it just fear of trying to rewrite it from the ground up in Lisp, or is there something fundamental to the architecture that makes Lisp unsuitable?	AdmiralAsshat	15.130318	-3.957614	comment	3.0	13.0	1480535149	-10.390566
13137665	That's not cheeky, it's a perfectly 	That's not cheeky, it's a perfectly fair question.  Yes, that is certainly possible.  And there have been a few cool new ideas that have come along that are not easily subsumed by CL, like Haskell's type system.  It's easy to implement Hindley-Milner, but actually using that information to inform the compiler, plus adding laziness as a core language feature, is much harder.  But I think the jury is still very much out on whether or not Haskell is really a net win.But the most popular language on github at the moment is Javascript, and there is no question that it is simply a very badly designed Lisp with C syntax.  This is not intended to disparage Brendan Eich.  He had a week to design and implement something, and under those constraints he did a pretty amazing job.  But I can't help but 	lisper	15.095212	-4.011988	comment	3.0	47.0	1481275650	-10.4711685
13145960	okay, maybe i betrayed my biases the	okay, maybe i betrayed my biases there too much, but, i agree with everybody else: if lisp was such a great secret weapon, there would be a hell of a lot more visible success stories by now, other than just pg's original viaweb implementation, and some flight routing software.plenty of other tech has come from up nothing in the last few decades, to wide adoption, and big successes. the fact that lisp hasn't is, in my mind, prima facie evidence that it is not nearly as great as its proponents claim.	allenbrunson	15.150905	-3.9407556	comment	3.0	12.0	1481382788	-10.425475
13183544	Not sure why I'm taking the bait but	Not sure why I'm taking the bait but here I go:> Now we have much more powerful thingsLike what? Off the top of my head, Rust, Haskell and F# are probably the only ones that come close, and they're about as popular as the Lisps (i.e. not).> you should have try to popularize lisp like 10-20 years ago.Programmers want familiar syntax and infix notation while Lisps want homoiconicity. It's never going to happen.It's funny because people fear and loathe Lisp's parenthesis, while after a month of using Lisp, you don't see parens anymore (they're mostly for the parser).	kaoD	15.112305	-3.9889753	comment	3.0	30.0	1481795927	-10.354874
13193439	Because Common Lisp was the language	Because Common Lisp was the language for AI before the big AI-winter hit and it's now associated with approaches to AI that don't actually work.Also a lot of the latest AI is hyper optimized data crunching on GPUs which isn't necessarily one of lisp's strengths.	mtrimpe	15.141288	-3.9435196	comment	3.0	14.0	1481898706	-10.472543
13193456	And ML was originally written in Lis	And ML was originally written in Lisp.https://github.com/theoremprover-museum/LCF77/tree/master/sr...https://github.com/theoremprover-museum/HOL88/tree/master/sr...	lispm	15.115727	-3.9571273	comment	3.0	11.0	1481898888	-10.315576
13194079	You make some specific claims here t	You make some specific claims here that sound a little odd to this LISP and assembly language hacker.Assembly language doesn't provide any datatypes.  LISP does.  Assembly language doesn't provide any type checking.  LISP does.  Assembly language doesn't provide automatic storage reclamation.  LISP does.  Assembly language doesn't provide naming.  LISP does.You also make a claim about L1 caches and locality of reference.  Every LISP compiler writer, and every LISP garbage collector writer, knows about CDR-coding.  We also know about how Cheney copying garbage collectors and their descendants like the Baker incremental collector compact data, precisely for locality of reference.  The compiler writer of course is thinking about cache performance and how lines are mapped in particular target 	hindenburg	15.103175	-3.9747887	comment	3.0	10.0	1481903677	-10.3338375
13200279	This is nice, but only hardcore Lisp	"This is nice, but only hardcore Lisp users prefer writing C-in-sexpr's to just writing C.The ""industrial-strength"" alternative in the open-source world is just to parse C into an AST; several important projects like the Frama-C analyzer (and, IIRC, the Cocinelle project best-known for ""spatch"") use CIL (https://people.eecs.berkeley.edu/~necula/cil/), and of course many recently-started projects use the LLVM infrastructure.sexpr's do make the AST more obvious than relying on an external compiler, but you need to write a lot of macro's before ""more-convenient macro's"" beat ""more-convenient code""."	JoachimSchipper	15.106567	-3.986559	comment	3.0	12.0	1481974383	-10.253187
13214244	Lack of macro hygiene is just peachy	"Lack of macro hygiene is just peachy keen among Scheme programmers as long as you are explicit about which identifier bindings can leak into, or out of, the macro definition from the macro call site.Scheme standards before R6RS[0] were a rough consensus on which language features everyone could agree on as useful additions. That's why only syntax-rules made the cut, not because Scheme programmers object to the ability to break hygiene. Implementors disagreed on which mechanism for breaking hygiene was most ""correct"", so none made the cut and unhygienic macros weren't standardized.[0] R6RS, in a break from Scheme tradition, adopted a systemd-esque ""come up with a standard for these needed features, any standard, and everybody else needs to fall in line whether or not they like it"" approach."	bitwize	15.098272	-3.990273	comment	3.0	29.0	1482175616	-10.269359
13216191	Can you go into detail on using LISP	Can you go into detail on using LISP for text MUDS? I have an appreciation for text based games. I find the simplicity to be elegant.	throwaway7645	15.1348	-3.952079	comment	3.0	14.0	1482192514	-10.433203
13273577	Was the lisp machine OS fundamentall	Was the lisp machine OS fundamentally non-portable to other hardware? It's my impression that it could have been, with similar amount of effort to making the first port of any OS.Unix is intended to be portable, but creating and maintaining a port (including compilers and drivers) is a large effort, and somehow a community never materialized around supporting Lisp Machine on PCs, the way Unix on PCs did.	tlb	15.13444	-3.948812	comment	3.0	10.0	1482958628	-10.405359
13355867	Building a community around lisp is 	"Building a community around lisp is tricky. While there are many criticisms to this article [1], there are some elements of the ""Lisp Curse"" which is true - each programmer tends to rewrite his/her own libraries and so a collaborative framework seldom emerges even while many programmers may work in the same domain. This can be a disadvantage in a domain like the natural sciences where deep collaborations are necessary.Furthermore, the disconnect with traditional mathematical syntax has also turned off many users. There was a predecessor to R called Lisp-Stat [2] which never achieved the acceptance that S/R did, and the Lisp-based syntax  of Lisp-Stat was cited as one of the reasons.Following the example of a high-profile Lisp supporter like Peter Norvig who accepted Python as a ""Lispy"" alt"	hatmatrix	15.128335	-3.9649339	comment	3.0	20.0	1483965274	-10.36523
13379106	Meh.As a long time Emacs user, the o	Meh.As a long time Emacs user, the only way I'd even consider switching off of GNU Emacs would be if there was a port written in Common Lisp that replaced ELisp with Common Lisp.  Even then, I'd only switch if it had replacements for the ELisp modules I use (ERC, Slime, C++-mode, etc.).As an end user, I don't see any advantages in switching to yet another Emacs rewrite in yet another low level language.	jlarocco	15.101735	-3.9695928	comment	3.0	28.0	1484183973	-10.349018
13422013	SBCL does not create binaries per se	SBCL does not create binaries per se, but dumps the program image.  While it practically is a binary, it's not equal to an executable that a conventional compiler/linker produces.	gkya	15.123507	-3.9486637	comment	3.0	17.0	1484691731	-10.393312
13539965	That could work within a single, wel	"That could work within a single, well coordinated project. Beyond that, the Common Lisp package system doesn't cooperate the way you'd like it to, so you're back at    (libraryA:bar (libraryB:foo object))

Since the package system is not hierarchical and doesn't allow local aliases, if you're unlucky you get fully qualified Java-convention package names and end up writing:    (com.myfavoritecorp.dept1a.project7.subprojectX:bar
       (com.biggercorp.dept32.project2.subprojectE:foo
          object)"	cronjobber	15.056346	-4.002382	comment	3.0	17.0	1485949830	-10.182024
13580087	"> And what do you mean by ""s-express"	"> And what do you mean by ""s-expressions just too simple""? Isn't simplicity something to strive for?I should stress ""a bit"". Actually, looking closer at s-expressions right now (I was writing based on what I remembered), I'd like to flip that statement. S-expressions are just a bit more complex than what I have in mind. Or alternately: they're equivalent under some trivial transformation.It depends on how you look at things - there are supposedly many different implementations of s-expressions, which support different fundamental data types. The basic idea is simpler. There are no fundamental data types, just nodes. For example a 'bit' is a node which can contain one of two child nodes ('one' or 'zero'). Any tree which represents data in memory on a computer can be expanded down to a colle"	audunw	15.073542	-4.0207353	comment	3.0	10.0	1486393932	-10.335614
13601097	The author very clearly defined what	"The author very clearly defined what he means by functional, and he is correct, idiomatic Lisp is not. IF being a value-returning expression only encourages functional programming in the author's sense, since functions with conditionals can be written without explicit control flow where you can sneak side effects in. But, to be clear, flow control doesn't affect functional purity, and so it can be said that IF expressions vs. statements don't actually provide more or less functional behavior.With side effects rife within Lisp's standard library, and with things like dynamic variables included with the language, I have a difficult time believing that it would be easy to ""abstract out"" side effects with some macros, while simultaneously providing a convenient, broad set of capabilities to pr"	reikonomusha	15.114246	-3.9881673	comment	3.0	12.0	1486581265	-10.422111
13601343	This is complete and utter hogwash.>	This is complete and utter hogwash.> Clearly lisp procedures are not functionsSome are.  Others are not.The only thing a language needs to be legitimately called a functional language is for functions to be first-class data objects.  It's helpful but not necessary for them to be lexically scoped.  It is also helpful but not necessary to have a conditional expression.  Common Lisp has all of these things.  In fact, Common Lisp has all of the features commonly associated with modern functional languages except static type inference (and you can add that if you really want it).Common Lisp is not a purely functional language, but that's true of pretty much every language except Haskell.	lisper	15.123326	-3.9860613	comment	3.0	21.0	1486582812	-10.4729805
13600920	> In fact it can be argued that lisp	"> In fact it can be argued that lisp is one of the least functional languages ever createdCome on. Returning a value from an (if ...) already makes it more functional than a lot of languages. Sure, it's not functional in the sense Haskell is functional, but you could certainly write all your code in a functional manner using it, abstracting out any side effects via macros. I would say it's fairly well-geared towards functional programming if one was determined to use it for such a thing.That said, I wouldn't call lisp a ""functional"" language. I'd call it multi-purpose. It CAN be functional, it CAN be imperative, it CAN be object-oriented.It's certainly not the least functional language ever created though."	orthecreedence	15.117855	-3.9921348	comment	3.0	19.0	1486580009	-10.460377
21228155	And this might save Raku.Lisp has a 	"And this might save Raku.Lisp has a social problem: It's been called Lisp too long. People look at some simplified LISP 1.5-esque thing in a programming languages textbook and see a ""pure"" language (which isn't so pure compared to Haskell, but the creep of what ""functional programming"" means is its own post) which is completely useless. They don't see modern Common Lisp with its package management facility and its packages which you can manage which provide actual functionality and its FFI bindings to external libraries and the fact it compiles to optimized machine code... no, they only see some parentheses thing which is interpreted-and-therefore-slow (you know... like Javascript on V8... ) and is too elegantly pure to be bound to the outside world. Meanwhile, all the Foogols get new name"	msla	15.127315	-3.965996	comment	3.0	13.0	1570825746	-10.452801
21231391	The parens are the shadow cast by Li	The parens are the shadow cast by Lisp's consistency, which is the reason to wish for Lisp in the first place.The solution is not to look at the parens. It's a bit like not listening to tinnitus, which is harder for some than for others. Tools help.	dang	15.124375	-3.9631896	comment	3.0	30.0	1570867383	-10.433429
21231628	It's used to implement a generalizat	"It's used to implement a generalization of assignment. If you have a special form that can tell you where something is stored, you can make macros to set it. E.g.  > (set x '(a b c))
  (a b c)
  > (set (2 x) 'z)
  z
  > x
  (a z c)

which you can do in Common Lisp, and  > (set ((if (coin) 1 3) x) 'y)
  y
  > x
  (y z c)

which you can't."	pg	15.086906	-4.01516	comment	3.0	15.0	1570871103	-10.433496
21232130	I don’t think so. My simple reading 	I don’t think so. My simple reading of things there is that that was for one particular micro-benchmark (and the Benchmarks Game is acknowledged to be unrealistic and not actually suitable for comparing language performance), that the results were not actually conclusive, and that it had required telling SBCL to do some stupidly dangerous things that you should probably never turn on on real software, because they may well make it behave catastrophically badly rather than just crashing when you have a bug.On https://benchmarksgame-team.pages.debian.net/benchmarksgame/... at present, the fastest SBCL implementation, which seems to include these optimisations, is at 2.0, with other SBCL implementations being slower, the first one (whatever that means) being 8.0; meanwhile, the Rust implement	chrismorgan	15.107746	-3.959474	comment	3.0	10.0	1570878414	8.208106
21235001	This is a good point, in that Lisp i	"This is a good point, in that Lisp is better than the other languages. But why not go all the way, and drop the parens? If the goal of Bel is to be a ""good language"", with shorter programs, why oh why not also strive for shorter syntax?I love Lisp and have gotten more good constructive feedback from the Lisp community than anywhere else (with the Haskell community being a close second), but I don't understand why there's only been a dozen or so serious attempts to do Lisp without parens (I-Expressions being the best so far, better than the subsequent Wisp, etc). There should be 1,000x attempts.This should be the top priority of most Lisp researchers. I of course think my Tree Notation is the solution, but I could easily be wrong, and there could be a better way, but the () need to go!"	breck	15.116875	-3.978902	comment	3.0	16.0	1570903659	-10.372337
21251896	From a 2002 Stallman lecture:There w	From a 2002 Stallman lecture:There was no free software Emacs editor that ran on Unix. I did, however, have a friend who had participated in developing Gosling's Emacs. Gosling had given him, by email, permission to distribute his own version. He proposed to me that I use that version. Then I discovered that Gosling's Emacs did not have a real Lisp. It had a programming language that was known as ‘mocklisp’, which looks syntactically like Lisp, but didn't have the data structures of Lisp. So programs were not data, and vital elements of Lisp were missing. Its data structures were strings, numbers and a few other specialized things.I concluded I couldn't use it and had to replace it all, the first step of which was to write an actual Lisp interpreter. I gradually adapted every part of the e	tjr	15.1206	-3.9558597	comment	3.0	30.0	1571081660	-10.368422
21280928	might be interesting for you, Lips i	might be interesting for you, Lips in production:https://tech.grammarly.com/blog/running-lisp-in-production	fheld	15.09898	-3.9819016	comment	3.0	11.0	1571312330	-10.40853
21333478	You say that but one thing that i al	You say that but one thing that i always dislike when i consider taking a look at Lisps is how everything seems to be either on Emacs or looks like it'd really like to be Emacs.Personally I want a full blown IDE that takes advantage of advanced modern technologies such as displays that can draw individual pixels, have a model of the codebase that allows advanced features such as word completion and preferably fits nicely with the underlying OS. A debugger would also be nice, but i understand that sometimes i ask too much.I wouldn't mind paying for such a tool (though i do mind DRM schemes and subscriptions - i want to be able to pay once and then be on my way). Cursive looks something i'd pay for if i was really interested into Clojure and was using macOS.	Crinus	15.091879	-3.9753156	comment	3.0	11.0	1571830304	-10.4094715
21352775	Retrofitting an existing language wi	Retrofitting an existing language with flexible syntax (in this case, LISP) to non-English languages is relatively easy. They are not necessarily bad and can be useful for learners and casual users, but deviating from ASCII alone doesn't remove a cultural bias as the OP states. Programming languages have to be developed from scratch to fit to other spoken languages and cultures in my opinion. I'm aware of multiple (non-esoteric [1]) languages in this direction, none satisfactory enough though.[1] If we allow esolangs I would proudly present Aheui (https://esolangs.org/wiki/Aheui) as a good example.	lifthrasiir	15.133936	-3.9576008	comment	3.0	20.0	1571989851	-10.372952
21375454	Something super simple but that real	"Something super simple but that really entertained me when learning lisp:     (loop(print(eval(read)))

to have a REPL. (Just reverse the letters, easy enough to remember).That to me is elegance. It's simple yet powerful, and just 4 words really."	Insanity	15.128225	-3.9551477	comment	3.0	14.0	1572254940	-10.419798
21400089	"""It was done at least once"" != ""it w"	"""It was done at least once"" != ""it was a good choice"", though.There's a reason why most OSes are not written in Lisp, and it's not because the OS writers aren't smart enough to learn Lisp.  It's not because they don't know it exists.  It's because there are better languages to write an OS in."	AnimalMuppet	15.14409	-3.9451187	comment	3.0	15.0	1572455838	-10.415298
21544176	One language that seldom gets mentio	One language that seldom gets mentioned is Postscript.  People tend to think of it as just a page descriptor language, but really that is just the built-in graphic functions.So we have a post fix (RPN, similar to HP calculators) expression style, which is really a mirror image of Lisp.  You have genuine first class functions, introspection, and something I don't see that often is first class environments.  That is you can, within any part of the code, activate an environment (they call it a dictionary, which is very similar to a C structure).  And they stack, so that something not in the active environment can be automatically looked up in a parent environment.	derekp7	15.128268	-3.963128	comment	3.0	12.0	1573819671	-10.404824
21560049	Don't get me wrong -- I love Common 	Don't get me wrong -- I love Common Lisp (except when it comes to I/O). The underlying OS and drivers are almost certainly written in C. To think you are going to consistently beat (correctly written) C at I/O is unrealistic.	waynecochran	15.130317	-3.9476938	comment	3.0	11.0	1574024825	-10.438709
21579542	A totally different comment: any one	A totally different comment: any one know if arbitrary word order so important feature of Latin as a language, why no such thing in computer language.Lisp is Most flexible I suppose but basically it is fixed form (verb x).  Whatever verb is it governs how x is interpret. Also you cannot eliminate (). Hence the basic and simple structure is fixed.Not sure any use of arbitrary word order.	ngcc_hk	15.120033	-3.9769654	comment	3.0	16.0	1574206322	-10.422991
21624911	Similarities Between C++ and Lisp	Similarities Between C++ and Lisp	pcr910303	15.129646	-3.9621024	story	3.0	2.0	1574647701	-10.401958
21639243	I think the germane point about Emac	I think the germane point about Emacs here is that some people like writing Lisp and some people hate it. If you hate it Emacs is likely not going to be your best environment, and that’s fine.I really like writing Lisp so Emacs has a simple way of doing anything I want, but it’s not for everyone.	benreesman	15.110251	-3.9637892	comment	3.0	16.0	1574783140	-10.36851
21643434	LISP is a functional programming lan	LISP is a functional programming language.	zabzonk	15.13151	-3.9596262	comment	3.0	12.0	1574807461	-10.448742
21643894	The thing that matters is that code 	The thing that matters is that code is written as s-expressions, which has a simple textual serialization format with lists, symbols, numbers, strings, vectors and a bunch of other data types. Thus any Lisp form is automatically data: not simple strings or complex syntax trees.This enables a bunch of stuff: code can be relatively easily treated as data. It allows easy code generation,  transformations (-> macros), traversal (-> interpreters/compilers) or editing.The parentheses are just a part of the s-expression textual syntax. The s-expressions then are used by basic operations like READ, MACROEXPAND, PRINT and EVAL. Additionally many of the primitive data functions can be used to manipulate code: first/rest, list, append, reverse, map, ...	lispm	15.108443	-3.9893012	comment	3.0	17.0	1574811741	-10.37769
21665987	Gccemacs: Experiment with native com	Gccemacs: Experiment with native compiled Emacs Lisp	pjmlp	15.116504	-3.9590342	story	3.0	86.0	1575052569	-10.3180485
21672068	Couldn't emacs lisp be simply ported	Couldn't emacs lisp be simply ported to work on the JVM? Then emacs would get a battle tested virtual machine, and the emacs devs could focus on the editor, instead of dealing with VM speed.	dmortin	15.052526	-3.9955227	comment	3.0	26.0	1575146945	-10.379837
21720001	No, I'm serious. Lisp is incredibly 	"No, I'm serious. Lisp is incredibly fast to write, and (with a bit of practice) is amazingly readable. People foreign to Lisp often look at it and without even slightest attempt to give it a try, immediately reject it as ""hard to read"". 
But in reality, as I said - Lisp retains readability even on small screens, good luck trying that with literally any other programming language. 
The only drawback of Lisp syntax I can think of - probably it is not a very good choice for white-boarding interviews."	iLemming	15.134159	-3.9579353	comment	3.0	13.0	1575619551	-10.443047
21751320	I wrote an L-systems implementation 	I wrote an L-systems implementation in Common Lisp as part of a thesis around 2002. The software, thesis and some raytraced images are still available at my old university home page: http://www.ii.uib.no/~knute/lsystems/llisp.htmlIf anyone plans to test the software: I haven't run it in ages, and I suspect that the OpenGL bindings will be tricky to get working today. The rest of the code hopefully still works.	knutae	15.142248	-3.938482	comment	3.0	10.0	1575974359	-10.40784
21757846	The title of this post should be cha	"The title of this post should be changed to ""Armed Bear Common Lisp - Common Lisp on the JVM."" It's an iconic name, and then people would actually know what the post title was referring to."	kick	15.14783	-3.9311883	comment	3.0	12.0	1576019263	-10.561438
21758742	A lot of things in Lisp force the im	A lot of things in Lisp force the implementation of lists as cons cells. It’s probably possible to do something different, but no one has, and the result won’t be a Common Lisp.(Consider that the detail of improper lists is enshrined in the language.)	ts4z	15.104717	-3.9974492	comment	3.0	11.0	1576028182	-10.525667
21760547	I've done it, now I hate Lisp. I've 	"I've done it, now I hate Lisp. I've read On Lisp and Let Over Lambda, I've used Clojure in production, and I still hate Lisp, any and all of them. What am I doing wrong? Perhaps it's that reading code is more important than being clever when writing it. Or maybe that Lisp syntax doesn't pass the squint test[0] because it makes the wrong tradeoff of catering to the machine instead of us good ole' humans?When I make my own language, I'll make sure to make macro calls as clumsy and hideous as possible to discourage their unexpanded use. I'll also make the whole language available at compile time but without syntax manipulation (a la Zig) to make most macros unnecessary.So no, Lisp is far from ""the language to end all languages"" or whatever it is you smug Lithp weenies imagine it to be.[0] htt"	LessDmesg	15.118838	-3.9824338	comment	3.0	12.0	1576051881	-10.586351
21760631	I like LISPs conceptually. However, 	I like LISPs conceptually. However, I have a strong preference for static type systems, so I have probably written 10x more lines of code of LISP implementations than LISP code itself.	shpongled	15.131871	-3.9619782	comment	3.0	11.0	1576053169	-10.448347
39074568	Common Lisp's block / return-from an	Common Lisp's block / return-from and unwind-protect	bshanks	15.128987	-3.958619	story	3.0	126.0	1705801055	-10.412997
39075892	Could you clarify what you mean by '	Could you clarify what you mean by 'there is nothing new under the sun' when referring to programming with Common Lisp? Are you indicating that Lisp has already introduced many of the concepts and features that are now found in modern programming languages, implying that contemporary languages have largely assimilated Lisp's ideas and paradigms?Your comment left me with a strange sentiment. I'm somewhat disheartening because it implies that learning Lisp might be redundant given that contemporary languages have already incorporated its best aspects.	waynesonfire	15.140317	-3.9531217	comment	3.0	16.0	1705815279	-10.458932
39106674	"""because you are trying to describe "	"""because you are trying to describe a program in a data structure""(cries in lisp)"	tomjakubowski	15.114756	-3.9823935	comment	3.0	12.0	1706031533	-10.412827
39122811	I think common lispers should just a	I think common lispers should just accept that they are lone wolf programmers and get on with our lonely lives. Jokes asside, I dont think energy should be spent on editor support. Too much work and little to gain. Instead what needs to be done is to study the so many great libraries and writing the damn documentation (and make it fun). Documentation problem is THE low hanging fruit toward improving the cl ecosystem and attracting new loners. I think once people get the confidence to read and write lisp codebases are much easier to digest than other languages. Which I think is partly responsible for the crap doc situation. But if you think about it this also makes lisp in some sense the perfect open source language.Kudos to things like the cookbook tho !	medo-bear	15.124118	-3.959512	comment	3.0	10.0	1706131378	-10.429803
39143416	I keep trying to dedicate time to ge	"I keep trying to dedicate time to getting comfortable with lisp, and it hasn't happened yet. So I just live vicariously through posts about lisps.One thing that stands out about them is that they're all so happy.  Try it. Search up a HN post about a Lisp. They'll be using words like ""joyful"".So my theory is that while lisp may have plenty of technical merits, part of why it's so great is that it's typically being used by people who are having fun.That's not to say that it would perform poorly if used under duress, but maybe there's some wisdom in not putting that experience that you enjoy anywhere near drudgery, lest it become contaminated."	__MatrixMan__	15.14948	-3.939512	comment	3.0	22.0	1706281496	-10.475407
39143722	I spent quite a bit of effort seekin	I spent quite a bit of effort seeking Lisp Enlightenment (TM) because of the happy people using Lisp that you mention[0]. The fact that Lisp is not used more commonly for practical applications is actually a great source of frustration for me now, and I think I share that experience with many other people who enjoy using Lisp.The thing about Lisp is that when you get used to it, you realize how needlessly obtuse so much of programming is today. So much effort has been spent making programming harder and harder to understand.At this point I truly think that if Lisp had won, the world would be quite a different place for the better. We live in a world where the average person thinks that a terminal emulator is an error window, and coding is something they identify as not being able to do. Li	Zambyte	15.1473255	-3.944201	comment	3.0	13.0	1706282876	-10.465695
39183401	My take on Lisp after going (partway	My take on Lisp after going (partway) through SICP, is that it's a syntax and not so much a language. The language is what you build up for the particular kinds of things you need to do. This is both the strength and weakness of Lisp, with a tight-knit competent team, everything is elegantly achievable. However on a small/understaffed team or one with high turnover, each member has to onboard onto that team's language built using Lisp.Imagine the best and worst DSLs that you've had to use. Joining a Lisp team would be somewhere on that spectrum though I hope their homegrown/app language is far better than the average/bad DSL.Clojure is much better in that it has many 'batteries included' and opinions on things to make different codebases less different than with other Lisps.	karmakaze	15.127973	-3.968976	comment	3.0	11.0	1706566082	-10.77458
39189430	"> (function arg1 arg2)
> 
> Instead "	"> (function arg1 arg2)
> 
> Instead of
> 
> function(arg1, arg2)That isn't the problem of learning Lisp. The problem with learning Lisp is   (`a ,b c)

and the infinite power thus infinite responsibility of the wizard programmer.> There is plenty of ""lowest common denominator"" code like this written in Lisp. Much Lisp code is not buried under inscrutable macros, just like not all Java code is buried under layers of inscrutable classes.But the problem remains: it only takes one wizard to make reading code impossible by outsiders.The canonical way to write a Lisp system is to define a DSL (or, should I say, system-specific language) and implement the system in that. But this means no-one outside of the language/system developers know the language, this means Lisp tends to be write-only by de"	baq	15.133793	-3.960061	comment	3.0	10.0	1706618610	-10.383036
39347049	alists and plists are a much closer 	alists and plists are a much closer lisp analog to python's dicts though	NikkiA	15.101331	-3.9926033	comment	3.0	10.0	1707756357	-10.177853
18051762	Lisp in Dart 2.0	Lisp in Dart 2.0	tosh	15.142658	-3.953621	story	3.0	105.0	1537719610	-13.910217
18129261	People have described Forth as Lisp 	People have described Forth as Lisp without the parentheses.Definitely some interesting parallels.	macintux	15.104113	-3.9750843	comment	3.0	14.0	1538566703	-10.366293
18163743	2008:  I never thought I'd be walkin	2008:  I never thought I'd be walking around with a full Unix machine in my pocket.2018:  I never thought I'd be walking around with a full Symbolics Lisp Machine in my pocket.	thought_alarm	15.113942	-3.9497488	comment	3.0	10.0	1538965398	-10.263914
18185116	There are 'bad things' in any progra	There are 'bad things' in any programming language.Common Lisp is actually quite a bit more advanced out of the box than Emacs Lisp: lexical binding, excellent error handling, good support for compilation, extensive object-oriented features, it has multiple implementations with independet code bases, implementations with threading, ...CL has been used to develop Emacs editors already.But the thing is a non-starter. There are a few million lines of Emacs Lisp for a specific editor, which nobody will rewrite.	lispm	15.101561	-3.9690657	comment	3.0	13.0	1539181514	-1.4242789
18193166	>>For example on the Deep Space One 	>>For example on the Deep Space One spaceship the application was deployed with LispWorks>>Imagine your application is a CAD system written in Common Lisp with CLOS (there are and were a bunch of those).For some one considering seriously writing Lisp as a full time job, are these kind of opportunities still there?I mean how big is Common Lisp usage these days?	kamaal	15.143819	-3.9474583	comment	3.0	11.0	1539263259	-10.469506
18193342	The one that kills me, every time I 	The one that kills me, every time I look at CL, is the lack of a real Boolean type. Maybe I'm nuts, but that really isn't acceptable in this century.	s_kilk	15.054367	-4.007033	comment	3.0	17.0	1539264635	-10.373745
18193377	I think most programmers today would	I think most programmers today wouldn't have heard about Lisp Machines.Unless some one describes it to us, we wouldn't even know what that experience even felt like.	kamaal	15.139742	-3.937559	comment	3.0	19.0	1539264939	-10.430471
18193754	The sad part in all this is, many pe	The sad part in all this is, many people like me will never see how Lisp Machines worked, what it mean't to use and how the overall experience was.This is really like some one describing Ice Cream to a person who never tasted it ever.	kamaal	15.147994	-3.9354017	comment	3.0	11.0	1539267752	-10.474384
18215921	This is cool. I wrote a similar Lisp	This is cool. I wrote a similar Lisp but got stuck debugging my copying GC. The interaction between the Lisp environment chain and the C stack is tricky.I prefer something like this over Norvig's Lisp interpreter written in Python. Norvig's is good for understanding environments and eval/apply, but IMO it's cheating to use the host language's GC for allocations.I would add integers, even if it costs a few lines of code... using `itos` and re-parsing the string when evaluating an int is just too painful for me.	blt	15.11594	-3.972053	comment	3.0	12.0	1539556506	-10.345681
18226339	Lisp - oh what it could have been. I	Lisp - oh what it could have been. It had such potential, but then it got broken. I find it fascinating that those who are dedicated to the proselytisation of Lisp don't see the brokenness of the language. For them, all of the broken things are the features of the language.Scheme was one attempt to fix some of those flaws.In latter times, we see the development of Kernel to fix other flaws.So many second class citizens, so many exceptions to the rule.I am going through the source code for Maxima CAS (written in Lisp) and in so many ways, it's a mess. I am not at all disparaging those who have been involved in writing the Maxima CAS system and its source. They have done an incredible job and what they have achieved is remarkable.However, like any software system of any complexity in any lan	oldandtired	15.134748	-3.95665	comment	3.0	28.0	1539662252	-10.462807
18227690	Well, at some point we have to face 	"Well, at some point we have to face reality. There have been hundreds if not thousands of successful projects with teams of hundreds if not thousands of developers working on them, at the same time or over time. These projects have been generally in Cobol (ok, we can chalk that up to brute forcing a tech from they didn't know any better), C, C++, Java, C#.There seems to be a connection between scaling a project regarding developer numbers and programming language ""power"". Having a smaller, shared vocabulary seems to greatly outweigh programming language ""power"" as the number of programmers goes up greatly.Lisp had 60 years to prove its human scaling capabilities. So far it hasn't convinced."	oblio	15.12981	-3.9540105	comment	3.0	20.0	1539678810	-10.472391
18227975	I know about that the whole lime - l	I know about that the whole lime - lemon thing. Two things:1. That was before the scientific age. They didn't know about vitamin C at the time, they couldn't even see it, even if they'd somehow believe in it.2. There is no scientific proof, 0, none, that Lisp is superior. And it's almost impossible to prove it, since it requires controlled studies at a large scale - good luck with taking away hundreds of productive programmers for that study :) All we have is hearsay and personal opinions.	oblio	15.145005	-3.940197	comment	3.0	12.0	1539682591	-10.430083
18228787	> You can write a lisp in a few line	"> You can write a lisp in a few lines of Forth.Seems unlikely. Forth isn't garbage collected, is untyped, etc etc. So you'd have to add those things in ""a few lines"".Though I guess it depends what you mean by ""a few"". I was thinking a couple of dozen. Looks like someone's done it in 500 (though without GC -- is that still Lisp?): https://forums.parallax.com/discussion/160027/lisp-technical..."	benhoyt	15.144393	-3.931003	comment	3.0	11.0	1539692969	-10.412374
29773141	The thing is that trying to understa	"The thing is that trying to understand ""the power of Lisp"" via the toy interpreter from The Roots of Lisp[0] is like trying to understand ""the beauty of the sea"" after seeing a single five-minute YouTube video explaining it.It will give you the basic idea, but it won't tell you about macros, reader macros, compiler macros, and having the whole language always available to build your abstractions on; it won't tell you about CLOS, including multiple dispatch, metaclasses, or method combinations; it won't tell you about the condition system and programming from inside the debugger; it won't tell you about live recompilation and live coding; it won't tell you about the JVM interoperability of Clojure, Kawa, or ABCL; it won't tell you about Racket's tower-of-languages approach to programming; I"	phoe-krk	15.087935	-4.020529	comment	3.0	64.0	1641153860	-10.900137
29773317	While I don’t disagree with Josh’s b	While I don’t disagree with Josh’s blog, concentrating on just language features leaves out the style of Lisp development: bottom up REPL style development. When I have to use Haskell or Python, I find myself working as if I were using Lisp: I still favor the REPL and building up from primitive functions to the top level application. This is probably a bad habit but it is the way I work. BTW, using the standard Emacs support for Python works very well: load a file, then re-evaluate just changed classes and functions (not Lisp, but a good work flow anyway).	mark_l_watson	15.116899	-3.9739194	comment	3.0	18.0	1641154694	-10.419821
29773935	I'm programming in Lisp (Chez Scheme	I'm programming in Lisp (Chez Scheme) now.I've been a serious Lisp programmer (recreationally and sometimes professionally) for around 10 years and I have programmed in Common Lisp, Scheme, my own weird dialects, Emacs Lisp, etc.At this point I feel like almost everything written about Lisp is silly. Taken as a language family as a whole, there isn't much that separates Lisp from most of the other languages that are out there _except_ syntax-transformations or macros which, frankly, most people should never use.For me, the best thing about Lisp is the regularity of the syntax. What I like least about almost all other programming languages is all the useless syntactic doodads and wingdings. The brackets, the indentation sensitive stuff, the unneeded complexity that languages insist on assoc	vincent-toups	15.125826	-3.96987	comment	3.0	11.0	1641157881	-10.423737
29857115	Funny, but the premise is insane: th	Funny, but the premise is insane: that Lisp is ful of things that are done better elsewhere and that Lisp is the weapon against bugs.  I worked professionally in Lisp (Scheme) and this is 100% false.  In my experience dynamically typed languages (incl. Lisp, Python, and Smalltalk) will absolutely be more bug prone than a good typed language (like Haskell or Rust) on non-trivial programs.	FullyFunctional	15.134274	-3.960261	comment	3.0	30.0	1641680721	-10.381239
29872943	Where Lisp Fails: At Turning People 	Where Lisp Fails: At Turning People into Fungible Cogs	signa11	15.149138	-3.9371471	story	3.0	4.0	1641812030	-10.472645
29896445	I probably don't have the Common Lis	I probably don't have the Common Lisp chops to comprehend them, but is any implementation of these macros available to browse?	twoodfin	15.125299	-3.9631026	comment	3.0	16.0	1641929049	-10.300262
29941558	I think there are people with more a	I think there are people with more and less strict definitions of what can be called a Lisp family language.  I believe I have seen one person who had a definition such that nothing but Common Lisp was a Lisp, not even Scheme.  I don't recall why, probably because their reasons did not make much sense to me.IMHO, I consider Common Lisp, Scheme, Clojure, Emacs Lisp, Autolisp, and a few others I'm forgetting about now a Lisp.  I prefer some over others, but I don't kick them out of my Lisp club because they have features I prefer less.	andy_fingerhut	15.144556	-3.9471405	comment	3.0	11.0	1642200381	-10.462219
29990059	"Why? Is there a reason other than ""m"	"Why? Is there a reason other than ""most people don't know lisp and it's cheaper not to teach them?"	boppo1	15.1513815	-3.9346387	comment	3.0	15.0	1642567526	-10.4773855
30005010	Common Lisp has a type system, if I 	Common Lisp has a type system, if I understood your meaning right.	darthrupert	15.13335	-3.9640086	comment	3.0	10.0	1642655961	-10.279658
30009687	"Just to add: the built-in ""Introduct"	"Just to add: the built-in ""Introduction to Programming in Emacs Lisp"" is also really really great.  I have been using emacs for a while, with one framework or another, but always hesitated actually learning lisp.  I was too focused on learning the kinds of languages and systems that might get me a job, and it felt like too big of a venture in learning a whole language just for my development environment.  Now, I have a given up on the employable thing, and have been enlightened by SICP and lispey languages, and in general, the simple beauty of Emacs itself, not just what I can make it do.  It takes only a little time to get comfortable with the nested (), and weird vocabulary, and it just really will click with you at some point, how simple it all really is, how every function bears on the"	beepbooptheory	15.125785	-3.9579039	comment	3.0	34.0	1642690815	-10.4488945
30011203	"How do you access the built-in ""Intr"	"How do you access the built-in ""Introduction to Programming in Emacs Lisp""?"	gypsyharlot	15.136163	-3.9452717	comment	3.0	27.0	1642696779	-10.427161
30046788	So is Lisp in good shape today? See 	So is Lisp in good shape today? See some cool releases of this year: https://www.reddit.com/r/Common_Lisp/comments/rp5lik/what_wa... CLOG (GUI in browser), M1 support for SBCL, LispWorks 8, VSCode plugin, Coalton (ML on top of CL), SB-SIMD and many new improvements to SBCL, new Clozure version, we know of more companies using CL...	vindarel	15.126489	-3.9581995	comment	3.0	14.0	1642951483	-10.461362
30126088	I guess it's my day to represent the	I guess it's my day to represent the Smug Lisp Weenie† faction of Hacker News?† https://wiki.c2.com/?SmugLispWeenieThis is what happens when you don't have user extensible syntax, you end up petitioning committees for... another way to write a threading macro.If you want macros so badly have you considered, wait for it, s-expressions?	samatman	15.108895	-3.9898818	comment	3.0	13.0	1643462744	-10.307077
30139627	Load McCLIM into SBCL. See https://g	Load McCLIM into SBCL. See https://github.com/McCLIM/McCLIM or https://mcclim.common-lisp.devIt's available also via Quicklisp.	lispm	15.13581	-3.9391897	comment	3.0	14.0	1643566961	-10.401339
30150044	I wanted to use an Emacs distributio	I wanted to use an Emacs distribution, but ended up against them as I've always preferred to just use the tool barebones and add on functionality when I need it. Maybe I'll dedicate some time to trying out Doom or Spacemacs and see if I am really missing anything that I haven't cobbled together from reading the built-in documentation and snippets of lisp.	AndroidKitKat	15.114781	-3.9581606	comment	3.0	12.0	1643647556	-10.381861
30174612	> It's really not that much more eff	> It's really not that much more efficient when you compare Lisps to modern languages that share features like interactive (REPL) development, garbage collection, large standard libraries, concurrency primitives and abstractions, object/functional programming styles, integrated package managers, etc.pick 2!But seriously, what modern languages have all these features?	duped	15.129681	-3.9621043	comment	3.0	23.0	1643784902	-10.446433
30177530	That’s fine, but I don’t see where o	"That’s fine, but I don’t see where one gets ""light years ahead of any programming IDE out there"" from that.I like Lisps/Schemes as much as the next person, but other languages don’t have parentheses to deal with, so by that same token, you’re getting that for free, such as an ML like F#."	bmitc	15.132246	-3.9549003	comment	3.0	10.0	1643810218	-10.434879
30177621	How do you convince good programmers	How do you convince good programmers to spend their life writing lisp? It's very hard to find lisp work after your company, so it kind of wasted years.	vbezhenar	15.147088	-3.9394841	comment	3.0	11.0	1643810575	-10.468507
30179572	The majority of programmers did not 	"The majority of programmers did not learn Lisp in college. Most universities don't have it in their curriculum, and if they do the closest is usually a ""programming language"" course that gives 1-2 weeks of coverage for 5-15 languages."	Jtsummers	15.1415615	-3.9472826	comment	3.0	11.0	1643818545	-10.457675
30187215	ok i couldn't resist ... Lisp is wri	ok i couldn't resist ... Lisp is written in Lisp :)	medo-bear	15.137865	-3.9438553	comment	3.0	14.0	1643852210	-10.439426
30314783	I've seen the talks from RacketCon a	"I've seen the talks from RacketCon about it, but I was not impressed this time. They never talk about ergonomics of editing code properly. With S-expressions I can always select any expression or sub expression, because there is a clear start and end marker. This is probably about tooling. You could probably build some language support for that for shrubbery syntax, but it is going to be hairy. I am not convinced support for that will ever be as good as the code editing experience with S-expressions. That is why already the readme makes me think: ""No!"":> Another disadvantage of S-expressions is that many of the parentheses are redundant after the expression is pretty-printed, because indentation provides the same grouping information in a more human-readable way.The parentheses are not red"	zelphirkalt	15.079583	-4.0176797	comment	3.0	12.0	1644688910	-10.280336
30317975	pretty much lisp macros with the con	pretty much lisp macros with the constraints of a compile language.haskell templates are similar.	dmead	15.109215	-3.9944725	comment	3.0	39.0	1644713675	-10.374775
30595973	Same here, I need something like thi	Same here, I need something like this for my Lisp interpreter. I was thinking about Simple Dynamic Strings but I like this better.https://github.com/willcipriano/Connery	willcipriano	15.105537	-3.9790657	comment	3.0	11.0	1646708645	-10.442076
30612770	Visible Lisp Computer: embedded real	Visible Lisp Computer: embedded real-time display of Lisp workspace using uLisp	Gollapalli	15.133593	-3.9371483	story	3.0	55.0	1646820064	-10.416914
18254451	My main beef with treating the Commo	My main beef with treating the Common Lisp spec as a sacred text is simple:1. There were things at the time that were not quite standardizable that are now. Examples: Some degree of concurrency, system definition, the CLOS meta-object protocol, networking.2. There are things that were created or became important in the meantime that should be standardizable now: Unicode and localization, concurrency building blocks like threads and locks and queues and atomic operations, cryptography, compression, higher level networking (URLs, HTTP, etc.).3. There are just bugs and holes and incompleteness in the standard due mostly to compromise from the then current vendors. For example, not everything fits the sequence protocols, the language isn’t CLOS all the way down, streams, etc.All this argues th	eschaton	15.130846	-3.958228	comment	3.0	36.0	1539927895	-10.468755
18257409	It's good because it offers the oppo	"It's good because it offers the opportunity to simplify and rationalize the type system and associated protocols without losing features.In the early 1990s I worked on an experimental Newton OS written in Dylan. At that time, Dylan was still called ""Ralph,"" and it was basically an implementation of Scheme in which all datatypes were CLOS classes. It was ""CLOS all the way down.""Ralph offered substantially the same affordances and conveniences as Common Lisp, but with a simpler and more coherent set of APIs. Ralph was easier to learn and remember, and easier to extend.To illustrate why, consider finite maps. The idea of a finite map is a convenient abstraction with a well-defined API. Common Lisp offers a couple of convenient ways to represent finite maps, and it's easy to build new represen"	mikelevins	15.129431	-3.9723077	comment	3.0	19.0	1539963174	-10.514347
18268167	What is the purpose of this? Educati	What is the purpose of this? Education? It sounds like yet another reinvention of Lisp.	another-cuppa	15.156272	-3.9329662	comment	3.0	18.0	1540132933	-10.494837
18309333	I thought it would be a down with Li	I thought it would be a down with Lisp article, but it was like my experience with the language, omg, how cool. From that ancient introduction to Lisp all I learned was that Lisp was as close to perfection and beauty as I would get in a programming language.	kleopullin	15.142542	-3.9501197	comment	3.0	76.0	1540562920	-10.436102
18309801	I would like to make the controversi	"I would like to make the controversial claim that homoiconicity counts against adoption; the single representation carries little structural information and the meaning of a symbol is highly dependent on its containing context. Whereas the ALGOL-derived languages use different types of bracket or other means to indicate visually what the semantics are.Ironically modern Javascript often replicates the bracket pileup, just with ""})"" instead. Python does away with it by having ""nonindented newline"" as an invisible semantic character that closes any number of scopes."	pjc50	15.094844	-3.9966533	comment	3.0	22.0	1540565944	-10.412669
18309424	If this presentation of Lisp and mod	If this presentation of Lisp and model of computation clicks with you, you owe it to yourself to read Structures and Interpretations of Computer Programs (SICP).The Abelson from the OP's lecture is the co-author, and the presentation described exactly follows the structure of the book (including the derivative example).It opened my eyes to a new way of thinking about coding when I first read it (and worked through the exercises) many years ago.	dharmon	15.145933	-3.9386477	comment	3.0	54.0	1540563580	-10.44919
18311198	All this could be done easily in C (	"All this could be done easily in C (function pointers, factorial for loop etc.). And sampling a function twice at 0.0001 dx's apart and calling it ""doing calculus"" is a stretch.The author seems to be making the case that, contrary to his original skepticism, Lisp is indeed some magical higher-order language, but I honestly don't see it. Lisp's ratio of philosophizing to noteworthy projects seems to tend toward infinity."	QuadrupleA	15.134618	-3.9572115	comment	3.0	14.0	1540574401	-10.388916
18312627	I think the thing that impressed the	"I think the thing that impressed the author at the time was more the fact that functions, being first-class values, can be introduced at runtime in a REPL, rather than having to be ""planned"" at compile time. So the C code isn't really analogous, but the Python code is.But re: the Python code—I would say that, from the perspective of the 1960s, all modern ""dynamic"" languages that have REPLs (like Python) are Lisps in essential character.""Lisp"", back then, referred less to ""a language that uses a lot of parentheses"", and more to things like:• runtime sum-typing using implicit tagged unions;• parameterization of functions using linked lists (or hash-maps) of paired interned-string ""keys"" and arbitrary product-typed values, rather than parameterization using bitflags or product-types of option"	derefr	15.128256	-3.9712927	comment	3.0	11.0	1540587147	-10.434957
18315698	> Presumably, this is because you've	"> Presumably, this is because you've looked at Lisp code, but you probably haven't understood Lisp.I'm not sure this is a great presumption. Someone can be familiar with lisps, understand the design choices involved, even deeply appretiate the beauty of the resulting language, while still prefering languages with a more flexible syntax> This is what people refer to when they mean that ""the brackets disappear after a while."" You're not focusing on them; they're handled by something else.This is exactly the problem. Lisps surrender the issue of syntax completely to the interpreter/compiler, which makes it easy for a machine to parse, but harder for a human. I personally prefer syntax to be designed for humans to read and write, because its going to be translated to something different to be "	joel_ms	15.110776	-3.994245	comment	3.0	12.0	1540648654	-10.332811
18336030	> They're trying to reinvent lisp, o	> They're trying to reinvent lisp, of course a much less efficient lisp.yes, please show us all those high performance libraries written in lisp	jcelerier	15.128286	-3.9522302	comment	3.0	11.0	1540904299	-10.436155
18343652	Fun with Symbolic Derivatives in Lis	Fun with Symbolic Derivatives in Lisp	taeric	15.126369	-3.962348	story	3.0	84.0	1540965852	-10.397972
18377215	It's actually quite amazing that it'	It's actually quite amazing that it's possible to run Lisp in 48k of RAM, but it is.http://www.flownet.com/ron/plisp.html	lisper	15.136866	-3.9396224	comment	3.0	15.0	1541355364	-10.4138155
18407123	> and you’ll see that SEXPRs are rig	> and you’ll see that SEXPRs are right there lurking barely beneath the surfaceThen why the surface? Why can't we just have a lisp with a good data-science library? Scheme seems the easiest of all the programming languages to me. I bet I can teach Scheme (not including advanced FP stuff though) to anybody faster than any other language although I have never used it to code anything serious (because libraries), I actually find it simpler than Python or even VBA. Phenomenally everybody seems so scared by the parentheses but these are not a serious problem given an intelligent IDE with proper outlining and highlighting.	qwerty456127	15.124724	-3.968186	comment	3.0	12.0	1541692698	-10.474434
18447014	Sorry if this is a hated question - 	Sorry if this is a hated question - but are all Lisp the same rats nest of parenthesis?ive always been interested in Lisp but that is so ugly - i would a JavaScript/Ruby/Python method chaining to 5 levels of nested parenthesis	svnpenn	15.101428	-3.996731	comment	3.0	14.0	1542163367	-10.356058
18477509	> The INCITS 226–1994 standard consi	> The INCITS 226–1994 standard consists of 1153 pages. This was only beaten by C++ ISO/IEC 14882:2011 standard with 1338 pages some 17 years after. C++ has to drag a bag of heritage though, it was not always that big. Common Lisp was created huge from the scratch.This is a surprisingly incorrect remark, given that the author is apparently fairly well aware of programming language history. Common Lisp is a relatively successful attempt to standardize and bring together a lot of different Lisp varieties that evolved over decades.	jorams	15.123457	-3.9630606	comment	3.0	15.0	1542490493	3.9817255
18505059	I don't see how that follows at all.	I don't see how that follows at all.If you're implying all program languages are derived from C, that's simply false. Lisp is based on the lambda calculus and predates C, as one easy counter-example.If you're implying that all languages run on top of C, that's also false. Theoretical Lisp Machines [0] have been envisioned which do not run C anywhere, and many languages (rust, go, etc) can be built into unikernals that run on real hardware with no C anywhere in the mix.As far as I can tell, your statement is both pointless and wrong in even a generous interpretation of it.[0]: https://en.wikipedia.org/wiki/Lisp_machine	TheDong	15.129082	-3.9585743	comment	3.0	35.0	1542826749	-10.410903
18505076	Show me a lisp which is used by enou	Show me a lisp which is used by enough people to fill a conference in 2018 that isn't implemented in C. Show me a lisp machine which was manufactured any time in the past 10 years.	Sir_Cmpwn	15.144662	-3.937978	comment	3.0	30.0	1542826851	-10.428196
18505465	The runtime is written in C. That's 	The runtime is written in C. That's the important bit. Just because the compiler, standard library, etc, isn't - doesn't mean it's not based on C. You cannot use SBCL without a C compiler.	Sir_Cmpwn	15.128721	-3.948119	comment	3.0	23.0	1542829870	-10.367866
18519382	I would also buy a Lisp Machine, pro	I would also buy a Lisp Machine, provided I could afford one. I'm really interested to see this software environment that I've heard spoken so highly of. What I've understood so far of it sounds amazing.	jolmg	15.130999	-3.9392862	comment	3.0	27.0	1543013790	-10.442956
18522036	C'mon, you are really proving gp rig	C'mon, you are really proving gp right here with that kind of superlative language. It's plain untrue. If the s/w was even very good for it's time, why would nobody have cared to just port it to a general purpose machine? After all LISP is all high level stuff, divorced from the hardware level. So, if the software was even just good, why did nobody care to carry it into the future?	_0ffh	15.13423	-3.9517672	comment	3.0	17.0	1543068138	-10.441466
18606985	Several languages seem to share this	Several languages seem to share this curse. You do see companies advertise it on language conferences or websites: Jane Street for OCaml, Remedy Entertainment for D-lang, Naughty Dog and ITA for Common Lisp. But you are often left wondering if it is the tip if the iceberg, or an accurate reflection of industry use. In the case of CL, you see multiple commercial implementations still being supported, indicating much more use than one would suspect from grepping github projects.A pattern I seem to observe is that if the program/framework/platform grows large and successful enough, the company gets acquired for its tech and everything gets rewritten in some more 'industry standard' language.edit: As pointed out, Jane Street advertises its OCaml use, not Haskell. Oops!	yvdriess	15.103251	-3.9801254	comment	3.0	11.0	1544004498	-10.559944
18617156	If you missed it, the tiny section o	If you missed it, the tiny section on ITS has some gems:When you connected to one of the ITs machines (even over the net) and wanted to log in, ECC suggests checking to see if anyone is logged in with the name you wanted and if not, login in with that name. Not create an account. “Logging in” in those days mainly set your home directory. No accounts, no passwordsThe command interpreter (shell in modern parlance) was the debugger, DDT.  If any program crashed you could debug in in situ rather (with all connections open, files open etc) rather than sifting through a core dump.  It’s ass if /bin/sh was gdb.Those were great days in a more civilised age.  You can see here where the mutability of the Lisp Machines came from.	gumby	15.100815	-3.9513974	comment	3.0	23.0	1544096506	-8.688293
18668805	"Instead of using a vague term like """	"Instead of using a vague term like ""power"", perhaps the LISP fans should promote the concept ""leverage"", whereby you can talk about getting a task done with the fewest words of code. Small LISP programs can be incredibly clever, and transformation languages like LISP and FORTH are well known to win every program-shortness contest. However Assembler has always been more powerful in the sense that you can do things in Assembler that you can't do in higher level languages, because there is no direct mapping from a higher level language to many of the special instructions that exist on modern chips. So using ""power"" is a lamentable word choice. LISP does have problems though, many consider it a ""write-only"" language which transfers very poorly to other programmers. You can measure transferabil"	magicmouse	15.129074	-3.9543622	comment	3.0	16.0	1544659769	-10.370913
18689985	I personally question the utility of	"I personally question the utility of such terseness, and much prefer the verbosity of the Lisp family of languages, where cultural norms make for function names like ""number-to-string"" and ""expand-file-name"", rather than the norms I've seen in languages like APL, K, J, Q, OCaml, and Haskell, which seem to love more mathematically-inspired single-letter names like ""n"" or ""k"", and various operators in a similar vein.The Lisp-like way of programming is more appealing to me because it makes the programs very easy to read.  You can mostly get a sense of what they're doing just by reading them like ordinary English.  I've found this especially useful when I'm trying to understand code I'm not already familiar with, or when looking at my own code months or years from when I wrote it, and it's esp"	pmoriarty	15.106757	-3.9881997	comment	3.0	12.0	1544903114	-10.381613
18710831	For a while, yes. I know from experi	For a while, yes. I know from experience that going the other way is a struggle as well. Habits die hard and change takes effort.There's nothing superior about these type systems, they're simply two of the most static and rigid systems in circulation right now.Try writing C, Lisp and Forth until it clicks. Then we can sit down and have an informed discussion about missing features.	sifoobar	15.126295	-3.9612343	comment	3.0	12.0	1545169209	-10.431517
18765008	"""Scheme"" implies a unified/central s"	"""Scheme"" implies a unified/central schemer, though. We can already call it a fad, or a mania (a la tulip mania)."	GavinMcG	15.104154	-3.9671435	comment	3.0	16.0	1545859143	-10.380148
18783140	> Compared to C, Python is the bette	> Compared to C, Python is the better choice. However, it seems like you haven't learned a Lisp dialect. I would love to know if you would still prefer Python once you know Scheme.the school I went used to teach C, Python and Scheme in the first year (nowadays it's C, Python and Racket). I don't think I remember more than one or two people actually liking the LISP experience, how bad it was when comparing to other languages is actually a common joke subject amongst alumni.	jcelerier	15.099746	-3.990097	comment	3.0	17.0	1546082854	13.371683
18842024	Isn't changing the head of a Lisp li	Isn't changing the head of a Lisp lisp by referring to the same tail from a new head an example of a persistent data structure?	chrisseaton	15.141552	-3.9345357	comment	3.0	20.0	1546824361	-10.523636
18855736	But that's because all the languages	But that's because all the languages you know are basically dialects of each other because they all descend from ALGOL, not because they are inherently easier to understand. Similarly, someone trained in Lisp would find things like Scheme and Clojure easier to understand than something like Python because those likewise are dialects of Lisp. I'd strongly recommend studying languages different from ones you know -- they are mind expanding even if you never use them in practice. Not just Lisp, but things like Haskell, OCAML/F#, and Prolog will change the way you think.	jhbadger	15.1237755	-3.9701786	comment	3.0	19.0	1546958349	-10.395333
18855896	> not because they are inherently ea	"> not because they are inherently easier to understandI'm honestly not sure that that's true. I would bet money that someone who primarily works in Lisp would still have an easier time sitting down and reading Python code than someone who works in Python sitting down and reading Lisp, because I think it might truly be inherently easier to understand.There is intrinsic meaning in:    x = 5
    let x = 5

etc., insofar as these translate character for character, word for word, into human language, whereas this simply doesn't:    (let (x 5))"	wycy	15.12385	-3.9767942	comment	3.0	15.0	1546959697	-10.406833
18908868	Arguments about labels are always te	"Arguments about labels are always tedious and fruitless.   They don't advance anybody's understanding of anything important, like the substance of the whatever those labels might apply to.  Arguing about whether or not ""Lisp"" means ""Common Lisp"" doesn't advance anybody's understanding of Common Lisp."	darkpuma	15.148777	-3.9400654	comment	3.0	12.0	1547526729	-10.4688425
18910975	I only skimmed, but parts of this ar	"I only skimmed, but parts of this article read as just another pro-LISP piece... A rant against other languages (which the author terms ""DSLs"" simply because they're not Turing complete) like LaTeX, HTML, regex, SQL etc. and lists alternatives, all of which are S-expression-based. Well, the superiority of S-expressions is just, like, your opinion, man. Personally, I consider them inferior to pretty much any other syntax (joke languages like Brainfuck, Whitespace, JavaScript excluded). An in absolute terms, the whole civilisation was built on syntax-full DSLs (law, math, engineering, ...).I mean, how is this (Skribilo):     (define (freedom . body)
       (ref :url ""http://www.gnu.org/philosophy/free-sw.html"" :text body))

     (p [Skribilo is a ,(freedom [free]) document production tool th"	tomp	15.100359	-4.0119553	comment	3.0	17.0	1547559039	-10.352464
18912583	I'm not sure it should really count 	"I'm not sure it should really count as a ""Lisp book"", but The Art of the Metaobject Protocol"" is one of my favorite technical books ever.It takes some knocks for not really containing anything about how to use CLOS. Instead, it's how CLOS is built. At a higher level, it's ""how to build an object-oriented language/object system from scratch"" using Lisp as a vehicle."	deong	15.140984	-3.9448912	comment	3.0	15.0	1547571439	-10.431688
18920574	I’m actually surprised there isn’t a	I’m actually surprised there isn’t a library called libemacs.  It would fulfill the mythos and be really useful for a lot of tools.	protomyth	15.108957	-3.9480014	comment	3.0	11.0	1547644933	8.216577
17215837	I felt like seeing a lisp machine	I felt like seeing a lisp machine	agumonkey	15.150149	-3.9329104	comment	3.0	13.0	1527965936	-10.483457
17307598	I don't understand why HN hates R. H	I don't understand why HN hates R. HN loves lisp, and R as a language shares a much greater affinity with lisp languages than python or Go do. The language was born out of the original authors reading SICP (as statisticians). Sure, many of the users of R molded it to look like what they were used to (S), but that just highlights the powerful metaprogramming capabilities of the language.	wdkrnls	15.132765	-3.957235	comment	3.0	11.0	1528929548	-10.433423
17439828	LISP always makes me sad. It's a lan	LISP always makes me sad. It's a language from which all modern languages could learn so much (and currently a lot of features of LISP get cloned). LISP Machines pioneered basically 90% of what modern computers and the internet do today.Yet, it's a very niche language, an almost forgotten artifact of time.	zaarn	15.141632	-3.950773	comment	3.0	99.0	1530515663	-10.474773
17440124	Languages don't create unmaintainabl	Languages don't create unmaintainable code, people do. I don't get why there's such hate against Lisp. (Granted, as others have noted, the author of this paper obviously drank from the Lisp kool-aid fountain)	quantisan	15.134208	-3.9579346	comment	3.0	19.0	1530520414	-10.450711
17440318	"If you think that is why Lisp is a """	"If you think that is why Lisp is a ""niche language"" then you should check out C. It has a ""preprocessor"" and you can do all kinds of things that make it hard to read your code, yet it is by any metric very popular, which provides a counterexample to your claim that ""There is little demand for programming languages that are hard to maintain."" Check out [1] for a few examples.[1] https://www.cise.ufl.edu/~manuel/obfuscate/obfuscate.html"	bachmeier	15.131285	-3.9657109	comment	3.0	17.0	1530523284	-10.450132
17441516	Modern languages have learned a lot 	Modern languages have learned a lot from Lisp. In fact they've stolen just about every major feature from it, except for s-expr syntax. Which should tell you something about s-expr syntax.	cageface	15.1109085	-3.984789	comment	3.0	19.0	1530538959	-10.401644
17480678	SBCL is together with luajit the fas	SBCL is together with luajit the fastest dynamic programming implementation there is. It runs laps around things like python and ruby. It does not have a steep learning curve. You become quite capable quite fast,but there is a lot to an implementation like SBCL and it will take a long time to understand all of it.The metaprogramming utilities of lisp are still unmatched.Scheme (my daily driver) is a smaller language. It consists of a small set of well chosen primitives that easily compose to build higher abstractions. It is really nice to work with.	bjoli	15.125631	-3.9526038	comment	3.0	15.0	1530998752	-10.40868
17507457	Debugging is an extraordinarily firs	Debugging is an extraordinarily first-class, up-front, frequent activity in Common Lisp, as the facilities are built into the language itself. While Lisp gets a lot of flak for basically (up to a few daring power-user exceptions) requiring Emacs, SLIME/SLY [1,2] are environments that will make you feel closer to your program than you get in other environments, including graphical IDEs.Given that the normal way to develop a Lisp program is to do it incrementally, your program (or someone else’s!) will break, and it will break often, and you’ll get launched into an interactive debugger. But it’s friendly, not requiring a completely separate, foreign toolchain, and much of the functionality works regardless of which editors/IDEs you’re using (though Emacs makes the experience much more ergono	reikonomusha	15.105166	-3.9685123	comment	3.0	16.0	1531321389	-10.373777
17524240	Remind me again... what's wrong with	Remind me again... what's wrong with common-lisp:read?	slyrus	15.157209	-3.932152	comment	3.0	10.0	1531498681	-10.457043
17533697	For what it's worth, on a fairly rec	"For what it's worth, on a fairly recent SBCL, here's what the compiler/interpreter prints when you enter the author's function:  ~> sbcl
  This is SBCL 1.4.7, an implementation of ANSI Common Lisp.
  More information about SBCL is available at <http://www.sbcl.org/>.
  
  SBCL is free software, provided as is, with absolutely no warranty.
  It is mostly in the public domain; some portions are provided under
  BSD-style licenses.  See the CREDITS and COPYING files in the
  distribution for more information.
  * (defun add-text-padding (str &key padding newline)
    ""Add padding to text STR. Every line except for the first one, will be
  prefixed with PADDING spaces. If NEWLINE is non-NIL, newline character will
  be prepended to the text making it start on the next line with padding
  appli"	waterhouse	15.124179	-3.9535885	comment	3.0	11.0	1531626586	-10.389798
17535175	>for example .NET’s LINQ cannot be e	>for example .NET’s LINQ cannot be expressed in LISP, not unless you add a static type systemDoesn't that imply that Lisp, sans-static typing, is not Turing-Complete?  Surely that is not the case.	na85	15.101665	-3.9945023	comment	3.0	14.0	1531661912	-10.181728
17535185	>Speaking of tests, recently I disco	">Speaking of tests, recently I discovered that Zach Beane AKA Xach, an über-level Common Lisp hacker doesn’t usually write tests. FYI, he is the author of Quicklisp, that is something like (but not quite) Cabal or Stack. Quicklisp is de-facto the only widely used library manager in Common Lisp world, and so it’s written in Common Lisp and doesn’t have any tests. It’s a wonder for me how it’s not breaking!Why is it ""a wonder""? We could, and did, write robust code, for decades before testing and TDD became a thing."	coldtea	15.134944	-3.954198	comment	3.0	11.0	1531662069	-10.431347
17535918	What are the core features that diff	What are the core features that differentiate Arc from other lisp dialects?	georgewsinger	15.145268	-3.9473765	comment	3.0	31.0	1531672551	-10.494109
17563279	I donnot like any lisp implemented b	I donnot like any lisp implemented by Java, very bad taste of developer already.	hk-mars	15.146009	-3.9467525	comment	3.0	12.0	1531961959	-10.425223
17605954	Workshop on the Psychological Realit	Workshop on the Psychological Reality of Lisp (1981)	kazinator	15.155068	-3.9323466	story	3.0	25.0	1532477372	-10.48172
17666977	Do you need to have a solid foundati	Do you need to have a solid foundation in lisp to understand it or is it approachable for experienced software developers in other domains?	aidos	15.147858	-3.9396758	comment	3.0	13.0	1533157433	-10.468236
17667995	You can write lisp-y python quite ea	You can write lisp-y python quite easily. It's not good, pythonic or maintainable, but for learning purposes it is acceptable, especially on the 2.x series. Just start with list comprehensions.Lua and Ruby I fail to see how they are in any way lisp-y.	antt	15.10029	-3.9920974	comment	3.0	11.0	1533166102	-10.202516
17704725	This is, in fact, the story behind L	This is, in fact, the story behind Lisp Machines. Unfortunately, humans quickly forgot the lessons from the aliens, and made computing the mess it is today.The history is documented here: http://landoflisp.com/ (scroll down and follow the arrows).	TeMPOraL	15.140241	-3.936392	comment	3.0	12.0	1533630459	8.219643
17709144	The problem is all of this relies on	"The problem is all of this relies on a representation of the data structure you're manipulating. What exactly is the structure that a Lisp machine is manipulating?The basis of Lisp is the Lambda Calculus, and a generalization of that gets you term rewriting. Both the basis and the generalization of Lisp admit to requiring a tree (or a graph, in the case of Cons-cells) to get on with the computations, because that's the ""state"" that you're working with.The problem is that while these things in the minds of humans are pretty easy to work with, implementing them physically has you rely on things like the RAM model, which, while pretty far away from the Turing Machine, still has machine-like qualities.That's my argument. We can't really build ""Lisp Machines"", we can build ""Random Access Machin"	imode	15.115825	-3.975646	comment	3.0	10.0	1533666123	-10.47857
17739638	How Factor compiler is different fro	How Factor compiler is different from something like SBCL? It's interesting because Factor have plans to support ARM/Android/iOS, how hard to achieve these goals? It's interesting because Common Lisp's (SBCL, CCL), Scheme (Chez Scheme), Smalltalk (Pharo, Squeak) also have native compiler's, but no one have iOS/Android support, SBCL also have self-contained executables and ARM port. What are the biggest problems to these projects from having iOS/Android support.	pome	15.127003	-3.9501202	comment	3.0	13.0	1533995059	-10.422634
17763141	Thanks, that was a fun read. BTW, I 	Thanks, that was a fun read. BTW, I don’t think Richard totally dislikes Common Lisp: years ago I got an email from him about releasing my ancient Springer-Verlag Common Lisp book under the FSF documentation license. Unfortunately I couldn’t do it because I didn’t have the manuscript files.	mark_l_watson	15.152734	-3.9305146	comment	3.0	12.0	1534295101	-10.488414
17821951	Evaluating Vax Lisp 3.1	Evaluating Vax Lisp 3.1	mr_tyzic	15.144004	-3.936986	story	3.0	106.0	1534970421	-10.416047
17848185	Reminder that lisps are FP too.	Reminder that lisps are FP too.	Touche	15.148121	-3.939207	comment	3.0	10.0	1535320994	-10.479189
17858512	LISP sympathizer here:I don't need y	LISP sympathizer here:I don't need yet another theoretical exercise in how to do computation in LISP, I need a concrete example of how to load and use getopts LISP code to construct command line programs in CCL (for example with CLON and CCL). Programs written in ANSI Common LISP which behave like every other program found in /usr/bin and /usr/sbin.What LISP needs is more concrete examples solving everyday problems, like how to prop up a LISP web server? How to run LISP applications from one? How to perform string manipulation? Data extraction? How to connect to an Oracle database? SQLite database? How to package one's finished application into a pkgsrc or an RPM package? And so on, and so forth.I'm over the concepts, but that doesn't mean I know how to solve everyday problems with the lan	Annatar	15.124843	-3.9646761	comment	3.0	13.0	1535461825	-10.453323
16310017	S-Expressions (1997)	S-Expressions (1997)	panic	15.078066	-4.008407	story	3.0	125.0	1517849506	-10.309099
16313982	> The problem with these schemes is 	"> The problem with these schemes is that they're at odds with metaprogramming. One huge advantage of s-expressions is that the code is expressed using data literals.I don't think it is necessary for there to be a single uniform syntax for code to be able to fully leverage metaprogramming.Take for instance Mathematica (barring complexities of the evaluator itself...)  The underlying type for almost everything in the language is the ""expression,"" essentially a tagged list.  The front-end language, called ""standard form,"" can be converted to and from expressions.  Expressions can more-or-less be directly serialized as ""full form,"" which looks like McCarthy's M-expressions, and standard form extends this notation with operators and precedence rules. (Technically, standard form is given in a 2d"	kmill	15.055664	-4.04356	comment	3.0	17.0	1517883641	-10.35905
16388332	This is the most pedantic post I hav	This is the most pedantic post I have ever read on the subject. The point is that code is data, enough said. You manipulate your functions the same way you manipulate lists, because they are the same thing.Stuff like this is frankly why so many programmers shy away from lisp and s-expression based languages.	whalesalad	15.100264	-3.995308	comment	3.0	18.0	1518733481	-10.442796
16392837	One of the greatest lies that Lisper	"One of the greatest lies that Lispers have is: ""Lisp has no syntax"". Syntax is defined as ""the structure of statements in a computer language.""What Lisp has, and is, is a syntax to describe an AST. If you get the syntax wrong, your program won't run. And even that syntax isn't uniform across the various Lisps (some will throw in weird chars and constructs here and there to make dealing with common structures easier etc.)It does make it somewhat easier to manipulate code as data if you wish to. And it does somewhat make reasoning about some parts of your code somewhat easier. Is it that good as it's glorified to be?The author links to Korma as an example of the power of code as data, and macros:    (select users 
      (where {:active true})
      (order :created)
      (limit 5)
      (off"	dmitriid	15.1199255	-3.9772656	comment	3.0	10.0	1518793839	-10.392061
16397878	There is one more thing that frequen	There is one more thing that frequently comes up -- for good reason -- but is not really a feature unique to Lisp, only a strong part of Lisp culture: live coding, inspection, self-documentation and hotswapping, or what we call hackability.If you don't like how some Lisp application works, you can frequently just replace the contentious parts as the program is running. If something does not seem right, it is trivial to inspect all parts of the internal state. If you don't understand a variable, you can look up its documentation inside the running program.It's a fantastic experience.	kqr	15.106927	-3.9818993	comment	3.0	18.0	1518826401	-10.384707
16407572	I’d take advantage of this opportuni	I’d take advantage of this opportunity to start a discussion about a somewhat related article, the famed Blub article:http://www.paulgraham.com/avg.html> The more of an IT flavor the job descriptions had, the less dangerous the company was. The safest kind were the ones that wanted Oracle experience. You never had to worry about those. You were also safe if they said they wanted C++ or Java developers. If they wanted Perl or Python programmers, that would be a bit frightening-- that's starting to sound like a company where the technical side, at least, is run by real hackers. If I had ever seen a job posting looking for Lisp hackers, I would have been really worried.17 years later and I still don’t see all those Lisp startups :)I’d argue that 8) will never happen because the gap between hu	oblio	15.140643	-3.9415271	comment	3.0	47.0	1518980681	-10.411644
16407822	Reading the article, I'm a little bi	Reading the article, I'm a little bit curious - I've heard a lot that more productive languages become less productive over a certain team size, since productivity typically comes from a lesser degree of strictness.  Does lisp have similar problems?	pasabagi	15.138961	-3.9494452	comment	3.0	32.0	1518982737	-10.466947
16407972	Paul Graham's Viaweb was rewritten i	Paul Graham's Viaweb was rewritten in C++ and Perl after the aquisition by Yahoo. I can imagine that this was easier to deal with for a large team than the original implementation in Lisp.	rerx	15.144794	-3.9381073	comment	3.0	13.0	1518983682	-10.40834
16408458	Do you use them professionally?It se	Do you use them professionally?It seems to me that very few companies use Lisp-like languages used in production. Even Haskell seems more common.The big deal with using Lispy languages is that companies don't want to use them -- it's a lot easier to hire developers who know other languages. So, I'm stuck with Java whether I like it or not, and I appreciate any functional programming features that can be packed in to new Java releases, even if they end up being a bit clunky.	twblalock	15.124713	-3.973035	comment	3.0	10.0	1518986723	-10.503133
16412481	>So, if one isn't careful, it's poss	">So, if one isn't careful, it's possible to write a very clean, very nice Lisp DSL which is totally incomprehensible to anybody but the author, and thus hell to maintain over time.This is a myth. DSLs in Lisp are almost always done in Lisp syntax, no surprises. The idea of having a higher abstraction is to make the problem domain map more clearly to the code.>totally incomprehensible to anybody but the authorNow, what people who like to repeat this myth forget to say, is that when using an OOP language, say, Java, and using another's person code, one also needs to learn the classes that this person has created, the methods and how they interact. And this can be ""totally incomprehensible to anybody but the author"".>Relevant quoteNo, not relevant. Joel Spolsky is talking about device abstrac"	flavio81	15.132055	-3.9608624	comment	3.0	14.0	1519043800	-10.349195
36548330	I'm not suggesting we should stop st	I'm not suggesting we should stop striving for better programming languages or even that the status quo is good enough. My point was not to discourage innovation in Lisp or in any other language.Quite the contrary, I believe that the world of programming is constantly evolving and not revolving solely around whether Lisp is the best. There is a plethora of new languages being generated that are designed to solve problems in unique, innovative ways. For example, languages like Rust, Elixir, Go, and Haskell are much younger than Lisp and are great in their respective fields.You know, in some ways, the situation often seems reversed. Some Lisp enthusiasts treat non-Lispers as if they are yet to grasp 'the truth', implying that with enough effort and enlightenment, they too will understand and	submeta	15.140696	-3.948776	comment	3.0	13.0	1688203798	-10.46221
36550827	After reading many think-pieces evan	After reading many think-pieces evangelising LISP, I decided to get into it.However, I hate Emacs.Is this going to be a problem long term? Right now I'm entering code in a text editor, but I'm still solving toy learning problems only.	FredPret	15.090504	-3.9761434	comment	3.0	10.0	1688223571	-10.372451
36594502	That explains why Lisp is so conveni	That explains why Lisp is so convenient for implementing DSLs.  Homoiconicity skips all the bike shedding around syntax and parsing.	giovannibonetti	15.112817	-3.979759	comment	3.0	65.0	1688519909	-10.397784
36597138	> I know what I am talking about.Sor	"> I know what I am talking about.Sorry, but you manifestly don't:> there's no magic to them (compared to macros you could do as pre-processing in any other language)The ""magic"" of s-expressions is that they make it easy to operate on the source code of a program as a hierarchical data structure (i.e. as an AST) rather than as text.  That turns out to be an extremely powerful lever.  It is is one of the reasons Lisp has lasted as long and been as influential as it has.  I'm sorry if this sounds like an ad-hominem, but if you think there is ""no magic"" to S-expressions the most likely explanation is that you don't really understand them.  There is nothing comparable in any other language.  There's a reason that they are still in use today.  Indeed, there is a reason that they keep getting re-"	lisper	15.096329	-3.9960756	comment	3.0	24.0	1688543732	-10.3327465
36640417	Having never used a lisp machine, an	Having never used a lisp machine, and only having a basic understanding of it -- but if the whole system is a lisp image + apps are just calling into the OS as if they were lisp functions, woulden't a 'pure GPL' be problematic becuase EVERYTHING running in it would have to be GPL?  Are there clear linking boundaries in symbolics lisp between apps + the OS ?	jasonjayr	15.130566	-3.9494863	comment	3.0	21.0	1688779334	-10.412116
36641350	Program Edit and Continue is a fragi	Program Edit and Continue is a fragile self modifying C code hack that you would never dare try in production on a customer machine.It doesn't simply replace a function binding; it actually replaces code and puts the instruction pointer of existing threads that were running that code into some similar location in the new code. (Which is pretty amazing, to be sure).What's going on in Lisp code reloading is something a lot pedestrian; just new functions are replacing old ones. Thread which are in the middle of running the old functions continue with those ones. When the last thread is done executing a function, it can be garbage collected.	kazinator	15.096197	-3.9817333	comment	3.0	12.0	1688790563	-10.423991
36640984	I bet there is a valid argument that	I bet there is a valid argument that there’s nothing here of any commercial value anymore.The industry has gone beyond “catching up” to surpassing the values of the Lisp Machine and Genera. Any grand ideas of this era have been considered, and either mined, reimplemented, and exploited  or simply rejected as being past their time.The lack of a Lisp machine or environment like Genera is not holding Lisp (much less the entire modern family of Lisp-y languages) back. And modern IDEs are off the charts, even if they don’t check every single box of what Genera has to offer.As an industry, we’ve not just stood on the shoulders of giants of the past like Genera, we’ve stepped off and up and moved ahead.I’ve seen the Genera image that’s floating around, it ran in a VM of some kind. There’s a coupl	whartung	15.14087	-3.939473	comment	3.0	24.0	1688785180	-10.425602
36669039	Lisp stat landing page basically sou	Lisp stat landing page basically sounds like Julia, except they “kept” the syntax and it can compile.I don’t know how mature it is, but it’s sale pitch really speaks to me.https://lisp-stat.dev/	wodenokoto	15.131482	-3.9507828	comment	3.0	13.0	1689007741	-10.542489
36700578	It's interesting that folks go down 	It's interesting that folks go down this hacky route when they can use something like Vespa, which is orders of magnitude better from a performance, relevance, scalability, and developer ergonomics perspective.	binarymax	15.06537	-3.9629993	comment	3.0	16.0	1689191038	-10.406488
36713595	Ask HN: What Were the Differences Be	Ask HN: What Were the Differences Between Symbolics Genera and Xerox Interlisp-D	linguae	15.137411	-3.9419034	story	3.0	8.0	1689271768	-10.42319
36754590	I well remember the epiphany I felt 	I well remember the epiphany I felt while learning Logo in elementary school, at the moment I understood what recursion is.While I have never worked as a professional software developer, computers have been a hobby all my life. I don't think the fact that the language I have mostly written code in in recent years is Emacs Lisp is unrelated to the above moment.	ylee	15.117562	-3.9568007	comment	3.0	10.0	1689572953	-10.376885
36887538	Sorry that was unclear. What I meant	Sorry that was unclear. What I meant was: a while back, I was exploring Scheme (motivated by SICP) and then ran out of free time. Now, I’ve got some free time again and want to try Common Lisp because of the REPL-driven workflow.It wasn’t meant to be a comment on Scheme vs. CL.	schemescape	15.139967	-3.9437327	comment	3.0	10.0	1690420198	-10.476929
36887967	Lots of languages that are not lisp 	Lots of languages that are not lisp have this ability.	dleslie	15.13653	-3.955255	comment	3.0	22.0	1690423533	-10.418283
36889812	">The ""Wolfram Language"" user typical"	">The ""Wolfram Language"" user typically does not write code in FullForm. It's used as an internal representation.I have no clue what you're talking about - it's an available primitive and I use it all the time.>and not so good at compiling code...Lol I am 100% sure that the majority of lisps cannot be aot compiled."	mathisfun123	15.127238	-3.9646306	comment	3.0	18.0	1690440176	-10.444073
36890072	> FullForm Plus[a, b]How can I make 	> FullForm Plus[a, b]How can I make this any more clear? You are able, in Mathematica, to write Plus[a, b] with your own fingers on your own keyboard and it will be interpreted as the same thing as a+b> I'd expect that they can.Clisp is not the only lisp - I can name 10 others that cannot be compiled.	mathisfun123	15.042859	-4.0297084	comment	3.0	12.0	1690442337	-6.9519944
24473067	I don't know anything about Emacs Li	"I don't know anything about Emacs Lisp. Why is it ""objectively bad?"""	boring_twenties	15.13196	-3.9535663	comment	3.0	12.0	1600106171	-10.410754
24581256	For a very simple, very readable Lis	"For a very simple, very readable Lisp reader, see Lumen's reader.l file: https://github.com/sctb/lumen/blob/master/reader.lIt compiles to Javacript and Lua, so if you prefer reading those, you can:https://github.com/sctb/lumen/blob/master/bin/reader.jshttps://github.com/sctb/lumen/blob/master/bin/reader.luaIt turns out that you can greatly simplify the code by e.g. ""does an atom start with 0x, 0-9, or dash? if so, try converting it to a number.""That turns out to handle cases like 1e9 too. Whereas ""1e"" becomes a valid lisp symbol. So you can set it to your own value.The emacs source code is also worth reading. It's not simple, but it's simple enough to be und"	sillysaurusx	15.126364	-3.9545958	comment	3.0	17.0	1600969454	-10.290846
24643754	Lisp's Mysterious Tuple Problem	Lisp's Mysterious Tuple Problem	fishmaster	15.143589	-3.940231	story	3.0	2.0	1601499507	-10.484363
24717118	Just tried the code in SBCL and it d	"Just tried the code in SBCL and it definitely gives a compiler warning even without executing the function:    This is SBCL 1.5.6, an implementation of ANSI Common Lisp.
    More information about SBCL is available at <http://www.sbcl.org/>.
    
    SBCL is free software, provided as is, with absolutely no warranty.
    It is mostly in the public domain; some portions are provided under
    BSD-style licenses.  See the CREDITS and COPYING files in the
    distribution for more information.
    * (defun add-text-padding (str &key padding newline)
      ""Add padding to text STR. Every line except for the first one, will be
    prefixed with PADDING spaces. If NEWLINE is non-NIL, newline character will
    be prepended to the text making it start on the next line with padding
    applied to "	dunefox	15.1227	-3.949939	comment	3.0	19.0	1602145785	-10.39939
24717279	Note that this is on SBCL 1.5.6 whic	Note that this is on SBCL 1.5.6 which is a little bit over a year old at this point; the article is from 2015 so we should pick a properly dated version from https://sourceforge.net/projects/sbcl/files/sbcl/ and check there.The Common Lisp implementations and compilers keep on getting better with time and they produce more and more compile-time warnings (especially SBCL).	phoe-krk	15.12746	-3.9456751	comment	3.0	10.0	1602147787	-10.399886
38756210	It's funny how that sort of immediac	It's funny how that sort of immediacy is what people like about lisps, but to my knowledge there is nothing like the RAD interface Lazarus and Delphi have in the open source lisp world.	regularfry	15.138594	-3.943847	comment	3.0	10.0	1703447409	-10.462602
38766129	The description of Lisp machines sou	The description of Lisp machines sounds a lot like running Emacs in a way. Is Emacs… just a Lisp machine emulator?!(There is a lot I dislike about Emacs Lisp; there is a lot of power in it though. :)	ashton314	15.134576	-3.9458983	comment	3.0	11.0	1703538572	-10.420279
31806497	Common Lisp does by default. Calling	Common Lisp does by default. Calling (/ 1 3) gives 1/3 which is a rational. The individual components of a rational number are bignums, so the size of the fraction is only limited to available RAM.However, this is not enough in many cases. For example, how would you store pi? In the case of Lisp, pi is stored as a floating point number, and the conversion rules say that a mathematical operation between a rational and a floating point number yields a floating point number. This means that even though you have rational numbers, you still have to be aware of floating point.	lokedhs	15.092294	-3.9847822	comment	3.0	10.0	1655701738	-10.38168
31811268	Why is it easy to implement a Lisp?	Why is it easy to implement a Lisp?	Tomte	15.142951	-3.9433496	story	3.0	19.0	1655737757	-10.449752
31934970	I know it's a total pipe dream, but 	I know it's a total pipe dream, but this is what makes me most sad about lisp never being taken seriously.It could have been common practice to create and pull in new language constructs like what this is doing.	spicybright	15.142184	-3.9477618	comment	3.0	18.0	1656606775	-10.45133
32044678	Could you expand on the REPL bit? Ha	Could you expand on the REPL bit? Having worked with JS, Python and Elixir, they feel more or less the same. What’s Lisps have that these don’t?	slekker	15.128898	-3.948122	comment	3.0	12.0	1657460534	-10.429823
32047285	This is a nice write up.The dark sid	"This is a nice write up.The dark side is that they've put years into developing the core infrastructure to empower their Lisp game journey. Ideally that's all usable by others to ""stand on the shoulders"", so to speak, but that's always a challenge.I honestly have never had to work on a ""running image"" of any consequence. I've never worked on anything more than a few thousand lines of code. I've never needed any kind of source level ""step"" debugging. The ability to redefine a function quickly, I just throw in some prints to figure something out.Reloading the entire source file was always fast enough to now warrant hunting down any of the more interactive mechanisms available. This is all across using simple vi, or emacs, or even LispWorks.  (defun l () (load ""src.lisp""))

Just save the file"	whartung	15.087598	-3.9670508	comment	3.0	11.0	1657476879	-10.439469
32057728	I have a theory about it, as someone	I have a theory about it, as someone who used Lisp since 1987 and Scheme more thereafter:  there's no concise version of what https://docs.python.org is and that makes ALL the difference.I know what exists, have the books, etc, but nothing is as well organized to be as easily searchable and without digression as what the Python world has set up for itself.	jjtheblunt	15.096016	-3.9938614	comment	3.0	15.0	1657554587	-10.17571
32059913	Ah, a Lisp user. Common Lisp is Exhi	Ah, a Lisp user. Common Lisp is Exhibit A for standardization. Every Lisp user claims it is great because of either standardization of advanced features in the days when the Berlin Wall has barely fallen or the mere existence of macros. No real first-party improvement to the language in almost three decades after ANSI standardisation. Massive fragmentation in the compiler ecosystem, rarely do libraries work out of the box on non-SBCL tooling.  Yes, I can definitely see the advantage of standardization now, very much so.	melony	15.134833	-3.9637716	comment	3.0	21.0	1657564440	-10.477115
32095845	One of the nice things about Lisp is	One of the nice things about Lisp is there are no statements, only expressions.  It's easier to think about your code.Lisp was the first language I used (other than assembly code) so when I encountered C I was puzzled why they even bothered to have statements at all.  40 years later I still don't understand the point.	gumby	15.112264	-3.983436	comment	3.0	16.0	1657805371	-10.350962
32122683	This looks very interesting, there i	This looks very interesting, there is definitely need for SBOM generators that can handle multiple languages.Do HN got a recommendation for other CLI based SBOM generators?Dependency Track is too resource intensive for a small scale company, I just need a simple CLI based SBOM generator that can handle C++ (conan), Python and Go.	DethNinja	15.119364	-3.957495	comment	3.0	15.0	1658011907	-10.431995
32177403	Could you elaborate on this a bit ? 	Could you elaborate on this a bit ? Lisp has next to no numerical libraries IIRC ?	tpejrl23432	15.127227	-3.9577637	comment	3.0	18.0	1658397012	-10.414237
32266462	Cmacro: Lisp Macros for C	Cmacro: Lisp Macros for C	thesephist	15.057087	-4.0350304	story	3.0	67.0	1659025281	-10.285913
32372833	So it's Lisp with uglier syntax?	So it's Lisp with uglier syntax?	jlarocco	15.127631	-3.9612253	comment	3.0	10.0	1659832611	-10.420887
32458238	Emacs would be a fine choice, but is	Emacs would be a fine choice, but is not mandatory, if you can live with less support for parens found in other editors. Emacs traditionally excels at working with lispy languages and REPLs.I started working through the book, but did not feel like using Common Lisp. Instead I used GNU Guile. I am not very far in the book yet, but so far I was able to translate between Common Lisp and Scheme easily.So for me the way to set things up was to install GNU Guile. I did that via GNU Guix package manager. However, GNU Guix can also install SBCL, so that you could use Common Lisp as the book does. SBCL is also in many distros' repositories.	zelphirkalt	15.131935	-3.9484613	comment	3.0	17.0	1660474610	-10.352767
32480909	Why Lisp is the most productive prog	Why Lisp is the most productive programming language [video]	gibsonf1	15.136796	-3.9498997	story	3.0	3.0	1660643437	-10.496559
22032753	Depends on what you are implementing	Depends on what you are implementing and how.I find Lisp good if you have a rough top-down design and lots of bottom-up implementation details to suss-out. You can test each bit as you build and in passing you might implement a DSL for your domain.  There are many compiled Lisps (both CL and Scheme) so performance can be quite good.Generally, it is hard to deploy Lisp on client systems (if that is a requirement) without introducing many dependencies. Loko Scheme being an exception, since it (like Golang) compiles to a single executable with no dependencies.GC and VMs are common in many alternative environments so that's not a point of difference.If you like Lisp and your dev and target environments are suitable and you are a solo developer or have a team of Lispers then why not use it?  In	CyberFonic	15.142763	-3.9430735	comment	3.0	11.0	1578903725	-10.448556
22063792	IMO Lisp is just overrated, it lacks	IMO Lisp is just overrated, it lacks visual clues, reads right to left with horrible nesting etc..Sure it has some good concepts. But fanboys on internet make it seem like some God tier thing.	terminaljunkid	15.148588	-3.9361844	comment	3.0	59.0	1579177013	-10.452796
22087621	I'm glad that Lisp is not used in sp	I'm glad that Lisp is not used in spacecraft control system.	zerr	15.152133	-3.9329276	comment	3.0	37.0	1579385202	-10.466486
22087656	This just reminds me of how many tim	"This just reminds me of how many times I've been told things like ""you can't use that java code that is open source and working and does exactly what we want - we're a python shop!"" and other such nonsenses.I'm always amazed at how people have strong feelings for the tools/languages, rather than what they do and how they can help you.  Even in this example, the Google person didn't even ask what they wanted to use Lisp for.People I guess just really like rewriting software in different languages?"	cbanek	15.101383	-3.9811172	comment	3.0	17.0	1579385508	-10.412704
22087937	When was the last time you saw a kid	"When was the last time you saw a kid who made a cool game or software and made money using LISP?The best motivator is recognition. Kids don't care if a language has books and whether there ""exists"" a game development kit. They only care about how much satisfaction they will get by learning something and building something with it.If you want your kid to learn programming, the best approach is to teach them Swift or Java, or Javascript, so they can build a mobile app or web app and show off to their friends. And they will get the joy of building something that is actually used by others. That's how you get people to be interested.LISP won't get you anywhere in that sense. Sure you may learn some programming concepts, but the ROI is not worth it. Kids might as well spend a bit more effort to"	cocktailpeanuts	15.146681	-3.935527	comment	3.0	17.0	1579387821	-10.557188
22088634	From my point of view, Lisp gives pr	"From my point of view, Lisp gives programmers too much power.
No company wants giving a programmer so much concentrated power, they want it distributed around the workforce, and people disposable. Replace them whenever is needed.With lisp you can modify your development platform to suit your needs, In practice, over time you create your own programming language.You create your DSP(Domain specific language) with your own systems. This is not standard. You are dependent on the programmer.Companies prefer to buy ""solutions""(packages,environments) from companies and depend on those solutions. They are standard and you can hire people trained on them. Replace them if needed and make people continue the work that someone else left.That is because ""solutions"" have open documentation, designed by "	pritovido	15.1389475	-3.9501956	comment	3.0	11.0	1579396263	-10.443182
22088885	That's a good question.  The honest 	That's a good question.  The honest answer is I don't know.  It's hard to do controlled experiments on this sort of thing.I can say this though: the ability to meta-abstract the language is a HUGE lever that no other language has.  And one can also observe subsets of Common Lisp being continually re-invented in other languages.  So CL must have gotten something right.	lisper	15.134753	-3.9484904	comment	3.0	15.0	1579399871	-10.465186
22088000	Do you use Lisp at your workplace? I	Do you use Lisp at your workplace? I see it defended a lot but few people I meet actually use it (I've met one full-time Lisp developer in my life!)	exdsq	15.140002	-3.9371026	comment	3.0	10.0	1579388590	-10.463069
22088662	> I can get things done in Lisp with	> I can get things done in Lisp with 1/10th the effort it would take in any other languageShould that be read as 1/10th the effort it would take you in any other language (because of your long history with lisp), or do you suppose it would apply to arbitrary other competent people?Like let's say we could make a few clones of you and start them all out on identical lives except that their early choice of language is different: one gets Haskell, another gets Forth, another Python, Ruby, etc.In this scenario you're saying you'd bet on the clone who went with Lisp being most productive?	westoncb	15.143704	-3.947307	comment	3.0	18.0	1579396559	-10.483873
22089290	McCarthy invented conditionals. Seri	"McCarthy invented conditionals. Seriously, if you've ever typed ""if"" into a program you owe a debt to Lisp. Likewise garbage collection. Lisp didn't absorb that; Lisp invented it. Likewise dynamic typing, first-class functions, recursion, etc etc.It's not even slightly disingenuous to imply that every other language is simply ""reinventing Lisp""."	dreamcompiler	15.140315	-3.951657	comment	3.0	10.0	1579405313	-10.428076
38925657	To the contrary.  In CL some flexibi	To the contrary.  In CL some flexibility was given up (compared to other LISP dialects) in favor of enabling optimizing compilers, e.g. the standard symbols cannot be reassigned (also preserving the sanity of human readers).  CL also offers what some now call 'gradual typing', i.e. optional type declarations.  And remaining flexibility, e.g. around the OO support, limits how well the compiler can optimize the code.	guenthert	15.103993	-3.9926927	comment	3.0	17.0	1704805189	-10.211133
39059155	I'm too young to have ever touched a	I'm too young to have ever touched a lisp machine, but I heard many opinions about them. If you used one, could you please briefly share your experience?	GTP	15.146473	-3.932912	comment	3.0	13.0	1705688897	-10.413781
39059220	This sounds like a terrible way to r	This sounds like a terrible way to run a lisp emulator.  One shell command after another which assume one has the apt(1) package manager available on their system.Maybe the title of the article is poorly done.The easiest way to run a lisp machine is just to start emacs (there are ports for various operating systems) or try something like racket where you have a REPL with graphics and other goodies installed.I know HN loves lisp, but putting this article on the front page is a good way to deter lisp adoption.	zeroclicks	15.119931	-3.952818	comment	3.0	11.0	1705689238	-10.41695
32614362	Did you mind checking the availabili	Did you mind checking the availability of people with lisp skills vs most other languages used in research and DS? Or the availability of libraries and pace of evolution? If your solution is to teach lisp massively and have everyone just build their tooling, can you explain why it hasn't happened yet, despite lisp being around much longer than most languages in use in this field - and many attempts at what you're suggesting?	bobbruno	15.146695	-3.939859	comment	3.0	12.0	1661560303	-10.44075
39376400	Essentially all the Lisp features ex	Essentially all the Lisp features except for s-expression syntax and attendant macros have been adopted by popular mainstream languages. CL has already given everything it had to give.	edflsafoiewq	15.113671	-3.9735785	comment	3.0	11.0	1707949358	-10.364531
39377888	Popularity is a matter of luck. But 	Popularity is a matter of luck. But suppose that the forces that drive luck somehow aligned themselves with promoting Lisp. There are ways Lisp would sabotage the luck being radiated upon it.Programmers who get into CL will hit various silly obstacles:- No standard way to express special characters in string literals.- No standard Unicode support; no \u1234 notation in the standard.  I/O with character encodings is implementation-specific.- Weird pathname handling that is simultaneously too abstract, and too nonportable, which is oxymoronic. The pathname abstraction caters to features of operating systems that basically no longer exist. Yet at the same time, two CL implementations on the same modern OS (POSIX or Windows) cannot agree on all the details regarding how a pathname string (the 	kazinator	15.132266	-3.959953	comment	3.0	10.0	1707959335	-10.445815
39379189	> Also: a maintenance nightmare as s	"> Also: a maintenance nightmare as soon as you have more than ~1 person working on the codebase!Lisp isn't any harder to maintain than any other language. The Lisp codebases I've worked on, even professionally, were originally written by talented, experienced engineers and were in fact wonderful to maintain.> Now imagine something like Lisp where every developer & team morphs it in a different way and you have a product with hundreds of developers on it.Dr. Ian Malcom's could/should distinction applies here. Most Lisp teams do not ""morph the language"" willy-nilly. They set standards of what to do and what not to do, establish a house style, build up a library of in-house functions and macros, and the more junior programmers imitate the more senior ones, just like any other dev team in any "	bitwize	15.137808	-3.9507222	comment	3.0	21.0	1707972152	-10.461004
39402211	I like the idea of a more modern Ema	I like the idea of a more modern Emacs that uses the full power of Common Lisp a lot, but I worry I'd miss a lot of features. Does Lem have org mode, a good LSP system, something like projectile, and the ability to display images and GUI buttons and such? And most importantly, does it have an evil mode with doom/spacemacs style leader key support?	logicprog	15.096916	-3.9597008	comment	3.0	12.0	1708113725	-10.412358
39467760	Common Lisp doesn't have a top level	Common Lisp doesn't have a top level lexical scope, which seems to be what you're looking for here.Putting something like VAR everywhere now causes issues because it's not a form that returns a value.  Also, there's no place to hang declare forms on it.  And if it's executed conditionally, what does that mean?  The var is declared on one branch but not the other?	pfdietz	15.088212	-4.0061526	comment	3.0	27.0	1708612894	-10.295581
39615736	In college, my programming languages	"In college, my programming languages class used a language called ""Mystery"" (I believe created by my professor), which was configurable. Assignments would be like ""write some test programs to figure out whether the language is configured to use pass-by-value or pass-by-reference"". And there were a bunch of other knobs that could be turned, and in each case, the idea was that we could figure out the knob's setting by writing programs and seeing what they did.I loved this, both as a teaching aid, and as an eye-opener that programming languages are just an accumulation of choices with different trade-offs that can all go different ways and result in something that works, perhaps a bit better or perhaps worse, or perhaps just a bit more toward or away from one's own personal taste.This is sort"	sanderjd	15.11475	-3.979645	comment	3.0	26.0	1709731803	-10.31736
39617988	I have the same dream.  A part of me	I have the same dream.  A part of me wishes Richard Stallman set out on making a Lisp OS instead of making a Unix clone, but this was the mid-1980s and thus I understand the technical limitations and the social environment of the time.  The 1990s could’ve been a better time; workstations and commodity PCs were powerful enough to run an entire Lisp or Smalltalk operating system, and there would’ve been substantial interest in such a system.  Imagine had we ended up with a free, open source Lisp or Smalltalk OS running on the Pentium and PowerPC machines of the era as an alternative to Linux and the BSDs.  I think this would’ve been an easier foundation to develop a FOSS desktop instead of the X11/KDE/GNOME/Wayland situation we have today.But the dream isn’t dead.  If only I had more free ti	linguae	15.103949	-3.9515438	comment	3.0	17.0	1709744320	-10.335598
39649805	I don't even know why we have any *M	I don't even know why we have any *ML. Everything they can do can be done with Lisp-syntax better.	435345345	15.11224	-3.9822195	comment	3.0	15.0	1709965205	-10.394795
39666627	Given Peter Norvig's work on Lisp an	"Given Peter Norvig's work on Lisp and Python, pity that after 24 years, his ""Python for Lisp Programmers"" essay from 2000 is still mostly true.Python might have overtaken Lisp's role in AI, but still needs some catching up in tooling.""The two main drawbacks of Python from my point of view are (1) there is very little compile-time error analysis and type declaration, even less than Lisp, and (2) execution time is much slower than Lisp, often by a factor of 10 (sometimes by 100 and sometimes by 1). Qualitatively, Python feels about the same speed as interpreted Lisp, but very noticably slower than compiled Lisp. For this reason I wouldn't recommend Python for applications that are (or are likely to become over time) compute intensive (unless you are willing to move the speed bottlenecks into"	pjmlp	15.132795	-3.9623258	comment	3.0	17.0	1710155611	-10.335685
32661287	Let me guess... they junked the Lisp	Let me guess... they junked the Lisp codebase and replaced it with some PHP and Perl?DARFC...	lproven	15.134283	-3.9551888	comment	3.0	14.0	1661949441	-10.422624
32725369	SBCL is de-facto most popular implem	SBCL is de-facto most popular implementation of Common Lisp, if I dare say. It is free, it is well maintained, it is easily available, and it is fast. As a student/enthusiast, it doesn't get much better.Lispworks/Allegro is better if specialized requirements or actual money is on the table. Lispworks supports mobile platforms IIRC which SBCL does not, for ex. But if all one needs is server side deployments or personal projects, there is no need, nor any use of commercial implementations, as good as they might be.	e3bc54b2	15.12927	-3.945113	comment	3.0	10.0	1662391715	-10.411302
32729822	> A better developer experience. Ema	> A better developer experience. Emacs + Slime is way better development and debugging experience than either Emacs + Geiser, or Emacs + Racket-Mode or Drracket.I've thought about learning a Lisp in the past, but the Lisp community's insistence on using Emacs has completely put me off of it. I will not use Emacs under any circumstances, and you couldn't pay me enough money to change. And this had lead me to conclude that Lisp is simply not for me.	amyjess	15.114483	-3.9564252	comment	3.0	11.0	1662414036	9.286388
32747094	> The fact that Common Lisp is a sta	> The fact that Common Lisp is a standard is both a blessing and a curse. Many developers consider this to be the former, as your code is much less likely to break over time. For others, it means that the language is frozen in time.This is not a consequence of it being a standard, rather no one has bothered of creating a new revision of the standard, like has been happening with Ada, C, C++, JavaScript,....for the last decades.	pjmlp	15.136594	-3.9609606	comment	3.0	14.0	1662531851	-10.452514
32761777	Lisp code tends to have fewer delimi	Lisp code tends to have fewer delimiting punctuation characters than most algol style current languages. I think people tend to dislike languages that have only the minimum necessary, because it's easy to misread code then and redundancy helps compilers catch mistakes as inconsistent syntax.But there's always Forth for the the lighter taste in delimiters: https://github.com/TexTerry/forth-examples/blob/master/pasca...	fulafel	15.109936	-3.9869332	comment	3.0	10.0	1662617052	-10.318198
32788870	ITA Software (acquired by Google) bu	ITA Software (acquired by Google) built its own non-mainframe GDS, and then ARS, which integrated into the legacy mainframe network.If you just look up some of these concepts and protocols, it looks cryptic but doable, but it's harder than it looks, and there's also some less-straightforward opcodes.  Although there's documentation, it's not always enough, and consulting experts from IBM was necessary.  There was also building regression test suites from captured real-world protocol traffic, to verify that you can mimic the behavior of the parties.Perhaps of side interest to HN: ITA stated publicly that they decided they had to use Lisp, to have the complex undertaking be tractable.  Which meant they hired a ton of Lisp people, and got a lot of high-powered people who normally wouldn't wan	neilv	15.131366	-3.9487505	comment	3.0	14.0	1662798390	-10.405244
32823162	I couldn't tell you exactly why (tho	"I couldn't tell you exactly why (though I have some ideas), but Lisps seem to settle into amazingly stable languages. Even Clojure, with all its initial trendiness, has been remarkably resistant to bloat and churn. Such things as it's added have largely been either standardisations of things that people were doing anyway, or very natural extensions of ideas that were already there, and it still generally passes the ""compile X year old code"" test."	jwmcq	15.136282	-3.9561234	comment	3.0	15.0	1663070326	-10.535371
32846546	I swear, Lisp fandom is the Amiga fa	"I swear, Lisp fandom is the Amiga fandom of programming languages. You have these dedicated supporters who are willing to go to extreme, Herculean lengths to prove that their chosen thing can not only keep up, but in some sense surpass what is popular, combined with nostalgia about the past and ""what could have been"". In the distant past, Ph.D.s have been awarded based on such feats, like ""Look, we can compile Lisp code to run half as fast as Fortran"" and ""Look, we designed a chip that runs Lisp as a native instruction set"". Simultaneously ridiculous and cool, the very picture of hack value. But you're still engineering around the drawbacks of a slow, dynamically typed language.The Lisp machines were amazing in 1979. But no one is seriously building a Lisp machine today, because modern lan"	bitwize	15.131737	-3.9497864	comment	3.0	11.0	1663211807	-10.393703
16448716	> Like - it's 2018 and people are st	"> Like - it's 2018 and people are still using 'cdr' and 'cons' as terminology and happily expecting other people to learn those words and not even feeling bad about it.Oh please, cry me a river. Like monads, promises, or props are any better.> If the person justifying Lisp doesn't mind that the word 'cons' is terrible, why should I trust their aesthetic sense about anything? If I have to have ""miserable notations"" to get ""coding nirvana"", and coding nirvana is so great, why not fix the notations? do you just think everyone should have to struggle because you did?Your ignorance is baffling. The notation is a feature, not a bug. If you want the feature, then yes, you will have to struggle.While cons and cdr as concepts are necessary to learning what goes underneath the hood, idiomatic lisp i"	felideon	15.124362	-3.9717488	comment	3.0	15.0	1519414525	-10.466579
16449068	If you are just gluing code together	"If you are just gluing code together, Lisp is not necessarily the best choice.If you are working on difficult problems where you actually have to devise non-trivial algorithms, then Lisp is a good choice. The problem then becomes feeding that algorithm – when there are so many great libraries everywhere else to retrieve data from and send to other places, it becomes cumbersome to do it in Lisp.There is also value in restricting programmer flexibility. I suspect Golang got popular precisely because of its straighjacket (and I say this while staring at Golang code in another monitor).Turns out most people want Legos. Real artists are fewer in number, but those will want clay instead.Edit: typo.
Edit2: everywhere else"	outworlder	15.136723	-3.9563923	comment	3.0	11.0	1519416560	-10.455447
16569332	Haha yeah, I've become too used to C	"Haha yeah, I've become too used to C-like syntax (C, Go, Rust, etc).I wouldn't mind a Lisp syntax too, but Ruby and ML are definitely a ""no"" from me. I just can't bring myself to like them. Their syntax feels too ""loose"", not sure if that makes sense.Btw, I know there are some Lisp-like implementations out there, but same criteria applies: still not mainstream enough as of now."	strkek	15.115614	-3.9824927	comment	3.0	12.0	1520872677	-10.411828
16583800	The conclusion was inescapable: the 	The conclusion was inescapable: the problem wasn't Perl or C++ or Java, it was me. I just wasn't a very good programmer any more. Lisp's power had made me complacent, and the world had passed me by.Lisp can't help you if you're too smug for your own good.Disclaimer: I'm a Lisper.	phoe-krk	15.139508	-3.9490438	comment	3.0	14.0	1521025554	1.7338412
16584729	I know that Lisp has been largely st	"I know that Lisp has been largely stable, but are you sure it hasn't changed much? Programming paradigms advance, we didn't even have unit tests or continuous integration 20 years ago (at least not widely adopted in the industry). I find it hard to believe that even a Lisp programmer would be completely ""static"" across 20 years, i.e. the code written 20 years ago would be truly similar to the code he writes now.So I'm not sure I buy this argument, unless someone has solid counter arguments."	oblio	15.134781	-3.9577343	comment	3.0	10.0	1521035708	-10.49674
16604003	I wonder if there are any ways to bu	I wonder if there are any ways to build simple to compile but still useful languages outside of just doing Lisp or Lisp-like.	runevault	15.117955	-3.9683433	comment	3.0	11.0	1521234229	-10.3335905
16616068	> What would the LISP machines have 	> What would the LISP machines have been like? It still kills me to think that an OS crash on one of those took you into the Lisp debugger.Sometimes I think a lot of people do use LISP machines. It's just called emacs.I joked on here once that I think the end game for GNU/HURD was ultimately to become a LISP machine via emacs, and if you look at some dev setups, that's not too far from what macOS and Linux are for them today: a place to run emacs and a web browser.	SllX	15.125719	-3.9475787	comment	3.0	21.0	1521431226	-10.396116
16714115	Reddit was lisp, then python, then p	Reddit was lisp, then python, then python, then React (and some other stuff).	SquareWheel	15.121033	-3.9668648	comment	3.0	13.0	1522390954	-10.337915
16732631	Lisp was based on the lambda calculu	Lisp was based on the lambda calculus, not sure if you can get more functional than that. Common Lisp was obviously more multi paradigm, having one of the most powerful object system ever. Scala is obviously also multiparadigm, though many would rather ignore that side of the language.Most languages are multi paradigm, even clojure is used with an object-like entity component system, while there are papers that push Haskell as the best language for imperative programming. The word is kind of meaningless when applied to languages but more meaningful when applied to code.	seanmcdirmid	15.124396	-3.9777184	comment	3.0	12.0	1522648662	-10.473536
16796282	You don't need a language to be a LI	You don't need a language to be a LISP in order for them to be able to interpret themselves. There are several Java interpreters which can interpret themselves, for example.	chrisseaton	15.134212	-3.9557328	comment	3.0	17.0	1523302979	-10.4251175
19314511	Thanks!, I had not seen the style gu	Thanks!, I had not seen the style guide. As someone else said, this probably comes from Google’s purchase of ITA. Common Lisp is stable, well documented, many fine implementations so I find it odd that there are only pockets of developers/companies who use it. Similar situation with Haskell.	mark_l_watson	15.148868	-3.937637	comment	3.0	12.0	1551822051	-10.430592
19318912	I enjoyed this book. I personally di	I enjoyed this book. I personally did not find it condescending. Additionally, the implementation of a Forth interpreter in this book is the best introduction to Forth I've seen (even after years spent playing with Forth and reading one or two books on Forth). But I don't recommend this book as an introduction to (Common) Lisp.I recommend this order:1. Practical Common Lisp2. On Lisp (kind of a big jump, so maybe check out ANSI Common Lisp)3. Let over Lambda4. Lisp in Small Pieces (especially if you want to implement a Scheme or Common Lisp)With Common Lisp the Language (Guy Steele) and ANSI Common Lisp (Paul Graham) somewhere in the mix.These are all excellent books and must-reads for anyone interested in programming languages and/or the Lisp family.	eatonphil	15.147528	-3.9314494	comment	3.0	13.0	1551880979	-10.446814
19333180	Aren't s-expressions all one really 	Aren't s-expressions all one really needs?	lsh	15.089198	-4.008875	comment	3.0	30.0	1551997499	-10.347423
19342933	I am always amazed at how many libra	I am always amazed at how many libraries and tools there are for programming in Elisp. One of the things that make it so fun.	celeritascelery	15.111595	-3.9715538	comment	3.0	24.0	1552084991	-10.472332
19408042	This post is full of misinformation.	This post is full of misinformation.cl-lib.el is not discouraged, it's widely used by Emacs itself and pretty much every substantial Emacs Lisp library out there.What's discouraged is using an older version, cl.el, at runtime [1]  because it replaces existing Emacs Lisp functions and pollutes the namespace. Even that's ok to use at compile time though.Lastly, cl-lib.el is not cumbersome to use.[1] https://www.gnu.org/software/emacs/manual/html_node/cl/Organ...	insertcredit	15.134679	-3.9616182	comment	3.0	14.0	1552747650	-10.454307
19429801	"""Kilo LISP
A Kilo Byte-Sized LISP Sy"	"""Kilo LISP
A Kilo Byte-Sized LISP System""But it's 25k of code, the executables and memory requirements are both greater than 1k.Did it start off as 1k in size, and since expanded?"	benj111	15.100336	-3.9559677	comment	3.0	11.0	1552994954	-10.34989
19430267	Good to see Kilo LISP here!Note: LIS	Good to see Kilo LISP here!Note: LISP, not Lisp -- I refuse to get the memo! :)	nils-m-holm	15.149972	-3.9356966	comment	3.0	11.0	1552999995	-10.44602
19439464	That's why I wrote 'more like'. Give	"That's why I wrote 'more like'. Given that you haven't defined any semantics of your operators, it's more like a guess.Not sure if this helps you. But let's define a macro A:    CL-USER 32 > (defmacro a (b c)
                   (print (list :macro-expansion b c))
                   (list 'print (list 'quote (list :runtime :b b :c c))))
    A

This macro does two things: it prints something at macro expansion time and then generates some code it returns as a value.Now we can use this macro in some code:    CL-USER 33 > (defun test ()
                   (a 21 42))
    TEST

If we now compile the function, the macro gets executed and prints something:    CL-USER 34 > (compile 'test)

    (:MACRO-EXPANSION 21 42) 
    TEST
    NIL
    NIL

We can also call the macroexpander independent of the "	lispm	15.075178	-4.023794	comment	3.0	38.0	1553062056	-10.311889
19440795	Different name for the same thing, w	Different name for the same thing, whats your point? Lambdas/AF are used to delay evaluation but keep the default semantics.Macros are more than simple code transformers, that wording somehow implies that they somehow retain the semantics of the data passed to them, which mighy be the case but is not required at all.S-Expressions are just a serialisation format for the m-expression AST.	j-pb	15.092525	-4.0024776	comment	3.0	20.0	1553078967	-10.279271
19480410	The fundamental problem with S-expre	The fundamental problem with S-expressions is that they are intended for (1950s) machine readability and human ergonomics takes a back seat.	kevin_thibedeau	15.082688	-4.016641	comment	3.0	25.0	1553490353	-10.284902
19499363	I'd be keen to see a simple example 	I'd be keen to see a simple example of this pattern in Lisp (or another language). Does anybody have a good link?	konamicode	15.135256	-3.9500036	comment	3.0	10.0	1553680440	-10.478388
19520000	I'm not confused, and nothing I'm ta	"I'm not confused, and nothing I'm talking about is novel, eg:http://matt.might.net/articles/metacircular-evaluation-and-f...SICP is a great way to learn lisp and learning macros by extending the evaluator is a natural progression.I don't care how many lisp experts are ""correcting"" me on the way it works in the real world, because:a) I actually do understand how they're implemented in existing production lisps. No, really. I am not confused. In my own toy lisp compiler, I rely on first class macros and am attempting (and so far failing) to use partial evaluation to make the implementation cost somewhat sane. I am under no illusions this is normal.b) Being an expert doesn't automatically make you good at teaching (often the correlation is reversed), and the article being commented on was a t"	reitzensteinm	15.119603	-3.9778433	comment	3.0	19.0	1553848307	-10.415667
19550713	Symbolics Lisp: Using the DEC Alpha 	Symbolics Lisp: Using the DEC Alpha as a Programmable Micro-Engine (1993) [pdf]	kristianp	15.118076	-3.9551587	story	3.0	78.0	1554174381	-10.34039
19575170	It's the unreasonable effectiveness 	It's the unreasonable effectiveness of a language and an approach that has some real mathematical backing behind it (relational algebra).Lisps are unreasonably effective because they have lambda calculus behind them. The Hindley-Milner type system and linear types, both mathematically sound, are a large part of Rust's effectiveness and success, in my eyes.I still would like that SQL read a bit more set-theoretic, if less English-like. It would make it less quirky and more composable.	nine_k	15.063369	-4.0386496	comment	3.0	21.0	1554400468	9.88538
19677965	This book is well worn, dog eared, a	"This book is well worn, dog eared, and on my home office book shelf. While many people criticize it, for legitimate reasons, it is still a fun and wonderful journey through Common Lisp. I wish more books were written in this irreverent and whimsical style.If however you want a more traditional and ""from zero"" introduction to Lisp, then ""Common LISP - A Gentle Introduction to Symbolic Computation""[0] may be better. If you already know a little bit of Lisp and want to step up your abilities then ""Practical Common Lisp""[1] is probably what you are after.[0] https://www.cs.cmu.edu/~dst/LispBook/[1] http://www.gigamonkeys.com/book/"	Dangeranger	15.150342	-3.9332092	comment	3.0	42.0	1555454594	-10.440774
19678436	Is there such a thing as a bad Lisp 	"Is there such a thing as a bad Lisp book? ;) Maybe there are only ones you're not ready for yet... (I've been unsuccessfully searching for a hardcover of Art of the Metaobject Protocol for a while, I can make myself ready for it once I have it.)In HN tradition where we all recommend every book we've ever read similar to the submitted one (and Land of Lisp is worth reading), an overlooked recently published booklet I found is Common Lisp in the Wild: https://www.darkchestnut.com/book-common-lisp-application-de... Common Lisp is so flexible in letting you develop the way you want to develop, but if you're a professional programmer looking for a Maven-esque template of ""structure your project in this familiar way without sacrificing any of the interactive Lisp dev experience, enumerate versio"	Jach	15.150249	-3.9328732	comment	3.0	18.0	1555459146	4.8497524
19679456	Hey Dr Barski. I'm actually reading 	"Hey Dr Barski. I'm actually reading your book right now. I do have a question. How do you write Lisp effectively? And by that I mean, Lisp seems to be written from the inside out due to the nested lists. Is there something that makes it more natural to write:
 (trim-string (get-string '(some data)))
Or do you need to know that you're going to call trim before you get the string? Hope that makes sense."	Riverheart	15.114937	-3.9835548	comment	3.0	21.0	1555470953	-10.418558
19680309	The way I do it, is that in my edito	The way I do it, is that in my editor, I can type:'(some data|)Where | is my cursor.And then I have a keybinding that moves my cursor to the front and wraps around like so:(| '(some data))So I can type the next thing:(get-string| '(some data))Press it again:(| (get-string '(some-data)))And so on.That way, even though the code is visually nested, I can write it in logical order from what eval first to what eval last. A good editor for editing lisp code makes that possible, as I showed, and many other operations.Basically, get yourself accustomed to a good Lisp editor such as Emacs and I'm sure you'll find that problem will disappear. For me, it's even more productive now typing wise, because I can make more structural edits to my code, which is way faster.	didibus	15.085709	-4.010398	comment	3.0	10.0	1555483302	-10.332887
19732490	You should check out SBCL, it's comp	You should check out SBCL, it's competitive.	madmax96	15.121036	-3.9417906	comment	3.0	55.0	1556051273	-10.341839
19733752	Common Lisp is much more dynamic in 	"Common Lisp is much more dynamic in some ways, but much less dynamic in others. In PHP you can't redeclare functions or classes, while in Common Lisp you can. On the other hand, in PHP you can manipulate the current scope and make variables appear out of thin air, but you can't do stuff like that in Common Lisp.For example in PHP:    $a = $_GET['greeting'] ?? 'hello';
    eval('echo $a;'); // => hello, or an error or anything else if there is a query parameter called greeting.
    $c = [ $a => eval('return ""hi"";') ];
    extract($c);
    echo $hello; // => hi, or an error or anything else if there is a query parameter called greeting.

While in CL:    (let ((a ""hello""))
      (eval 'a))
    ; => debugger invoked, the variable A is unbound.

A CL compiler can make a lot of assumptions about"	jorams	15.111095	-3.9849107	comment	3.0	10.0	1556059540	-10.37542
19758722	Only if you're given raw memory acce	Only if you're given raw memory access, which you are not in Lisp.	admax88q	15.139978	-3.9464908	comment	3.0	10.0	1556293566	-10.393249
19811508	> `List(Vec<RispExp>)`The big questi	> `List(Vec<RispExp>)`The big question when implementing a runtime for a Lisp-like language in Rust is how the interpreter will interact with the GC. It looks like this project has avoided most of the complexity by not implementing actual lists, and allowing multiple references to the same value to exist only in restricted circumstances, hewing close to Rust's ownership model rather than a typical Lisp's. I wonder, is the plan to stay on this side of the space, as a lightweight language with potentially smooth FFI interoperation with other low-level/Rust code? Or to rewrite almost everything to support the high-level semantics of list-processing languages, with their emphasis on shared structure?	firethief	15.081806	-4.019523	comment	3.0	12.0	1556824282	-10.513662
19840775	"""And no one argues about syntax.""No "	"""And no one argues about syntax.""No one argues about the syntax, because everybody ""wins"" and gets their own syntax as a result, which is often held up as a key part of the explanation for why the Lisp family languages are wonderful and fun and mind-expanding and just awesome in every way... yet rarely escape from ""niche"" status and are yet to even threaten to break into the really top-tier languages.Because languages like Rust and Go, and Python and Java and honestly almost every other non-Lisp family language, want more cohesion in their codebases, they need a different solution to the problem."	jerf	15.119786	-3.9758458	comment	3.0	14.0	1557159369	-10.422064
19953515	I have written books on Common Lisp 	I have written books on Common Lisp and Scheme. Their power feature to me is the combination of functional programming (functions without side effects) and how these small functions can be built bottom-up in an interactive repl. Other languages like Python and Ruby also support repl style development, but aren't sufficiently functional. A little off topic, but I am working on a commercial product (KGcreator, a tool for generating graph data for knowledge graphs) and started prototyping in both Racket and Haskell. It was a tough call but I chose Haskell. I think of Haskell as being another Lisp language that also supports repl style development.	mark_l_watson	15.1164	-3.9876513	comment	3.0	19.0	1558277015	-10.490973
19961290	There’s a really interesting and act	There’s a really interesting and active sub-community of Lisp game developers. Baggers, Steve Losh, mfiano, borodust, dto, and 3b are but a few of the recurring names. There’s even a start-up game company building a large non-trivial game in Lisp [0]. A list of games written in Lisp is here [1]. Baggers has a huge amount (>100 videos!) of youtube content on programming the full graphics pipeline in Lisp [2] and he continues to post week to week.If you have the impression that Lisp is only used by a bunch of academic knuckleheads like myself, check these folks out![0] https://defungames.com/[1] https://github.com/lispgames/lispgames.github.io/wiki/Lisp-G...[2] https://www.youtube.com/user/CBaggers	reikonomusha	15.147518	-3.9344273	comment	3.0	10.0	1558365770	-10.468745
33047349	Really curious: what is nice about l	Really curious: what is nice about looking at Lisp code [aesthetically] in your editor? I find the multiple parenthesis weird in large codebases. I am not a Lisp developer, just limited knowledge playing and interacting with AutoLISP [1], Racket (love what I see in the REPL there), and really appreciate the idea of seeing things in function terms.[1] https://en.wikipedia.org/wiki/AutoLISP	wslh	15.098682	-3.9943974	comment	3.0	13.0	1664638513	-10.342618
33058680	Why is this so upvoted? There's noth	Why is this so upvoted? There's nothing interesting here, it's just some guy saying he likes using Lisp.	cudderlover	15.157874	-3.9323127	comment	3.0	14.0	1664734763	-10.499605
33058734	I wanted to love Lisp after learning	"I wanted to love Lisp after learning about it in ""Gödel, Escher, Bach"", and then in PG's Blub essay (which is why I'm a HN fan).The syntax is just off-putting and I was never compelled to learn it in school, so I remain in algol-land. If time and focus allowed I'd do the SICP self study path but it's too easy to surf HN and Reddit instead."	pstuart	15.152037	-3.9374146	comment	3.0	46.0	1664735103	-10.472094
33058861	Lisp really doesn’t have syntax… it’	Lisp really doesn’t have syntax… it’s an abstract syntax tree which is the output of most parsers	waynecochran	15.101229	-3.9878883	comment	3.0	21.0	1664735858	-10.222766
33058825	No personal attack intended, but wha	"No personal attack intended, but what I always find funny: the complaints about Lisp's syntax. Lisp's syntax is regular prefix notation all over and one of the defining features of the language.Algol languages on the other hand, and math even on paper, are a rather wild bunch: they mix infix operators like plus/minus (1+1), multiplication/division (2*2), have postfix operators like faculty (9!) and even user defined functions f(x, y) in prefix notation. That should be way more off-putting theoretically, but people just grew up with this ""mess"" and think that fine.Disclaimer: besides Lisp, I program in Perl or Shell too ;-)"	jcynix	15.102297	-3.9901986	comment	3.0	36.0	1664735710	-10.356319
24775034	Hurts my eyes just a liiitle bit. Me	Hurts my eyes just a liiitle bit. Methinks The MUSIMP/MULISP-approach would be less painful. Firstly you find a way to transform the language in S-expressions and then you just write regular lisp-macros. This would be hidden from regular Python-user, of course. As I recall the macrodefinitions were already totally unreadable if transformed into Algol/Python, so no worry about syntax.	timonoko	15.082059	-4.0062985	comment	3.0	12.0	1602670716	-10.200002
24867549	Author here.The Common Lisp Conditio	Author here.The Common Lisp Condition System is my first book and it was previously discussed on Hacker News[0] as soon as the Apress page for the book was first posted.The HN discussion was very fruitful and insightful and prompted me to add more content about the condition system in general. Due to time constraints and the flow of working on the book, it was impossible to add this new stuff to the actual body of the book, so me and Apress have decided to publish this content as an appendix named Discussing the Common Lisp Condition System and release it[1] on the Internet. The appendix is free to download and use in any way and I'd like to once again thank everyone who participated in the original thread.The book is currently available for purchase on Apress[2] (with chapter samplers) an	phoe-krk	15.132809	-3.9556673	comment	3.0	12.0	1603445507	-10.43166
24871215	If anyone else is wondering what the	"If anyone else is wondering what the Lisp ""condition system"" is...Apparently it's analogous to ""exception handling"" in other languages, but with some extra features.Props to the author for getting out his first book!"	javert	15.117935	-3.9730709	comment	3.0	23.0	1603470750	-10.380272
24893014	So what does Lisp make harder to imp	So what does Lisp make harder to implement than today's programming languages?It seems like large-scale composition relies on a well-structured way to define and enforce APIs, and oh wow, typing facilities.Performance has historically been an issue for Lisp because its model is tightly tied to interpretation, but perhaps modern JIT-style compilation can address this.Others?What type of issues do large Lisp projects typically run into?	trevyn	15.111214	-3.9767694	comment	3.0	19.0	1603689202	-10.391291
24893661	> This is maybe the best introductio	"> This is maybe the best introductions to Lisp i have seen, especially for a js dev like me it could hardly get more approachable and convincing.The classical one is ""The Nature of Lisp""[0], which introduces data-as-code through XML and Java build tools. Same idea, just with examples more relevant at the time of writing. Still worth a read for non-webdev programmers.Having learned Lisp, it's half funny, half disheartening to watch the industry repeatedly tries to rediscover ""code as data"", as people's configuration or data files in markup language du jour grow in complexity and eventually start directly encoding executable code... and then stop shy of embracing the code/data duality.--[0] - https://www.defmacro.org/ramblings/lisp.html"	TeMPOraL	15.09386	-3.9949596	comment	3.0	20.0	1603697876	13.353643
24894734	It is and it isn't :)Obviously opini	"It is and it isn't :)Obviously opinions on the language shouldn't be given too much weight if a person hasn't spent too much time investigating/ using it.As a non-JavaScript person,  all the JavaScript examples looks like gobbledygook unless I sit down and consciously think about what the examples are showing, and it kinda hurts my head a bit,  but I can slowly force myself through it.But as someone with a few years of lisp under my belt,  even the closure examples (and I've never used clojure) parse pretty close the speed of thought.It really is hard to explain to someone who hasn't used lisp for 6-12 months, but there really is a lisp ""enlightenment"" experience, which is totally unlike anything I've experienced with any of my other languages.  I'm not saying this makes it better or worse"	ACow_Adonis	15.118741	-3.9816885	comment	3.0	20.0	1603709549	-10.548251
24894342	I was a teenage Lisp enthusiast. One	I was a teenage Lisp enthusiast. One thing that's struck me as I've gained more professional experience is that writing the code isn't actually the difficult part of software engineering. It seems that way for personal projects, or if you're just getting started with coding.	foldr	15.16362	-3.97207	comment	3.0	32.0	1603705356	-10.429784
24896008	I'm not sure who GJS is but if you s	I'm not sure who GJS is but if you see any lisper editing text instead of operating on structures (with auto-balancing parenthesis and so on), it's 99% certain it's in an environment they are not familiar with, so they will make mistakes.I don't think anyone who write Lisp-like languages professionally doesn't use tools like parinfer/paraedit, where balancing parenthesis is not something you have to do.	capableweb	15.1006975	-3.997636	comment	3.0	13.0	1603719497	-10.361696
24897272	> it's the useless (unless you write	> it's the useless (unless you write an AST-rewriting macro) structureIn a good JS editor, how many key combinations and mouse clicks are required to jumping into, jumping out of, and cutting a block of code (eg. a function definition or a conditional expression), or transposing, merging, splitting, annexing, and de-annexing 2 blocks of codes? It usually takes me at most 2 key combinations with a Lisp editor (including navigating the cursor to the right place), thanks to Lisp's uniform structure.> Say, naming a thing, a function definition, and a function invocation are all very visually different in, say, JSAren't these also visually highlighted in a Lisp editor as well?Besides, a Lisp editor can optionally blur the parentheses so users don't mentally have to.(edit: formatting, recounting	minhm	15.115046	-3.986932	comment	3.0	14.0	1603726423	-10.369177
24913749	Greenspun's Tenth Rule of Programmin	"Greenspun's Tenth Rule of Programming: ""Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified bug-ridden slow implementation of half of Common Lisp.""  Now with more JavaScript."	cbm-vic-20	15.127329	-3.9579644	comment	3.0	12.0	1603846071	-10.339878
24932701	On Fexprs and Defmacro	On Fexprs and Defmacro	sea6ear	15.132067	-3.963046	story	3.0	42.0	1603991393	-10.378202
24934591	I am not too proud of a man to say t	"I am not too proud of a man to say that I read that all the way through,  and by the end,  still didn't understand one bit: and I'm a lisp person who at least knows a little bit about the history of the language.Can ANYONE here actually
translate that into English?"	ACow_Adonis	15.143216	-3.9358063	comment	3.0	11.0	1603999755	-10.452669
25013249	Imagine writing lisp and trying to f	Imagine writing lisp and trying to fix a mismatched paren with a screen reader.	tmp538394722	15.136261	-3.9410641	comment	3.0	13.0	1604724008	-10.327355
25180366	Well, certainly no one seems to unde	Well, certainly no one seems to understand how e.g. syntax-case works. But my impression is that macro hygiene in itself is a solution looking for a problem. The key advantage e.g. racket's macro system has over clojure or common lisp is not hygiene but being sufficiently well structured and rich to allow proper tooling. Good error messages with accurate locations >> macro hygiene.	patrec	15.118232	-3.9741626	comment	3.0	19.0	1606074094	-10.266853
25204053	Remember Lisp machines?  The M1 is a	Remember Lisp machines?  The M1 is a Swift machine.	lisper	15.144093	-3.9356592	comment	3.0	47.0	1606258979	-10.44249
25224754	It's interesting, but here's the eas	"It's interesting, but here's the easiest way to evaluate if a Lisp/Scheme implementation article is interesting:""Does it parse (2 . 3) vs (2 3) aka (2 3 . nil) correctly?""That little dot which signifies a cons-pair makes implementing Lisp/Scheme oh-so-stupidly-much harder.Suddenly your printing has to go all the way right before it can make decisions.  Your recursions suddenly need to be robust against not being a list.  etc."	bsder	15.120796	-3.9721737	comment	3.0	13.0	1606439384	-10.4439745
25237355	Just started learning Emacs Lisp. Co	Just started learning Emacs Lisp. Common Lisp is on my todo list. Glancing through these tasks, I realize I have a lot to learn before I can call myself proficient. But I am very eager. Started reading Guy Steele and Touretzky. Love the concepts, the simplicity, homoiconicity, Lisp macros, and the fact that it is time tested.## EditYears ago when I was confronted with a new technology that caught my interest, I‘d ask myself: Is it in use? Is it wide-spread? Is it used by companies in commercial situations?My questions have changed. Now I tend to apply questions like: Does the hacker in me get excited? Does this technology help me solve problems? Does it make my life easier?	submeta	15.149719	-3.9386346	comment	3.0	15.0	1606569744	-10.420756
25237728	Try this guide - it’s quite a good a	Try this guide - it’s quite a good and concise introduction and will get you coding quickly. It can be read alongside a textbook:https://github.com/ashok-khanna/common-lisp-by-example(Disclaimer: I’m the compiler of this guide)	abhinav22	15.139477	-3.946427	comment	3.0	12.0	1606574091	-10.43565
25291861	WebAsm: Forth with Lisp Syntax	WebAsm: Forth with Lisp Syntax	marksmillibend	15.1198	-3.949962	story	3.0	41.0	1607017509	-10.45387
25389362	Can I just say that I appreciate thi	Can I just say that I appreciate this trend of the last few years where opensource projects and organizations start collecting real data on who their users are and how they interact with them?I see it a lot in the Clojure community as well, as with various other communities (such as Emacs). Not only does it provide the people behind the projects better guidance, it also gives me a better idea how my own usage and opinions relate to the wider community.Having said that, one thing I found remarkable from the results of this survey is the proficiency in ELISP. A sizable fraction of the respondents feel proficient enough to write their own packages, a trait which I have yet to find someone in real life for (and I know more than a dozen emacs users). I can’t help but think there must be quite s	stingraycharles	15.066624	-3.970393	comment	3.0	14.0	1607713444	-11.110105
25494291	Can you show some concrete examples?	"Can you show some concrete examples? Non-idiotimatic Common Lisp compiled with SBCL can certainly come within a single digit integer factor of C, but your claim is much stronger. As for Chez, I have yet to see some code that compares favorably to even a fast scripting language, let alone a medium or high performance compiled language, and that's even if the code is littered with fixnum version of operators etc. Not what I'd call ""very good performance characteristics"" unless compared to bash or python."	patrec	15.122401	-3.9569032	comment	3.0	10.0	1608553821	-10.372259
25543506	If you thought a manga guide is fun,	If you thought a manga guide is fun, a visual novel is even better. Don't miss the game Magical Language Lyrical Lisp (魔法言語 リリカルLisp, 2007) [0] from the same (?) author, it's a magical girl visual novel tutorial on basic Lisp syntax.I was stunned when I first saw it back then. Initially I thought it was just a simple parody, like asking you some questions and comparing it with the answers. But it was the result of serious hacking, it was evaluating the Lisp code in your answers for real. The author apparently implemented an actual Lisp interpreter using the scripting language of the NScripter visual novel engine. Although it's a really minimalist Proof-of-Concept, but it even has a mark-and-sweep garbage collector and an incomplete tail call optimization (supported feature list [1]). Sourc	segfaultbuserr	15.1384115	-3.9463181	comment	3.0	10.0	1608991486	-10.42279
25562274	Aside from legitimate gripes about a	"Aside from legitimate gripes about a recycled name, there's a lot of undue negativity in this thread.Not one person cares that HN-LISPER is not impressed that OP wrote yet-another-Lisp-interpreter-in-language-X or that you're unhappy with the style of their parentheses. Save it.As ""easy"" an exercise as it may be, I will guarantee you that OP learned a lot about Lisp, the host language, its build infrastructure, etc. The project is currently unlicensed (you should think about licensing it, OP!), but the source is available for others to study and learn from, too.So, I say bravo!"	ethagnawl	15.146761	-3.9340625	comment	3.0	16.0	1609183276	-10.473783
25620734	> That is, all source code and all o	> That is, all source code and all objects are stored in memory.Common Lisp usually stores code in form of normal source files that are then possible to load into a clean-slate Lisp image. It's possible to dump images and restore them, but it's not the norm of working with CL.Unlike in Smalltalk, I currently know of no tools that allow one to easily edit source code of functions/methods that have already been compiled into the system, and therefore the dependency on the filesystem source files is heavy and immediate.AFAIK dumping images in CL is mostly used for shortening load times by preloading code and data, and for application delivery, but not for live editing support.	phoe-krk	15.050305	-3.9967797	comment	3.0	11.0	1609666557	-10.426992
25621115	Why not just learn a Lisp yourself? 	"Why not just learn a Lisp yourself? You'll get far more out of it than watching a video. The old adage is still true: learning a Lisp makes you a better programmer.Your choices are:* Common Lisp: install emacs, SBCL and set up SLIME,* Clojure: install emacs, Clojure and set up CIDER,* Scheme: install emacs, racket (or guile) and set up Geiser,* Emacs Lisp: install emacs.You'll notice that they all involve emacs. There are probably other ways but you want something that is quite tightly coupled, which all of those emacs packages provide. REPL driven programming is better served by an editor like emacs rather than vim. You want something where you can quickly write/edit code in one buffer and send it to the REPL with a couple of keystrokes. The lower the ""cost"" of this operation the better; "	globular-toast	15.113649	-3.960567	comment	3.0	11.0	1609672464	-10.525179
25624014	I think you might have just got used	I think you might have just got used to it, but it's definitely worse. My job involves consistent writing of 50% Clojure, 40% Java, 3% Kotlin, 3% Scala and another 3% of others (Python, Javascript, HTML, SQL, etc.). And so as I actively code in both Lisp and Algol syntaxes (and wtv Python is), I definitely always miss my structural navigation and editing features in the non-Lisp languages. So I'm guessing you kind of just forgot how nice it is.Having said that, there's some disadvantages to the Lisp syntax as well, rightward drift due to constant nesting is real, and can make readability and even some edits a lot more annoying, whereas the flatter structure of other syntaxes doesn't have this problem as much. I still find its pros outweighs the cons personally, but your mileage may vary.	didibus	15.112358	-3.9967241	comment	3.0	11.0	1609700034	-10.52002
25627095	The problem with lisp is that most p	The problem with lisp is that most programmers find the syntax extremely off putting. I've been watching this debate go around and around in circles for 20 years now and nothing has changed. And as much as I appreciate the power of macros I feel like the features of other modern languages cover a lot of the same ground so the benefits of such a controversial syntax are diminished.Lisp is a fascinating and very elegant language and every developer can learn something from it but I gave up waiting for the lisp revolution a while ago.	cageface	15.118399	-3.9793203	comment	3.0	28.0	1609724268	-10.382225
25683700	Aren't you adding some assumptions a	Aren't you adding some assumptions about the implementation in your comment? Common Lisp doesn't require TCO, but it doesn't forbid it either, and SBCL chooses to do it. Your first sentence would be incorrect for a Common Lisp program someone executes with SBCL.	bachmeier	15.122195	-3.9669197	comment	3.0	12.0	1610106620	-10.427879
35521743	timonoko|3 years ago|parent|on: Lisp	"timonoko|3 years ago|parent|on: Lisp and Haskell (2015)Common Lisp could evolve into totally parenthesis-free language. By expanding the ""powerfull and versatile"" Loop-macro into full powerfullness and versatileness. Unfortunately two parenthessis needed, but you can redefine the language having those by default around every file."	timonoko	15.102328	-3.990362	comment	3.0	18.0	1681196197	-10.36665
35540195	I would like to compare this thing w	I would like to compare this thing with real Lisps in the terms of abilities.Also I would like to know the correct transcription of the name.	eimrine	15.148701	-3.9358766	comment	3.0	38.0	1681309444	-10.460729
35543997	I found his remarks about how (moder	I found his remarks about how (modern, ML-based) AI is the winter for Lisp interesting and congruent with how I see things currently. At the end of the day, many of the hardest problems in computing are solved best by simply throwing more compute (esp. matrix and array), memory, and data at them. Today's Lisp machines are GPGPU.	bitwize	15.14478	-3.9329116	comment	3.0	17.0	1681322479	-10.449111
35551415	I’m relatively unfamiliar with lisps	I’m relatively unfamiliar with lisps. Are all S-expression languages not created relatively equal? What is the difference between a “good” S-expression language and a “poor” one?	Nezteb	15.125927	-4.0134315	comment	3.0	10.0	1681364242	-10.40643
35558135	"Lisp is good""hellp world"" being a 78"	"Lisp is good""hellp world"" being a 784k exe is bad"	syngrog66	15.1444025	-3.9377265	comment	3.0	10.0	1681403806	-10.443743
35578006	So.... (if (/= den 0.0) (/ num den))	So.... (if (/= den 0.0) (/ num den))Languages keep reinventing Lisp.  Greenspun's 10th rule.	SeanLuke	15.110705	-3.9597158	comment	3.0	14.0	1681538320	-10.326921
35610104	It was strange at the time to put a 	It was strange at the time to put a lisp on the king of OOP languages, given all the lispers so fiercely dismissive of OOP, but never has a lisp language enjoyed such a huge ecosystem of libraries available.I use Erlang as my main language. I like that so many languages have lisp alternatives, so I can just rename the most common function calls to what I'm used to, and feel mostly at home between the different languages, other than different syntax for some data structures like maps.	JimmyRuska	15.134901	-3.9575424	comment	3.0	16.0	1681793742	-10.440856
35632197	LISP has been singing homoiconicity 	LISP has been singing homoiconicity as its feature. I lately start to think homoiconicity is really a wart. The macros are a system to program the code, while the code is a system to program the application. They are two different cognition tasks and making them nearly indistinguishable is not ideal.LISP has a full-featured macro system, thus hands down beats many languages that only possess handicapped macro system or no macro system at all. It uses the same/similar language to achieve it is mere accidental. In fact, I think LISP is an under-powered programming language due to its crudeness. But it's unconstrained macro system allows it compensate the programming part to certain degree. As a result, it is not a popular language and it will never be, but it is sufficiently unique and also 	hzhou321	15.108778	-3.987939	comment	3.0	19.0	1681932165	-10.366422
35702086	Note that this is primarily a syntac	Note that this is primarily a syntactical choice -- there isn't _currently_ much in the configuration language that actually resembles the functionality from regular lisp languages. I've been thinking quite a bit about how I could make use of the s-expression based syntax to turn yuck into a more feature-rich, actual lisp language, without completely going out-of-scope ^^	ElKowar	15.106665	-3.9924521	comment	3.0	10.0	1682437544	-10.391333
35752353	It moves fast at the start so maybe 	"It moves fast at the start so maybe not for the complete beginner, but I can really recommend ""Lisp in Small Pieces"" by Christian Queinnec: https://www.amazon.ca/Lisp-Small-Pieces-Christian-Queinnec/d...   It's a bit old now (early 90s) but Lisp is timeless :)  I think it's out of print now.  It goes through the implementation of both interpreters and compilers for Lisp, in Lisp.It starts with a very minimal meta-evaluator for something similar to McCarthy's original Lisp, and then explains why all the changes from Lisp 1.0 since were made.  Why did language designers change things in the first place?  And then it shows you how those differences are implemented.  One of the first lessons is the problems with the semantics of dynamic scoping, and the implementation of dynamic vs. lexical en"	retrac	15.138791	-3.95382	comment	3.0	11.0	1682772174	-10.474652
35757259	I'm starting to see the allure of pl	I'm starting to see the allure of plain Lisp. All it has is functions and functions have names which convey a meaning. Plus some syntax for creating macros.Now CAR and CDR don't convey a lot of meaning I agree. But that's just a matter of poor naming. They should (in my opinion) be called 'first' and 'rest', or something similarly meaningful and descriptive.Of course short-hands and aliases are good for most often used functions. But I would prefer those to be aliases, with a proper descriptive name available as well.And operator precedence, that makes code in a different language really hard to understand. Parenthesis make it explicit. Keep it simple.  That makes code more verbose but then you can use macros to make it less so.	galaxyLogic	15.097235	-3.992149	comment	3.0	15.0	1682802841	-10.442748
35852583	> On the other hand, Lisp code writt	> On the other hand, Lisp code written some 30 years ago will most of the time, without issue, work on a modern Common Lisp implementation.Yeah, just like Perl. Or Latin. No one uses them, these are dead languages that belong to a museum.It can be fun to study them and you definitely should if you want to be well-educated and know the history behind the modern world, but that's it.	cynicalsecurity	15.130811	-3.957714	comment	3.0	19.0	1683474179	-10.452465
35853627	As a Lisp fan who sometimes codes in	As a Lisp fan who sometimes codes in Scheme and Common Lisp whenever I get the chance, I agree with you.  The gap has certainly narrowed in the past 20 or so years between Lisp and widely-used programming languages.  In addition, the rise of statically-typed functional programming languages like OCaml and Haskell provide another alternative for those who love functional programming but want Hindley-Milner types.I still think Lisp, whether in the form of Scheme or Common Lisp (I haven’t tried Clojure), is quite enlightening due to the immense flexibility these languages provide.  However, I’m reminded of the rationale of MIT’s decision back in 2009 to move away from SICP and Scheme in the intro CS course in favor of Python: the vast majority of developers aren’t building new ecosystems from	linguae	15.1308	-3.9598815	comment	3.0	12.0	1683480536	-10.551202
35855037	Comparing it to C++ compilers... doe	Comparing it to C++ compilers... does Lisp have zero-cost abstractions?	sva_	15.128995	-3.9573455	comment	3.0	47.0	1683489404	-10.39374
35862867	Success stories like this make a bet	"Success stories like this make a better argument for ""Why Lisp?"" than abstract blog posts.We know macros are awesome, but if you're trying to convert others please provide code, screenshots, or even an interactive web demo."	Archit3ch	15.133402	-3.9524534	comment	3.0	15.0	1683560554	-10.397422
28723542	I tried experimenting with Common LI	I tried experimenting with Common LISP but never understood how one was supposed to deploy a finished binary to the end user. It seemed like you were supposed to load up an environment? It made me leery of continuing.	tehjoker	15.141154	-3.9370437	comment	3.0	13.0	1633123474	-9.876522
28726229	> Pompom language is so simple that 	"> Pompom language is so simple that you can implement it yourself just by looking in the source code (you can think that our language is the BASIC language of proof assistants).    List
      | A :: ~ * ~> * => {(list A) :: |new |empty }. // A list is either a new or a empty constructor

Okay... BASIC is a high level language, and it's aimed at people who are not involved in sciences.  If your goal is to have a high level syntax, and aiming it at people maybe outside of those with formal proof background, I think that's a big miss.  The syntax is anything but BASIC, compounded by the choice of lisp."	Twirrim	15.116016	-3.9805167	comment	3.0	10.0	1633152886	-10.442435
28726543	In my lessons about scheme (given by	In my lessons about scheme (given by the french translator of TAOCP), I have the following essential characteristics:- static binding- closures (true)- tail recursion- garbage collectors-expression or typing is a matter of choice, but, IMHO, if you lack one of the four previous items, it is not really a lisp.	webreac	15.136663	-3.9496584	comment	3.0	25.0	1633157288	-10.450597
28728445	I wish LISP 2 was never abandoned. h	I wish LISP 2 was never abandoned. https://en.wikipedia.org/wiki/LISP_2	zerr	15.143667	-3.9391544	comment	3.0	19.0	1633181664	-10.470184
28729513	Hey, I made this! Feel free to ask a	"Hey, I made this! Feel free to ask anything.I released this in 2016. It was a significant undertaking and I burned out pretty hard afterwards. I was operating under a naive ""if you build it, they will come"" model whereby building a modern-looking website, the community would coalesce around it and contribute to the wiki etc. But my ""rallying people behind a cause"" skills were insufficient.One nice contribution: at the time Common Lisp didn't really have an official logo, which I felt was bad for marketing. So my friend made one: https://github.com/LispLang/lisplang.github.io/blob/master/a...This was decidedly a social rather than technical effort, and social problems are hard to solve."	zetalyrae	15.145695	-3.9416213	comment	3.0	16.0	1633189533	4.168498
28754741	Well, although it is sometimes descr	Well, although it is sometimes described as a lisp, it’s not Lisp. It has a lot of syntax. Personally, I like the syntax, but some people prefer more minimalist languages.	leephillips	15.13186	-3.9578533	comment	3.0	12.0	1633399469	-10.399308
28763046	"So someone ran ""clear mpls lsp"" inst"	"So someone ran ""clear mpls lsp"" instead of ""show mpls lsp""?"	chomp	15.104567	-3.938779	comment	3.0	14.0	1633456655	-10.391988
28849031	My experience that a certain systems	"My experience that a certain systems programming language of Unix origins featuring 1 namespace and an unhygienic token-based macro system also has few issues with function-name capture, even in code bases with seven digit LOCs.That makes me severely disinterested and skeptical about hygienic macros.They are too weird for the little benefit they provide. You can't look at a piece of code and know what it expands to.Hygienic macros break lexical scope, because code produced by a macro being invoked in some file ""A.lisp"" is seeing lexical variables defined in some different file ""B.lisp"". Lexical scope must be physically enclosed and contained. If you expand it here, it sees the variables that are here, and not some other ones elsewhere that you don't see here.Given a nesting like (x (y (z a"	kazinator	15.099325	-3.9995356	comment	3.0	12.0	1634108240	-10.333753
28963391	> It was the norm for a single progr	> It was the norm for a single programmer to be doing the work that would normally be a team (sometimes multiple teams).Be careful with what you conclude from this observation. Is it that A) Lispers are generally 10x Programmers, or that B) Lisps are generally poor languages for team environments?	pphysch	15.131835	-3.9563558	comment	3.0	27.0	1634940616	-10.463567
28964003	>  I liked the idea of distributing 	>  I liked the idea of distributing binary applications as well, which we needed to do in some instances, and building a binary runtime of the software was a great draw, too.fwiw this is possible to with clojure using graalvm. Only mentioning this because of the clojure comparison in the earlier paragraph. While I do lament the JVM I haven't found a straightforward way to build statically compiled binaries with sbcl. I would love to be proven wrong though! :D	zeIMOr5vRXhVpO	15.123215	-3.947666	comment	3.0	11.0	1634944994	-10.379712
28963315	> The article also mentioned they ha	"> The article also mentioned they have 3 programmersOne of the problems we had with promoting commercial use of Scheme and then Racket was that -- although some companies were using it to great success -- there weren't any job postings for it.It was the norm for a single programmer to be doing the work that would normally be a team (sometimes multiple teams).And the knowledge of that success wouldn't be well-known.  (Because they liked to focus on the work, or because the larger team of business etc. people they were in was also small, or, in at least one case, the business person thought ""we use Lisp"" would kill business deals even though the code wasn't customer-visible.)So there would be no success stories, no job postings mentioning it as something people should learn, etc.Which, I sup"	neilv	15.141147	-3.9353867	comment	3.0	39.0	1634940173	-10.460019
34148058	>it will be written so that it first	">it will be written so that it first defines everything as functions and then at the very end makes a single function call. This ensures that the script will only do anything if it has been completely downloaded.This is not sufficient. More care is required.    lsp_init() {
        ...
    }

    lsp_init

If the last line gets truncated between the `s` and the `p`, then `ls` gets executed. Of course `ls` is harmless, but I'm sure you can imagine how it could be worse.In other words, not only do you have to wrap your script in functions, but you have to ensure that any top-level function / command invocations are named such that they do not become different commands if truncated.This is unsolvable in general, because the user can have any arbitrary names in their $PATH , such as custom per"	Arnavion	15.131172	-3.9518719	comment	3.0	16.0	1672144062	-10.334431
34199138	What are the enduring innovations of	What are the enduring innovations of Lisp? (2022)	eslaught	15.152027	-3.9333456	story	3.0	15.0	1672511014	-10.498824
34315051	OT, we used to joke about LISP sourc	OT, we used to joke about LISP source code contains mostly brackets. Nowadays we  literally store, transform and pass around willy nillily	a_c	15.11449	-3.9780412	comment	3.0	32.0	1673293761	-10.369139
34321761	I use CL for hobby projects and do l	I use CL for hobby projects and do love it. The main difficulty with “industrial strength lisp” is finding places in the industry that want to do so. :/	Insanity	15.1396475	-3.9391632	comment	3.0	38.0	1673336916	-10.4462385
34334801	LISP was the introductory computer c	LISP was the introductory computer class language at MIT for nearly 40 years. The faculty felt it exhibited the important elements of programming and algorithms. Some students complained they wanted something more practical for getting a job. It appears the newer faculty replaced it with Python.	peter303	15.13094	-3.9583414	comment	3.0	13.0	1673408869	-10.422242
34341447	Hey, why does it matter if it's made	Hey, why does it matter if it's made in 'common lisp' ?	keldami	15.152572	-3.936071	comment	3.0	16.0	1673458712	-10.438933
34355057	I know what s-expressions are, vague	"I know what s-expressions are, vaguely. Vaguely in terms of ""I couldn't write a grammar for them off the top of my head."", that is, not ""what are they"".Is there a single agreed-upon defined grammar that everyone can use? Preferably one simple enough that like JSON's it is at least capable of being used as a graphic on the home page for the format? https://www.json.org/json-en.htmlThis is an honest question, because there may well be and I don't know it.However, I will put this marker down in advance: If multiple people jump up to say ""oh, yes, of course, it's right here"", and their answers are not 100% compatible with each other, then the answer is no.The other marker I'll put down is ""just use common lisp"", I want verification that it really is 100% standardized, no question what any cons"	jerf	15.066731	-4.0233717	comment	3.0	15.0	1673537746	-10.416562
34413160	"My favourite is ""Practical Common Li"	"My favourite is ""Practical Common Lisp"" by Peter Seibel (https://gigamonkeys.com/book/)Not only is the book free to read (although I would suggest to pay for it if you like it!) The code to parse binary files actually ""inspired"" my design of an actual production application which was very flexible, succinct and, most importantly,  so fast I had to spend a lot of effort convincing people the numbers are actually true.It taught me some important lessons about how you can achieve performance with Lisp languages and the real reasons for the power of macros. Not too shabby for the first book on Lisp I red!"	twawaaay	15.147605	-3.935134	comment	3.0	22.0	1673967596	-10.417131
34419840	Same, still trying to get a good boo	"Same, still trying to get a good book that's pragmatic and for experienced developers. Many starts from the basics, or don't even talk about stuff like Quicklisp and ASDF.I want a book to make production-ready software in Common Lisp, not to faff around. The Paul Graham ""On Lisp"" book seems excellent, and I'll dive into it next."	sph	15.148486	-3.9343753	comment	3.0	14.0	1673992200	-10.397101
34526106	> First obvious option is to get rid	"> First obvious option is to get rid of the infix ""-"" operator, which is what Lisp does. In lisp-like languages you don't write ""a - b"" instead you write ""- a b"", this way there is nothing to confuse ""a-b"" with.This is a gross error. In your sense, Lisp does not even have operators, only identifiers. The reason there is no confusion between ""(- a b)"" and ""(-ab)"" is the spacing that separates the three identifiers in the first case.[1]Your comment is especially weird because you go on to discuss Lisp's approach as being ""an alternative option to what Lisp does"".[1] However, Lisp does have a potential problem with identifiers that begin with a hyphen, due to the need to support literal numeric values like -3. Thus the Common Lisp decrement function is named ""1-"" despite not returning the val"	thaumasiotes	15.098705	-3.9984713	comment	3.0	11.0	1674691907	-10.376929
34552382	Carp: A Statically Typed Lisp	Carp: A Statically Typed Lisp	bobnamob	15.086609	-3.9926631	story	3.0	20.0	1674856278	-10.284569
23426131	> it’s lists, hash-tables, strings, 	"> it’s lists, hash-tables, strings, vectors, and all the types of things programmers manipulate every day.Except the lisps with good error messages don't really use those things without tagging on the file and line number where they came from.  You end up working with ""syntax objects"" or something instead."	xscott	15.111315	-3.9853344	comment	3.0	10.0	1591344205	-10.411416
23486034	Lisp-1 Has Won	Lisp-1 Has Won	galfarragem	15.15442	-3.930578	story	3.0	5.0	1591859720	-10.443509
23553334	I spoke to Rob shortly after he wrot	I spoke to Rob shortly after he wrote this code (a few weeks ago). He said he had been wanting to do some coding over the weekend and pulled his copy of the LISP 1.5 Programmer's Manual - which he bought long ago, in grad school I think he said - off his shelf, and this code was the result. He also talked about how reading that book back when he bought it was incredibly eye-opening at the time and had such a significant influence on almost everything he's done in his career.When I look through what Rob has done, I see a few patterns clearly traced to LISP, including a strong emphasis on recursive approaches and simplification by relying on functional (immutable) semantics. Look at the bitmap layers work, Newsqueak, Sawzall. There is of course also a heavy dose of pragmatism, which seems to	rsc	15.15099	-3.9334447	comment	3.0	13.0	1592411586	-10.456682
23559047	Lisp programmers realized in the 70s	Lisp programmers realized in the 70s that having an artificial division between code and data was frequently problematic, hopefully other languages continue to catch on as well :)	thurn	15.119875	-3.965417	comment	3.0	34.0	1592445880	-10.445194
23569748	You must understand the point I am m	You must understand the point I am missing. Why learn a language in the LISP family as a young developer? Does it somehow improve you overall?	schrute	15.148407	-3.9431226	comment	3.0	14.0	1592526870	-10.460645
23600338	If you need someone online to justif	If you need someone online to justify for you learning new things in your field you have probably already lost.  This field is unrelenting, it requires constant learning.  I'm nearing 40 and it hasn't stopped. The one advantage is the more you learn the more skills transfer from one thing to the next.So the most compelling reason I have is because learning new things should be something that you find exciting.  What makes Lisp unique is that it is a lot different than other languages out there.  If you know one imperative language, learning another may expand your horizons but not in the same way something from a different paradigm would.If you already know a functional language or two, then it might not be worthwhile.  That is very much up to you.  But even though I have never used Lisp I	nightski	15.145229	-3.945183	comment	3.0	17.0	1592834855	-10.439575
23677176	I have a suspicion, which I have nev	I have a suspicion, which I have never verified, that the things that make emacs great are basically the things that made Lisp Machines great back when those were a thing - that emacs is best viewed as a Lisp Machine embedded in a modern operating system.I never used a real Lisp Machine, but I'd love if someone who did can confirm this.	noahl	15.1196995	-3.9528544	comment	3.0	10.0	1593435762	-10.391766
19972101	Points 1 and 2 sound like a REPL.Say	Points 1 and 2 sound like a REPL.Say we had a REPL that also had a table (like excel, each cell has an address... a 2D stack if you will).Say we interact using a mouse to select a cell or in the REPL to specify what cell we want to write to. Then, if we use a Lisp, we have tabular code and tabular data...I might code this up for fun.	all2	15.130658	-3.9547002	comment	3.0	10.0	1558458440	-10.458454
19985084	I'd like to try Lisp for a personal 	I'd like to try Lisp for a personal web project I'm working on.  What's the Lisp equivalent of a LAMP stack?  What is the recommended process for an Ubuntu server?	reaperducer	15.132126	-3.9496095	comment	3.0	11.0	1558556811	-10.437291
19989119	For a Vim user, what is a good plugi	For a Vim user, what is a good plugin to provide SLIME like paredit and REPL capabilities for programming in Common Lisp? Is there a clear winner plugin in Vim like there is SLIME for Emacs?	hoveractive	15.068113	-3.9709234	comment	3.0	15.0	1558593666	-10.393066
19997661	>High-level, what makes Forth intere	>High-level, what makes Forth interesting? What are it’s major strengths and weaknesses?Strengths: Lisp-level metaprogramming facilities while also being extremely fast and close to the metal. Weakness: the Perl problem (write-only) but worse.	unixbeard1337	15.137839	-3.950248	comment	3.0	25.0	1558660991	-10.440316
20196897	Ah. Understood. I solve this problem	"Ah. Understood. I solve this problem by forking every Quicklisp repo I use, and telling ASDF to look in my local clones first. This also solves the problem of making it easy to submit a pull request when I fix a bug in a Quicklisp library.Also -- and this is very important to me -- it means I'm in control of which version of every library I use. I've been burned too many times by Quicklisp ""updating"" a library that was previously working which doesn't any more. Now I have direct git control over my version coherency and I'm a happy camper."	dreamcompiler	15.090099	-3.9652684	comment	3.0	13.0	1560708091	-10.382752
20197381	Re statically typed Lisp, I’m keepin	Re statically typed Lisp, I’m keeping an eye on Carp [1] which seems to be a quite active project.[1] https://github.com/carp-lang/Carp	andrenth	15.113056	-3.969872	comment	3.0	28.0	1560713143	-10.305167
20211782	LISP has been a system programming l	LISP has been a system programming language. Still is.People just don't think about it much but forget that for a time, LISP was the shit in computer science, we invented half of the modern desktop on LISP machines!	zaarn	15.139816	-3.9500492	comment	3.0	32.0	1560857108	-10.437982
20313776	> I'm just pointing out that there a	"> I'm just pointing out that there are millions of developers that won't useYou are just stating it. Without any reason. One can't argue against a statement, you have to provide reasons behind your statement for there to be an argument.For example: ""Asking people to use an editor where C-c doesn't copy and they have to relearn the keybindings is an unnecessary barrier of entry"". I would agree with that and note that as a stop measure they can use the mouse for most tasks so they can postpone learning Emacs until they have learned CL.If you are on OSX CCL has an alternate IDE that's pretty good. Otherwise you can pay Lispworks or Allegro. Yeah it would be awesome if there were a multitude of IDEs, but people are not going to write IDEs for environments they don't use for free, it is unreaso"	PuercoPop	14.978168	-4.053394	comment	3.0	16.0	1561830073	-10.366858
20322915	I disagree. The C programming langua	I disagree. The C programming language is directly responsible for countless damning flaws in modern software and can be credited for the existence of the majority of the modern computer security industry.You can write system software in many languages, including Lisp. For a less outlandish example, Ada is specifically designed for producing reliable systems worked on by teams of people in a way that reduces errors at program run time.I find it amusing to mention UNIX fundamentals as a reason to learn C, considering UNIX is the only reason C has persisted for so long anyway. Real operating systems focused largely on interoperation between languages, not funnelling everything through a single one; Lisp machines focused on compilation to a single language, but that language was well-designed	verisimilitudes	15.119513	-3.9697154	comment	3.0	17.0	1561962521	-10.401533
20333952	All languages are becoming Lisp, exc	All languages are becoming Lisp, except for the added challenge of avoiding parentheses.	drcode	15.110267	-3.987273	comment	3.0	11.0	1562066229	-10.375664
13621953	A small Lisp-Machine in an FPGA	A small Lisp-Machine in an FPGA	poindontcare	15.139963	-3.9380932	story	3.0	90.0	1486806481	-10.418676
13640623	C or Lisp would be better choices if	C or Lisp would be better choices if maximum learning is the goal, or Haskell if hard core type fundamentalism appeals.	codr4life	15.129294	-3.9745634	comment	3.0	10.0	1487038115	-10.398832
13797566	Performance and Evaluation of Lisp S	Performance and Evaluation of Lisp Systems (1985) [pdf]	mpweiher	15.142596	-3.9425132	story	3.0	66.0	1488738701	-10.418547
13821493	Which is why you're not allowed to u	Which is why you're not allowed to use a Lisp interpreter or use any method of evaluating data as code. In this model the only thing that data can do is change which code paths run, not what they do.	Spivak	15.122612	-3.97487	comment	3.0	10.0	1488992112	-10.419428
13933218	> The assumption is that the machine	> The assumption is that the machine code of the C++ compiler is significantly faster than that emitted by a comparable dynamic language compiler. While this may hold true in general, it does not necessarily hold true with Lisp. Lisp is a programmable programming languages. If we are inclined to program it for speed, we can.My Lisp-fu isn't as strong as my C++-fu so someone correct me if I'm wrong but isn't the GC an intrinsic part of Lisp? Do more modern Lisps allow you to mark value types so you can control memory access patterns(which is where the true speed of C/C++ comes from).	vvanders	15.10193	-3.9970832	comment	3.0	29.0	1490205940	-10.407602
13941016	Most of those jokes are completely o	"Most of those jokes are completely out of date. ""Eight Megs and Constantly Swapping"" used to be a big deal, but today it's not.I don't think running Elisp in Emacs takes away from it being ""native."" At least insofar as there are no popular text editors (that I know of!) which expect you to compile your plugins and macros to native code. They all have interpreters of one kind or another. What Emacs doesn't have, though, is an inner platform effect: Emacs is the platform, there isn't a second one underneath (no browser engine)."	gmfawcett	15.02447	-3.9756951	comment	3.0	20.0	1490285178	-10.32755
13949653	The Blub Paradox argument basically 	"The Blub Paradox argument basically states that you must use the most powerful language because it's the only one that'll let you have a broader perspective to judge all the other programming languages.
Ironically, this kind of perspective is very narrow itself. You gotta consider the ultimate goal of writing software is to generate solutions that successfully solve users' problems. For complex problems that require lots of people working together, usually the effectiveness of that collaboration is the hardest of all problems, well above the technical problems.
Most of all modern programming languages can solve all the problems, in different ways. So the criteria for selecting a language is not power, but how it facilitates existing and new members of a team to make progress."	alpeb	15.137622	-3.945239	comment	3.0	10.0	1490370160	-10.456938
13951529	> I've always wondered why LISP was 	> I've always wondered why LISP was such a hot-topic of discussion for CS people.Because in a discussion with five CS people, only one has actual real Lisp programming experience, one has some freshman experience in some professor's one-weekend Lisp-like dialect where a run-time type error segfaults, and the other three have different misconceptions about what Lisp is.	kazinator	15.137802	-3.954794	comment	3.0	14.0	1490383586	-10.460072
13952010	The only thing you need to do to und	The only thing you need to do to understand lisp's entrancement is to write an interpreter for it, and in doing so you'll see why it's easier to write a lisp interpreter than it is for any other language. All you need to understand the appeal is a look at https://github.com/kanaka/mal.Personally I learned the appeal of lisp while following this tutorial on writing a scheme in Haskell: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_.... There's a reason there'll never be a tutorial like that for a toy Haskell interpreter.	pebblexe	15.135579	-3.9586847	comment	3.0	12.0	1490387525	-10.459095
13981279	which lisp interpreter did you use ?	which lisp interpreter did you use ?	netmask	15.127287	-3.9535394	comment	3.0	20.0	1490739408	-10.327644
13983003	The biggest problem with lisp adopti	The biggest problem with lisp adoption imo is that the first step of every path begins with emacs.Emacs needs to die for lisp to flourish in a more modern editor.Light Table was a good start, but we need some power behind similar projects.I always thought guilemacs was the obvious successor, but it still hasn't happened.	killin_dan	15.113866	-3.9529552	comment	3.0	15.0	1490756632	5.8867264
30798949	People who promote the virtues of li	People who promote the virtues of lisp online usually talk about the powerful repl.Here they advertise jupyter notebooks.Does that give that lisp repl experience I’ve heard so much about or is it just like my familiar r and Python repl experience?	wodenokoto	15.126068	-3.959065	comment	3.0	10.0	1648186341	-10.575369
30813006	I think many people have conjectures	"I think many people have conjectures, such as this one, but I don't think it's a tech problem, or a ""Lisp is too powerful for its own good"" problem. It's a ""people aren't writing software"" problem. History has demonstrated umpteen times that developing large, sophisticated, maintained, and maintainable projects in Lisp is entirely and demonstrably possible. Modern Common Lisp coding practices gravitate toward modular, reusable libraries through proper modules via ASDF packages (""systems"") and Common Lisp namespaces (""packages"")."	reikonomusha	15.135542	-3.9553146	comment	3.0	15.0	1648310472	-10.419241
30813282	Personally, I think the problem is t	"Personally, I think the problem is that CommonLisp is just another programming language, whereas Lisp really shines when it provides a full-fledged programming environment. Nowadays, it would seem best to create such an environment on top of commodity hardware as a ""virtual machine"" that abstracts away from the hardware in a general, portable way. However, a good  environment (1) needs a purpose, and (2) somebody needs to write it. Lisp currently fails on both points. The purpose used to be symbolic AI and NLP among other things. Nowadays it could be the same, or a web framework with integrated distributed computing and database, or scientific computing, or a server for certain business services, etc. There are many application domains for which a virtual ""Lisp machine"" would be beneficial"	13415	15.144787	-3.9336505	comment	3.0	10.0	1648312567	-10.425308
30918017	I just raided the project git repo a	I just raided the project git repo and there is definitely no common lisp in there. Unfortunate name clash!https://asdf.common-lisp.dev/	CraigJPerry	15.144879	-3.9398584	comment	3.0	11.0	1649160982	-10.441158
30962648	The Art of Lisp and Writing	The Art of Lisp and Writing	exdsq	15.145411	-3.9361815	story	3.0	37.0	1649452867	-10.465298
30964851	> Lisp is for working with computati	> Lisp is for working with computational ideas and expression, whereas Java is for expressing completed programsNot my experience at all. I often use the type system to play with and shape ideas before writing any code. The type system is a very high level specification language that allows me to express complex ideas in a few type declarations. With the added benefit that my automatic assistant (the type checker) helps me ensure that I have thought about everything before writing even a single line of code. It is a wonderful way to think about concepts, ideas and the architecture before writing any code.	mbrodersen	15.12856	-3.9626346	comment	3.0	11.0	1649472191	-10.459896
34623610	While I agree that RPN should be tau	"While I agree that RPN should be taught in schools, ease of parsing is not a reason to force them on everyone. Similarly, just because people get accustomed to lisp does not mean it's a good language. I say this as a lisp ""enthusiast"" using it for pretty much everything I can.Whatever language we teach in schools should be simple and quite natural to get the hang of, and should be somewhat ""industry standard"" if they choose to continue with said language.Python is a great candidate because of its reliance on indents and lack of delimeters. While ""we"" consider lisp's parenthesis incredibly useful, new programs find it scary. Forcing it on people does not make it any less scary.For me lisp wouldn't be enjoyable without good tooling. Parinfer, paredit, emacs, slynk, etc. make lisp enjoyable t"	shaunsingh0207	15.118421	-3.9743855	comment	3.0	11.0	1675325078	-10.373855
34624671	If it's +(1 2 3) then the language i	If it's +(1 2 3) then the language is no longer homoiconic and you will lose the primary leverage of being a Lisp. The fact that Lisp code consists entirely of Lisp data literals (code as data) is what enables Lisp macros and the superior REPL experience.	simongray	15.119339	-3.9757423	comment	3.0	16.0	1675333536	-10.459694
34675977	Personally, the biggest benefit of l	"Personally, the biggest benefit of lisps is that features to the language can be added by not only the language designers, but by the users.JavaScript wanted to add the synthetic sugar for async/await, so the language had to be redesigned with that in mind. In a lisp, async/await could be implemented by a library instead, keeping the core still small and nimble.This of course is also a foot gun when used improperly, where some codebases can be harder for new developers to grok everything, as they basically have to learn a new language built on top of the standard language. But I've found that if you keep the ""new language features"" to a minimum and have good documentation, developers quickly get onboard and start to be productive."	capableweb	15.138004	-3.956815	comment	3.0	11.0	1675682725	-10.47359
34706608	That's not a fair comparison, rewrit	That's not a fair comparison, rewriting anything in any lisp will dramatically reduce the amount of cruft, both lines of code and complexity.	capableweb	15.076704	-3.9860911	comment	3.0	11.0	1675854616	-10.409952
34747589	This is my really high level and poo	This is my really high level and poorly explained thoughts on this. I have enormous trouble reading functional programming languages.Python gets away significant whitespace by reading like pseudo code and is fairly clean. It uses words rather than symbols.C syntax provides visual structure using brackets.It seems to keep things readable, you get the option of using symbols or significant whitespace for scope.Functional languages have a tendency to do both. Lisp’s syntax is defined by replacing syntax with parentheses.You basically get into a situation where you need to be able to read and comprehend math-like lines of code. Which doesn’t seem to mesh well with the structure of nature language.It’s kind of like abstraction in programming. Some people kind of get it. Some people really get i	kayodelycaon	15.096734	-4.005712	comment	3.0	30.0	1676072353	-10.392983
34845036	I think its a pretty nice language.T	"I think its a pretty nice language.Those extra bits of syntax that makes it ""not a lisp"" are mostly around defining ""not list"" kind if data structures. I find it practical."	progre	15.118574	-3.9812264	comment	3.0	31.0	1676707975	-10.434003
34848343	The funny thing is that it's _not_ m	The funny thing is that it's _not_ more parentheses, roughly, than one would expect to find in any Algol/C-inspired language, like C# or JavaScript.The opening paren is simply relocated to the other side of the function name or keyword.What we're experiencing is just a cognitive bias which causes us to prefer the more familiar over the less familiar ([the mere-exposure effect, also called the familiarity principle](https://en.wikipedia.org/wiki/Mere-exposure_effect)).I've never used a Lisp-family language, but I find the reaction against parentheses to be overblown.The reading order of the code is also _consistent,_ rather than the frequent switching between infix notation, prefix notation, and postfix notation which we have to learn and parse in most languages outside the Lisp family. Thi	mypetocean	15.083021	-4.0066586	comment	3.0	12.0	1676738987	-10.341043
34863299	(I've done a lot of Lisp, for money,	(I've done a lot of Lisp, for money, and for open source platform&community buildout.)HN articles about exotic things, not just Lisp, do seem to get upvoted disproportionately.Also, PG declared Lisp as something you're supposed to think is important or a superpower, and I've wondered whether that also contributes to some upvotes on HN.But I'm not aware that a single one of the bajillion YC startups used Lisp.Maybe it's like an admirable religious dogma that a congregation affirms each weekend, and then promptly forgets about for the rest of the week.	neilv	15.150434	-3.9319468	comment	3.0	24.0	1676851559	-10.457001
34863486	I feel like there may be more Emacs 	I feel like there may be more Emacs Lisp being written recently than other Lisps and prose about Lisp combined.	owl57	15.145995	-3.9446132	comment	3.0	14.0	1676853092	-10.444926
34909624	Common Lisp implementations in 2023:	Common Lisp implementations in 2023:- SBCLEverything else is de-facto dead or in a proprietary silo.	zetalyrae	15.140239	-3.9411545	comment	3.0	13.0	1677155697	-10.438266
34909733	In my opinion, the simplest way is t	In my opinion, the simplest way is to start with Common Lisp, with SBCL and the Practical Common Lisp book by Peter Seibel.Make sure you are comfortable with Emacs. It is possible to write Common Lisp without it, but Emacs and SLIME are so much better than anything else it feels like cheating.	galdor	15.137233	-3.9446652	comment	3.0	11.0	1677156372	-10.498533
34975938	Describing stuff as Lisp-like is a g	"Describing stuff as Lisp-like is a good way to sidestep arguments about ""proper"" Lisp.What even is a proper Lisp? http://steve-yegge.blogspot.com/2006/04/lisp-is-not-acceptab..."	shaftoe444	15.150893	-3.9391148	comment	3.0	10.0	1677623937	-10.464313
35031516	LISP isn't a pure functional languag	LISP isn't a pure functional language, it's a multi-paradigm language that is as dynamic as they come. Its problem isn't lack of expressivity, it's probably that it's too flexible (and of course the syntax throws people off).As for Haskell, I guess that gets into the question of how you define expressivity, which is admittedly a very fuzzy term. Here I meant it to mean capable of fluently expressing many different kinds of algorithms without having to resort to circumlocution.Functional programming is natively supported in almost all modern languages. You call a function which calls a function which calls a function which calls a function, return the result. There's no syntactic sugar, just function calls.In Haskell, while I've seen people argue that do notation may as well be imperative c	lolinder	15.118081	-3.9923384	comment	3.0	30.0	1678036049	-10.480395
35092264	Found this page to be a nice intro t	Found this page to be a nice intro to the syntax and semantics:https://github.com/carp-lang/Carp/blob/master/docs/LanguageG...This part hits a real sweet spot for me:> Carp borrows its looks from Clojure but the runtime semantics are much closer to those of ML or Rust.One of my current side-projects is a little Civ-style game I'm working on in Racket, which I decided to start coding in on a whim. Will see how it goes moving pieces of it across to Carp.	philbo	15.02284	-4.0447493	comment	3.0	10.0	1678439667	-10.377632
35094426	Many have tried. The upshot is, it i	Many have tried. The upshot is, it is either not as cool as it is in our heads if you get it, or it isn't as easy as it is in our heads.You don't even really need s-expressions to do what you're talking about. You can do it off of any grammar, which all current programming languages have[1]. S-expressions are slightly easier, but they aren't easier in the place where the real problem lies. The real problem lies in the fact that the code isn't shaped the way you think it is and it isn't as nice as you think it is and it turns out nearly every attempt to project code into something other than our current plain text representation flounders on the pathological nature of source code.Personally I think this is a fundamental problem, but there is an avenue to where I would be wrong. If somebody 	jerf	15.064785	-4.031724	comment	3.0	22.0	1678457215	-10.342021
25443205	Exactly.Though, to be fair, if someo	"Exactly.Though, to be fair, if someone says they want to learn LISP and then you tell them to learn Emacs... well, now they have TWO problems! xDI love and use Emacs. And I also, unsurprisingly, don't like or recommend that people start off with all of these ""starter packs"".But at the same time, if you don't already know Emacs and you want to learn LISP, I don't know what I'd recommend."	ragnese	15.137533	-3.9458015	comment	3.0	11.0	1608130514	-10.435154
36961618	I wish I had the enthusiasm, grit an	"I wish I had the enthusiasm, grit and dare I say ""sisu"" that lisp developers possess. I worked with a guy - very skilled Clojure developer - who was an absolute wizard in Emacs. If a car company sold a vehicle that was powered by emacs, he would have bought it. He will probably construct his own casket out of elisp to be buried in."	whalesalad	15.139561	-3.9461286	comment	3.0	20.0	1690919193	-10.545997
36996558	I was briefly excited that this was 	I was briefly excited that this was Lisp for the Raspberry Pi Pico, but it is not.	LeafItAlone	15.145067	-3.9359777	comment	3.0	10.0	1691133672	-10.458165
36997051	The problem with Lisp is that there 	The problem with Lisp is that there are different dialects, and if you program in more than one, you need to be aware of the differences between them.   It would be nice to be able to switch between them on different projects without being caught out by their differences before getting used to the other dialect, or having to context-switch.   It would also be nice to port programs from one dialect to another without major editing.   But Picolisp is another dialect, which on the surface is quite different from Common Lisp and Scheme/Racket and, I assume, Clojure.  If you want to keep your Lisp implementation small, why not just implement a subset of Common Lisp, or build/use a Scheme variant?	DonaldFisk	15.120514	-3.9761972	comment	3.0	22.0	1691137426	-10.545951
37018561	Are there any Lisps that are particu	Are there any Lisps that are particularly bad for scripting? Elisp comes to mind since it's not great unless you're already inside Emacs, but if you are it's pretty good.	Zambyte	15.090467	-3.9763672	comment	3.0	12.0	1691290644	-10.347059
37087627	ADDENDUM: I love Lisp but I want to 	ADDENDUM: I love Lisp but I want to clarify that its secret sauce is that it enables exploratory programming: programming from inside the system.While most languages are akin to preparing a detailed blueprint and executing it (then stop to update the blueprint and try again), exploratory programming is like sculpture. You have an unformed mass full of unrealised potential, and you slowly carve it to shape.The ADHD/Bipolar mind of the article isn't great at making plans, it's great at following its gut instinct, making shit up step by step.Lisp enables this flow, but also Forth, Smalltalk, Self, etc., which I've been deeply obsessed with lately. Sadly, all we have today on the mainstream are basic REPLs which are a harmless, defanged version of these old environments promoting creativity an	sph	15.137837	-3.953134	comment	3.0	23.0	1691754722	-10.48759
37088080	I’m fairly annoyed with myself on my	I’m fairly annoyed with myself on my worse days for heading into embedded as a career path when Lisp (clojure mainly) is the only development process I’ve really ever felt fit my brain. I’m positive that there is a Lispy language out there (actually in existence, or the aether) that is appropriate for embedded work, but the constraints of the target make it difficult to envision.I like C and assembly because they’re simple from a language semantics level but incidental complexity is nearly unavoidable. I’m not sure if I have undiagnosed ADHD like many here are wondering, but I do wish I could go back to living in a REPL without giving up the joy of working on real hardware at the register programming level.	jakeinspace	15.123451	-3.9561977	comment	3.0	13.0	1691757939	-10.617671
37103317	One of the ideas of Lisp is that you	"One of the ideas of Lisp is that you can extend/change the language to bring it near the actual domain level. The so-called ""Embedded Domain Specific Language"" is common in Lisp."	lispm	15.119247	-3.9670615	comment	3.0	16.0	1691867867	-10.389163
37103852	I once recorded a demo video, runnin	I once recorded a demo video, running Concordia on an actual Symbolics Lisp Machine.https://vimeo.com/83886950	lispm	15.13238	-3.946676	comment	3.0	21.0	1691871378	-10.373971
37105010	To abuse the metaphor - lisp and lis	"To abuse the metaphor - lisp and lispers are completely tone deaf. There's an enormous number of people writing code that don't care one wit about ""elegance"" or ""power"" or ""beauty"" or whatever weird intangibles lisp has pretensions to. These people (such heretics) in fact don't care about software unto itself at all. They only care about using software to accomplish some goal, finish some task, solve some real (earthly) problem.> The real issue is that many people don't want to become virtuoso, but just want to learn as little from their tools to make rent.I would love to be a virtuoso pianist or painter or singer. I can't fathom the desire to be a virtuoso programmer - it would be like being a virtuoso widget assembler. I mean sure our bosses wishes all of us were virtuoso widget assemble"	mathisfun123	15.141198	-3.9372816	comment	3.0	10.0	1691881345	-10.518267
37165657	> moving programs between implementa	> moving programs between implementations was a bit of a crapshoot.You just summarized the historical reason why LISP and its various incarnations (Scheme among others) failed.So many different patois, no way to move code from one to the other without giant headaches.	ur-whale	15.134646	-3.9535606	comment	3.0	10.0	1692295323	-10.425766
37167208	Given how easy it is to build a Turi	"Given how easy it is to build a Turing machine, I'd argue that building something you don't envision is the 99% of the time rule and it's already captured by https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule ""Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.""In fact I'd argue that it's much harder to not accidentally build something that you don't envision."	random3	15.1094055	-3.9694424	comment	3.0	10.0	1692302737	-10.320682
37203670	No, it's not lambdas all the way dow	"No, it's not lambdas all the way down.  Lisp machines are long gone.I really wish people would stop teaching the ""metacircular"" stuff so early.  McCarthy even missed metacircularity.  It took a genuine genius on the level of Stephen Russell to ""get it"" and convert everything to a functional programming language.Tell people to implement a Lisp down on the imperative language of the machine.  Suddenly, you will get it.  Mutability is a pain in the ass.  Recursion has issues.  Garbage collection isn't optional--it's required because all of your ""lambda"" shenanigans are beating the hell out of the allocator and cons-ing up trash like a victim of ""Hoarders"".Once you see the guts, suddenly metacircularity makes sense.  It also isn't particularly interesting anymore."	bsder	15.118776	-3.9747784	comment	3.0	12.0	1692571650	-10.412245
37260032	SBCL has an interactive/incremental/	SBCL has an interactive/incremental/in-memory native code compiler and a file compiler.https://www.sbcl.org/	lispm	15.112087	-3.959034	comment	3.0	11.0	1692959068	-10.375672
37301363	Other great achievements from last y	"Other great achievements from last year [0]:- SBCL is  callable as a shared library (see sbcl-librarian)- sb-simd- prebuilt binaries for Android (termux, unofficial)- better image compression using zstd- I'll add https://github.com/sionescu/sbcl-goodies, binaries with ""goodies"" inside (OpenSSL, libfixposix)yay![0]: https://lisp-journey.gitlab.io/blog/these-years-in-common-li...bonus from 2021: true static binaries are coming https://www.timmons.dev/posts/static-executables-with-sbcl-v..."	vindarel	15.12896	-3.9440706	comment	3.0	12.0	1693262800	-10.432987
37323774	"> :class=""alert"" is strictly worse t"	"> :class=""alert"" is strictly worse than ((class . ""alert"")) or any other variation that actually leverages s-expressions instead of merging key and value into the same symbol. Ew.I hear you, but I wasn't aiming for leveraging the power of macros. Using `((class . ""alert""))` does not provide any benefits over :class=""alert"".> Not a fan of the bare words instead of strings either, which means this cannot be naively evaluated by a Lisp.I traded off ergonomics against ""Evaluation by a Lisp processor"".Instead of     (div ""My first "" (b ""hello"") (em "" world""))

I'd rather do     (div My first (b hello) (em world))

Thank you for your input."	lelanthran	15.091727	-4.006638	comment	3.0	28.0	1693409778	10.126047
37458188	Lisp has a profound effect on the bu	Lisp has a profound effect on the business model because it can give you a dramatic productivity boost (like an order of magnitude or more) but it makes staffing more difficult because there aren't many experienced Lisp programmers because very few organizations use it, which makes for a vicious cycle.  But this is precisely the sort of situation that if enough people simply changed their minds that by itself could change the underlying reality.It's not just Lisp.  There's a similar thing happening today with Rust, which is clearly superior to C from a technical point of view, but which very few people use simply because there are very few people using it.  But Rust might be one of the rare exceptions where the technical superiority is enough to allow it to break this cycle.	lisper	15.134583	-3.9606085	comment	3.0	30.0	1694368106	-10.455838
37459028	> I can give you concrete examples o	> I can give you concrete examples of demonstrable >10x productivity improvements which resulted in products succeeding where they otherwise would undoubtedly have failed.Well, I would definitely be interested in these examples. I occasionally write Lisp (admittedly, Emacs Lisp rather than Common Lisp) and while I appreciate having macros and other metaprogramming tools at my fingertips, I've never encountered a situation in which their use was critically important. I can always replicated the thing I wanted to do in Python with a bit of boilerplate; if I had to choose, I would certainly take Python's huge ecosystem over Lisp's metaprogramming. Frankly, I don't think there have been any language silver bullets after structured programming and garbage collection. So I'm very skeptical of th	pkkm	15.114122	-3.9746082	comment	3.0	12.0	1694373495	-10.423457
37459262	Historically I think there's a very 	Historically I think there's a very strong case that Symbolics did outperform others with their software productivity, especially in graphics. They had an ability to wade into certain domains and produce legitimately shockingly competitive products, which really should not have been possible.But I also think Lisp leads to spectacular burnout as I think it imposes a greater cognitive requirement on the part of the developer.A Symbolics graphics reel from 1989 https://www.youtube.com/watch?v=V4HXPJtym2QThis stuff was still in use on Final Fantasy 7 https://lunduke.substack.com/p/the-computers-used-to-do-3d-a...	fidotron	15.136289	-3.9450543	comment	3.0	12.0	1694375090	-10.320712
29007592	Well, if we're going to venture that	Well, if we're going to venture that far into excuse land Common Lisp has access to every C library in the world through CFFI.Look, I love Lisp, but reality isn't going anywhere.	codr7	15.126289	-3.9534063	comment	3.0	10.0	1635289979	-10.383536
29017710	tl;dr three major pain points:(1) no	tl;dr three major pain points:(1) no native async(2) small library ecosystem(3) CL community NIH syndrome:> I think the straw that broke the camel’s back was when a few people started making copycat projects that added no real value (other than benchmarking fast) but stole mindshare from all the work I had put in.These are good points. (1) is a real, true problem with CL (as opposed to things that people commonly think of that aren't actually that bad e.g. syntax), and it's probably not going to be solved in a satisfactory way anytime soon - the design of the language is pretty nice, but seems to exclude first-class continuations (according to [1]), async, and coroutines. (yes, you can emulate these things using macros, but that often involves tree-walking, and results in non-orthogonal fe	throw10920	15.11822	-3.9719923	comment	3.0	13.0	1635361936	-10.55204
29093479	Are you working under an NDA or some	Are you working under an NDA or something? Are you being threatened?  Blink three times if you need help.Seriously, is there a reason you have to hint about what Lisp you use?	JasonFruit	15.149236	-3.9385898	comment	3.0	10.0	1635940971	-10.51615
29105566	I know Kirat really well. Fun fact, 	"I know Kirat really well. Fun fact, one two-week dev cycle we had 667 distinct developers commit to the secdb code base which Kirat's boss described to me as ""The number of the beast.... plus Kirat""Second fun thing.  Kirat was advocating for lisp for secdb for a long time and used to rag on me for liking python when it's so slow."	seanhunter	15.126473	-3.9457927	comment	3.0	13.0	1636023744	-10.425285
29114196	> no hand-waving, use of any parenth	> no hand-waving, use of any parentheses, or referencesNot a fan of Lisp?	biofox	15.114811	-3.9711409	comment	3.0	12.0	1636072816	-10.379671
29131030	I wouldn't say something lacking a L	I wouldn't say something lacking a LSP is modern by todays standards, as that would mean it lacks syntax highlighting, go-to definition, and other basic things for a bunch of languages.	askonomm	15.109576	-3.9654908	comment	3.0	12.0	1636212553	-10.451598
29134822	If you want a Scheme that's embedded	"If you want a Scheme that's embedded in another program as an extension language, or to make software that's distributed normally as part of a Linux or BSD distro... probably Guile.For most other practical purposes... probably Racket.There are a few other options I still keep in mind, including Gambit and Chicken.(Actually, lately, the ""Lisp"" I'm using is Python.  Python is usually tolerable, and the huge ecosystem and easy employability are nice in some ways.  But Lisp technical sophistication and community signal:noise ratio tend to increase with the percentage of parentheses.  Not because parentheses are magical, though they are-- but because the parentheses Lisps are built on better original foundations, and then disproportionately attract people on technical merits rather than marketa"	neilv	15.118406	-3.9677994	comment	3.0	29.0	1636241044	-10.349847
29140521	Common Lisp code optimisation	Common Lisp code optimisation	lokedhs	15.134905	-3.9410722	story	3.0	128.0	1636300837	-10.417857
29203207	> Lisp is one of more familiar thing	> Lisp is one of more familiar things in programmingSimply not true in practice.https://insights.stackoverflow.com/survey/2021#section-most-...edit: fixed link, header was pointing at wrong section	pphysch	15.141398	-3.9490519	comment	3.0	20.0	1636743629	-10.454245
29235453	Well, if you made one, it would be m	"Well, if you made one, it would be much better than the original. We had one refrigerator-sized Symbolics machine at the aerospace company, during the false AI boom of the 1980s. I used it a few times, but it had one LISP fan who used it a lot for a specific project. It broke down a lot, and Symbolics service was very poor. The early versions had a really slow garbage collector. Minutes.  With everything in one address space, you had to wait out the GC; you couldn't kill your program and start over. Many of those special-purpose buttons on the Space Cadet-derived keyboard didn't actually do anything. Unless, of course, someone rebound them in EMACS.I did LISP work then, but mostly using Franz LISP on VAXen and Sun Workstations.
I was never really into the LISP cult, though I wrote a lot of"	Animats	15.122667	-3.949377	comment	3.0	14.0	1637025862	-10.304071
29277265	The example for the Yield effect [1]	The example for the Yield effect [1] looks suspiciously like the condition system of Common Lisp and restarts.[1] https://effekt-lang.org/#intro-handlers	i_don_t_know	15.093547	-3.9996564	comment	3.0	11.0	1637331042	-10.266196
29291905	It says that Maxima also has its own	It says that Maxima also has its own programming language (written in Lisp). Any opinions on it good or bad?	etaioinshrdlu	15.080593	-3.97389	comment	3.0	14.0	1637442906	-10.3700075
29328688	> Most languages not directly influe	"> Most languages not directly influenced by C (new or old) simply don't have these bizarre issuesI don't agree.  Lisp is ""easy"" to parse, but difficult to add structure to.  Tcl similarly.  Typeless languages are now out of favor--everybody wants to be able to add types.Perl is a nightmare and probably undecidable.  Satan help you if you miss a period in COBOL because God sure won't.  FORTRAN is famous for it's DO LOOP construct that would hose you.About the only language that wasn't hot garbage to parse was Pascal.  And I seem to recall that was intentional."	bsder	15.113717	-3.9763048	comment	3.0	16.0	1637750385	-7.2441993
29507107	Common lisp is surprising not functi	Common lisp is surprising not functional.  It embraces that all things can be first class things.  But mutable code is very very easy in common lisp.	taeric	15.134459	-3.9575753	comment	3.0	23.0	1639118735	-10.499154
29508371	Until everyone and their dog decided	Until everyone and their dog decided to turn functional as a synonym for as Haskell does it, Lisp was quite functional.	pjmlp	15.116465	-3.9901733	comment	3.0	15.0	1639132067	-10.454261
29631875	Lisp is a language that people actua	Lisp is a language that people actually use to get work done; Brainfuck isn't.	not2b	15.138233	-3.953299	comment	3.0	11.0	1640043070	-10.399381
29636628	> a let rec construction for dataIs 	> a let rec construction for dataIs there actually any Lisp dialect where letrec works for data? I'm not aware of such, at least where it comes to major ones (CL and common implementations of Scheme).	jhgb	15.108702	-3.9767392	comment	3.0	10.0	1640089003	-10.381458
35914179	maybe i am missing something but thi	"maybe i am missing something but this is old news for embeddable common lisp. see threading section in this article from 1994[0], or is this extreme-threading different somehow? there is also a recent llvm-based implementation [1] that aims for direct lisp-cpp interface.i know my usage of the word ""just"" might suggest otherwise but i am not trying to deminish this feat. i use common lisp for scientific work and whenever i hear about something cool in another language i ask myself can i do this with my toolset. this is the reason i am asking this.[0] https://dl.acm.org/doi/pdf/10.1145/224139.1379849[1] https://clasp-developers.github.io/"	medo-bear	15.129487	-3.950052	comment	3.0	10.0	1683886329	-10.328239
35937063	> Lisp, which seems to go to great l	"> Lisp, which seems to go to great lengths to isolate you from the details of machine organization.Right there, along with Haskell is exactly why Lisp was never an option for me. And much like the author, I've been subjected to the darn thing multiple times since an early age (the 80's).[EDIT]: and most notably missing from the list: The Lisp ecosystem is pretty much impossible to understand.There are so many flavors of the darn thing none of which are interoperable with the others.Every time I found something written in some random dialect of Lisp, there's always a missing piece to get it to run on my machines unless it's a 20 line coding exercise.I've also never found a list that explains why ""this Lisp is different from that Lisp because ..."" .Everyone in that world seems to assume thei"	ur-whale	15.139127	-3.9581742	comment	3.0	10.0	1684061972	-10.439565
36017430	This is such a tired trope. Scheme, 	This is such a tired trope. Scheme, CL and clojure all have people building incredible things with them. Not to mention things like Cisco buying the company behind chez scheme. Ask yourself why. Ask yourself why nubank bought cognitect. Consider spritely goblins being built in scheme. lisp is a weapon.	shaunxcode	15.144258	-3.9485307	comment	3.0	14.0	1684635726	-10.813203
36018642	> all have people building incredibl	> all have people building incredible things with them.what the trope really meant is that why these lisp dialects do not become mainstream despite the sales pitch of it being superior.The examples mentioned are niche at most. Why is it that you are more likely to see a nodejs app or a java app, if you randomly sampled any software project?	chii	15.140957	-3.9495895	comment	3.0	10.0	1684652755	-10.476733
36022599	> Scheme looks like Lisp but isn't r	> Scheme looks like Lisp but isn't really LispWell that’s a surprising statement, i’ve heard it touted as more lispy than common lisp.	harperlee	15.144784	-3.9466653	comment	3.0	12.0	1684687166	-10.432897
36028646	What's the point of posting this? Yo	"What's the point of posting this? You may not be their target demographic. No one's forcing you to use it.If I see a post about a new Lisp dialect (something I have no interest in), commenting ""That will be a hard no from me thanks."" is a waste of time and space."	ipsum2	15.150201	-3.9442406	comment	3.0	12.0	1684742963	-10.460649
36044128	What would you say to people like me	What would you say to people like me who never ever use LSP regardless of language? I think a team of people with my workflow (plain emacs and a repl) could build and serious software projects successfully. So maybe LSP isn't the be-all end-all in that department?	whateveracct	15.111633	-3.9728756	comment	3.0	13.0	1684849244	-10.437329
36107154	Steel Bank Common Lisp 2.3.5 release	Steel Bank Common Lisp 2.3.5 released	mm007emko	15.144073	-3.933978	story	3.0	130.0	1685303486	-10.453462
36121590	Lisp user here. How come they can’t 	Lisp user here. How come they can’t change their parser?	LispSporks22	15.118752	-3.9716346	comment	3.0	10.0	1685426566	-10.402874
36154867	notably not 'lisp features that have	notably not 'lisp features that have been absorbed elsewhere' but instead the opposite, lisp features that still make it uniquetl;dr1. no part of the system off limits2. pervasive interactivity3. homoiconicity	smegsicle	15.148962	-3.941682	comment	3.0	26.0	1685642183	-10.490237
36155569	Honestly just using Steel Bank Commo	Honestly just using Steel Bank Common Lisp is the best choice if you are looking to build high quality software which just works.A lot of my software which earns a $4 million profit per year has SBCL sub systems though that is slowly decreasing as we are moving away from Lisp.	ilrwbwrkhv	15.127536	-3.9482143	comment	3.0	16.0	1685645294	-10.444109
36194924	Can you share where do you use lisp?	Can you share where do you use lisp? I'm curious what are its niches nowadays.	gostsamo	15.143579	-3.938796	comment	3.0	54.0	1685964956	-10.46409
36195181	The blub paradox strikes the lispers	The blub paradox strikes the lispers hardest, for they have been reassured by PG and each other that there is no language better than lisp. Those of us using more powerful languages should learn from their hubris.	hoosieree	15.139987	-3.9434423	comment	3.0	19.0	1685967276	-10.4533615
36195350	Well, I like Lisp, too.  But the mac	Well, I like Lisp, too.  But the macros are not really good, but they are basically buggy ('non-hygienic'), and it took a few years to realise and repair that.  Look at Scheme or Racket instead.	beeforpork	15.131656	-3.9575717	comment	3.0	14.0	1685968486	-10.417115
36195799	> Neither the LH people holding LH s	"> Neither the LH people holding LH scissors nor the RH people holding RH scissors are ""wrong"". It's just the RH people trying to use LH scissors who are having a bad time.True, and good insight, but it doesn't mean that all scissors, or all languages, are equal. They can all perform computation, but a person with a particular language might create incredible things that another person with another language would have a hard time with.Let's appreciate the difference in tastes, which reflect our different in thought processes and approach to the world, but it does not mean that every language is the same, nor every person is the same. A Lisp virtuoso will build tools which are completely alien in design and operation than tools built by a Java virtuoso.I really don't want to take this off-to"	sph	15.138676	-3.9470086	comment	3.0	14.0	1685971171	-10.447291
36198522	Framing it as addiction was a mistak	Framing it as addiction was a mistake, but the intention is accurate: S-expressions are weird when you're used to C-like languages until they're not. You have to push yourself long enough to get used to them, and most people don't want to do that. Once you do, everything makes sense.What did it for me is realising that after some time, you don't pay attention to the parentheses. Identation in lisps is semantic, which looks weird when you're used to one level at a time. But try using a sensible formatter (e.g. Clojure's cljfmt, Racket's fixw). They will show you good ways to format your code, making it very readable, parentheses and all.Then you get used to structural editing with Paredit or vim-sexp, and you're sold on S-expresssions.	maleldil	15.0969715	-4.0026	comment	3.0	14.0	1685981812	-10.372706
36239741	Well I counted 0 references to Lisp 	Well I counted 0 references to Lisp or Scheme in the documentation, so it seems to be presented as novel.	frou_dh	15.14182	-3.9440753	comment	3.0	10.0	1686221069	-10.421132
36241799	If this project interests you but is	If this project interests you but is a bit more minimal than you need, the Janet language is a slightly-less but still pretty lightweight embeddable Lisp with a strong library and community: https://janet-lang.org/	joeatwork	15.134477	-3.942733	comment	3.0	18.0	1686231938	-10.513741
36265812	Why the AI community still needs Lis	Why the AI community still needs Lisp (1996)	mepian	15.142491	-3.9374406	story	3.0	17.0	1686353820	-10.426929
36270565	The Embeddable Common Lisp (2005) [p	The Embeddable Common Lisp (2005) [pdf]	andsoitis	15.1467285	-3.9341557	story	3.0	42.0	1686405998	-10.420322
36271228	I would like to use it to produce fu	I would like to use it to produce fully static executables for simple utilities written in Common Lisp, but I haven’t successfully gotten it to work yet. Basically, in any case where a 50 MB SBCL binary would be overkill (eg performance is not critical and portability is the top concern).I’ve also read elsewhere that ECL runs on OpenBSD, where other CLs have traditionally not been fully featured.Edit: also seems like it could help with compiling to WebAssembly (again, when performance is not critical), although I think their work there is not complete yet.	schemescape	15.112133	-3.9532144	comment	3.0	13.0	1686410094	-10.320276
36395677	> express programs in as few express	> express programs in as few expressions as possibleI don't find this appealing on its face. Extreme terseness, even when done very elegantly, makes programs very hard to read and sometimes also hard to maintain.I suspect that's one of the reasons Lisps (and functional languages in general) haven't caught up in popularity even as it becomes much easier to adopt one for any target and in any organization.	smt88	15.104757	-3.9882586	comment	3.0	14.0	1687203824	-10.40575
36500333	What Lisp needs is an IntelliJ IDE.F	What Lisp needs is an IntelliJ IDE.Failing that, true support for out-of-the-box with Visual Studio Code would be nice. Yes, I know about Alive and that... what I mean is, you open up a Lisp file and it asks to download the LSP for Lisp, Alive, and other support extensions.	bitwize	15.098654	-3.9613574	comment	3.0	15.0	1687909695	-10.428624
25843064	What is the magic behind Lisp anyway	What is the magic behind Lisp anyways?Is it that the Lisp language exposes the Abstract Syntax Tree (AST) of the code, so that you can reformulate it into your domain-specific macros, thereby helping you encapsulate complex logic into more succinct constructs?Is this why they say that Lisp is fantastic for small groups of programmers, that share similar groupthink, and uses all the same macros, but it becomes a horrendous mess when multiple teams are involved.	blackrock	15.1333885	-3.966359	comment	3.0	12.0	1611122922	-10.414613
25886630	Ask HN: LISPers, do you use homoicon	Ask HN: LISPers, do you use homoiconicity (code-as-data)?	lopatin	15.123472	-3.9697027	story	3.0	3.0	1611439934	-10.430318
25962939	I love them. Lisp can use lists for 	I love them. Lisp can use lists for everything, and PHP arrays ;)Thanks to their mixed nature they're very versatile. People even make small DSLs out of them. And they're order-preserving, so they won't inject non-determinism just to smugly teach you a lesson about real hash tables.	pornel	15.109929	-3.9784622	comment	3.0	12.0	1611956200	-10.475404
26035837	Script Lisp	Script Lisp	rcarmo	15.11715	-3.9688041	story	3.0	88.0	1612530284	-10.299931
26066273	Interestingly, not much about ML. Su	Interestingly, not much about ML. Surprinsing for lisp which, if I understand correctly, has roots in AI...	wiz21c	15.134928	-3.944931	comment	3.0	24.0	1612800216	-10.390281
26067478	As someone who has written a lot of 	As someone who has written a lot of CL and now deals mostly in scheme, why is an unhygienic macro system important? I don't think it matters much, and frankly I think something like vanilla syntax-case isn't hygienic enough. Either I don't want to care about accidentally capturing identifiers (and be very explicit when I do want it - Day like in srgi-72), or I want to have a system where I deal with explicitly (defmacro)Which I am using matters very little.	bjoli	15.107565	-3.9812045	comment	3.0	30.0	1612805429	-10.321599
26067353	To me, the entire point of Lisp, the	To me, the entire point of Lisp, the thing that sets it apart from other languages, is unhygeinic macros. Since that is my view, I can only recommend Common Lisp. CL is the opposite of modern, but just because something is modern doesn't make it good, nor does old make bad.	tines	15.129106	-3.964482	comment	3.0	36.0	1612804760	-10.458455
26070198	Correct me if I'm wrong, but Lisp-2 	Correct me if I'm wrong, but Lisp-2 vs. Lisp-1 has nothing to do with hygiene, it just splits Scheme's single problem (lexically binding values in macros) into two problems (lexically binding values in macros, and lexically binding functions in macros).The real problem, which Naggum includes, is the lack of GENSYM (if scheme indeed lacks it), and lack of first class symbols, as he mentioned.	tines	15.133251	-3.9614785	comment	3.0	11.0	1612818754	-10.389792
26072351	> Common Lisp would greatly benefit 	> Common Lisp would greatly benefit from programmers obsessed with making the language more useful to themselves and others today.It's never going to happen.Lispers were saying this same tune back when I last was using Common Lisp in 2003.Even back then there were better Lisps than Lisp. Perl is a better Lisp than Lisp. Perl gave the world CPAN and, I believe, the first real mainstream usage of a garbage collector (this is before Java and JavaScript, which I guess one could argue were more mainstream but possibly only due to the fact the internet was a much smaller place compared to today).Since then we've gone through PHP, Python, Ruby, JavaScript (ES6/node), Clojure, Scala, C#, and many other languages slightly off my radar (Rust, Go, Swift, Kotlin, etc.). There is simply no niche Common	deckard1	15.130854	-3.968009	comment	3.0	10.0	1612830786	-10.440269
26116386	Since this is HN I will point out th	Since this is HN I will point out that s-expressions are vastly superior:    (path (d (M 10 10) (H 90) (V 90) (H 10) (L 10 10)))	goto11	15.076381	-4.013344	comment	3.0	12.0	1613152258	-10.269506
26221614	Never understood why languages like 	Never understood why languages like this don't just adopt full Lisp syntax. I'd have been much more interested.	didibus	15.126548	-3.9692075	comment	3.0	10.0	1613977160	-10.446558
26298338	Yeah but none of those are inherent 	"Yeah but none of those are inherent advantages of Lisp...I really don't get this sort of ""Lisp is cool"" article touting advantages the Author was impressed by during their childhood that have long since been overtaken by technical advancements in other languages."	FeepingCreature	15.144353	-3.943954	comment	3.0	17.0	1614557236	-10.436464
26298738	Continuation on “Not This Lisp Again	Continuation on “Not This Lisp Again”	p_l	15.147625	-3.9378555	story	3.0	49.0	1614561052	-10.438865
26389133	Almost 20 years ago, I met Patrick a	Almost 20 years ago, I met Patrick at a Lisp meetup in a pub in London where he talked to us about Croma, the Lisp he developed for Web use.  I learned that he was looking for a Lisp machine, and as I had a Symbolics 3630 which I hardly ever used, I arranged for someone to pick it up and deliver it to him.   I wonder if it still works and if he is still using it.	DonaldFisk	15.149338	-3.9367518	comment	3.0	15.0	1615226474	-10.43998
31055667	I suppose it depends on what you mea	"I suppose it depends on what you mean by ""static types"" since you can optionally specify types in Common Lisp. SBCL even does precise type checking[1]:""If a variable is declared to be (integer 3 17) then its value must always be an integer between 3 and 17. If multiple type declarations apply to a single variable, then all the declarations must be correct; it is as though all the types were intersected producing a single and type specifier.""[1] http://www.sbcl.org/manual/#Handling-of-Types"	bachmeier	15.113296	-3.96849	comment	3.0	16.0	1650139715	-10.31732
31149681	> Any sufficiently complicated C or 	> Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.I call BS on that “rule”. 25+ years of experience here working on very large C/C++ code bases used by large commercial companies. And I have never ever seen this happen in practice. I know that the often cited “rule” makes some Lisp fans feel all smug and superior. But it doesn’t seem to be based on reality.	mbrodersen	15.123823	-3.9610152	comment	3.0	16.0	1650847641	-10.364445
31179632	“LISP is worth learning for a differ	“LISP is worth learning for a different reason — the profound enlightenment experience you will have when you finally get it. That experience will make you a better programmer for the rest of your days, even if you never actually use LISP itself a lot.”— http://www.catb.org/~esr/faqs/hacker-howto.html#skills1	teddyh	15.139466	-3.946692	comment	3.0	21.0	1651066357	-10.477056
31179958	"Honestly, ""just because I want to"" s"	"Honestly, ""just because I want to"" sounds like a more compelling argument than talking about enlightenment. Mainly because the latter implies that people who don't know lisp are somehow unenlightened or lacking in some way - that comes across as really arrogant and it's clearly false since there are many successful and highly skilled programmers who don't know or care about lisp.I kind of agree with the GP comment - nobody needs to learn lisp. The main reason to learn it is some personal interest or curiosity."	jstx1	15.152667	-3.9343631	comment	3.0	16.0	1651067958	-10.474606
31182783	That's also the problem with Lisp (a	"That's also the problem with Lisp (and other powerful languages). They are far too malleable. They can be changed into unrecognizable blobs by people with lots of intelligence but low wisdom (I include myself in that group).They don't _have_ to. They can lead (and often do) to clean implementations. But we tend to like 'cleverness'. The larger the team, the more detrimental the effect.That's why we ended up with Java. And more recently, golang. As much as I like Go on its niche, it's a straightjacket. I'd often think to myself ""this whole file I've been working for a week on would be 5 lines of scheme or lisp"". But then if I get run over by a bus the company could theoretically replace me the next day (they couldn't because there's far more knowledge required than coding, but they think th"	outworlder	15.11283	-3.974332	comment	3.0	10.0	1651079566	1.6518385
31226684	Same, and I was also very surprised 	Same, and I was also very surprised to learn of a professional programmer who had never heard of Lisp! Not meaning to condemn the author: apparently I have a bubble around my own head.	b3morales	15.145765	-3.942801	comment	3.0	14.0	1651425128	-10.495379
31247919	Whenever people bring up Lisp syntax	Whenever people bring up Lisp syntax, I like to remind everyone about io language. Its homoiconicity is inspired by Lisp, and almost all good things about Lisp syntax are applied in io, but at the same time it avoids this awkwardness that turns away most of the people (and turns the remaining minority into zealots :-)So if you design a language and want to use Lisp-like syntax, I recommend to also check out io before steaming ahead.	oleganza	15.115245	-3.9823606	comment	3.0	10.0	1651583996	-10.346961
31248903	What I look for in a language first 	What I look for in a language first is how good the support is for concurrency, and especially if it has a good, modern concurrent garbage collector.A quick search brought up this:https://lisp-journey.gitlab.io/blog/pro-mailing-list-on-comm...> This was primarily for the lack of good parallel, concurrent garbage collectors in Common Lisp implementations. The CL version of elPrep was actually still a tad faster than any of the C++, Go, or Java versions, but we had to work hard to avoid long GC pauses. elPrep allocates a lot of memory, and the pause time hurts a lot. We solved this by, basically, disabling the garbage collector, and reusing memory manually as much as possible, which turned the program into almost a manually memory-managed affair.	amelius	15.124473	-3.9554055	comment	3.0	11.0	1651588774	-10.401736
31252448	> all the parentheses are unnecessar	> all the parentheses are unnecessary tooThat's not quite true.  In Forth it is impossible to tell syntactically where the function calls are.> it is the closest thing to Lisp machines experience you can get today.I think Clozure Common Lisp running on a Mac (i.e. with the IDE) is pretty close as well.But I don't begrudge anyone their Smalltalk.  It's just not a good impedance match to my brain.	lisper	15.099342	-3.9955437	comment	3.0	20.0	1651606189	-10.3314
31253826	I've been fascinated with the 'Lispi	I've been fascinated with the 'Lisping in the JPL' piece (even though I tend to prefer Scheme). However, I've been trying to find something substantial about the 'remote agent' and I can't really find much. Sure, there are some articles describing at a very high level how it worked, but not much more than that. At least, I couldn't find.Do you think anything survived that would shed more light in its workings? Not even talking about the code (although that would have been wonderful, and maybe it should be provided - taxpayer funded and whatnot).	outworlder	15.136471	-3.9313397	comment	3.0	12.0	1651613321	-10.45324
31254359	> macros aren't functionsThat's true	> macros aren't functionsThat's true, and it is arguable that Lisp could be improved by making macro invocations have a distinguished syntax.But in practice it's usually pretty clear what is a macro and what is a function because of naming conventions, and because macros commonly admit syntax that would be illegal in a function call e.g. (let ((x 1)) ...)  But however bad this problem is in Lisp, it's much worse in Forth.> Forth doesn't really have functionsThat is debatable.  If I write 1 2 + 3 * then I think of the + and the * as function invocations that take their arguments off the stack and leave their results on the stack.  It's true that this is not exactly the same as a function call in Lisp, but it's similar.  In any case, if I write:a b c d e f g h i jthere is absolutely no way t	lisper	15.085482	-4.005889	comment	3.0	11.0	1651616548	-10.376375
31256097	Laughs in LispCode is Data would lik	Laughs in LispCode is Data would like to have a word	nvader	15.123151	-3.9616563	comment	3.0	12.0	1651631438	-10.416399
31328469	Common Lisp has had this for decades	Common Lisp has had this for decades: DEFINE-COMPIILER-MACRO.	lisper	15.107636	-3.9822743	comment	3.0	26.0	1652197445	-10.292072
31561569	> There's absolutely nothing wrong w	"> There's absolutely nothing wrong with Emacs being programmed in Lisp and it sure as hell isn't ""a poor architectural decision""I love Scheme and Lisp. I've probably written several million lines of code in both Scheme and Lisp and I've contributed code to several Lisp and Scheme compilers.But languages are absolutely slow or fast! There are fast Schemes and Lisps and there are slow ones. Emacs has probably the slowest one by far. For example, Emacs still relies on dynamic binding after all of this time. That's a performance disaster.There is simply no efficient implementation of Elisp possible as it stands and as it is used today. Even with JIT compiling Elisp performance is simply wretched."	light_hue_1	15.116508	-3.9612238	comment	3.0	16.0	1653932874	-10.467693
31584997	Funny enough I was talking with some	Funny enough I was talking with someone who wanted to make a lisp run on a very small ARM SoC and we discovered that the 7090 Lisp 1.5 was developed on likely had more core+drum than the SoC had ram.	aidenn0	15.134847	-3.9423842	comment	3.0	24.0	1654103713	-10.395252
31589163	Do you mind enumerating what those s	Do you mind enumerating what those systems are? I've only played around with Allegro CL and SBCL myself.	dmux	15.137297	-3.9356194	comment	3.0	13.0	1654123936	-10.434599
31594232	So true! Also, there are no decent U	So true! Also, there are no decent UI frameworks for Lisp, so it's impossible to build a full stack app that looks good in a modern browser without adding a TS or JS web component layer. And... There's no modern IDE for Lisp.I think this aspect of ignoring UIs and aesthetics has seriously held back CL.	dtagames	15.110428	-3.9705389	comment	3.0	12.0	1654174589	-10.427269
31637633	Well, the unique bit is images and h	Well, the unique bit is images and homoiconic metaprogramming, not just metaprogramming. You can get that unsafely (code generation scripts) or safely (program extraction from a proof language) a lot of other places.But the main argument is that Lisp is hyperproductive if you’re an individual brain genius who’s memorized every emacs key combo. And my point is that it doesn’t matter if you can produce something fast if you can’t know if that thing actually works.This is the traditional “static vs dynamic typing” argument but you know, a lot of new languages have new kinds of safety features going beyond “static typing”.And of course Lisp does make unusual decisions affecting safety. Making all numbers bignums means math is more likely to be correct since it won’t overflow, but untrusted use	astrange	15.111428	-3.9828122	comment	3.0	10.0	1654495331	-10.256638
14065279	CL allows us to write code the way w	CL allows us to write code the way we think about a problem--and then bring life to that way of framing the problem. We can come up with an ideal way of describing a solution and then make a language work that way. I say a language because the target of our code might be C or JavaScript (these days that is more often the case for me than targeting CL itself, cf. 4500 recent lines of Lisp that turns into 8000 lines of terse JavaScript).Our ability to reason correctly about systems directly corresponds to how complex they are. And I posit that complexity in code is best measured in number of symbols (because lines can be arbitrarily long, and longer symbol names can actually be helpful). So a system that reduces the number of symbols necessary to express a solution increases the size of a so	enduser	15.108838	-3.9915936	comment	3.0	10.0	1491624989	-10.414816
14066584	"Common Lisp packages are ""weird"" bec"	"Common Lisp packages are ""weird"" because they don't express the same concept popular languages do. CL package is not a Java package. I know I tripped over this at the beginning.Some helpful links:http://www​.flownet.com/gat/packages.pdfhttp://www.gigamonkeys.com/book/programming-in-the-large-pac...As for community, it's fine now. Lots of friendly and helpful people there."	TeMPOraL	15.131875	-3.9625993	comment	3.0	12.0	1491654284	-10.463877
14167941	Berkeley made the same switch at aro	Berkeley made the same switch at around the same time, and it made me sad.Having done the intro course in Scheme, I'd say it helped me understand functional programming far more than I ever could have with Python, and it opened me up to different ways of thinking.Even though I never again used any Lisp variant, I'm still really glad I learned it and feel that what I learned using Lisp has informed my future decisions.	jedberg	15.140108	-3.9572084	comment	3.0	12.0	1492798703	-10.448322
14248070	For me it's not the paranthesis, but	For me it's not the paranthesis, but that Lisp posts always show low level code. At least half of my programming is tying together high level services and libraries. I know how I can express those concepts succinctly in Java, C++, JS, Swift etc. I'd love to see some examples of Lisp for something like a REST controller, where I call services, repositories etc.	emsy	15.137525	-3.9618063	comment	3.0	10.0	1493743900	-10.414664
14248114	You left out a rather glaring object	You left out a rather glaring objection:7 - Lisp has a tendency to lure programmers up the river of insanity [0] due to the sheer power of macros (particularly reader macros). This can leave the rest of the team (or any successors) struggling with a mountain of technical debt. Overall, I think the power of Lisp makes it difficult for a community to organize without a BDFL to keep everyone on the same page.[0]  http://tvtropes.org/pmwiki/pmwiki.php/Main/RiverOfInsanity	chongli	15.134742	-3.9548688	comment	3.0	11.0	1493744177	-10.463403
14248502	7 - It's too easy to make a mess. An	7 - It's too easy to make a mess. And the mess made by brilliant people who are looking for any excuse to put higher order metaprogramming and functional concepts into production is considerable.8 - It has consistently lost in the marketplace in the last 20 years. We had most top CS grads in North America groomed on SICP at one point in history. You'd think many of them would want to use Lisp in production. Many of them did. Now MIT uses Python to introduce programming, and Lisp code bases tend to be (horrifying) legacy systems. Virtually no startups base the core of their business on Lisp anymore, and it's not because the technical founders aren't aware of it.(Lots of skunkworks Clojure projects are out there bearing load though.)	Will_Parker	15.132052	-3.960119	comment	3.0	42.0	1493746319	-10.538685
14249400	SICP uses Scheme, which is not Lisp.	"SICP uses Scheme, which is not Lisp. It was taught at an introductory level because some concepts of computation can be taught nicely with Scheme, up to making a compiler for another language (perhaps a ""real"" language in the student's minds?), but it doesn't actually teach you Lisp, and I imagine leaves a bad taste in many students' mouth at the nonsense no-for-looping-no-mutation they had to suffer through which isn't a requirement in Lisp (nor necessarily in Scheme). SICP doesn't even have something as quick to go through as e.g. this series http://malisper.me/2015/07/07/debugging-lisp-part-1-recompil... to get a feel for what it's actually like to work with Lisp.Clojure has been very successful though it seems like your point #7 would apply more-so to it (since Lisp isn't as functional"	Jach	15.131184	-3.9544506	comment	3.0	39.0	1493751167	-10.527447
14249826	> 1 - All those parenthesis. (Still 	> 1 - All those parenthesis. (Still a top objection)If you actually count parens fairly you will find that Lisp has no more than any other language, it's just that other languages use a mix of parens, square brackets and curly braces whereas Lisp only uses parens.  Also, if you really don't like parens, you can get rid of a lot of them using macros.  See e.g.:https://github.com/rongarret/ergoliband in particular the binding-block (BB) construct.> 2 - Lisp doesn't look like or work like what I'm used to.Neither does anything else until you get used to it.> 3 - Lisp doesn't have as many libraries as the most popular mainstream programming languages.That used to be one of my objections, but it's simply not true any more.  And with Quicklisp accessing the (very large) collection of available l	lisper	15.110371	-3.9842885	comment	3.0	46.0	1493753890	-10.34745
14250677	Is Python a LISP? Is JavaScript a LI	"Is Python a LISP? Is JavaScript a LISP? Is Java a LISP? What do you mean by LISP, by its core principles? What does a different set of core principles look like that lends itself to a different family? I threw in my vague classification above: sexps and macros. But you can have macros without sexps, and sexps without macros (lots of ""toy lisp interpreters"" do that), are they LISPs? Lastly one wonders why we don't go calling all these C-like languages ALGOLs. What do you gain by trying to separate from other ALGOLs?Or less extremely, why don't we consider Python and Ruby to be the same family, or Java and C#? Those pairs are arguably more similar than the pair of Common Lisp and Scheme."	Jach	15.132658	-3.962543	comment	3.0	12.0	1493759684	-10.458605
14252252	To me, that's a sign that maybe a la	To me, that's a sign that maybe a language has too little syntax.I can read C++, Javascript and PHP just as well in plain text because the other non-paren elements provide necessary contextual cues, along with nesting. Syntax coloring is helpful, but it shouldn't be necessary.I can at least understand nesting closing parens on their own lines, the way Roboprog did above, but throwing all of them on a single line just seems like needless noise.	krapp	15.082142	-4.0040555	comment	3.0	16.0	1493774000	-10.141367
14252382	>Is it that absurd? Where is Scheme'	>Is it that absurd? Where is Scheme's CLOS, condition system, built-in debugging framework, and batteries-included standard library? Type declarations? Dynamic scoping? Multi-methods?Does Lisp from 1960 have these things? Then I guess it isn't really Lisp?	Volt	15.135847	-3.9501774	comment	3.0	11.0	1493775792	-10.431352
14253066	The hesitation I'd have with Lisp(s)	The hesitation I'd have with Lisp(s) as an outsider, which ties in to number 3, is that the language itself is compact, elegant and extensible. It's the opposite problem to C++ (the language is too large) - the language is too small and it encourages you to build other languages inside it. So it'd be very hard to share code with others because as soon as you start building abstractions your language and worldview diverges from everyone else's version of lisp - to use a library you have to learn someone else's mini-language. Maybe this is an invented concern though, did you find integrating other libraries a problem?Did you have any problems with development speed or performance in production or was that fine?	grey-area	15.13078	-3.9603934	comment	3.0	11.0	1493786073	-10.44487
14269307	Basically 'Relational Lisp' won. Jus	Basically 'Relational Lisp' won. Just three hours development time.	lispm	15.140847	-3.9434276	comment	3.0	16.0	1493935757	-10.457017
14325573	I feel like writing a LISP in a gc'e	I feel like writing a LISP in a gc'ed language is taking away most of the fun of it.  I wrote one in C (without a conservative garbage collector) and the most interesting aspect was what had to be done to allow garbage collection.Garbage collection can run inside nearly all subroutines.  So any temporary references stored outside of the heap need to be kept track of at all times.  If gc occurs you have to able to walk the entire heap and the entire callstack to mark live data.  This is obvious but I enjoyed finding it out (and subsequently rewriting everything).	rrmm	15.093596	-3.994999	comment	3.0	11.0	1494607799	-10.300858
14333793	Indeed, homoiconicity is a very powe	"Indeed, homoiconicity is a very powerful thing. It doesn't have to be core to the nature of the language, though; as far as I know, any Turing-equivalent language readily admits a metacircular interpreter, and so really a homoiconic language is a language with a compiler in the standard library.As a thought experiment, imagine Lisp without macros. It's not hard; after all, ""The Little Schemer"" covers metacircular interpretation without ever mentioning macros. So what's going on? Apparently we don't need macros! But, we could add macros to a Lisp by reifying them in the metacircular interpreter. There's actually a feature in plain sight which makes this possible, and it's the humble (quote) special form. This is what makes code and data intermix so cleanly in Lisp.This is why languages like"	DonbunEf7	15.107973	-3.989065	comment	3.0	13.0	1494725296	-10.423484
14417848	I suppose, and I'm a big Purescript 	I suppose, and I'm a big Purescript & Haskell fan these days but...My take is that Common Lisp was never really truly a functional language. It has always been a hybrid language that focused on the unique aspects of Lisp first, and everything else second. Lisp's focus on superior macro facilities, the CLOS, and the MOP really shows in the spec. CL primitives were never as concerned about general composability as they were about offering syntax to cover every conceivable case.To some extent, I miss this philosophy. Meta-syntactic programming is something important and fundamental to language (as opposed to the monadic style of haskell which is more fundamental to computation).	KirinDave	15.12064	-3.982259	comment	3.0	13.0	1495725563	-10.466874
14476148	Single quote denotes a symbol in sch	Single quote denotes a symbol in scheme.  But this snippest is not strictly scheme.  Perhaps it is SXML but I am not familiar with it.	brianon99	15.118927	-3.9597988	comment	3.0	12.0	1496493922	-10.356664
14480806	>Keep in mind that a compiler like S	">Keep in mind that a compiler like SBCL will put Lisp performancewise in the rangeSimple short benchmarks don't show a complete picture of the language, since they're  easy to optimize>written in Macintosh Common Lisp needed 20 MB RAMAt the time when computers had 32/64 MB of RAM.>. You can use many Lisp implementations just like scripting languages.
>If a compiler is used (say: SBCL, ECL, LispWorks, GCL, CCL, Allegro CL, mocl, ...) , then Lisp does not require runtime interpretation.
>Only if you include an interpreter.So which one is it?>Treeshakers remove unused code and data. Parts of the runtime are still there.Huh, What kind of unused code and data is there in a 25MB hello world?
https://web.archive.org/web/20090324024745/http://mbishop.es...>If all fails, you can always compile Comm"	FrozenVoid	15.11715	-3.9686835	comment	3.0	25.0	1496574881	-10.368671
14482286	For me the problem with Lisp is that	For me the problem with Lisp is that it's just ugly to look at. Compare some Lisp code to an equivalent in Python, just in terms of the raw visual appeal of the text. The parentheses and indentations obscure the logical meaning of the code.	d_burfoot	15.112073	-3.9828053	comment	3.0	15.0	1496594211	-10.304228
14489346	Python and Lisp coder here.At first 	Python and Lisp coder here.At first look, Lisp is ugly to look at.However once you start learning Lisp and writing your self programs, it becomes fairly easy to read not only your code but others' code.> The parentheses and indentations obscure the logical meaning of the code.Indentations have no effect in Lisp, they are only there to make code more readable.Parentheses are there to clearly tell you which statement is acting over which other statement, so they are there to give you a clear light about the meaning of the code.Visual appeal can be just fine, as long as the indentation is well-applied. The same is true for widely used languages like Java, C, C++, C#, and Javascript. Wrongly indented C code can be frustrating to read.Have this small, silly snippet of Common Lisp code and take 	flavio81	15.110174	-3.987651	comment	3.0	12.0	1496683068	-10.379144
14526968	L2 is an experimental programming la	"L2 is an experimental programming language that maps efficiently to machine code (like C). I think it is interesting because I have not seen
1) control flow primitives that are like Scheme's continuations but that are also efficient
2) L2's variant of s-expressions that do not need a symbol or string data type
3) a macro system that is equivalent to but operates differently from Common Lisp's"	murisitarusenga	15.118502	-3.9764194	comment	3.0	16.0	1497094131	-10.428879
14582073	I agree Emacs Lisp is pretty inferio	I agree Emacs Lisp is pretty inferior as far as lisps go, but IMO this seems pretty misguided.Technically impressive, I'm sure, but will it be around for another 30 years?If someone writes a module using this, will I be able to rely on that module keeping on working for the years to come?	josteink	15.114008	-3.9581873	comment	3.0	22.0	1497810670	5.8020697
14583310	That is actually a great comparison 	That is actually a great comparison and a very strong argument for not using JavaScript. BASIC was big in the 1980s; where is BASIC today? Elisp code from the 1980s still runs or can be trivially ported to Emacs 25. Lisp is not a fad and Lisp never goes away.	sedachv	14.9871435	-4.067021	comment	3.0	13.0	1497824564	-10.394872
14614933	Not mentioned: written in Allegro Co	Not mentioned: written in Allegro Common Lisp (for the IDE on SGIs) and Scheme/GOOL running on the Playstation.	lispm	15.144154	-3.934742	comment	3.0	12.0	1498162179	-10.403265
14653035	I think it's about visual parsing.  	I think it's about visual parsing.  They may be greater in number in C derived languages but it's not idiomatic or considered clean by anyone to write it as you did, where it's typical to see things like )))))) in lisp.If there were multiple markers stacked up in a C based language they'd be visually distinguished from one another ];} and you'd at least have a chance.Look, we can get used to anything so clearly the lisp way can work.  But it seems pretty straightforward to me why people think it's visually confusing and why lisp gets made fun of.  Simplicity in syntax is great but lisp really overdid it.  If you invented a human language that could get by with only 12 letters, I wouldn't give you kudos for that because of the general principle that simplicity is good...	moxious	15.130715	-3.964885	comment	3.0	13.0	1498646474	-10.468432
14653553	> tired of closing themThis comment 	> tired of closing themThis comment misses the point entirely. The point isn't to mitigate having to type them, it's to help keep structural preservation. All of these structural editors also do so much more than just close the parens. They allow you to edit the code as the tree it is as well as navigate it as such. Without the parens actually being there, you couldn't do that in a determininistic way, thus the auto-closing of parens is more of a side effect than anything else.	triclops200	15.069604	-4.013274	comment	3.0	13.0	1498653779	-10.128982
14656035	You know, I think it's a fine argume	"You know, I think it's a fine argument to say, ""Yes, Lisp has a lot of parentheses but we like how it looks."" I don't think it makes sense to say, ""No, other languages have more punctuation characters than Lisp."" The latter is an objective statement that can be actually tested.I went to Rosetta Code and grabbed the implementations of Conway's Game of Life in Racket, Ruby, Python, and Java. For each one, I manually removed comments and string literals. Then I wrote a little script. It looks at each character in the file and groups them into categories:    bracket: ()[]{}
    whitespace: space\t\r\n
    text: a-zA-Z01-9_
    punctuation: =,;<>-'!|?:#/*%+.

Then I looked at each file to see what fraction of non-whitespace characters are brackets or punctuation (including brackets). Here's the"	munificent	15.111489	-3.9841528	comment	3.0	13.0	1498670169	-10.406602
14662105	> All is javaPossible tip: sneak in 	> All is javaPossible tip: sneak in ABCL when they're not looking. ABCL is a Common Lisp implementation for JVM, with (what seems like) relatively OK interop between Lisp and Java code.	TeMPOraL	15.118759	-3.9714072	comment	3.0	21.0	1498732247	-10.525057
20357850	I believe every new LISP author shou	I believe every new LISP author should begin their presentation with how does their language compare to other LISPs (CommonLisp, Racket and Clojure in particular). Mentioning it's a LISP-1 in the beginning is nice but not really enough.	qwerty456127	15.164591	-3.9341218	comment	3.0	27.0	1562274770	-10.7903
20369287	Has anyone used Carp? What is your e	Has anyone used Carp? What is your experience with it?I looked at it a few times over the years and the domain (statically typed language with Rust-esque lifetimes for no GC) is exactly what I've wanted a few times, but there isn't any mention of embeding Carp in a program, only using it standalone. Targetting e.g. video games with low latency is fine, but I'd rather write an engine (or use an existing one!) and use Carp for scripting than be locked into solely Carp.	chc4	15.080886	-3.9681847	comment	3.0	10.0	1562415710	-10.28328
20369914	i mean, is code written in lisp-like	"i mean, is code written in lisp-like functional style maintainable? it always takes a few seconds more per line of code for it to register if it does at all... versus code written in say imperative or declarative style.i mean what could this possibly mean? ""(bg rend &(rgb (/ @state 2) (/ @state 3) (/ @state 4))))"""	blondin	15.12996	-3.9698613	comment	3.0	12.0	1562424180	-10.459866
20374332	> Multics Emacs was the first Emacs 	> Multics Emacs was the first Emacs implemented in LISPNo, the first Emacs in Lisp was the one from Dan Weinreb for the Lisp Machine, which was also the second Emacs implementation. It was called EINE, EINE Is Not Emacs. Then ZWEI, ZWEI Was EINE Initially.	lispm	15.126802	-3.9550343	comment	3.0	11.0	1562492648	-10.383494
20375622	I wonder what is the most widely use	I wonder what is the most widely used, popular program, that has been written in Lisp?  Is it Emacs?Every time I sit down to try to learn Lisp, I end up wondering what the hell I'll use it for.  Functional programming languages seem to have flipped a bit in my mind that predisposes me to be prejudiced against Lisp .. I find it very hard to do anything actually useful with it, whereas I can pick up c++ or Lua or Python and immediately get something running.I'm not saying this is Lisps' fault, but I've been programming for 30 years and have tried many times to become a Lisp programmer.. its just never been effective.	fit2rule	15.136947	-3.956642	comment	3.0	16.0	1562513978	-10.445688
20375694	Lisp hasn't failed. Software enginee	Lisp hasn't failed. Software engineering has failed to reach the conceptual level that Lisp operates at.	abrax3141	15.147538	-3.9417152	comment	3.0	36.0	1562514933	-10.444786
20376271	The crust of the article is:> The re	The crust of the article is:> The reason Lisp failed was that it was too successful at what it was designed for. Lisp, alone amongst the early languages was flexible enough that the language itself could be remade into whatever the user required. [...] However, the process causes Balkanization. It results in many sub-languages all slightly different. This is the true reason why Lisp code is unreadable to others. In most other languages it is relatively simple to work out what a given line of code does. Lisp, with its extreme expressibility, causes problems as a given symbol could be a variable, function or operator, and a large amount of code may need to be read to find out which.And I perfectly agree. You can see it in tutorials too. You can even see it in any Lisp-lover comments showing 	sametmax	15.13469	-3.9575555	comment	3.0	10.0	1562520181	-10.425043
20376441	Was Pascal a failure? Lots of progra	Was Pascal a failure? Lots of programs were written in it. It had killer apps. Lots of programmers learned it. It made its way into the education system.Lisp might be viewed similarly. It’s not a fad and big companies don’t use it widely, but does that make it a failure?Google uses Common Lisp. (They even host a style guide!) So does Rigetti Computing making quantum computers. So does/did DWave, another quantum company. There are a handful of companies that have existed between 15–30 years developing Lisp compilers (LispWorks, Franz Inc, etc). Lisp also seems to be making HN front page at least once a week.	reikonomusha	15.142527	-3.9451194	comment	3.0	25.0	1562521530	-10.44989
20378032	"""The parentheses disappear.""  Exactl"	"""The parentheses disappear.""  Exactly so.  But, you have to use a proper editor with automatic indent, paren matching, and the ability to navigate by s-expressions.  Composing lisp with something like Notepad is just a waste of time and an exercise in frustration.It is the unambiguous notation enabled by the parentheses that allow lisp to process code as data and construct programs on the fly.IMHO, those who suggest eliminating the parentheses don't yet understand lisp.  Trying to make lisp more widely acceptable by eliminating them is throwing the baby out with the bathwater."	wrycoder	15.1028805	-3.9932532	comment	3.0	11.0	1562535289	-10.336485
20378507	>Common Lisp is about on a par with 	>Common Lisp is about on a par with Python in what it has built in, inferior in its ecosystemabout 20x+ faster than Python, too; speed in the same order of magnitude than C.>and for some modern stuff (threads, sockets)pretty amazing you bring out threads in this comparison, when Python doesn't even support true multithreading.>Macros are magic that lets you reprogram the language. Reprogrammed languages break the ability of a programmer to drop in and read the code.It's the other way around. Lisp macros allow to eliminate boilerplate and produce clearer code. This is obvious to any lisper.	flavio81	15.121715	-3.9773455	comment	3.0	25.0	1562539837	-10.387381
20378587	> It's the other way around. Lisp ma	"> It's the other way around. Lisp macros allow to eliminate boilerplate and produce clearer code. This is obvious to any lisper.I don't have any particular experience with Lisp macros, but my experience with the closest equivalent in every language I've experienced them in is very different from your experience. For the person who wrote the system, it's a clean and expressive way that eliminates boilerplate. For everybody else, though, it's an underdocumented mess of magic incantations with some mental notes of ""don't try to combine these things together, it will blow up,"" and if you ever have to debug a problem in the macro itself, you're going to find it to be a royal pain."	jcranmer	15.112038	-3.98854	comment	3.0	11.0	1562540764	-10.379765
20379047	Elephant in the room: the hostility 	"Elephant in the room: the hostility of the LISP community. Is there any language community with quite the reputation for unwelcoming unpleasantness, combined with the opposite - no counterbalancing reputation for welcoming friendliness?That people feel bad when they try to enter LISP world is much documented[1]. That Python and, say, Julia, managed to get reputations as welcoming communities long after Eternal September says the problem isn't ""everyone"" invading Usenet.I'm expecting immediate downvotes for this comment, but what I really hope for is ""yes I have that feeling about LISP world compared to other languages"" or ""no I feel LISP world is represented approximately the same as other languages"".[1] e.g. https://eli.thegreenplace.net/2006/10/27/the-sad-state-of-th... from which comes "	jodrellblank	15.141744	-3.945937	comment	3.0	10.0	1562546808	-10.464984
20416245	I've been making a language called T	"I've been making a language called TXR for ... oh, ten years this coming August now. It combines a Lisp dialect (""TXR Lisp"") with a whole-document pattern-based extraction language (""TXR Pattern Language"").  It takes the form of a simple executable with a few satellite files in your /usr/share.Lots of ""batteries"" are included in TXR Lisp: object system with static and instance slots, single inheritance, GC finalization and a form of RAII, exception handling, delimited continuations, byte code compiler for virtual machine, file compilation, macros (of course), regexes, built-in lazy lists, a fantastic set of macros for partial application, a comprehensive declarative FFI, good amount of POSIX wrapage built-in, a decent REPL with history, completion, multi-line editing, visual copy-paste, .."	kazinator	15.116071	-3.9730432	comment	3.0	14.0	1562882131	-10.397256
20433525	Even if you give LISP a role, one al	"Even if you give LISP a role, one also has to consider that it was a time when the most popular languages (C++, early Java, Perl) were pretty low-level and not at all web-friendly or async-friendly. LISP could bridge that gap because it makes it very easy to build DSLs and ""go up"" in abstraction with minimal fuss. If you start with Python or Ruby and their popular frameworks, these days, most of that work is already done for you."	toyg	15.129662	-3.9651444	comment	3.0	17.0	1563114081	-10.435481
20505102	Serious question: Why do parens matt	"Serious question: Why do parens matter so much?I read the post and all the comments here, where people are very adamant about their opinions on parens.  It seems to me that while syntax is important, parens in this context is about as close to ""just syntax"" as we can get. Racket-sans-parens would still be Racket.Am I missing something fundamental?"	badtuple	15.06127	-4.0206327	comment	3.0	10.0	1563867304	-10.143319
20507184	I think Common Lisp just needs a reb	I think Common Lisp just needs a rebranding/remarketing strategy. Until recently I always thought it was an ancient, mostly obsolete language that had a cult following due to Emacs or something. For some reason I grouped Common Lisp together with Fortran and COBOL in my mind and didn't realize it was separate from Lisp.That perception needs to change if you want it to gain more traction among developers.	umvi	15.133089	-3.9607337	comment	3.0	13.0	1563893582	-10.456095
20519632	I wish I had internalized this earli	I wish I had internalized this earlier in my career — to write code for human readers first, and compilers second.I hope someone proves me wrong, but I think you really need a Lisp to do this right.  Things always break apart with other languages because they don’t fully decouple from a computer architecture, and architectures change. When expressing ideas, human brains do not operate as Harvard machines (even though certain programming languages will try convince you so).Lisp does provide the means to limitlessly abstract and combine knowledge. There is no predefined architecture to mold an idea into, so concepts and their connections can get expressed in a natural way.For example in C-style languages, the means of combination aren’t general at all, e.g. the way to combine a function with	pieterk	15.122144	-3.9699185	comment	3.0	25.0	1564002023	-10.418307
20582036	> It is much easier to explain Lisp 	> It is much easier to explain Lisp if we begin from a blank slate.More so than any other language I know of, Lisp's reputation precedes it. Everyone seems to know all about Lisp. It's remarkably rare to find people who genuinely want to  explore Lisp the way they do other (newer) languages, with no preconceptions and biases.It also seems people do things less and less out of sheer (scholarly) curiosity these days.	zshrdlu	15.151467	-3.9375365	comment	3.0	33.0	1564647606	-10.486959
20604399	> the syntax of MANOOL is actually s	> the syntax of MANOOL is actually so simple that it could be “described on a postcard”.This immediately makes me want to read said postcard. Is there something to this effect? [Couldn't find it.]I didn't see the advantage in using braces instead of Lisp-parens or functional languages that use neither. The first thought that came to mind was using the semi-colon insertion parsing like Go, but on source text that uses whitespace indentation like Python and insert all the braces needed by the parser.	karmakaze	15.102452	-3.9965	comment	3.0	14.0	1564892326	-10.335086
20607489	Lisp is not typically a low-level pr	"Lisp is not typically a low-level programming language, but rather extremely high-level (high level of abstraction)[0].The ""dialect language of Lisp"" quote just means that it's a variation of Lisp, but running in a Python environment.The term ""domain-specific languages"" refers to programming languages created for a specific, often one-of, task. If you look at this repo, you'll see various languages used to create diagrams and graphs in this library. These are all examples of DSLs (note, they're in many places, this is just an example):https://github.com/francoislaberge/diagramsRegarding Hy specifically, it's basically Python that uses a different syntax, or skin, of sorts. Instead of white-spaces and colons, you get parentheses and...parentheses. It's more complex than that, but it's basic"	jnbiche	15.152606	-4.000439	comment	3.0	23.0	1564936249	-10.414691
20669990	Like most people, I'm going to keep 	"Like most people, I'm going to keep using the word ""homoiconic"" because it is a useful term.The article just shows that if you insist on an absurdly strict definition you end up with nonsense.  Even the ""strings"" based definition doesn't work if you're being especially literal, since there are no strings, there are just electrical fields that may or may not be in physically nearby places.Everything in software is, at some level, an abstraction.  And that's okay.S-expressions are merely a textual representation; Lisp systems don't normally store exactly the text representation.  So what?  The upshot is that homoiconic representations make certain kinds of transformations easy to use, understand, and display... and that's what people mean today.I agree that homoiconicity is not strictly bool"	dwheeler	15.103835	-3.987954	comment	3.0	10.0	1565552381	-10.420168
20697600	Part of the reason is Paul Graham's 	Part of the reason is Paul Graham's essay about his experience using Lisp at a startup: http://www.paulgraham.com/avg.html	Thorondor	15.149193	-3.9354587	comment	3.0	11.0	1565802717	-10.489457
20698256	Lisp is the red pill to programming.	"Lisp is the red pill to programming. A mind-blowing out-of-the-box experience. An alien technology. -- Lisp has a so called ""no turning back point"", true lispers cannot bear other dialects after experiencing it. From scientists in underground military bases to rich tech VCs: everyone obeys Lisp here.."	badsavage	15.138454	-3.94984	comment	3.0	10.0	1565806006	-10.482061
20699367	Lisp is the light saber of languages	Lisp is the light saber of languages : an elegant weapon for a more (mumble) age. Blasters and death stars are more effective.Nobody builds anything important with it, but it feels more pure to build toys with it than more practical languages. Some people make big toys.Nobody is expected to understand anybody else's code, so you can indulge any kind of whim, and it is easy to make any whim work well enough. Meanwhile, the mathematical bedrock of computation outcrops more frequently, so that programs can resemble theorems if you like that.	ncmncm	15.132121	-3.960877	comment	3.0	15.0	1565812821	-10.448974
20733844	Adding my own disagreement about usi	Adding my own disagreement about using either portacle or roswell. If you're running literally any widely used Linux distro, or {Free|Open}bsd you are a package install away from a working common lisp install. I've seen this come up alot in irc and reddit, this push to get people to use a C library (!) to get to common lisp, and its downright bizarre. If you're that bent on packaging and C, use Guile or Gambit.  And if you're just a random person perusing this thread, just go download the simplest thing and get started, not slime (which is awesome) not Lem (which is fine), just lisp and a text editor	dtornabene	15.112623	-3.9554486	comment	3.0	11.0	1566173904	-10.392385
20736280	Each time I see a LISP related artic	Each time I see a LISP related article on Hacker News, I always ask myself why LISP is so popular only on HN. This is the only website where I hear about LISP. Is LISP popular on HN because it brings advantages to the table or is it popular because it looks cool to say you use it, or something else?Please help me understand. I am tempted to learn it but needs justification.	madiathomas	15.151694	-3.9354422	comment	3.0	24.0	1566207704	-10.4949255
20821573	Allegro is nice. It’s fast, and has 	Allegro is nice. It’s fast, and has a great development environment. I used it all the time years ago.I recently decided to screw around with Lisp again and have been using SBCL with Atom via the Slime plugin, but it’s not very good. I can’t evaluate functions from the editor, nor can I copy-paste multiline functions into the repl. It’s very frustrating.	jonathankoren	15.158467	-3.9646645	comment	3.0	13.0	1567011264	-10.347949
20845602	> get the AST (a data structure AFAI	> get the AST (a data structure AFAIK), manipulate it in a sane fashion in Python, compile it, return the result. No string munching eval requireI use both Lisps and Python, and especially after learning to use Lisps I've wanted to do this in Python, so I looked for the ability to do what you describe here.While it is technically possible to do this (like most things) in Python, it is quite the effort and nowhere near ergonomic. Among all the cases where I could really use this, I found it worth the effort to instead:1. Manipulate & generate code statically (from ASTs), as a build-time / dev-time step, using redbaron etc.; or2. Just use a Lisp (specifically, Hy).Both methods involved writing quite a lot of code. In the former: to load, parse, match, and transform ASTs; in the latter: to po	pritambaral	15.052314	-4.033055	comment	3.0	10.0	1567249033	-10.107722
20921677	Maybe the problem isn't so much that	"Maybe the problem isn't so much that Lisp is too easy, but rather that there's no central repository for Lisp modules?  Everybody runs into the ""I need a GUI environment"" and doesn't have anywhere to search for the 30 other GUIs that have already been written and never published so they write their own.  A centralized repository for these could help a lot, especially if it enforces documentation standards before accepting modules.It's a cultural issue with all of the pre-Internet languages.  Even titans like C and C++ lack a well defined repository outside of their stuffy standards committee defined standard libraries.  CPAN showed how powerful a resource like that can be 25 years ago and almost every language since has shipped with something similar, but old languages never seem to have c"	jandrese	15.118741	-3.9615824	comment	3.0	13.0	1568058342	-10.357977
20940604	This was an incredibly enjoyable rea	This was an incredibly enjoyable read. A lesson to take away is that many of the ideas of Lisp can be taken advantage of without reeling in the entirety of an existing stack.Writing a Lisp parser is easy. Walking Lisp code is easy. Serializing Lisp code is easy. Adding a new primitive is easy. Adding very basic syntax transforming macros is easy. All of these are virtually trivial if your host language is a Lisp, as was the case with Co2.What they didn’t do is what many people might think are table stakes with Lisp: writing a garbage collector, writing a runtime, supporting lambdas, and so on. Those are unreasonable asks for 2K RAM on a 6502. I wouldn’t say they wrote a bonafide Lisp, but they made use of many ideas of Lisp successfully to write a game that is very surprisingly readable wh	reikonomusha	15.132384	-3.9548004	comment	3.0	30.0	1568212452	-10.388271
20940655	"If you aren't going to have a GC, ""r"	"If you aren't going to have a GC, ""rich"" runtime or lambda support, what does LISP really bring you over FORTH? And implementations of the latter on 6502 have been commonplace since the 1980s..."	zozbot234	15.131062	-3.9550548	comment	3.0	14.0	1568212711	-10.404008
20946952	They did parse it, albeit indirectly	They did parse it, albeit indirectly, by Racket’s reader. Co2 is a language, not a bunch of function calls, so it’s not quite the same as building a library in your favorite language. The article even gives examples of new syntax they produced.Parsing Lisp in Lisp is so easy because it’s free.	reikonomusha	15.117998	-3.965443	comment	3.0	18.0	1568253168	-10.337605
20986659	It was also found in the 80s that an	It was also found in the 80s that any operating system written in LISP was dog slow. They even started making dedicated hardware interpreters of LISP to try and get around this. https://en.wikipedia.org/wiki/Lisp_machineWhen you need to start designing your hardware around your computer language you know there's a problem going on.	mlindner	15.133175	-3.9472396	comment	3.0	10.0	1568655842	-10.402667
23730107	Closos: Specification of a Lisp oper	Closos: Specification of a Lisp operating system (2013) [pdf]	ska80	15.132999	-3.946708	story	3.0	90.0	1593836648	-10.42743
23763203	I think it's perfectly fine to use a	I think it's perfectly fine to use a nested list object that gets picked apart with destructuring until the point that it becomes a maintenance or performance problem. (That point could arrive later that same day, or it might come never).This approach is one of the things that make Lisp Lisp; if it gives you an allergic reaction, use something else.	kazinator	15.09836	-4.0047407	comment	3.0	21.0	1594151028	-10.52042
23766165	> Symbol guidelines: You should use 	"> Symbol guidelines: You should use lower caseLike flipping through for the soft porn in a friend's ""romance"" novel, I must confess I searched straight for this guideline.It astonishes me that Lisp systems still default to all caps. Of course one can quickly disable this, but why send the old gheezer ""GET OFF MY LAWN!"" message? That's exactly what people do, get off Lisp's lawn. They don't even get to the part where the parentheses (completely unnecessary for representing a tree in 2020) are a hazing exercise / loyalty test.I love Lisp, but its public relations is the poster child for ""How can people who are so smart be so dumb?"""	Syzygies	15.085437	-3.986384	comment	3.0	21.0	1594172805	-10.401286
23827057	This is a cute quote, especially if 	This is a cute quote, especially if one's difficult decisions involve letting other men do the actual work.It does not really apply to software, where most good programmers are obsessive and hard working. Yes, that also applies to Lisp, where someone has to write the actual interpreters and compilers that others use to run their 100 macros on and pontificate how easy everything is.	NLAIWhdj	15.1351595	-3.9467373	comment	3.0	31.0	1594684583	-10.432032
23935976	This is awesome! Great work OP!Alway	"This is awesome! Great work OP!Always look forward to more Lispy ShowHNs. On another note, I am learning common lisp too, but I do not currently get how to make standalone projects. I tried quickproject but most of the time I remain confused. Is there a good explanation of this stuff online?Currently I stick with (load ""lisp-file""), with one main.lisp (I come from the C world) which calls everything else, but it is not really scalable nor really professional. Something like cargo or lein could work wonders!"	z3phyr	15.1381855	-3.9394147	comment	3.0	10.0	1595567869	-5.3681173
24031607	Any particular reason why Lisp doesn	Any particular reason why Lisp doesn't also tend to compose with smaller functions? Did it just happen to evolve that way? Is it easier to get the types of the smaller functions right when you have a compiler to help you like you do in Haskell?	m12k	15.129082	-3.9725657	comment	3.0	26.0	1596401359	-10.42628
24031742	Common Lisp doesn’t just have LOOP, 	Common Lisp doesn’t just have LOOP, it also has Series [1]. I think the actual philosophical difference may be that Haskell does this with  compiler support for stream function composition, whereas Common Lisp does it with a set of language-level macros any user could write (if they were as smart as Richard Waters).[1] https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node347.html	wrs	15.11677	-3.987316	comment	3.0	15.0	1596402377	-10.447847
24032124	I followed a (pure) mathematics educ	I followed a (pure) mathematics education, and I totally dig lisp.  On the other hand, I abhor haskell and hate almost everything about it!	enriquto	15.122351	-3.9807038	comment	3.0	23.0	1596405443	-10.474544
24032433	There's a more fundamental philisoph	"There's a more fundamental philisophical difference:Common Lisp promotes the use of doclines and apropos tools in order to discover and understand behaviour, with symbol names that tend to describe the function of what they represent.Haskell leans on type signatures and symbolic operators.IMHO, a pseudo-random sequence of non-word symbols tied to a type signature is of very little use.IE, something fabricated:    (-*/) :: A -> M c -> B

Ah yes, so understandable."	dleslie	15.119547	-3.9977174	comment	3.0	15.0	1596408203	-10.431718
24181463	Lisp has two big ideas. The first bi	Lisp has two big ideas. The first big idea is that a regular syntax allows the trivial implementation of macros. Just have a separate compilation where the AST is passed in as a list to different macros and then compile the result.The second idea (not shared by the some Lisps like Scheme) is that of a system image which is modified in real time. This allows on the fly debugging, adding of new features, etc with no downtime.Macros have worked there way into languages like Julia or Nim, while the system image idea is mostly constrained to Smalltalk and Common Lisp.The best example of the power of macros is Racket, which has world class meta programming facilities and is probably the best language in existence for creating new languages, DSLs, and doing experimental PL research.I've used both	smabie	15.125191	-3.9732594	comment	3.0	12.0	1597613108	-10.403908
33081949	While we are at it, anyone knows wha	While we are at it, anyone knows what's the Common Lisp story in webdev? Both backend and frontend?	ducktective	15.141748	-3.9323978	comment	4.0	12.0	1664897982	-10.430643
33197955	I know that lisp compilers compile c	"I know that lisp compilers compile compute heavy trivial functions directly to machine code. But how is the output of a program containing a lisp macro for example. Let's say define a lisp macro don't call it and generate its assembly. What is the machine code output? This is the part I'm speechless about.""The logic inside that helps dispatch based on the dynamic types at runtime"" is the interpreter part IMHO. Plus you need logic to add the metaprogramming elements that require you to change the code after it has been written.We need to generate an example of something we can't do in C, something which requires evaluation at runtime."	terminalcommand	15.106175	-3.9851792	comment	4.0	20.0	1665704797	-10.336651
33289078	Wayflan: a from-scratch Wayland clie	Wayflan: a from-scratch Wayland client for Common Lisp	susam	15.137682	-3.9420156	story	4.0	118.0	1666366309	-10.43606
33463424	>After writing Lisp there is just so	>After writing Lisp there is just something wrong about how most languages have an additional step in order to generate the AST. Why?Because it's possible to have a lot better representations of computer code for humans than AST.	vegai_	15.087734	-4.0023603	comment	4.0	18.0	1667549532	-10.242803
33463862	You claim that Lisp is not dead but 	You claim that Lisp is not dead but is there any proof to that? I mean, beside the few posts on HN praising it.I have encountered hundreds of software engineers over the years and literally not one has ever mentioned Lisp.Could it be that Lisp is not dead because the people that started learning programming when it was popular are not dead?	iLoveOncall	15.144261	-3.9391139	comment	4.0	18.0	1667554052	-10.442924
33536098	Syntax and layout ware worth yet a f	Syntax and layout ware worth yet a few more orders of magnitude of words. But that argument has slipped past LISPers forever. I'll just let them keep scratching their heads why Python got so popular when LISP was around for so long and is /clearly/ superior.	pierrebai	15.113289	-3.9816875	comment	4.0	12.0	1668019617	-10.374707
33575788	He certainly implies that he thinks 	He certainly implies that he thinks Common Lisp (and maybe Dylan) would have been as popular as Java is today if the lottery had played out differently.I wonder if anyone else feels this way. The programming world would be a different place.I can’t help but fantasize about how incredible eMacs would be by now if that had been the case. (Not that it isn’t already incredible.)	comfypotato	15.136488	-3.9496715	comment	4.0	79.0	1668278686	-10.443279
33577298	> I have never really understood peo	"> I have never really understood people‘s aversion to parenthesesA common refrain from Lisp family language enthusiasts. (Personally I prefer Smalltalk-style ""conversational"" syntax to Lisp-style or C-style syntax, yet it's similarly unpopular.)For better or for worse, the vast majority of programmers seem to have voted with their feet for C-style syntax (C/C++/Java/JavaScript/etc.) and its variants (Python). In a C/C++/Java/JavaScript world, C syntax has a fair amount of leverage.It's a shame that Dylan didn't continue, as it seems to have taken a decent crack at adding algebraic syntax to Common Lisp - arguably realizing McCarthy's original vision of infix M-expressions as a more programmer-friendly syntax. I wonder how hard it would be to add a Dylan-style syntax layer to modern CL?Be t"	musicale	15.123737	-3.9737165	comment	4.0	22.0	1668288546	-10.381368
33578176	The early LISP crowd just didn't get	"The early LISP crowd just didn't get the concept of making a product. The idea that eventually you generate an executable and leave the development environment behind was totally alien. I used Berkeley's Franz LISP in my years at the aerospace company. That was a compiler which generated .o files. So they were close to being able to do this.
But you didn't link the .o files; you had to load them into the development environment to run them. Compiling was just an optimization. I asked the Franz LISP devs why they didn't provide a runtime you could just link in, yielding a releaseable executable program without all the baggage for breaking and debugging. This was a totally alien concept to them.INTERLISP and Symbolics were even worse - you were always in the development environment and could"	Animats	15.131325	-3.9440846	comment	4.0	23.0	1668294907	-10.3468685
33605806	Doesn’t VS do that too though?  Also	Doesn’t VS do that too though?  Also if you’re talking about performance or memory profiling, why are you using a Lisp in the first place?	jimbob45	15.138054	-3.9488018	comment	4.0	32.0	1668491751	-10.445475
33606081	> This means roughly that if you und	> This means roughly that if you understand enough Lisp to understand this programAny recommendations on good resources for learning Lisp to a degree that this program is understandable?	hamandcheese	15.14779	-3.9373655	comment	4.0	12.0	1668495152	-10.4486475
33617193	At first, I thought it was referring	At first, I thought it was referring to the conversation program, Eliza.Then I thought it was referring to a programming language, Eliza.Now I think it is referring to a modern programming language created to replicate the implementation of the conversation program, ELIZA.The whole thing could have been far less confusing if:1. The page provided more context about what ELIZA is.2. If ELIZA is indeed a programming language (a Lisp?) inspired by the original ELIZA, it would be a good idea to give it a different name.Anyway, it was frustrating to read this page so I have stopped.	zomglings	15.13518	-3.9341354	comment	4.0	27.0	1668557937	-10.302631
33679816	Reader Macros in Common Lisp (2014)	Reader Macros in Common Lisp (2014)	susam	15.122077	-3.9616997	story	4.0	93.0	1668939728	-10.364741
33728526	>  I also have no real desire to div	>  I also have no real desire to dive into strongly typed functional languages -That's a big shame. But don't knock it until you've tried it.> And all of those modern functional languages are as fringe (or even more fringe) than Lisp is.I'm not convinced Lisp is more popular anymore. I've spent the last 10 years being a full time Haskell and OCaml programmer. The killer application is compilers and associated tooling. Almost no one is choosing Lisp for this today. And why would they?> but let's be honest: programming languages that appeal to mainstream developersWhere do you think the newer mainstream languages are getting e.g. algebraic datatypes and pattern matching from?	grumpyprole	15.122281	-3.977638	comment	4.0	12.0	1669273595	-10.437795
33752920	Paredit changed the way I write Comm	Paredit changed the way I write Common Lisp, and I personally consider it a sort of killer feature of developer experience. Combined with canonical indentation of Lisp code (where every line can be indented in essentially just a single correct way, determined automatically by the editor), editing Lisp code actually becomes one of the most pleasurable of activities in programming. When you go back to editing Python, JavaScript, or C—even with a slick IDE—it just feels like a DX regression.	reikonomusha	15.095368	-3.9919372	comment	4.0	20.0	1669473019	-10.370928
33753921	Is it worth trying to make a serious	"Is it worth trying to make a serious effort with things like paredit, if you're already happy with default Emacs lisp modes? I feel like they're already overpowered.When I last tried this, I felt like I was struggling against the mode's understanding of my syntax, more than it was assisting me. I didn't figure out how to ""think"" in its language. I want to know if I'm missing out on something wonderful, or if it's more of a ""just another tool, don't worry about it""."	perihelions	15.090922	-3.988837	comment	4.0	17.0	1669479608	-10.372367
33756038	Is there a particular tutorial or me	Is there a particular tutorial or method you followed to be fluent with Paredit. I like Lisp/Scheme but have never adopted any of the tools like Paredit or Parinfer but would be interested in doing so.	bmitc	15.089318	-3.9922457	comment	4.0	13.0	1669492553	-10.278107
33981454	You just need Lisp then, and you can	You just need Lisp then, and you can have all your DSLs you want for the problem at hand, instead of writing a new tokenizer, lexer, parser, interpreter every time. ;-)	sph	15.092129	-3.9964654	comment	4.0	17.0	1671008622	-10.237967
34016484	Such anger for this question. One go	Such anger for this question. One good answer (so far) and two unhelpfuls. It’s a good question perhaps asked badly. So I’ll take the liberty of rephrasing. Why learn lisp today instead of haskell, rust, kotlin, or any of the myriad other languages on offer?	johnnylambada	15.132318	-3.9559433	comment	4.0	14.0	1671208135	-10.451042
34017701	I tend to write with an excessive am	I tend to write with an excessive amount of parenthesis with context/tangents. I used to joke it was due to Lisp/Scheme being one of my first languages. Took me a few years to realize the ADD connection.	mrexroad	15.099733	-3.9839356	comment	4.0	18.0	1671213056	-10.359236
26631308	Compiling a Lisp to x86_64 (2020)	Compiling a Lisp to x86_64 (2020)	sillysaurusx	15.129695	-3.9487925	story	4.0	128.0	1617079120	-10.371433
26633555	Depends on how hard you want to stre	"Depends on how hard you want to stretch the definition of ""Lisp"" here. But I guess if someone would make a proper Lisp for CLR and marry Emacs with PowerShell, then we'd be half-way towards resurrecting the corpse of Lisp Machine into a functioning zombie."	TeMPOraL	15.14064	-3.9439557	comment	4.0	20.0	1617105456	-10.445645
26694972	Early Lisp Part II	Early Lisp Part II	wglb	15.154371	-3.9323227	story	4.0	82.0	1617592716	-10.438996
26724182	Did we really “lose” the Lisp Machin	Did we really “lose” the Lisp Machine, or did we just realize that compiling Lisp to a general-purpose instruction set like x86 and then having someone else in charge of creating hardware to efficiently execute that is much more clever?	runeks	15.134546	-3.9415677	comment	4.0	43.0	1617800241	-10.405145
26968152	ThinLisp (Threaded Interpreted Lisp)	ThinLisp (Threaded Interpreted Lisp) and Microprocessors	daly	15.12573	-3.954	story	4.0	3.0	1619609277	-10.393041
27005000	Emacs Lisp book revived: Marcin Bork	Emacs Lisp book revived: Marcin Borkowski	nanna	15.150606	-3.9326985	story	4.0	91.0	1619864153	-10.445116
27036862	> I'm convinced Lisp self-asphyxiate	> I'm convinced Lisp self-asphyxiated by fighting a last stand on parentheses, which is so far from the point of Lisp.I think the reason Lisp self-asphyxiated is because people don't get it.Most try to spend a little bit time programming it as if it was C/Java/Python/whetever else they have used on their last project. They just see a language that can do what they need but it is all wonky and so why bother?Compared to other languages, to get benefits from using Lisp you actually need to understand what the benefits are and what causes the benefits.You can switch from C to Python and reap benefits of Python without having some kind of deep understanding.That's because programming in Python is basically same thing as programming in C, it is just more efficient. There is less stuff to set up 	lmilcin	15.129232	-3.9629483	comment	4.0	18.0	1620131517	-10.313681
27060649	I don’t think it’s the parents, but 	I don’t think it’s the parents, but the s-expression themselves.LISPs forces you to maintain the stack for the parse tree in your head, something humans aren’t that great at — s-expressions are the programming language equivalent of center embedding, which is quite alien for human languages (the depth is three at most: compare that to your favorite lisp program)	snotrockets	15.105984	-3.9898016	comment	4.0	25.0	1620291183	-10.331698
27279379	As I've been learning more Emacs Lis	As I've been learning more Emacs Lisp and Common Lisp, I've found that they're really quite similar.  So I've been wondering why Emacs wasn't written in Common Lisp.  Of course, I think the answer to that one is the age of Emacs -- it was around before CL? -- but this project will be one that I check in on periodically, for sure.	acdw	15.137889	-3.9569457	comment	4.0	24.0	1621962246	-10.465353
27298202	> Does the Common Lisp standard need	> Does the Common Lisp standard need to be revamped?Yes.  Will it happen?  Almost certainly not, though I would like nothing better than to be proven wrong about this.> it just always amazes me how much innovation is still happening from simple, unfancy s-expressionsTurns out S-expressions are just a Really Good Idea (tm).  That's why people keep reinventing them over and over.	lisper	15.101708	-3.997327	comment	4.0	20.0	1622077957	-10.362789
27309794	I know different pedagogical approac	"I know different pedagogical approaches work for different people, but in my experience the fastest and easiest way to learn Lisp is to bite the bullet and jump right into it.   I think when it comes to the parentheses of Lisp, the premise is straightforward; there just isn't a whole lot to actually learn.  I believe most of the difficulty comes from people psyching themselves out before they even try.  That describes my personal experience with the matter anyway.Also with regards to prefix notation being unintuitive: We already teach something very similar to schoolchildren learning arithmetic:      1
    + 2
    ---

Here, as with (+ 1 2), the operator is on the left most side.   The operands are arranged horizontally in lisp instead of vertically, but the supposed weirdness of the opera"	wearywanderer	15.102402	-3.9968982	comment	4.0	23.0	1622157503	-10.324181
27311827	Wouldn't lisp done with indents and 	Wouldn't lisp done with indents and newlines instead of brackets and whitespace be fun?Edit: Apparently there's alternative syntax for Scheme called wisp.	scotty79	15.125202	-3.9617903	comment	4.0	18.0	1622177238	-10.430612
12584491	I have been trying to get into the w	I have been trying to get into the whole Lisp paradigm for 1-2 years now.  I own Realm of Racket, amongst a collection of Lisp books.Racket is all the promise of developer-centric power tooling that puts Common Lisp to shame.I recommend you watch one of the core devs, Matt Flath, build a a hygenic macro expander.https://www.youtube.com/watch?v=Or_yKiI3Ha4Notice how his talk, likely written in its own documentation language Scribble, shows demos of DrRacket.  I am more of an emacs guy, but do you see the interactive colorized debugger pointing out variable binding and flow control?  That is the only thing that I have seen in the Lisp world that takes SLIME and laughs at its dogged simplicity.Also, as you watch this talk, observe how he takes the complexity of something I am still certain I 	616c	15.145056	-3.940698	comment	4.0	24.0	1474915571	-10.377362
12659439	I'm 26, and modulo the kids, this is	I'm 26, and modulo the kids, this is how I feel as well. I've been programming professionally for almost ten years, and I feel less and less pressure to keep up with the latest packages on NPM or whatever the flavor of the month is. It's much more interesting to know what has been tried before, and why that didn't stick. Like this newLISP thing, why should we suddenly start writing Lisp? The language is older than C, for god's sake.	toxik	15.124818	-3.9600244	comment	4.0	26.0	1475835008	-10.448205
12703913	Symbolics made some really cool tech	Symbolics made some really cool tech. I just wish everybody would stop complaining about it. Yes, it was amazing. Yes, nothing modern can ever compare, not even Emacs, an environment arising from the same culture. Yes, we who experienced The Glory of the Lispm must eternally genuflect before it, condescending to anybody who didn't.Instead, go look at what Symbolics did (or try: it's quite hard to get the emulator running), and learn. That system lost, and it's never coming back, but you can learn from what they did well when building your own system.But when you have, don't complain about the inferiority of our systems. It may be true (I can't get the emulator running to find out), but it gets annoying pretty fast. Take the energy you would use doing that, and put it into making your syste	qwertyuiop924	15.123221	-3.9494243	comment	4.0	76.0	1476391727	-9.132537
12704232	I used to work with a number of LISP	"I used to work with a number of LISP machine believers at the MIT AI Lab/CSAIL. They all had more modern computers for day to day tasks, but used the lispm for most of their programming. This wasn't that long ago (I left in 2010), and I suspect that those machines will remain in active use for as long as people can keep them running.They all believed that the loss of the lisp machine was a serious loss to society and were all very much saddened by it. I never used the system enough to come to my own conclusions in that regard, but it was interesting food for thought. As somebody for whom Linux/POSIX is very deeply entrenched, would I even recognize a truly superior system if it was dropped in my lap? More importantly, would society in general? The superior technology is rarely the ""winner"""	noahm	15.139894	-3.9380877	comment	4.0	52.0	1476394461	-10.405696
12704832	It was by far the most productive pr	"It was by far the most productive programming environment I have ever used.  The level of integration of the editor, debugger, IO system, and interpreted and compiled code is unparalleled.  Interestingly it philosophically descended from MACLISP development on a machine (PDP-10) that was designed with Lisp in mind and that had an O/S (ITS) whose ""shell"" was a debugger, so you could also do pretty tightly coupled development with EMACS (in TECO) and your code in a mix of interpreted and compiled Lisp.  In theory this deep level of integration need not be Lisp-specific, but I haven't seen it that often.The closest I've used were the three environments at PARC when I was there: Smalltalk, Mesa/Cedar and Interlisp-D.  When I use Xcode or Eclipse I feel removed from the machine.  In these other"	gumby	15.083225	-3.9748895	comment	4.0	18.0	1476399286	-10.336257
12778708	I'm always impressed how the magic o	I'm always impressed how the magic of interpreters and compilers can be explained so succinctly.Inspired by Jonesforth, I wrote a complete Lisp interpreter in a single ARM assembly file: https://github.com/marcpaq/arpilisp	marcpaq	15.123844	-3.9525442	comment	4.0	14.0	1477316899	-10.331066
12801083	Why would functions in a lisp-2 be m	Why would functions in a lisp-2 be more awkward than in a lisp-1?PHP has been too long ago for me to understand your comparison.Would you please explain it differently?	aerique	15.119308	-3.9808786	comment	4.0	18.0	1477519438	-10.439327
12832560	My nomination for what we get wrong 	My nomination for what we get wrong over and over again: working under the assumption that there is One True Syntax.  There isn't.  Different syntaxes are suitable for different needs.A single language can support multiple syntaxes if the AST is exposed as a first-class construct.  This makes it easy to write new syntactic front-ends.  Unfortunately, the only language to date that supports this idea is Lisp, which means that this incredibly powerful idea is conflated in most people's minds with lots of irritating silly parentheses.  (One of the reasons for this conflation is that once you start adopting this mindset the parens become a lot less silly and irritating, but that's another story.)I'm currently working on cryptography code, where algebraic syntax is very convenient.  Here's an e	lisper	15.109288	-3.9888065	comment	4.0	15.0	1477864174	-10.366398
13012812	I was keeping a close eye on Eve unt	I was keeping a close eye on Eve until it changed direction from programming for everyone to yet another lisp. Is there any writeup/discussion on why this happened?I do like learning about mind-expanding languages, and something resonated with me when the CardWiki interface was revealed. I get that this language is very 'human readable' but at the end of the day if I want to read or write it I will actually have to put a lot of time into learning it.I'm already suffering decision paralysis with my current language shortlist and this language doesn't make the cut. The card wiki was innovative, like LightTable. To me, this is 'just a language'. I realised you moved away from the wiki idea for a reason but is putting a GUI on the language still on the roadmap?	0x01	15.141083	-3.9488845	comment	4.0	24.0	1479806167	-10.466932
13097333	Quicklisp is not panacea, even thoug	"Quicklisp is not panacea, even though it simplifies matters to a substantial degree for people new to Common Lisp.On the other hand Quicklisp has serious issues:+ Minimal if any documentation of internals.+ A substantial chunk of the codebase can only be described
  as spaghetti code. To make matters even worse, most functions lack documentation strings. A sad state of affairs given the interactive and self-documenting nature of CL.+ Is vulnerable to man-in-the-middle attacks since it verifies neither certificates nor checksums. This means that using Quicklisp can get you owned. Unacceptable these days.+ Operates over a 'curated repository' model that Xach is managing. The repository has been found to be vulnerable to man-in-the-middle attacks in the past since packages were fetched over p"	armitron	15.134449	-3.9301732	comment	4.0	21.0	1480796549	-10.363562
13193167	Lisp was developed because McCarthy 	"Lisp was developed because McCarthy needed a tool for experimenting with AI. Found a video of McCarthy talking about AI: https://www.youtube.com/watch?v=Ozipf13jRr4And if anyone cares, here is nice Shirt with McCarthy on it ;)
https://www.teepublic.com/t-shirt/666689-john-mccarthy-lisp-...I think it should be mandatory for CS students to implement their own little Lisp using the building blocks McCarthy described! Instead they are learning Java and ist crappy OO..."	kluck	15.1415205	-3.9479198	comment	4.0	32.0	1481896089	-10.462509
13195345	I don't think actual Lisp programmer	"I don't think actual Lisp programmers share this obsession with purity and ideal forms. It's more something that shows up in blog posts about Lisp by people who probably don't actually use it. The title of this one is telling: it's about ""the idea of Lisp.""On the other hand, if you look at, say, ANSI Common Lisp, it's not at all some kind of perfectionistic attempt at divine elegance. It's a pragmatic compromise resulting from years, decades, of actual use on real computers.Just browse around the SBCL compiler source code and you'll see that this stuff is developed by people who definitely aren't afraid of the messy practical reality of hardware:https://github.com/sbcl/sbcl/tree/master/src/compiler/x86-64Generally spend some time within the Lisp community and see how many people you see fr"	mbrock	15.135993	-3.949609	comment	4.0	39.0	1481911990	-10.420554
13195350	Garbage collection is not necessary 	Garbage collection is not necessary for lisp. Garbage collection only provides the illusion of infinite memory. Just like malloc/free.	crististm	15.103903	-3.9874153	comment	4.0	30.0	1481912057	-10.393296
13216290	I was only a lowly content builder a	"I was only a lowly content builder and quest manager, so I can't speak much to how the server mechanics worked.But essentially, each entity (usually a mob) would have a set of event scripts (attached to some kind of internal lookup table), and each time an event happened, it would call the appropriate scripts/function/macro.So what I did was logic such as ""game tick -> wander one step in a random direction"" or ""player enters room -> attack"", but also slightly more complex ones such as ""combat round -> if low health, flee"".The cool feature of the server was that you could specify multiple options in the template, and it would randomly pick one for a newly created instance, giving some variety to behaviors (eg, some guards flee and some fight to the death). Each instance could also be given "	SomeStupidPoint	15.133083	-3.957808	comment	4.0	13.0	1482193478	-10.411607
13253831	Lisp gets nothing but loving praise 	Lisp gets nothing but loving praise from most people who've really looked into it. To me, it's a really good indicator of someone's quality as a programmer - someone who treats programming as just a job will probably never run into it in any meaningful way, but a true hacker will eventually encounter it and be able to appreciate its elegance.Wanting something like lisp to gain mainstream popularity would be a naive wish - your average web developer wouldn't be able to appreciate it, and over time lisp would change to become more like PhP. No offense meant to such people of course, not everyone needs to have that kind of passion, and someone needs to do web development - God knows it won't be me!	kahrkunne	15.14006	-3.9457974	comment	4.0	21.0	1482667115	-10.456318
13257388	It's not a shame for a language to l	"It's not a shame for a language to lose against Python. Python has by far the best focus on usability of the standard libraries of all the languages I have ever seen (which includes major ones). As they say, ""practicality beats purity"".Let me compare for example Lisp lists with Python lists. Lisp lists are in a way more low-level, lacking useful things as slices. Sure you can always write a function to do a slice, but the point is many useful functions are missing from the standard libraries. I tried to learn Common Lisp and Clojure (I like the language more than Python) but I was never more productive in it than in Python for this reason.This year, I have actually done some AoC in Haskell, and it's a similar deal as with Lisp. There are plenty libraries, but they just don't work as well t"	js8	15.10859	-3.9868636	comment	4.0	18.0	1482738115	-10.367899
13373794	Not evidence, only subjective gut fe	Not evidence, only subjective gut feelings, and I've had adoption in mind. But I'm hesitant to answer this question, because it will invariably lead to language flame-wars. Anyway, it seems to me that Algol68, Pascal, and Ada are less obscure than C and C++, but the latter are clearly more popular and have proven their worth over a long time.At the same time, implicit-block type procedural languages like Visualbasic and Realbasic/Xojo are popular, but they do not get much love from professional programmers, even though they are maybe the least obscure among all imperative mainstream languages. LISPs are also an interesting case, S-expressions are among the least complicated and easiest to grasp syntax and CommonLisp offers practically everything a programmer could ever wish for (including 	jonathanstrange	15.106491	-3.9886358	comment	4.0	27.0	1484142232	-10.514967
13406663	Coroutine iters in Common Lisp	Coroutine iters in Common Lisp	codr4life	15.147742	-3.9388049	story	4.0	59.0	1484517880	-10.443003
13420856	http://www.red-lang.org for those wh	http://www.red-lang.org for those who doesn't necessarily need Lisp, but appreciates homoiconicity and other nice things.> This executable is a full blown native interpreter with a JIT, GC, etc.> A small, fast, native lispI have issue with the use of the word 'native' here. For me 'native' mostly means AOT compiling.	xaduha	15.118762	-3.9620123	comment	4.0	36.0	1484684842	-10.383772
13603675	Yep... Lisp machines were thoroughly	"Yep... Lisp machines were thoroughly in the ""mini""computer (cabinet-sized) category and completely missed out on the microcomputer revolution. IBM PCs were cheaper and got the job done. To an extent.The AI winter didn't help Lisp's popularity."	milcron	15.1383295	-3.9410422	comment	4.0	14.0	1486601649	-10.485897
27609353	I think the programming language cho	"I think the programming language chosen to teach programming matters a lot.  I'm unsure if this is the case for everyone, but the language I'm using dictates my mindset in solving a problem.  If I'm using Python, then my data structures will very likely be lists and dicts, and my solution will resolve around manipulating those.  While C means that I'll be using structs and pointers, so I need to keep some thought capacity available there.C makes me think like an engineer, deliberate and thoughtful; Python makes me think like a child, playful and experimental; Java makes me want to break up the problems a lot and generalize every case.  Etc.I like lisp as a teaching language.  I understand why first-year programming classes prefer more ""useful"" languages. But I genuinely think lisp puts me "	mywittyname	15.04971	-4.033671	comment	4.0	12.0	1624478325	-9.137736
27621014	Cl-bodge: a cross-platform Common Li	Cl-bodge: a cross-platform Common Lisp game and application framework	bananaoomarang	15.139521	-3.9369712	story	4.0	93.0	1624555835	-10.33708
27706447	As a hobby I want to learn a lisp. W	As a hobby I want to learn a lisp. Where should I begin? :)	theshadowknows	15.150799	-3.9345105	comment	4.0	12.0	1625184340	-10.450657
27715043	Architecture of Lisp Machines (2008)	Architecture of Lisp Machines (2008) [pdf]	todsacerdoti	15.13703	-3.9401958	story	4.0	150.0	1625250644	-10.418171
27805591	Lisp doesn’t really have many, if at	Lisp doesn’t really have many, if at all, super weird concepts that need months of thinking about in order to understand.Training seems like some lost art as we collectively move toward a more disposable programming ethos. Training a good programmer how to write Lisp is, what, two weeks of work? Learn how to make variables, write functions, define classes, and compile a project. That gets you 80% of the way there, and definitely gets you across the “productivity threshold”.Somehow, in the same breath, we find it okay to spend weeks agreeing on how to ship Python code, what the standard development environment is, and how a 2->3 transition of 100,000 lines of code will be accomplished.	reikonomusha	15.137693	-3.9501247	comment	4.0	53.0	1626048491	-10.437998
27877616	It's oh so convenient until it isn't	It's oh so convenient until it isn't; until you need to make distinctions between missing values and booleans.I still haven't decided if it's a good idea or not, and I've been hacking Common Lisp for more than 20 years.	codr7	15.129864	-3.9609683	comment	4.0	24.0	1626650456	-10.473893
27916876	Ask HN: Best way to learn Smalltalk?	Ask HN: Best way to learn Smalltalk?	avindroth	15.144463	-3.9432805	story	4.0	14.0	1626944706	-10.466501
12025702	"Lisp is close to syntaxless. What ""l"	"Lisp is close to syntaxless. What ""lisp syntax"" means is principled to the bones systems, including syntax. The fact that everything in lisp was in recursively defined lists meant you could reuse recursive thinking everywhere. An `infinite` tower of reuse. You get genericity, pattern matching, combinatorial generation for very low cost. It's not practical for people crunching data or opening files .. but whenever you need to attack something a little more complex the 'practicality' argument shift sides."	agumonkey	15.112925	-3.9836943	comment	4.0	20.0	1467546127	-10.419266
12112781	> However, the good features of Lisp	"> However, the good features of Lisp are now normal features of any modern language. And some of those features have gone into the dustbin for good reasons. And some of them (static vs dynamic typing) are personal taste.I definitely agree that with each passing year, languages that are not recognizable as being related to lisp have more features that mad lisp special in the past.Features I regularly use that are good, but aren't ""normal features of any modern language"" (some are implementation details, but common to most CL implementations)1 CLOS2 Homoiconicity3 A good interactive debugger with incremental compilation4 Generalized references5 An equivalent to reader macrosIn addition, while some form of AST parsing and manipulation may exist in many modern languages, it is typically much l"	aidenn0	15.141351	-3.9483514	comment	4.0	20.0	1468805425	-10.432083
12113124	> I really miss that in other langua	> I really miss that in other languages.Elixir has a pretty good lisp-inspired macro system. And it's hygienic by default, too.And Elixir's pattern matching actually makes manipulating the forms even easier.	wtetzner	15.108851	-3.9886003	comment	4.0	23.0	1468813310	-10.373652
12197372	For me, it's a question of tooling.I	For me, it's a question of tooling.I would love to see a Common Lisp expert do an entire book on Armed Bear Common Lisp (Common Lisp entirely on the JVM). Edi Weitz hinted at what might be possible in his book, Common Lisp Recipes, but only very superficially.To me, the power of Common Lisp married to the ubiquity and library of the JVM is the great possible future for CL.	claystu	15.145331	-3.9392743	comment	4.0	49.0	1469979081	-10.515049
12197450	> For me, it's a question of tooling	> For me, it's a question of tooling.emacs & slime[1]> I would love to see a Common Lisp expert do an entire book on Armed Bear Common LispI'm curious what you'd expect from such a book. There are some excellent books on CL in general and good libraries that provide a convenient layer over implementation specific things (e.g.: uiop or cl-fad). One usually does not think about a specific CL implementation when writing code - I'd even go as far as saying that targeting a specific implementation is usually a sign of bad coding style.[1] https://common-lisp.net/project/slime/	jlg23	15.1286	-3.9665568	comment	4.0	41.0	1469980554	-10.425339
12197658	This article appears on HN on a regu	"This article appears on HN on a regular basis, so I thought people might be interested in a bit of historical trivia: the reason this article is called ""Lisp as an Alternative to Java"" instead of some other language is that it cribbed the title off my original study (http://www.flownet.com/gat/papers/lisp-java.pdf).  The reason that article was titled the way it was is that I was working at JPL at the time and there was a software crisis underway.  To that point, spacecraft had been mostly programmed in assembly language.  The then-recently-launched Cassini spacecraft was a notable exception, having been programmed in Ada.  But it was becoming clear that neither of these approaches scaled well, and so the hunt was on for an alternative.  Java was the hot new language at the time, and it wa"	lisper	15.109404	-3.9882169	comment	4.0	32.0	1469983818	-10.442238
12200123	I like Scheme/Lisp but I don't know 	"I like Scheme/Lisp but I don't know if I buy the whole ""learning Lisp turns you into a better programmer"". Maybe more knowledgeable but not necessarily a better a developer.In some ways learning a really flexible language like Lisp can turn you even into a really bad developer. I say ""developer"" instead of ""programer"" because I want to emphasize working with others and thus sharing code with others. Of course this is based on some past observations working with MIT grads and various other academia so take my opinion with a grain of salt.IMO the language that really changed everything for me was the ML family of languages and maybe C. I would say knowing C and ML is more worthwhile than Lisp (Lisp is not exactly hard to learn anyway... the basics that is)."	agentgt	15.135605	-3.9587817	comment	4.0	26.0	1470023942	-10.486811
12200208	With Lisp I get the data thing but w	With Lisp I get the data thing but with ML you learn almost everything is a language.I can't really explain it but the whole variant/ADT pattern matching really forces to make you think of your problem domain as a specification or language (e.g. DSL). It is one of the reason why I think so many compilers are written in ML (that and the toolset is awesome for it).	agentgt	15.113817	-3.9811723	comment	4.0	14.0	1470025962	-10.360033
12231738	Haskell and Lisp complement each oth	"Haskell and Lisp complement each other in a lot of ways. Lisp is about empowering the programmer, and building on that empowerment. Haskell is about restricting the programmer, and then building on those restrictions. For a clear example, consider STM, how it works in Haskell, and how it doesn't work particularly well in Lisp because of the inability to restrict transactions in the necessary way.Lisp is good to learn, but because it has ""won"" in a lot of ways I'm not convinced it's as important as it used to be. Lisp acquired its reputation in a world where a C programmer would pick up Lisp and holy shit dynamic typing, first-class functions, garbage collection, REPL, macros, powerful syntax-aware editors (which C got, but later), atoms, recursion, violent foaming at the mouth and falling "	jerf	15.125403	-3.9733188	comment	4.0	25.0	1470400262	-10.45205
12232568	I would like to see a light-syntax d	I would like to see a light-syntax dialect of Lisp that recognized semantic white space to get you out of the parentheses maze. (But you could still optionally use parens when you wanted.)Disclaimer: I've been coding almost exclusively F# and SQL for nearly 3 years, and any kind of ceremony and noise characters in code just throw me off. Typescript is being hard on me right now.	jackfoxy	15.096716	-3.9956279	comment	4.0	14.0	1470407369	-10.335074
12327247	"Every Lisp article promoting the ""el"	"Every Lisp article promoting the ""elegance"" of its syntax will do the exact opposite to non-users of Lisp.This is no exception.From the first example on there is not one case where the Lisp syntax is a clearer expression of the concept and it's hard to justify that anything that is less clear is elegant in the slightest.Personally I'd put destructing assignment as more elegant for the first example:    [a, b, c] = [10, 20, 30]

But that's just me."	abritinthebay	15.101102	-3.9996426	comment	4.0	44.0	1471710956	-10.386955
12359212	Part of the problem is that JSON and	Part of the problem is that JSON and Sexprs aren't that they AREN'T serialization formats. They've been pressed into service as such, but they are actually notation for datastructures: In python, it may not be idiomatic to crawl dicts like this, but in JS, those aren't dicts, they're objects. If they've been de-serialized to some degree, they may even have their own methods.By the same token, in Lisp, Sexprs aren't a serialization format. They're a notation for the linked cons cells that Lisp data is made of. In Lisp, that Sexpr will be crawled for data, or maybe even executed.So while in Python, both may seem to be serialization formats, they aren't.Either way, if the application programmer has any sense, they'll abstract away the format of their data. In a lisp app, you won't be cdring d	qwertyuiop924	15.107688	-3.9894702	comment	4.0	35.0	1472135069	-10.44485
12439249	EB and I both worked at Lucid, which	EB and I both worked at Lucid, which produced a Common Lisp system, not to my knowledge a version of Emacs (though maybe so after I left in 1989?).  Some other early employees knew and liked Lisp, but we didn't use it on any core functionality.  The text substitution logic you mention, that I wrote, was really simple and not particularly Lisp-like.  Though again, after I handed it off, who knows what happened.	skaphan	15.12767	-3.9499848	comment	4.0	16.0	1473195533	-10.444362
12499913	What is the scheme equivent of ANSI 	What is the scheme equivent of ANSI C or Common Lisp?By that I mean what is the default/main/vanilla scheme?	na85	15.14046	-3.9400444	comment	4.0	30.0	1473877896	-10.439535
35497834	Making IELM (Emacs Lisp REPL) More C	Making IELM (Emacs Lisp REPL) More Comfortable	billiob	15.135516	-3.9361775	story	4.0	83.0	1680989501	-10.499971
28004869	We’re working on it :) [1]The intere	We’re working on it :) [1]The interesting problem is that it’s still kind of a developer experience mess. We can get pretty far with libbpf skeleton, libbpf-rs, etc, but I think we’re still waiting on the “killer” framework for this (or some other kind of language support).[1] I work with Pavel, Jens, and Alexei	alexgartrell	15.099603	-3.973646	comment	4.0	23.0	1627624222	-10.31383
28042537	The ecosystem is a function of popul	The ecosystem is a function of popularity.Lisp isn't very popular because, at least in my opinion, it requires a relatively high level of maturity and experience to be used effectively on nontrivial projects.Every single project in Lisp (Common Lisp, Clojure) that I have observed ended in a disaster mostly because developers could not figure out what the strengths of Lisp are to realize the benefits and then killed themselves with too much freedom.Absent large enough number of success stories companies will default on Java because it is good enough language to be able to effectively realize typical enterprise application and dumb enough to be used by a beginner dev, even at the cost of boilerplate.At least that's the official story. It is really difficult to explain to business that you co	lmilcin	15.132912	-3.9606175	comment	4.0	22.0	1627937838	-10.461303
28042789	Lisp is a wonderful language (Common	Lisp is a wonderful language (Common Lisp in particular, but I am dabbling in Scheme now too), and absolutely fantastic for web development - seriously people should give it a chance in that space, I would totally develop any SPA in Lisp[1].QuickLisp is simply a joy to use, and the language is very portable with a fantastic specification and many top notch compilers.IMO, what holds it back is a lack of a top notch IDE. It took me a year of love & hate with Emacs, I can now make pretty good use of the amazing software that is Emacs (where everything can be changed), but honestly at times I want a simple point & click free IDE which is polished and does most things well and out of the box. Portacle is a step in the right direction, but the Emacs dependency IMO does make the language a bit mo	abhinav22	15.110899	-3.9568264	comment	4.0	18.0	1627939115	-10.383292
28109726	I'd like to hear your opinion about 	I'd like to hear your opinion about the following vision of language comparisons:Lisp as a language is much more malleable to the problem at hand.  This will mean it will attract a small group of smarter people, but create code which is harder to read and hence harder to give to other people.  Hence, lisp programs tend be smaller, more creative, better quality, faster to create, but also to stagnate when their creators leave.Java, more recently Go, and maybe even Cobol, attract a bigger group of more average people.  They'll write in a simpler, more standardized style.  The programs tend to be more bureacratic, average, less optimized, but also much more readable. They  are the better choice when you need  maintainability over a long time by a varied group of programmers.I don't remember w	hyperman1	15.123274	-3.96598	comment	4.0	24.0	1628453682	-10.42962
28165525	It has been discussed many times alr	It has been discussed many times already. Projects like this don't produce a Lisp. It's a toy, Lisp-like language at best. Calling it a Lisp does a disservice to the proper languages in the family.	nesarkvechnep	15.14048	-3.9469986	comment	4.0	20.0	1628829671	-10.469106
28166908	Surely a tour de force to do this in	Surely a tour de force to do this in this many languages. It’s been helpful to me to see how I might write a parser.On a different tangent: what is it about lisp that people love so much? Are lisp programmers much more productive? Is the code better in terms of performance or lack of bugs?	gigatexal	15.11386	-3.9795954	comment	4.0	14.0	1628845569	-10.328482
28179950	Plain old Common Lisp has similar is	Plain old Common Lisp has similar issues on the Mac. (And possibly Windows too - I haven't looked.)There's supposed a one click dev system installer, but it hasn't been updated for a while. There's a many click recommended collection of tools, but it looks like half a day of work to get it all installed and then you're supposed to use Emacs.You can add a REPL to something like Sublime Text. Or install Atom and go through another convoluted process which launches a Lisp server and etc etc etc.I gave up and got back to work at that point. It might work smoothly if I worked through it all. Then again... it might not.Which is a shame, because I like the look of Lisp very much and I really would like to play with it.	TheOtherHobbes	15.121863	-3.9522698	comment	4.0	13.0	1628942280	-10.40982
28340114	> A concrete example: Lisp macros.Wh	> A concrete example: Lisp macros.Who didn't see this coming?For someone who's constantly extolling the importance of other languages and flexible thinking, Paul doesn't seem to ever be able to get his mind out of Lisp.> [Lisp macros] by their nature would be hard to implement properly in a language without turning it into a dialect of Lisp.There are numerous counter examples to this claim, the most obvious one being Rust.How do you call someone who only knows one language and refuses to learn new ones? Oh right, a blub programmer.	hota_mazi	15.128709	-3.9622655	comment	4.0	13.0	1630173974	-10.450617
28340765	I've been using Emacs for more than 	I've been using Emacs for more than 20 years, these are all (for the most part) non-issues, brought up by folks who either are new to Emacs or never read the documentation / dived below the surface.1. Emacs Lisp is great (for the problem domain), exists and works. Common Lisp could work but then given how close Emacs Lisp and CL are, there's no clear benefit, especially with Emacs getting native compilation. Scheme was proposed, some POC code written and failed because nobody was interested. It doesn't fit and fragmenting one of Emacs's greatest strengths (consistent ecosystem of working Emacs Lisp code) is a terrible idea.2. The Emacs UI core is completely toolkit-agnostic. It doesn't use GTK on Windows. It doesn't use GTK on macOS. You can run _graphical_ Emacs without GTK or any toolkit	creamytaco	15.110553	-3.9483838	comment	4.0	20.0	1630178982	-10.354016
28376422	Emacs is a huge stumbling block for 	Emacs is a huge stumbling block for me. Everyone used emacs and expected you to as well.Common Lisp seems great - I'm so curious about CLOS - but I cannot get along with emacs, and I have tried.	LAC-Tech	15.10674	-3.9588366	comment	4.0	25.0	1630470302	-10.357099
28549730	I program multiple languages includi	I program multiple languages including Common Lisp.I don't buy that Common Lisp is too large. I would say the opposite is true. The base language is rather simple and what you mistake for language are just standard library.What is complex is it being Lisp language which means you need to adjust your brain structure to a different level of functioning and focus when reading code.**But languages do get too large.I think the reason languages get too large is because developers, as soon as they get some experience, start demanding more features. Maybe they want to have more functional experience in an object-oriented language, or maybe they want async in one that was not designed for it.These developers form a core of users that enjoys being able to absorb these features over time as the langu	lmilcin	15.131907	-3.9602034	comment	4.0	34.0	1631785506	-10.42245
22313831	Why is that? What’s special about li	Why is that? What’s special about lisp?	dr_j_	15.151812	-3.932116	comment	4.0	39.0	1581549335	-10.48362
22414170	"I hate the ""lists of myths"" (that ar"	"I hate the ""lists of myths"" (that aren't) genre.> Common Lisp does not have compile-time type checking.Nothing in the standard mentions compile time checking requirements and there is no useful de-facto standard that you (or tooling!) could seriously build upon either. I'd be suprised if python did not have better ""compile-time type checking"" for all practical purposes. Yes, SBCL gives much better type warnings at compile time than python, but for python you have mypy and it's A Thing, and still a joke compared to a proper type system like Ocaml's.> Common Lisp is too specialized, it’s not for general-purpose development.Common Lisp has no eco-system to speak of for machine learning, web development, command-line utilities, games programming, mobile development, GUI programming, embedded d"	patrec	15.125186	-3.959984	comment	4.0	33.0	1582646262	-10.425151
22473260	Sure lisp is a wonderful language, b	Sure lisp is a wonderful language, but let's not pretend there's no difference between incidental and accidental complexity.	jdc	15.143647	-3.9462504	comment	4.0	20.0	1583230889	-10.470295
22474677	One of the traditional criticisms of	One of the traditional criticisms of Lisp, though, is that it lets programmers re-introduce a whole lot of accidental complexity in their Lisp code, and, worse, everyone introduces a completely different set of accidental complexities into their code.	jerf	15.1369915	-3.9539053	comment	4.0	14.0	1583245691	-10.480159
22584022	I've only written a little bit of it	"I've only written a little bit of it, but it brings me anxiety.Any language without static types brings me a certain degree of anxiety, thinking at all times about all the ways a  given piece of code might be misused and go terribly wrong.But in Lisp you add another layer: that anything looking like a function call could actually be a macro, further blowing open the door of possibilities for what an unfamiliar piece of code might do.Of course, parsing Lisp is an exercise in tranquility ;)It's all about the programmer's personality, I think. Graydon Hoare expressed my feelings: ""Basically I've an anxious, pessimist personality; most systems I try to build are a reflection of how terrifying software-as-it-is-made feels to me. I'm seeking peace and security amid a nightmare of chaos."""	_bxg1	15.142842	-3.9488754	comment	4.0	19.0	1584286727	-10.480879
22728913	What are you interested in? The reco	What are you interested in? The recommendations I can make for someone fascinated with LISP are different than the ones I can make for someone interested in computing history are different than the ones I can make for someone interested in processor design and so on. There's a very wide selection here.	kick	15.145919	-3.9449275	comment	4.0	22.0	1585583202	-0.25109902
19112125	The super-complicated LIFO example i	The super-complicated LIFO example is, unfortunately, a contrived example:“Ich stimme dem Maler, der die Meinung, dass Rot keine Farbe ist, vertritt, zu.”This sentence can be rewritten in German just as in the English translation:“Ich stimme dem Maler zu, der die Meinung vertritt, dass Rot keine Farbe ist.”	kara_jade	15.134665	-3.9442477	comment	4.0	16.0	1549609460	-10.405873
19122578	This article is chock-full of misinf	This article is chock-full of misinformation.> an s-expression [is] a fancy term for a list of [cons] cellsNo, it's not.  An S-expression is a serialization of a (single) cons cell, whose elements might be other cells.>  We're using a vector instead [of cons cells], but the two are equivalentNo, they are not.  When represented as cons cells, CDR is a non-consing O(1) operation.  When represented as vectors, CDR is a copying O(n) operation (and because it necessarily makes a copy, the semantics are different if you introduce mutation).The fact that S-expressions represent cons cells and NOT vectors is crucially important.  It is the feature from which Lisp derives much of its power.It is possible to make a Lisp-like language where the surface syntax represents vectors instead of cons cells.	lisper	15.112458	-3.984247	comment	4.0	45.0	1549724337	-10.516081
19175423	> Due to COBOL's lack of functions a	> Due to COBOL's lack of functions and recursion, the recursion required for Lisp is built from the ground up using file processing.Does this mean that they are storing the stack as records on a file ? Hopefully they will implement tail recursion as soon as possible :-)	mrighele	15.099467	-3.97312	comment	4.0	18.0	1550270562	-10.4759655
19222164	Mathematica is literally the worst P	Mathematica is literally the worst PL I've ever used, especially since you effectively have to use their built-in editor that doesn't even have multiple undo. Of course, it is the least-worst symbolic system out there currently. But, it's not like lisp wouldn't have developed similar capabilities if Mathematica didn't come around.	lenticular	15.089622	-3.9822056	comment	4.0	15.0	1550797094	-10.300437
19273659	Please provide an example of an s-ex	Please provide an example of an s-expression that provides more information than can be encoded though a text string that is the same length, and in fact identical to said s-string.I mean, I get it. Lispers like lisp, and think it’s “better”. But it’s more more expressive than text, and in fact operating on text gives you natural access not just to s-expressions but to any other programming languages or structured and unstructed examples of text.If you shell operated only on s-expressions that would either have you reduce expresiveness, or just doing tricks to encode the text-stream as a s-expression which hardly qualifies as making it more expressive, that’s just adding extra redundant information around the original information.	hjk05	15.086177	-4.0153327	comment	4.0	12.0	1551378343	-10.336796
19318394	I always wonder if Common Lispers wh	I always wonder if Common Lispers who bash Scheme know that Guy Steele (who also is the chairman of the Common Lisp standards committee) was the co-creator of Scheme.	jhbadger	15.140876	-3.9468195	comment	4.0	18.0	1551875760	-10.484365
19346797	Common Lisp currently isn’t so great	Common Lisp currently isn’t so great for purely functional programming. The language has the equivalent of GOTO, imperative loops, mutable objects, etc. But work is being done to make it a better functional language.	reikonomusha	15.119874	-3.9853108	comment	4.0	14.0	1552148285	-10.467114
19407924	Lisp is pretty ugly :)    (eql (* x 	"Lisp is pretty ugly :)    (eql (* x (+ y z)) (+ (* x y) (* x z)))

I wonder if its famed sense of enlightenment is partly just overcoming the mental hurdle of it's syntax.Edit: typo fix, had x/z mixed up"	QuadrupleA	15.105874	-3.990739	comment	4.0	26.0	1552746069	-10.376991
19407962	Some would argue that the fact that 	Some would argue that the fact that you have all of those alternative forms is part of the problem. Lisp is one of the (if not the) most individualistic programming languages around. Lisp makes it easy for a programmer to create their very own impenetrable, arcane, domain specific languages. This causes large organizations to avoid it like the plague.Large teams don't want artists, they want replaceable parts.	chongli	15.150705	-3.9424286	comment	4.0	14.0	1552746645	-10.457653
19408072	he doesn’t make any coherent argumen	"he doesn’t make any coherent argument as to why one is more clear or preferred than the other. he simply states it and moves on with this bias. for example, when he compares 2 to 2a, i feel he doesn’t really address anything and just states his preference as the more clear one.plus, he of course seems to know nothing about lisp (or just ignores it) where you might have:  (+ a (+ b c)) = (+ (+ a b) c) = (+ a b c)

all three are valid lisp syntax and represent associativity of addition well, including “dropping the parentheses”. the thing is, procedure notation as opposed to infix operators actually make it more explicit by what is meant by associativity. this is because it makes explicit about what comes first because of how procedures are evaluated. this is much more explicit than conventi"	nikofeyn	15.076631	-4.0232806	comment	4.0	17.0	1552747883	-10.349793
19408025	Why all Lisp editors/IDE's look like	Why all Lisp editors/IDE's look like Emacs?	badsectoracula	15.064059	-3.9799387	comment	4.0	13.0	1552747383	-10.326539
19671775	Lisp Machine Hacking (2018)	Lisp Machine Hacking (2018)	kristianp	15.131179	-3.9407656	story	4.0	90.0	1555399579	-10.434674
19678120	I second the recommendation for Prac	I second the recommendation for Practical Common Lisp, even for complete beginners and newcomers to Lisp. It covers the very basics, and the writing style is accessible and patient.	nothrabannosir	15.143816	-3.940775	comment	4.0	24.0	1555456034	-10.455397
19684433	Sounds like Lisp Machine Lisp reborn	Sounds like Lisp Machine Lisp reborn.	guicho271828	15.145738	-3.9356272	comment	4.0	14.0	1555521287	-10.447557
19905409	Maybe this will need C based highly 	Maybe this will need C based highly optimized backend as well, however, the code looks very clean and beautiful to me. I hope someday differentiable programming becomes possible in common lisp.	chunsj	15.126787	-3.9565573	comment	4.0	34.0	1557792474	-10.404657
15882370	Lisp seems to take the exact opposit	Lisp seems to take the exact opposite approach as Go. The power of languages like Lisp appeal to me, so I have a hard time understanding why people want a language that intentionally limits itself. Read Graham's book and he's talking about how macros are great for writing maintainable code because you can make it both short and very readable because it's close to the domain.But then you hear the arguments in favor of Go maintainability, and it's about copy/pasting being preferable to abstraction and not having too many ways to do things, so everyone's code looks familiar. Also that the extra LOC are more readable to Go maintainers than powerful abstractions. That surprises me, because languages like Lisp, Smalltalk, Ruby and Haskell are all about powerful abstraction capabilities so you ca	goatlover	15.103945	-3.9972227	comment	4.0	27.0	1512769849	10.264263
15893380	    One strange phenomenon when codi	"    One strange phenomenon when coding in C is using macros. This is not something which can be seen in other programming languages (other than C++).

This is false. Lisp is a language, or rather, a family of languages, where macros play a giant role, and the author does not seem to mention them.But again, Lisps generally have more powerful macros than C does - they allow for arbitrary compile-time computation."	phoe-krk	15.114562	-3.9766128	comment	4.0	17.0	1512938384	-10.423331
17909302	Why not use lisp syntax, at all? Why	Why not use lisp syntax, at all? Why do we have to reinvent syntax every single generation? I'm not an old school engineer (I'm in my early 20s and in my first job, freshly outta college) but I can't see why we don't use lisp, prolog or ML syntax for everything. Seems vastly better than C-like synaxes in all ways I can think of, easier to implement, easier to extend, easier to read (imho) etc... When I program even in a low caliber lisp like elisp (which I do routinely since I use emacs) it feels like syntax gets in my way less frequently compared to python, C, Javascript etc... I just wanna think about my program, and not the syntax. If lisp is not expressive enough, why not just ML? Why do we have to reinvent it so many times when syntax is not an interesting or relevant problem (e.g. Ru	gnulinux	15.105362	-3.9916961	comment	4.0	35.0	1536071676	-10.413501
17980697	Heh.  Emacs/lisp users always make p	"Heh.  Emacs/lisp users always make posts like: ""look at this great [thing] to completely simplify [thing]"" while simultaneously posting 82 steps to get it all working and automated :)"	pixelrevision	15.104267	-3.9884887	comment	4.0	18.0	1536860813	-10.392842
18030386	Ask HN: Any good Lisp-lile language 	Ask HN: Any good Lisp-lile language that compiles to both JS and Python?	nnq	15.112803	-3.9753006	story	4.0	7.0	1537428007	-10.441608
18105985	> Development convenience was also a	"> Development convenience was also among the collateral damage.Don't you find that web & javascript are pretty much a straight denial of your argument ?They're ""secure"" (meaning we let anyone's javascript code just run in our browsers, even embedded in other people's code, and seriously expect no ill effects)They're extremely inconvenient to develop with. Especially compared to those ""run-time above all else"" environments you mention. For one, you need to know 5-6 languages to use the web.> Because you use C or one of its derivatives instead of Lisp or one of its derivatives. In Common Lisp you can not only debug a function without restarting your program, you can redefine classes without restarting your program. It is truly awesome. You should try it some time.I think you'll find that pre"	candiodari	15.099146	-3.9890685	comment	4.0	16.0	1538312336	-10.418768
18193079	> Allegro CL or Franz Lisp.Same thin	"> Allegro CL or Franz Lisp.Same thing.  Franz is the company.  Allegro Lisp is the product.  Like ""Apple Macintosh computer.""> But why is it 'high performant' compared to other implementations? Like say CMU CL(now SBCL).Somewhat better compiler, but mainly lots of extra features (better debugging, graphics, better libraries).> why would one use Clozure CL instead of SBCL?I use CCL because 1) I like the IDE and 2) its compiler is fast so you can always compile everything essentially for free.  In other CLs you have to choose between running in compiled or interpreted mode, and that can sometimes cause problems.  CCL doesn't have an interpreter at all.  It always compiles everything and that makes it easier to use."	lisper	15.135489	-3.9496999	comment	4.0	18.0	1539262551	-10.430254
18193110	What resources would you recommend o	What resources would you recommend one read to understand more about debugging facilities in Common Lisp?	kamaal	15.122754	-3.9595327	comment	4.0	12.0	1539262760	-10.351508
18203374	I'm just now starting to crack open 	I'm just now starting to crack open some Lisp tutorials, coming from the OOP side of the fence, so please excuse the ignorance. For my learning purposes, would you be open to explaining how symbolic expressions would circumvent the need for a file system?	jj12345	15.122398	-3.9628398	comment	4.0	45.0	1539367611	-10.37502
18215967	Why do people keep implementing LISP	Why do people keep implementing LISP on everything? Aren’t there more interesting things to do?	iddan	15.1445265	-3.9439893	comment	4.0	17.0	1539556970	-10.453676
18226237	The lisp circle jerk is a little too	The lisp circle jerk is a little too much sometimes.	adamnemecek	15.155507	-3.9326775	comment	4.0	15.0	1539661225	-10.427031
18228244	Lisp and Scheme are great. They woul	Lisp and Scheme are great. They would be my favorite programming languages, if they had a statically typed, Hindley-Milner type system.As they stand, they are great learning tools, but I would never build something serious with them. Let alone questions about parallelism, concurrency, available libraries, development tools, etc.Any suggestions are welcome.	etatoby	15.123615	-3.9557612	comment	4.0	12.0	1539687404	-10.460539
18267493	Elisp is awesome! Emacs is truly an 	Elisp is awesome! Emacs is truly an integrated development environment also thanks to this great extension language.This paper provides a nice overview of past and also very recent language developments. For example, support for bignums (Section 7.3) is one of the most exciting new features.Thank you very much for putting this together, and for all your work on Emacs!	triska	15.099376	-3.9662414	comment	4.0	46.0	1540119833	-10.338018
18282262	C++ is getting more and more like Li	C++ is getting more and more like Lisp.	nemoniac	15.124194	-3.9648864	comment	4.0	14.0	1540291541	-10.414612
18309404	Lisp is a fun language to program in	"Lisp is a fun language to program in. I learned Lisp after already being familiar with Java / Python and some other languages, which maybe made it even more beautiful.One of my favourite pieces of code is a Lisp REPL in Lisp:    (defun repl()
            (loop (print (eval (read)))))"	Insanity	15.116363	-3.9685235	comment	4.0	37.0	1540563446	-10.448288
18309616	So the author was excited about the 	So the author was excited about the concept of function composition? I'm a fan of lisp but I'm not seeing what's particularly novel about lisp here.	pweissbrod	15.141103	-3.9484055	comment	4.0	13.0	1540564862	-10.442031
18310164	> the number of parentheses is just 	> the number of parentheses is just mind bogglingThere aren't actually more parens in a Lisp program than a program written in a C-like syntax (which is really an algol-like syntax).  They just stand out more for two reasons:1.  There is less punctuation in general, so the parens are more obvious.  Instead of f(x, y, z) you write (f x y z).  Without the commas, the parens stand out because that's all that is left.2.  There is only one kind of parens in Lisp whereas C-like languages use at least three: (), [], and {}, so that makes any particular kind of paren less prominent.	lisper	15.10179	-3.9986043	comment	4.0	17.0	1540567849	-10.422092
18310706	my question is yes, lisp.. but what 	my question is yes, lisp.. but what is beyond lisp?	moocowtruck	15.143238	-3.9438884	comment	4.0	13.0	1540571099	-10.477421
18348320	A few questions for the Lisp fans ou	"A few questions for the Lisp fans out there:1. The summary here seems to be ""modern high-level languages, used, well, are just as productive as Lisp."" Does that seem right?2. One of the tensions for me in technology is between love of simplicity and love of complexity. An example of the latter is Enterprise Java, where the tendency toward a FactoryProxyBeanMutatorFactoryInterfaceImplementation is well known. Is the perceived superiority of Lisp perhaps because it attracts people with strong simplicity bias?3. Every ""Lisp is super-productive"" story I hear is about a lone individual. Is Lisp's suite spot that of the solo programmer? Since the rise of the Internet, I think most software has shifted to be about teams, and I'm wondering if Lisp is less suited to team collective ownership or pro"	wpietri	15.138971	-3.9523146	comment	4.0	17.0	1541012078	-10.487727
18348294	My summary: he worked at Google in t	"My summary: he worked at Google in the early 2000's (when there were indeed many astonishingly productive progammers), and he saw them being super productive in languages like Python.  And he himself became productive in such non-Lisp languages.He uses the hash table as an example, and I think it's apt.  Lisp does feel ""old"" to me with respect to having 10 different choices for hash tables in 10 different dialects.  (I briefly worked with Julia's femtolisp a couple years ago and felt this.)I also felt it when trying OCaml like 5 years ago.  I loved the language, but having to ""choose"" which hash table to use felt odd.Newer languages like Go and Rust (I think) both have Python/Perl-like hash tables built-in, or at least close to the core where all libraries can interchangeably use them.  I "	chubot	15.102195	-3.9815824	comment	4.0	14.0	1541011912	-10.501146
18428811	> Is this really true?Yes. There com	> Is this really true?Yes. There comes a moment in which you suddenly stop minding parentheses. For me it was when I started reading SICP and doing its exercises on paper. After writing a couple Lisp expressions by hand, something clicked in my brain, and since then I don't need to count parentheses anymore.I strongly suspect following the Lisp style of indentation and placing parens (closing parens go together, instead of one per line like in Algol-derived languages) is vital to achieving that.	TeMPOraL	15.104566	-3.9937248	comment	4.0	13.0	1541972789	-10.33842
18428908	I’ve used Lisp for decades, so it’s 	I’ve used Lisp for decades, so it’s hard to remember a time when the parentheses bothered me, but every new programming language has some surface syntax that can be off-putting. I used to hate the hard to type curly braces when I started with C, my fingers didn’t know where they were on the keyboard; at the time, I was programming with languages that used BEGIN and END. Now I prefer curly braces or even indented languages like Haskell or Python.I encourage others to learn lisp. It’s really not a hard language, and the parentheses don’t get in the way after a brief period of acclimation. It also opens up the real power of Emacs customization and programming, which is done in Lisp.	todd8	15.105577	-3.9925423	comment	4.0	17.0	1541973732	-10.3661375
18433582	> what Lisp developers have had sinc	> what Lisp developers have had since the early '80sWe absolutely did not have a globally, network-accessible terminal with pay-as-you-go computer time.I have no experience or interest in repl.it, but I think you're understating things somewhat.	geocar	15.124945	-3.960407	comment	4.0	17.0	1542040568	-10.584625
18449408	Introducing SourceKit-LSP	Introducing SourceKit-LSP	mbroncano	15.084019	-3.9581249	story	4.0	61.0	1542199479	-10.436093
18484628	Because most of the time they repres	Because most of the time they represent a huge debugging effort.For example, how do you step a macro expansion in Rust at any given point in a source level debugger?Yep, you don't.Even on Lisp, if we want something more developer friendly than (macroexpand) the only option are the commercial Common Lisp environments.Having said this, I also do like having macro support around, provided it gets used judiciously.	pjmlp	15.101076	-4.0016747	comment	4.0	16.0	1542611138	-10.388098
18532162	What part of the code that will comp	What part of the code that will compile under this simple compiler (i.e. `(+ 2 (+ 3 4))`) _doesn't_ have lisp semantics?	fao_	15.112752	-3.9765363	comment	4.0	13.0	1543225457	-10.3749075
18533768	I will admit that this stuff is way 	I will admit that this stuff is way over my head, but it's things like this that make me wonder why the Lisp machines/processors never really caught on...can anyone here shed some light into this for me?	tombert	15.143144	-3.9389193	comment	4.0	18.0	1543244617	-10.427913
18540221	What makes Lisp macros so special?	What makes Lisp macros so special?	neokantian	15.11918	-3.9809945	story	4.0	7.0	1543303111	-10.381831
18667951	> When you speak of non lisps are ‘b	> When you speak of non lisps are ‘blub’ you disregard the actual characteristic of those languages and how they fit to the task.What does 'blub' mean?	FigBug	15.147609	-3.93792	comment	4.0	39.0	1544650425	-10.464741
18703132	Wow!!! This is a wonderful talk.The 	"Wow!!! This is a wonderful talk.The title is so old school though that need changing.- How I use lisp to fight human aging or 
- why I choose lisp over python to combat protein generation
- my protein generation using llvm was done all by lisp for. ReasonThe talk is amazing. This one chemistry prof. who seems to be an IT expert but really just start lisp programming by building a lisp interpreter.Wow!!!https://github.com/clasp-developers/clasp And 
The cando one."	ngcc_hk	15.122219	-3.9666946	comment	4.0	12.0	1545088257	-10.339637
18705005	This is fascinating to me because co	This is fascinating to me because coming at it as a Lisp programmer, my impression of LLVM is that it's primarily a library for doing Lispy things in C.  It kind of makes sense, then, that you should be able to use the codegen parts of LLVM for implementing Lisp itself, and I love that someone has actually done that.  And that he bootstrapped it using an existing self-hosted compiler.The obvious question I have is why not just use something like SBCL as the starting point.  His own benchmarks show it's ~4x faster (so far).  Is it not easier to add GPU support to SBCL, than to write a new Lisp compiler from scratch?  Of course, this way is more fun.	ken	15.125361	-3.9545863	comment	4.0	22.0	1545116703	-10.393344
18855667	I'd love to know Lisp, just like I'd	I'd love to know Lisp, just like I'd love to know Python. I have no experience in either (I come mostly from Java, javascript with some Ruby and some ancient C/C++ experience). When I look at Python code, I understand what it does. I don't think I've ever written any Python, but I think I could sit down and be productive within a day.Lisp looks like complete gobbledygook to me. I'd love to be able to understand it and write it, but the syntax doesn't look like it's meant to be human readable. It's almost as much work as reading assembly.I should probably give it another try, though.	mcv	15.120471	-3.972681	comment	4.0	32.0	1546957586	-10.34413
18883910	I wish someone would release a good 	I wish someone would release a good book on Metasploit. Every book and tutorial I've found has been either helpful but too short, out of date, or used an example which you couldn't follow along with (either because they used a feature in the paid for product or because they attacked a vulnerability in an old version of an application that you can't get anymore instead of using a vulnerability already in metasploitable n). In fact, if you want me to buy anything Metasploit related you should probably start by writing that book. Please, write that book, lol. I have no idea how to use your product.	nobody271	15.139978	-3.940382	comment	4.0	13.0	1547218494	4.8269196
29751405	"I don't get the ""fewer libraries/mod"	"I don't get the ""fewer libraries/modules is a good thing"". I like using libraries where some has already encountered and created work-arounds for all of the edge cases for a really domain specific problem I'm not very familiar with so that I can focus on business logic. Am I missing something? What's fast about blindly discovering a bunch of stumbling blocks that you never imagined existed?All that said, I'm a fan of lisps, I've just never used one in production."	cjohnson318	15.113319	-3.9658012	comment	4.0	12.0	1640977942	-10.372233
29780307	Is there any big corp using it massi	Is there any big corp using it massively? why the shift up? It's kind of curious that a lisp is at the top of the list (according to SO). Not surprising, but curious. What do you think? any ideas?	ihojman	15.152299	-3.9351447	comment	4.0	14.0	1641214722	-10.443081
29858477	This book is probably the most fun I	This book is probably the most fun I have had with a programming book. I remember going through most of it the first day I cracked it open.Curious if anyone knows other books that take a similar approach: fun but not dumbed down.I tried a few from nostarch, in general I love their books, but i haven’t found one as engaging as land of lisp.	joe8756438	15.1496935	-3.9305146	comment	4.0	13.0	1641689110	-10.4453125
29861201	I was slightly surprised to learn ho	I was slightly surprised to learn how well Common Lisp had implemented its types. I keep wondering why CL almost completely failed to break into the minds of people in early 2000s. That was about the time I first learned about python, which kind of seemed to be everywhere. It took 5-10 years before I even heard of Common Lisp.And now it seems to me that the Common Lisp which was pretty much fixed in 90s is superior in many ways (runtime, programming environments, typing -- to mention a few) to even the revised python3 of 2021. And then Javascript, essentially a bad clone of Lisp, got popular? Makes absolutely no sense.	vegai_	15.130565	-3.9592328	comment	4.0	24.0	1641714327	-10.459648
29891523	Common Lisp: Macroexpand-time branch	Common Lisp: Macroexpand-time branching	CapitalistCartr	15.110887	-3.9765983	story	4.0	70.0	1641909722	-10.325654
29948263	That sounds a lot like a macro. Is t	That sounds a lot like a macro. Is the main difference that macros evaluate at compile time and fexprs evaluate at EVAL time? I imagine a facility like EVAL-WHEN[1] can blur the distinction.[1] http://www.lispworks.com/documentation/HyperSpec/Body/s_eval...	User23	15.120519	-3.9801946	comment	4.0	13.0	1642267516	-10.291746
30045522	Writing a Lisp interpreter an Lisp i	Writing a Lisp interpreter an Lisp is cheating. You get the reader and garbage collector for free.Don't get me wrong, it's fun. But if you want to learn about things, writing a Lisp interpreter in some (relatively speaking) low-level language like C/C++ is a much more satisfying experience. And then write a Lisp interpreter to run on your Lisp.Bonus points if you get to optimize tail recursion. (I didn't, but I didn't try to, so I don't consider it a failure.)	krylon	15.119921	-3.9681714	comment	4.0	15.0	1642938926	-10.364044
30174122	> With paredit, you get meta level d	> With paredit, you get meta level direct AST manipulation support in emacs that is still light years ahead of any programming IDE out there.Do you happen to know of a video or article with visual examples that demonstrates this? I always hear about these things with Common Lisp, but I have personally never seen it. I’d love to understand how this works or enables people.	bmitc	15.079169	-3.9983091	comment	4.0	23.0	1643780095	-10.253404
30174171	Lots of reasons.1) Lisp acquired a r	"Lots of reasons.1) Lisp acquired a reputation of being associated with AI, back when that was a bad thing, lots of government-funded ""expert system"" boondoggles and the like. It is not considered a general purpose language, despite being one.2) Lisp is thought to have poor library support. Unlike Java or JavaScript, which have standard libraries for every task, Lisp is thought to lack this. Quicklisp helps, but it's not as comprehensive as Maven or npm.3) Lisp is associated with a certain programmer type: highly intelligent, persnickety, only interested in solving interesting problems. Companies prefer programmers who have only a moderate amount of technical skill but who are diligent, who will take orders and get the job done without complaint.4) Not many programmers actually know Lisp, b"	bitwize	15.137565	-3.950282	comment	4.0	23.0	1643780511	-10.432069
30186395	When you capitalize lisp as in Lisp,	When you capitalize lisp as in Lisp, that usually refers to Common Lisp (also the lisp being discussed in the whole thread). Have you implemented Common Lisp?	medo-bear	15.140921	-3.9404345	comment	4.0	23.0	1643847346	-10.478759
30271989	Lisp in Production: an interview wit	Lisp in Production: an interview with the guys behind Nyxt Browser [video]	pedrodelfino	15.111589	-3.9341671	story	4.0	105.0	1644410926	-10.246807
30372056	Lisp Alien 3D Model	Lisp Alien 3D Model	kikytokamuro	15.142087	-3.9381154	story	4.0	61.0	1645098219	-10.3836355
30685183	> the system language is awkward (no	> the system language is awkward (no namespaces, dynamic scoping by default, ...)RMS's dislike of Common Lisp really caused a colossal amount of damage.  Imagine an Emacs written in Common Lisp instead of Emacs Lisp, with decades and decades of improvements.  Having written a reasonable amount of software in both, Common Lisp Emacs would be very, very preferable, in part for the reasons you list and in part for others (e.g. a full-fledged, built in object system and improved extensibility).	zeveb	15.122118	-3.9570749	comment	4.0	13.0	1647352016	-10.445925
16308922	> So this is literally LispNo, it's 	> So this is literally LispNo, it's close to S-expressions, but it's not a programming language like Lisp.> just with curly braces instead of parenthesisWell, and more syntax than S-expressions: it's got both objects and arrays as fundamental structures instead of just lists, and it has commas as noise characters.	dragonwriter	15.094644	-3.9980304	comment	4.0	19.0	1517841026	-10.386367
16313736	The problem with these schemes is th	The problem with these schemes is that they're at odds with metaprogramming. One huge advantage of s-expressions is that  the code is expressed using data literals. You can take any piece of code transform it as you would any regular data and then run it.The biggest practical improvement that I've seen was Clojure notation that expands the number of data literals to include vectors, maps, and sets. I think this greatly helps with readability as it provides additional visual cues, while still preserving homoiconicity.	yogthos	15.056209	-4.0526395	comment	4.0	25.0	1517879722	-10.541616
16351023	Common Lisp Brazil Community	Common Lisp Brazil Community	lerax	15.154069	-3.9329162	story	4.0	63.0	1518319962	-10.488537
16392727	See what I did there?Despite the goo	See what I did there?Despite the good intention, no, because you're trying to explain lisp using lisp. If I knew lisp, I wouldnt need you to explain what code-as-data means.Maybe it's time for a different strategy. As a matter of fact, I've tried to explain code-as-data using OOP just this morning: https://news.ycombinator.com/item?id=16389514	quadcore	15.112502	-3.9812205	comment	4.0	71.0	1518793070	-10.413175
16393389	In Lisp, my understanding is that wh	In Lisp, my understanding is that while you can manipulate the AST directly, you will likely introduce a bug unless you use the special functions for handling hygienic macros? And each flavor of Lisp has its own way of doing hygienic macros.	skybrian	15.115	-3.9774373	comment	4.0	12.0	1518797977	-10.282299
16394173	Can you elaborate what you would exp	Can you elaborate what you would expect from such a system ?As someone not having much familiarity with CLIM or common lisp, I seem to be lacking the perspective to appreciate the relevance of this technology in 2018.Things like support for truetype rendering, bezier curves, tab layout etc. are not exactly cutting edge advancements.	lf-non	15.083642	-3.9940455	comment	4.0	17.0	1518803416	-10.436038
16405083	Is there any flavor of lisp that is 	Is there any flavor of lisp that is close to luajit performances and still small?	egnehots	15.151784	-3.9336371	comment	4.0	23.0	1518943490	-10.439554
16407689	As much as I like Lisp, I don't thin	As much as I like Lisp, I don't think your choice of language will make or break your startup.	didibus	15.138453	-3.947378	comment	4.0	14.0	1518981656	-10.48282
16411457	Not the grandparent poster, but step	Not the grandparent poster, but stepping in.Lisp, due to its easy metaprogramming, gives abstraction enthusiasts rather more rope to hang themselves than languages which make abstraction inconvenient (e.g. Go, which has a simple type system, or Java, which is very verbose). So, if one isn't careful, it's possible to write a very clean, very nice Lisp DSL which is totally incomprehensible to anybody but the author, and thus hell to maintain over time.Relevant quote, from https://www.joelonsoftware.com/2000/07/22/microsoft-goes-bon... –> When great thinkers think about problems, they start to see patterns. They look at the problem of people sending each other word-processor files, and then they look at the problem of people sending each other spreadsheets, and they realize that there's a gen	kornish	15.110344	-3.9788997	comment	4.0	20.0	1519027428	-10.307314
16528222	"""scheme web framework"", except there"	"""scheme web framework"", except there are multiple scheme implementations and variants. I don't understand why the word scheme is even used, each scheme is basically a silo."	viperscape	15.117391	-3.9519508	comment	4.0	12.0	1520336701	-10.429094
16593084	I started to learn Lisp, and struggl	I started to learn Lisp, and struggled after trying to use:- Quicklisp (lisp package manager)- ASDF (builder)They are very complicated to use and understand.Then I abandoned Common Lisp...	weeber	15.135161	-3.948335	comment	4.0	16.0	1521124001	-10.441573
16765831	I think for people who want to be ab	I think for people who want to be able to have a bit of lisp into their daily lives, Clojure is where the majority of the current industry-focused mindshare is going. At least as far as new development of language features is concerned.For people who are less industry focused, and more interested in the evolution of lisp from a CS perspective, Racket has gobbled up that mindshare.Common Lisp, in spite of its strengths, multiple standard implementations, and historical pedigree, seems at risk of fading more if there isn't some new lifeblood injected. The problem if I understand it, is that the Common Lisp spec is so gigantic, and was itself the product of a tenuous truce between many warring tribes of lisps long forgotten. I wonder how possible a new spec even is?	peatmoss	15.1394205	-3.9637454	comment	4.0	24.0	1522942534	-10.843286
16900787	I find this comment frustrating, jus	"I find this comment frustrating, just like many of the Lisp comments. Asserting a condescending statement with zero explanation. These Lisp comments aren't taking the form ""oh, Lisp has something like this too, we can learn from it,"" instead it's, ""something like this feature exists in Lisp, therefore these ideas clearly aren't new."" For example on the thread about gradual typing, Common Lisp has definitely not had gradual typing since the concept didn't exist until the last 10 years (distinct from optional static typing). Yet that does not stop the commenter from asserting ""oh Lisp has had this for forever"" without any further discussion or nuance."	wcrichton	15.145825	-3.9461348	comment	4.0	14.0	1524462240	-10.460219
16952539	Common Lisp’s object system (CLOS) a	Common Lisp’s object system (CLOS) allows you to specify on a method by method basis whether or not the most-specific method has priority or the least-specific one does. Generally people just use the default behavior—least specific first—but this post makes the alternative sound interesting.	fiddlerwoaroof	15.112738	-3.9739146	comment	4.0	19.0	1525017612	-10.453303
16973691	> It annoys me when people conflate 	> It annoys me when people conflate a terse and/or illegible programming style with functional programming.The problem is, functional programming languages are almost always harder to read than other languages. Haskell is the obvious example, but Lisp is pretty bad too. It takes a bit of experience to be able to refactor in the middle of a Lisp block without messing up the balancing of the parentheses. Yes, it can be learned, and it can be learned faster than people expect. But the barrier to entry is much higher than it is for most languages.By the way, I love both Haskell and Lisp, and I think more people should use them. But I'm not going to pretend it's easy get started working with those languages.F# and other languages ML-style syntax are probably the easiest to read.	twblalock	15.110003	-3.9928694	comment	4.0	20.0	1525229702	-10.408504
17037285	> I sometimes wonder why Lisp has no	> I sometimes wonder why Lisp has not been more popular in the technology industry. Is it the lack of sufficient marketing? Is it the lack of an extensive library ecosystem?Data-point of one here, but I was instantly turned off by the conflation of the empty-list, nil, and boolean-false. I could tell instantly that I'd have a hard time interfacing with data from other real-world systems, so I decided to skip CL and stick to Clojure and various Schemes for my lispy kicks.	s_kilk	15.138727	-3.9592295	comment	4.0	36.0	1525942871	-10.651803
17038445	Any good implementations if common l	Any good implementations if common lisp on Windows?	djhaskin987	15.126174	-3.9485772	comment	4.0	12.0	1525957266	-10.419073
17040077	> I sometimes wonder why Lisp has no	"> I sometimes wonder why Lisp has not been more popular in the technology industry.Larry Wall said that a language should make the easy things easy, and the hard things possible.  I think the problem is that Lisp doesn't make the easy things easy.Before you tar and feather me, hear me out.  There are two different ways in which Lisp doesn't make the easy things easy.First, syntax.  ""But it's easy!  In fact, it's the easiest!"" you reply.  But for the vast majority of programmers, Lisp syntax is not easy.  You could argue that they just need to be trained.  But the syntax is different enough that they are reluctant to try.Second, installation and package management.  This is part of what is now expected to be easy.  If Lisp doesn't have an install and package management that is as easy as, s"	AnimalMuppet	15.135313	-3.9562755	comment	4.0	19.0	1525968041	-10.412702
17042315	You quoted two companies using Lisp 	You quoted two companies using Lisp when there are millions of Java devs. That's like a boxer with a record of 1-500. I love Lisp, but c'mon...I guarantee it has far more hobby users than professional users.ABCL, FRANZ, ALLEGRO, SBCL, CLISP, GNU CL, Clozure might all be common lisp, but they are different implementations with different tools that will confuse a new person and several cost money.Practical Common Lisp isn't very good in my opinion, that was the example i actually used. SICP is great for a mind-opening experience, but not super useful on how to write modern software and is why the creators dropped it at MIT.For multi-core I'd rather it be core than a library, but perhaps that is petty of me.I think Lisp is great, but why it isn't popular shouldn't be a mystery to anyone.	FractalLP	15.131583	-3.956609	comment	4.0	25.0	1525981384	-10.453511
17120465	Some points:- Yes, the original publ	"Some points:- Yes, the original publication year was 2000. I've added that to the file.- @HelloNurse: You've got the key point. I provided Lisp code to teach AI; but my goal was to teach AI, not Lisp. As more schools and students were familiar with Python and not with Lisp, I needed to make the switch to keep teaching AI effectively.- @jonathanstrange: Yes, ""batteries included"" is key to Python; there is some pain in doing any change; this page attempted to alleviate some of the pain.- @rauhl: ""in the silence a thousand words were said"". I'm not sure what words are in that silence. But to me, the words are: Lisp and Python are different ecosystems with different customs. The Lisp community likes to solve lots of problems with macros. The Python community doesn't. For 95% of the usages, nei"	norvig	15.132179	-3.9599588	comment	4.0	14.0	1526926681	-10.461719
22861273	Interestingly, though, some language	"Interestingly, though, some languages get it right:    northrup@Topaz:~/Desktop$ perl -de1
    
    Loading DB routines from perl5db.pl version 1.55
    Editor support available.
    
    Enter h or 'h h' for help, or 'man perldebug' for more help.
    
    main::(-e:1): 1
      DB<1> say 0.1 + 0.2
    0.3

[…]    northrup@Topaz:~$ csi
    CHICKEN
    (c) 2008-2019, The CHICKEN Team
    (c) 2000-2007, Felix L. Winkelmann
    Version 5.1.0 (rev 8e62f718)
    linux-unix-gnu-x86-64 [ 64bit dload ptables ]
    
    #;1> (+ 0.1 0.2)
    0.3

[…]    northrup@Topaz:~$ sbcl
    This is SBCL 1.5.8, an implementation of ANSI Common Lisp.
    More information about SBCL is available at <http://www.sbcl.org/>.
    
    SBCL is free software, provided as is, with absolutely no warranty.
    It is mostl"	yellowapple	15.127233	-3.9532194	comment	4.0	24.0	1586820215	-10.378415
23042311	If I may ask, what references would 	If I may ask, what references would you recommend to someone interested in something like Lisp, but who has never touched a functional language before?	PythagoRascal	15.141488	-3.9496334	comment	4.0	24.0	1588343385	-10.439462
23054556	After learning s-expression based sy	"After learning s-expression based syntax, I am just baffled why we even bother with anything else.When you play around with different Lisps, the syntax is always the same, the language differences becomes the semantics only.Other languages put too much emphasis on the syntax in my opinion. And while I understand the ""popularity"" appeal. I've almost never seen someone learning the s-expression syntax and afterwards not liking it.Basically I think it be worth it to push people to learn the s-expression syntax just so we can stop wasting our time with syntax afterwards.Also if I recall, without user macros, I think s-expression syntax is context free no?"	didibus	15.093056	-4.0009584	comment	4.0	24.0	1588450374	-10.353733
23068151	This seems convoluted compared to sa	This seems convoluted compared to say moving the Lisp implementation from Emacs Lisp to Common Lisp, of which several native code compiling implementations exists.	fmakunbound	15.1292095	-3.9545507	comment	4.0	41.0	1588600877	-10.409153
23164966	Is it really Lisp without cons?	Is it really Lisp without cons?	pjc50	15.155348	-3.9317927	comment	4.0	23.0	1589360695	-10.478148
23167779	I don't use lisp languages, but one 	"I don't use lisp languages, but one basic difference this has from other lisps is that functions accept multiple expressions, e.g.:    (defn greet [firstname lastname]
      (def fullname (string firstname "" "" lastname))
      (string ""Hello, "" fullname))

In other lisps, you'd have the last expression nested inside a `let` block:    (defn greet [firstname lastname]
      (let [fullname (string firstname "" "" lastname)]
        (string ""Hello, "" fullname)))

which makes the code hard to read and edit IMO. Languages like Haskell and OCaml suffer from a similar problem too."	frankpf	15.1067295	-3.9901311	comment	4.0	14.0	1589383531	-10.3689
23234112	Yep, I've used Common Lisp in produc	Yep, I've used Common Lisp in production. Several times. I'm in the middle of writing a new app with Lispworks right now.Common Lisp is generally the first thing I think of for any new work I undertake. There are exceptions, but usually my first choice is Common Lisp. It has been for a little over thirty years.I've often worked in other languages--usually because someone wants to pay me to do so. I usually pick Common Lisp, though, when the choice of tools is up to me, unless some specific requirement dictates otherwise.The objections you list might be an issue to some extent, but not much of one. Certainly not enough  to discourage me from using Common Lisp in a pretty wide variety of projects. I've used it for native desktop apps, for web apps, for system programming, for text editors, f	mikelevins	15.130364	-3.949197	comment	4.0	43.0	1589891548	-10.439202
37998237	What is the most Lisp-like type safe	What is the most Lisp-like type safe language?	0xDEF	15.130747	-3.9537292	comment	4.0	12.0	1698150810	-10.391873
25492099	> Lisp has extremely powerful code g	> Lisp has extremely powerful code generation, but makes serious performance compromisesThis is a serious exaggeration.Common Lisp has extremely good compilers that can meet C performance.There are plenty of Scheme implementations (I use Chez) with very good performance characteristics too.	elgatonegro	15.118337	-3.9656756	comment	4.0	35.0	1608524411	-10.359173
25500518	> They both allow for clean function	> They both allow for clean functional approaches and deep recursion in practice.Please tell me what kind of functional approaches Common Lisp and Scheme allow that Python doesn't.Scheme is the only one o the three that has t.c.e. as a language feature, of course.> Both get low level enough to get decent performance from the language itself (unlike python).Scheme is far, far more performant than C.L. and that's due to language design choices.> I guess what I'm saying is I can write CL code that feels very scheme like in approach and also is comfortable in the language. The same is not close to true of python.I think you might simply not know how to or believe that it feels more Scheme like simply because it's written in a similar syntax.Even JavaScript started as a Scheme dialect that late	Blikkentrekker	15.129401	-3.9638555	comment	4.0	12.0	1608590226	-10.458784
25559503	I'd prefer C++ interpreter written i	I'd prefer C++ interpreter written in Lisp...	rini17	15.118307	-3.9909117	comment	4.0	36.0	1609166500	-10.350493
25583855	Does common lisp have any  great lib	Does common lisp have any  great libraries for working with data? I’ve been reading some books over the holiday and I’d like to start getting my hands dirty, but my background is R, and my day to day is statistical analysis and graphics.	clircle	15.131904	-3.94091	comment	4.0	12.0	1609350333	-10.454712
25661701	Debugging Lisp (2015)	Debugging Lisp (2015)	wooby	15.12451	-3.9580412	story	4.0	117.0	1609963908	-10.331693
26054118	I think a much bigger consideration 	"I think a much bigger consideration would be the utter difficulty of reading something like this:  a-b - a - b

Even though I personally love hyphenated-identifiers in Lisp, I would not want them in any language that has infix operators, whether it cares about minification or not."	tsimionescu	15.110277	-3.9843478	comment	4.0	13.0	1612695369	-10.372782
26070131	Rather than rehash the ancient argum	Rather than rehash the ancient argument once again, I defer to this post:https://www.xach.com/naggum/articles/3225161536947499@naggum...(KMP was on both Common Lisp and Scheme standard committees; Erik Naggum was an eloquent, if controversial, Lisp expert)	varjag	15.14525	-3.9469848	comment	4.0	20.0	1612818421	-10.484118
26270819	> who sent me a Lisp program computi	> who sent me a Lisp program computing ...I don't really know Lisp, but how do you get a Lisp to run that expression? I tried it in Emacs Lisp, Racket, Common Lisp.It runs just fine in Python, and returns: 29760	thundergolfer	15.123775	-3.9712207	comment	4.0	13.0	1614306277	-10.193418
26375576	This all seems cool until you realis	This all seems cool until you realise that Lisp had full compile time access to the whole language for decades.	dunefox	15.135381	-3.9526694	comment	4.0	23.0	1615122548	-10.435747
26391994	C++ at least had the benefit of indu	C++ at least had the benefit of industry and OOP trend behind it. It was rather fortunate in this case.I've argued elsewhere on HN that Common Lisp died because they were closed and secretive at the exact moment they needed to go the opposite route.https://www.cs.cmu.edu/Groups/AI/html/faqs/lang/lisp/part4/f...Around 2004, Lisp was having a bit of a revival of sorts. Lisp was becoming trendy, various blogs and web sites were created. But the only documentation you could find was the HyperSpec. Which, as anyone that had the misfortune of reading, is awful as a reference. It's both too technical for casual software developers and not official enough for language implementers. There were two free, open source Lisps available (CMUCL, CLISP) and both were rather unloved and clunky at best.Even 	deckard1	15.1235	-3.9649181	comment	4.0	12.0	1615239570	-10.384967
35521351	Lispy vs. Pseudo-English Syntax (198	Lispy vs. Pseudo-English Syntax (1984)	djha-skin	15.120164	-3.969282	story	4.0	26.0	1681192534	-10.384301
35550392	I mean, let's be real: if you have S	I mean, let's be real: if you have SBCL and QuickLisp most newer S-expression based languages don't have much to offer.	tmtvl	15.116886	-3.964126	comment	4.0	31.0	1681355069	-10.380214
36564435	I can code code in C, Python, and Ja	I can code code in C, Python, and Java. But I don't have courage to learn Lisp.	lavventura	15.130777	-3.9588146	comment	4.0	13.0	1688323845	-10.434729
36640222	Is there still some kind of revenue 	Is there still some kind of revenue stream from Symbolics Lisp or does the owner just want it to die with him?	User23	15.150222	-3.938058	comment	4.0	27.0	1688777724	-10.435085
36640278	This would be a major development sh	This would be a major development should this come to pass.  Even if Genera doesn’t get released under a OSS-compliant license, this will be beneficial for hobbyists and historians (though I don’t know how restrictive non-commercial licenses are for people in academia), similar to the recent release of the Apple Lisa source code (which has similar stipulations).  I’ve always wanted to use Symbolics Genera, but I was born around the time of the AI winter of the late 1980s.I wonder if there were any efforts in the 1990s or 2000s to create a FOSS clone of Genera in the vein of either the GNU project, the Linux kernel, and 4.4BSD and its descendants.  I heard that Genera is quite complex, but complexity didn’t stop ReactOS and Haiku from chugging along after all these years.	linguae	15.103423	-3.9460125	comment	4.0	57.0	1688778243	-10.303617
36640681	I just don’t know why much of the Li	I just don’t know why much of the Lisp ecosystem is closed/commercial, like if you wanna do Common lisp you have to pay for Lisp Works. Could it be one reason for Lisp’s low popularity? If I want to pick up Python now, there’s amazing free tooling for it. If I want to pick up Common lisp, well …	behnamoh	15.138226	-3.9514046	comment	4.0	31.0	1688782159	-10.434274
36651554	Honest question-- why weren't the to	Honest question-- why weren't the tools glued together or perhaps replaced entirely with the lisp inside Emacs? What was it missing?	jancsika	15.129454	-3.9473345	comment	4.0	19.0	1688877548	-10.379662
36803630	Not only that. Now precisely because	Not only that. Now precisely because multicore is the only path to follow when we reach the end of the Moore’s law, we need more than ever functional programming. Is no coincidence that there are so much new languages that are trying to use those concepts, including a big revival of Lisp.	f1shy	15.118078	-3.9785192	comment	4.0	15.0	1689873489	-10.439686
36870577	I don't believe that I can change yo	I don't believe that I can change your mind on this, so I didn't intend to respond, but as this is the top comment, I do want to provide a rebuttal on why we do think this is actually a programming language, that the code we have written is actually a compiler, and why Marsha is a useful exploration of the programming language design space.First, a programming language is just a syntax to describe functionality that could be turned into an actual program. Lisp[1] was defined in 1958 but didn't have a full compiler until 1962. Was it not a programming language in the intervening 4 years? Marsha does not fall into this, since it can already generate working code, but the bar for what is a programming language, I believe, is lower than most would immediately think.Second, a programming langua	ISV_Damocles	15.133178	-3.9578798	comment	4.0	15.0	1690324249	-10.45254
36874513	"Their point was that the ""superpower"	"Their point was that the ""superpowers"" and mythology of Lisp come from a time (the 80s) in which C was the primary alternative, popular language. Standard ML came later and the further MLs in OCaml and F# came much, much later. Erlang was proprietary. Prolog was around but misunderstood and remains so. Smalltalk was there and super powerful (maybe moreso?), but as far as I understand, kept to certain machines.But now we have Elixir, Erlang, F#, OCaml, Scala, Racket, Chez Scheme, Gerbil Scheme, Chicken Scheme, Ruby, Python, Clojure, Pharo, etc. all competing with the standardized Lisp in Common Lisp.I love Lisp, or rather Scheme and its ilk, but the point is that its mythology comes from the 80s and early 90s in which it did sort of set the standard for modern languages. It's really a fanta"	bmitc	15.136578	-3.95738	comment	4.0	30.0	1690358924	-10.52253
36890858	At no point in time did I claim to k	"At no point in time did I claim to know lisp well. I stated my familiarity at the outset. But what you all did was claim to know a lot about every other interpreted runtime without a grain of salt.>Next you can find out what optimizing compilers do to avoid it, where possible or where wanted.But compilers I am an expert in and what you're implying is impossible - either you have dynamic linkage, which means symbol resolution is deferred until call (and possibly guarded) or you have the equivalent of RTLD_NOW ie early/eager binding. There is no ""optimization"" possible here because the symbol is not Schrodinger's cat - it is either resolved statically or at runtime - prefetching symbols with some lookahead or cabinet is the same thing as resolving at calltime/runtime because you still need a"	mathisfun123	15.108627	-3.9837186	comment	4.0	14.0	1690448631	-10.3861065
36920781	  The -P convention: turning a word 	"  The -P convention: turning a word into a question by appending the syllable ""P""; from the LISP convention of appending the letter ""P"" to denote a predicate (a Boolean-values function). The question should expect a yes/no answer, though it needn't. (See T and NIL.) At dinnertime: ""Foodp?""

I'm old enough to have been active in this era, and to have sent messages on teletypes using the ""P"" suffix.  But for us, it had nothing to do with LISP.  Our machines weren't that cool.In fact, they were so lame that many of the printing terminals lacked a question mark character.  The P was used as a substitute for a ? because it was the closest visual substitution.  And naturally, most of our messages were one or two words for economy.  ""FOODP"" would print correctly on machines that couldn't print ""F"	reaperducer	15.128707	-3.960031	comment	4.0	14.0	1690641728	-10.40531
36930928	"Is the configuration still ""paste th"	"Is the configuration still ""paste this mystery lisp code somewhere in a config / ini file in x,y,z place"" or is it finally plug-and-play like in VSC?"	oslacci	15.135078	-3.9463036	comment	4.0	20.0	1690723439	-10.386948
36992678	Common Lisp: The Good, the Bad, the 	Common Lisp: The Good, the Bad, the Ugly, the Legacy, the Ambivalent	behnamoh	15.151182	-3.9337323	story	4.0	44.0	1691100334	-10.466727
37103070	I prefer Go over Lisp on the cover b	I prefer Go over Lisp on the cover because I prefer the explicit, low magic code of Go with all its boiler plate and using my brain power on business problems not what makes me more productive or feel better / clever while doing my work.Horses for courses - I will never be a language designer / developer with this attitude.	leetrout	15.142657	-3.9499934	comment	4.0	37.0	1691866146	-10.470649
37261058	"the project's stated goal is:""I hope"	"the project's stated goal is:""I hope that Lisp will become more popular. I hope many people enjoy it. EISL aims to be user-friendly.""other lisps work towards a similar goal. racket, for example, has:- a large standard library- extensive documentation- a full-fledged IDE built in the language including a visual step debugger- a package manager supplying a large ecosystem of community libraries- numerous introductory programming books written about the language, and the language includes a compatibility mode for SICPin what ways is Easy-ISLisp an improvement in terms of user-friendliness?"	BaculumMeumEst	15.115862	-3.9582798	comment	4.0	15.0	1692967331	-10.437069
24549098	The Nature of Lisp	The Nature of Lisp	dunefox	15.148707	-3.937401	story	4.0	20.0	1600726999	-10.476215
24580453	Compiling a Lisp: Reader	Compiling a Lisp: Reader	azhenley	15.13409	-3.9492872	story	4.0	115.0	1600965344	-10.360505
24716449	Common Lisp could evolve into totall	"Common Lisp could evolve into totally parenthesis-free language. By expanding the ""powerfull and versatile"" Loop-macro into full powerfullness and versatileness. Unfortunately two parenthessis needed, but you can redefine the language having those by default around every file."	timonoko	15.103583	-3.9908557	comment	4.0	35.0	1602138650	-10.386048
24760413	I hate to be a downer, but I just do	"I hate to be a downer, but I just don't trust automatic code generation. 
Proof automation is nice because proofs are ultimately irrelevant. It doesn't matter what the proof is, only that there is one. With code, it's another matter. If I have to depend on heuristics for it to choose the right option that means that I'll actually have to read and verify whether it chose the correct one. At that point, I feel like I'm not really winning anything over just writing it myself.It's possible to write a complex specification to ensure the generated code would be correct, but current automation already struggles with generating proofs for hand written code, let alone generating code and verifying it.Also, it isn't clear to me whether tactics programs are supposed to be kept as code or just used by"	ImprobableTruth	15.036798	-4.029206	comment	4.0	20.0	1602543135	-10.156408
24775364	Why would you add macros to the most	Why would you add macros to the most succinct widely used programming language that is loved for its readability?Macros are generally useful because they A) make something more succinct, B) improve performance by doing something at compile time instead of runtime, or C) enable metaprogramming. The downside is that they risk the creation of unreadable or overly magic code.Python already is succinct and already has metaprogramming (although not to the extent of Lisp, as pointed out by the rationale). And we all know Python is slow, but the downsides of making it less readable through macros outweigh the upsides IMHO. Python is loved for being readable. Instead let's improve on its general performance.	WoodenChair	15.092973	-4.001371	comment	4.0	17.0	1602674706	-10.347049
24815323	Has anyone ever bootstrapped first t	Has anyone ever bootstrapped first to a Forth and then to a Lisp?	wwweston	15.148202	-3.9318283	comment	4.0	16.0	1602991794	-10.45571
24853643	Viewpoints Research Institute claims	"Viewpoints Research Institute claims that they did all of personal computing (including antialiased graphics needed to do SVGs, TCP/IP and an office application which could run both word processing workloads and PowerPoint) in under 20,000 lines of code. (Usually TCP/IP itself is 10k LOC so this is pretty impressive.)The basic idea that Alan Kay has presented in his many similar YouTube presentations (most of which run with that office application) is what we call today domain-specific languages, you write the rules for antialiasing a pixel in whatever the ideal language would be for those rules: you just imagine that you have a dream language and ""wishful think"" the solution: then you go and you reimplement that DSL in another language that you are wishfully conjuring, a language-language"	crdrost	15.136023	-3.94755	comment	4.0	13.0	1603324912	-10.327647
24894104	The Nature of Lisp (2006)	The Nature of Lisp (2006)	tosh	15.151141	-3.9341621	story	4.0	67.0	1603702881	-10.45211
24894076	The argument isn't whether less, rea	The argument isn't whether less, readable, higher-abstraction code is better than its opposite, it is. It's whether or not a real-world LISP code-base espouses these qualities.Which I don't believe it does, IMO the primary reason LISP isn't mainstream is because it results in less readable code for humans (i.e. the primary objective of programming languages), it's semantically the perfect minimalist language for a machine but I don't believe it's optimal readability for humans. Other disadvantages include lack of typing & poor tooling support. There's certainly domains it excels at due to its intrinsic qualities but I don't see it ever becoming a popular mainstream general purpose programming language.	mythz	15.13343	-3.96162	comment	4.0	16.0	1603702665	-10.430339
24894346	I think that should be the marketing	"I think that should be the marketing of Lisp: A necessary evil ;)But seriously speaking, for me Lisp would be much more appealing if it had been introduced to me as a specialized niche language, though for an important niche nonetheless, instead of as the be-all-and-all language for your superpowered startup [1].(For those that don't already have a goto list of counterarguments to ""Lisp all the things"": My main contra-point to Lisp is that with all the meta programming powers you get, you write yourself into your own little corner where no-one but you and your friends live. You want advanced syntax highlighting, linting, automatic refactoring for your special features? Write it yourself! You want outsiders to participate (think: new employees)? Write all documentation yourself, too!)[1] ht"	Perseids	15.132478	-3.959539	comment	4.0	16.0	1603705412	-10.476552
24894354	Everything is so extremely context s	Everything is so extremely context sensitive and has much more focus on text over symbols than other languages, which isn't a problem for computers but is a huge problem for humans. Therefore lisp is objectively harder to read for humans. If you have never read other code and is super familiar with lisp it is easier to read, but anyone with experience with both will find other languages much much much easier to read thanks to the much better UX design.I don't see how you can argue otherwise. It is as if you have no clue at all about how UX works. You can't get used to everything, there is a hierarchy of syntaxes, and lisp syntax is just plain bad for humans.	username90	15.121832	-3.9693375	comment	4.0	13.0	1603705455	-10.412838
24931577	Compiling a Lisp to x86-64: Labelled	Compiling a Lisp to x86-64: Labelled procedure calls	tekknolagi	15.134755	-3.9486609	story	4.0	93.0	1603985468	-10.388029
24945396	Early LISP implementations used dyna	"Early LISP implementations used dynamic scope. This means that non-local references in a function search for the variable's binding in the call chain: if A calls B then when B uses nonlocal variable x it refers to the x in A, not necessarily the x that belongs in the lexical parent of B as seen in the source code.
(Unlike C, Algol/Pascal/LISP can all define functions inside of other functions. These nested function definitions introduce lexical non-local scopes.)Dynamic scoping is easier to implement than lexical scoping. With lexical scoping, the run-time must incorporate some mechanism to find the stack frame of a lexical parent (as seen in the program's source code) to access a nonlocal variable's value. In dynamic scoping the run-time can just follow the stack frame order (starting at "	todd8	15.088769	-4.003587	comment	4.0	15.0	1604082620	-10.309601
25241868	Common Lisp Revival 2020 Fundraiser	Common Lisp Revival 2020 Fundraiser	thephoeron	15.153176	-3.9335873	story	4.0	2.0	1606609951	-10.445728
25294628	I've read the SBCL manual before, se	"I've read the SBCL manual before, several times.  It's not suitable for learning Lisp; it's written for people who already know Lisp but need an implementation-specific question answered.Let me illustrate:Suppose I want to compile my lisp code into an executable for easy deployment.  My first step is opening the SBCL manual and reading the entire section on the compiler.  There's nothing in there about how to actually invoke the compiler.  Maybe there's a command line option.  Read section 3 and find the ""saving a core image"" section.  It has lots of verbiage about saving state to disk so that you can restart the program in the same state.But I don't want to restart in whatever garbled development state I'm currently in.  I want the program to start in the initial state and progress normal"	na85	15.127436	-3.947872	comment	4.0	16.0	1607028483	-10.411786
25319446	> Then again, in Common Lisp it’s so	> Then again, in Common Lisp it’s somewhat rarer to have C extensions, so I don’t know how ASDF handles that.CFFIhttps://common-lisp.net/project/cffi/	pfdietz	15.10973	-3.9693332	comment	4.0	18.0	1607211090	-10.361374
25320112	The piece has the usual complaining 	"The piece has the usual complaining about CL being a Lisp-2.When I ask to have the advantage of a Lisp-1 explained to me, I get some handwaving about ""elegance"", rather than a specific explanation for why someone would want that.  Personally, I find a Lisp-2 (or a Lisp-N) to be more convenient and more understandable.  And I don't have to have lexical variables named ""lst""."	pfdietz	15.134154	-3.9585724	comment	4.0	18.0	1607218215	-10.467143
25320588	Any good guides on how to get starte	Any good guides on how to get started in Lisps, from a programming languages theory perspective?	MH15	15.144371	-3.9403975	comment	4.0	19.0	1607222949	-10.457312
25330945	Will you say it is ok for a complete	Will you say it is ok for a complete new person to lisp to learn sugar? Example is someone who has never learnt lisp in life?Or will you recommend learning sugar after learning some other lisp?	chriszhang	15.156676	-3.9302166	comment	4.0	17.0	1607337852	-10.458921
25341028	An indentation way to Lisp(based on 	An indentation way to Lisp(based on Cirru)	jiyinyiyong	15.10993	-3.981785	story	4.0	7.0	1607395432	-10.3447
25441886	If you mean Common Lisp, I'd say ins	If you mean Common Lisp, I'd say install SBCL and start playing with with the repl. Choose the editor you know best; even notepad is useful to copy and paste expressions to/from the repl. Any editor that's suited for programming will have a way to send expressions to the repl with a keystroke, which is much more comfortable. So basically, just pick VSCode.With that, you're ready to go. Take just one book and work through it, you don't need the best book, but a book will be better structured and more complete than multiple blog posts from different people. Practical Common Lisp (http://www.gigamonkeys.com/book/) is good and freely available. I used ANSI Common Lisp (http://www.paulgraham.com/acl.html), from Paul Graham (https://news.ycombinator.com/user?id=pg), long time ago and it's also g	harperlee	15.140777	-3.9409208	comment	4.0	16.0	1608122827	-10.38638
25443184	Why is common lisp ugly? Many people	Why is common lisp ugly? Many people here suggested common lisp. I was considering it. I like to learn for fun but I am looking for something practical. I will want to build some useful apps in the end with it.	priyanshuraj	15.153009	-3.934189	comment	4.0	14.0	1608130408	-10.434613
25443221	I forgot to ask in my main question.	I forgot to ask in my main question. I can't edit it anymore.I am seriously thinking of learnijg common lisp. Thank you for all the suggestions.Is it possible to build web apps in common lisp or any lisp? Any frameworks available?Is it possible to build multithreaded apps that use multiple CPU cores for performance? What is used? POSIX threads?	priyanshuraj	15.128382	-3.9547732	comment	4.0	13.0	1608130558	-10.4574
25443350	Can I read SICP while learning Cloju	Can I read SICP while learning Clojure? Is lisp very different?	coold	15.128344	-3.969621	comment	4.0	17.0	1608131017	-10.7832775
38611667	A closing parenthesis was missing in	A closing parenthesis was missing in its Lisp source code. Took 3 hours and 9 engineers to find where	ttoinou	15.110344	-3.9893823	comment	4.0	22.0	1702386745	-10.35282
38690058	If you were teleported back to the e	If you were teleported back to the early 1990s then what, at that time, was the most progressive programming language available?I note that both ML and Erlang were around at the time.  I have no experience with or knowledge of Lisp in production to know if it’s a serious answer or not.  For me, Lisp has always been there as a timeless alternative in the same way that visiting the countryside is always an option in between feverish daily life in whichever city I live in at the moment.	gorgoiler	15.133433	-3.9567623	comment	4.0	14.0	1702943898	-10.459964
38693439	Common Lisp interface to the pigpio 	Common Lisp interface to the pigpio Raspberry Pi hardware library	rcarmo	15.136358	-3.947771	story	4.0	96.0	1702977003	-10.371254
38768407	They were complicated to use but the	They were complicated to use but they were also self-teaching. I learned how to use a Lisp machine by sitting in front of one and trying things. By the end of a week I was fluent. And this was before the Internet; there was no Google. The machine itself contained all the docs and tutorials you needed to learn it. This was a remarkable achievement.Once you learned it you felt like a god because of the abilities the machine gave you. Some degree of learning curve was more than acceptable for that kind of power.	dreamcompiler	15.142878	-3.9401307	comment	4.0	15.0	1703557442	-10.473911
38965337	"Re ""it is a lisp"" and ""everything is"	"Re ""it is a lisp"" and ""everything is an expression"", I would like to add a bit of clarification.Or, given that you use Mathematica regularly while I was just reading surface docs (for purposes of doing some stuff with Wolfram Alpha), rather a question if my perspective is well-founded.Based on my understanding of how expression evaluation works, the slightly more revealing statements would be ""it is a lot of lisp macros"" and ""everything is an s-expression"". Which means, a big mess. Let me expand:As a functional programmer, ""everything is an expression"" sounds comforting, and I would expect there are clear transformation rules on how expressions are evaluated (and, maaybe, type signatures).Instead, what you get is, ""you can throw in some random form of expressions into this function, and it"	funaculi	15.10149	-3.994736	comment	4.0	12.0	1705046314	-10.352952
38982190	Isn't lisp a list language? Isn't ea	Isn't lisp a list language? Isn't easy to index but gives similar functionality	theusus	15.098219	-3.9989972	comment	4.0	15.0	1705166799	-10.4886465
32631479	Most well-written Lisp code has its 	"Most well-written Lisp code has its structure indicated primarily by the indentation.  Some form of offset rule is the most commonly suggested alternative Lisp syntax.  It does make the tree structure more obvious:    define                          (define (pos>? p1 p2)
      pos>? p1 p2                     (or (fx> (pos-row p1) (pos-row p2))
      or                                (and (fx= (pos-row p1) (pos-row p2))   
        fx>                                  (fx> (pos-col p1) (pos-col p2)))))
          pos-row p1
          pos-row p2
        and 
          fx=
            pos-row p1
            pos-row p2
          fx>
            pos-col p1 
            pos-col p2

The left looks a lot like a typical AST for many languages, such as C, shortly after parsing.  As the article points "	retrac	15.097476	-3.9950757	comment	4.0	58.0	1661716437	-10.388238
32724332	A Common Lisp example that leaves ou	A Common Lisp example that leaves out Lispworks and Allegro Common Lisp focusing only on SBCL + emacs, as usual.	pjmlp	15.132247	-3.9436326	comment	4.0	75.0	1662386240	-10.431855
32734615	My Lisp Experiences and the Developm	My Lisp Experiences and the Development of GNU Emacs	ctrlmeta	15.112209	-3.955431	story	4.0	32.0	1662454545	-10.3942995
32745850	Somehow, lisp ends up being really s	Somehow, lisp ends up being really slow. so it's doing something else wrong.	t6jvcereio	15.1416445	-3.943538	comment	4.0	12.0	1662519193	-10.425223
32784340	>Use compiler-friendly languages, by	>Use compiler-friendly languages, by which he is really taking about languages that are good for implementing compilers, like Lisp and MLwhy?	tester756	15.121593	-3.963003	comment	4.0	16.0	1662754539	-10.305286
38273618	There's literally dozens of us!If yo	"There's literally dozens of us!If you're serious about learning a Lisp but motivated more by, as you say, ""having more fun"" rather than, say, landing a six-figure job writing it professionally... then may I recommend Janet[0] for your consideration. Janet is an embeddably-small, yet surprisingly batteries-included Lisp implemented in pure C. In terms of syntax and core library it borrows more directly from Clojure than from Scheme, but all the modern Lisps have their bits of influence. I've found both the language and the tiny little community that exists around it delightful.As an example of the latter, somebody smart wrote a real actual book[1] about Janet recently that was on the HN front page for a day or so when he first released it. It's a gentle introduction not just to Janet but to"	cfiggers	15.13236	-3.9668722	comment	4.0	23.0	1700025933	-10.695088
38319818	> outweigh the niceties that other l	> outweigh the niceties that other lisps provide.But don’t people only use Emacs Lisp to program Emacs?	TerrifiedMouse	15.109135	-3.9600546	comment	4.0	17.0	1700316868	-10.38454
38399881	My company bought me a Xerox 1108 Li	My company bought me a Xerox 1108 Lisp Machine running Interlisp D in 1982. I write a commercial product for that environment that we sold for $5K, and it was a lot of fun. I run the latest Medley releases occasionally just for nostalgia. For present day hacking enjoyment I go with SBCL Common Lisp+Emacs, or Racket, or Python when I need the ecosystem.Xerox really did a great job creating their Lisp Machines, a joy to develop on.	mark_l_watson	15.132117	-3.936463	comment	4.0	38.0	1700790127	-10.383872
38512508	How do you look at the latter and kn	How do you look at the latter and know the code structure? Are you counting parentheses? Or are you relying on conventions around white space indentation. If the latter, are you not concerned a misplaced parentheses might make the code different from it appears? There could be bugs not shown in the indentation.Most lispers I know code in eMacs or other smart editors that provide auto code formatting and colored parens. But why not just make the indentation (or whatever that you really rely upon) the actual syntax, so there CANNOT be hidden bugs of that sort?Edit: to expand on this, I think it is no coincidence that most lisps remain untyped to this day. Strong typing is about having the compiler enforce type rules so you the developer can’t fuck it up. Weak typing is more convenient, but u	adastra22	15.113741	-3.9815483	comment	4.0	14.0	1701651606	-10.375259
14878893	Common Lisp Runtime Redefinition (20	Common Lisp Runtime Redefinition (2002)	brudgers	15.135019	-3.9483917	story	4.0	71.0	1501290307	-10.399823
14914391	It's just training. Buy and use a RP	It's just training. Buy and use a RPN calculator and lisp suddenly seems normal.(To answer your question directly, yes it's readable. You learn to look past the syntax in lisp the same as you stop reading semi-colons and curly braces in other languages)	evilduck	15.132808	-3.9575963	comment	4.0	15.0	1501706455	-10.43414
14925740	I am very interested in the s-expres	I am very interested in the s-expression stylesheet format. I think it would be preferable for me at least to CSS, especially the code for alternating rows; I imagine that people write programs in this language might have well done away with the need for CSS preprocessors that we have today. This also makes me ask a question - why are there no Lisp-like CSS preprocessors?I am reminded of the proposal to markup webpages with s-expressions rather than XML, though there are packages available (actually just macros) in CL that let you write websites this awy.	ue_	15.064165	-4.0230336	comment	4.0	14.0	1501811437	-10.397358
14997976	> It's unfortunate that ML and Lisp 	"> It's unfortunate that ML and Lisp didn't gain greater traction but that's likely due to Unix.Lisp and ML are competing by nature(MLs are famous from their typesystems) and their ""failure"" is not because of unix, but because of their inability to deliver 'fast' & readable apps. Also, the learning curve..."	sds2	15.141158	-3.9461236	comment	4.0	18.0	1502547726	-10.391311
15033702	yeah, lisp is cool, but I'd need a c	"yeah, lisp is cool, but I'd need a computer to run it on... I'm seriously considering one of those 8070 Series I Business System..... it has dual floppies, 591K bytes of storage a 19"" color display, a 60 cps impact matrix computer, and!! they say at twice the price it would be a bargin, so at $7000 it seems the way to go"	keithnz	15.12709	-3.9412704	comment	4.0	13.0	1502942158	5.9949017
15034744	After grokking the tokenisation, par	After grokking the tokenisation, parsing and eval of lisp like languages, what's the next step up?I usually have a bit of fun mocking out a language I'd like but end up getting into details like type systems. I never really get to expressing as a CFG.I'm wondering if the best course is to say right, keys now build a small, procedural language or some kind of barely typed C lookalike as the best step up?	jwdunne	15.1367445	-3.951986	comment	4.0	16.0	1502958079	-10.471152
15057755	The attitude in this screenshot may 	The attitude in this screenshot may explain why Lisp environments don't take off:https://common-lisp.net/project/mcclim/static/media/screensh...	pavlov	15.145017	-3.939102	comment	4.0	37.0	1503223389	-10.452593
15147665	Searching a Million Lines of Lisp	Searching a Million Lines of Lisp	pmoriarty	15.1495695	-3.936394	story	4.0	73.0	1504267730	-10.420655
15228986	Writing/understanding a lisp interpr	Writing/understanding a lisp interpreter is a longstanding item on my TODO list.Question:  how do I go from tackling this to tackling compilers?	omginternets	15.127313	-3.9677272	comment	4.0	13.0	1505235354	-10.400331
15230418	"There is a similar project called ""B"	"There is a similar project called ""Build Your Own Lisp""[0] (BYOL), which is a book that walks one through making a Lisp in C. Has anybody here done BYOL? How does it compare to MAL? If you had to choose one to learn how to create a Lisp, which would you choose?[0]: http://www.buildyourownlisp.com/"	sassy_samurai	15.140598	-3.9480011	comment	4.0	13.0	1505242411	-10.4025135
15275026	Going Faster with Lisp	Going Faster with Lisp	foob	15.146999	-3.9385865	story	4.0	124.0	1505735408	-10.419618
15279115	How easy is to embed this? If I wann	"How easy is to embed this? If I wanna make a language and use a lisp as the ""backend"" this one is good for this?"	mamcx	15.137916	-3.941428	comment	4.0	40.0	1505765592	-10.430984
15279323	Am I the only person that noticed th	Am I the only person that noticed the hover on the lisp code blocks?  Surprised me at first.  Can't tell if I like the idea or not.Rather, I know I like the idea.  I can't decide if I like the execution.  I'm leaning towards liking it.	taeric	15.145894	-3.9409215	comment	4.0	12.0	1505767134	-10.438848
15471702	A few things I know about Lisp Machi	A few things I know about Lisp Machines	gkya	15.147207	-3.9369202	story	4.0	85.0	1507980259	-10.430327
15525696	You just have to indent them the sam	You just have to indent them the same way you'd indent curly braces.The harder part about lisp is actually recursion. Surprisingly, there aren't a lot of programmers who can follow recursion naturally.(loop exists in lisp but recursion seems to be the common idiom)	didip	15.108534	-3.985491	comment	4.0	12.0	1508659345	-10.362115
15593781	>I mean, why was I unhappy as a prog	">I mean, why was I unhappy as a programmer after 18 years and said, ""if I can't switch to something like Common Lisp, I'm going to switch careers"". Why am I saying that? I'm saying it because I'm frustrated with a bunch of limitations in what I was using.>So, when I discovered Common Lisp, having used C++, I said that, ""I'm pretty sure to the answer to this question is, 'yeah, absolutely'"". And can we do that with a lower cognitive load? I also think, ""yes, absolutely"". And then the question is, ""can I make a Lisp I can use instead of Java or C#?"". Cuz you just heard my story, and I used Common Lisp a (?) couple of times, every time it got kicked out of production, or just ruled out of production, really not kicked out, it didn't get a chance. So I knew I had to target a runtime that peopl"	flavio81	15.106094	-3.986867	comment	4.0	23.0	1509462670	-10.470182
17440171	> Languages don't create unmaintaina	> Languages don't create unmaintainable code, people doHave you ever seen so-called academic code? If your developers are PhDs without a programming background, you're bound to get programs that reflect the complexity of their own throught process plus the subject they are dealing with. I don't think encouraging that through something as unbound as Lisp is a good idea, as much as I love how unbound Lisp is.Python probably hits a sweet spot in this regard.	vanderZwan	15.13072	-3.9621656	comment	4.0	18.0	1530521068	-10.428299
17442108	It tells me that the vast majority o	"It tells me that the vast majority of software developers do not want to read or maintain code in raw s-expression format, for the same reason that the vast majority of software developers do not want to read or maintain code in machine code.  S-expressions and machine code run, but when the argument is ""you won't see the parentheses after a while"" then clearly the parentheses shouldn't be there in the first place.  For example, normal people find ""a + b"" easier to read than ""(+ a b)"", because they receive 12-18 years of training in infix notation AND practically all materials with math (books, papers, etc.) use infix.  Lisp's current s-expression syntax is simply unacceptable to most software developers.Of course, s-expressions have a big advantage: homoiconicity.  Homoiconicity enables t"	dwheeler	15.091673	-4.0096135	comment	4.0	13.0	1530543153	-10.330965
17553911	This is the problem I have with Lisp	"This is the problem I have with Lisp, but exponentially worse. Languages like this try and stretch ever-closer to an imaginary ""perfectly pure language"". It's an interesting exercise, but in the process they get further and further away from concepts that are palatable to the human mind, and end up esoteric and minimalist beyond usefulness. We sometimes forget that programming languages are not designed for computers, but for humans who want to express ideas to computers."	_bxg1	15.137286	-3.952269	comment	4.0	40.0	1531865365	-10.454228
17633751	When I think about LISP and parens i	When I think about LISP and parens it just feels redundant if you’re gonna use indentation anyway.Parens are only useful if everything is on a single line. With new lines and indentation, things can become a lot cleaner like python style.I strongly believe python got so popular because of its very simple to read, almost pseudo-code like syntax that anyone could learn.List had great ideas, everything is a list, but dealing with parens hell makes me think it could be a lot more elegant.	nojvek	15.108701	-3.9891396	comment	4.0	21.0	1532794602	-10.2985735
17633929	Thanks for these comments. I didn't 	Thanks for these comments. I didn't realise alternative notations were planned and never took off. (Dylan in particular looks really interesting.)I can see the value of homoiconicity / code as data from the perspective of someone writing a parser.I've asked what writing code as s-expressions gets you as the end-user of a language before. People usually say, “macros” or “it's easier to manipulate code”. But macros exist in non-homoiconic languages, like Nim and Elixir. And in my short time using ClojureScript I'm not sure what manipulations Lisp syntax gave me that I don't already have with other languages in a modern text editor.I'd love to see examples of accomplished Lisp users on YouTube or elsewhere, to see what those code manipulations look like.	modernerd	15.093738	-4.0073004	comment	4.0	13.0	1532797010	-10.419049
17634380	If Lisp uses indentation and not par	If Lisp uses indentation and not parenthesis, then why is my mental caricature of Lisp just ((())))(()))((())))()()()(())))((())))?	egypturnash	15.105017	-3.994996	comment	4.0	12.0	1532803149	-10.346233
17762798	Stallman hates Common Lisp.https://w	Stallman hates Common Lisp.https://www.gnu.org/gnu/rms-lisp.en.html	melling	15.1441	-3.9415295	comment	4.0	19.0	1534289756	-10.428518
17797377	The key problem with this article is	"The key problem with this article is, that Norvig cherry-picked features of Lisp that are present with the languages that he contrasts it with. So, what happens then is that it will give the impression that Lisp somehow lost its uniqueness, or whatever makes it stand out among the others. The premises were at best, loaded.If we’re going to talk about CL, here are some of the features that still make it unique:  - live update of a running program, including (re)definitions of classes, condition handlers, etc.
  - object system which has multimethods, multiclasses, multidispatch.
  - it has a debugger and stepper which has complete access to the stack, with unwind protection
  - it has a very strong, unhygienic macro system.

The average programmer does not need a lot of these things because"	ebzzry	15.131002	-3.9622273	comment	4.0	20.0	1534732465	-10.43486
17798255	As I see it, Lisp is a language in (	As I see it, Lisp is a language in (pretty much) pure prefix notation and of which the core data structure is a linked list and in which functions are first-class values. The advantages of the prefix notational purity are manifold, but schools train people in the use of infix/Eulerian notation:f(a+b,g(x,y)) versus (f (+ a b) (g x y))The problem of notational convention has not been solved since 1958. Other languages painstakingly support infix/Euler, requiring comparatively incredible compiler construction effort. Doing so also removes the manifold advantages of Lisp's notational purity.JSON is much more popular than S-expressions. Therefore, we can assume that nested arraylist/hashtables are more popular than linked lists as the core language data structure.Pretty much every serious langu	neokantian	15.112574	-3.9864125	comment	4.0	20.0	1534749981	-10.408354
17801970	I've always been intellectually fasc	"I've always been intellectually fascinated by Lisp, but would NOT want to use it in a production (team) environment. It has two problems:First, is that it's too ""meta"" in that one can shape it to be just about anything they want. This can make it difficult for others to read your code, for they have to know your mind's style. Our typical ""office"" languages tend to hard-wire idioms, such as control structures (if, while, case, try, etc.) which make it easier for other readers to digest. It may be less parsimonious (more code), but it's overall easier for an outsider to come in and read it.Second is that nested lists are the wrong base structure for humans. Our natural languages are closer to maps or ordered maps (AKA ""associative arrays""), not nested lists. I was working with others at the "	tabtab	15.115451	-3.9884646	comment	4.0	19.0	1534786663	-10.473689
21058846	Talk of metaprogramming intrigues me	Talk of metaprogramming intrigues me. I'd like to hear what a Lisp user makes of it because I find non-Lisp users are usually amazed by any metaprogramming at all and can't be as critical about it.	marble-drink	15.130716	-3.9491465	comment	4.0	27.0	1569325132	-10.383161
21147584	Writing a compiler is still almost a	Writing a compiler is still almost always overkill, because implementing the compiler is one of the smallest parts of creating an effective programming language.Let's say you're starting a project, and you're choosing a language to write it in. You have two options:Language A:1. Has multiple mature compiler/interpreter implementations.2. Has lots of tooling built around it.3. Has extensive documentation.4. Has a diverse community to hire programmers from.5. Fits the problem domain okay.Language B:1. Has one buggy implementation that returns mangled stack traces on errors. See Kernighan's Lever[1].2. Has no tooling.3. The documentation is the compiler. So... no documentation.4. The only programmer that knows it is the one who wrote the compiler.5. Fits the problem domain as well as the prog	kerkeslager	15.084068	-4.000185	comment	4.0	26.0	1570113939	-10.438805
21354626	Sometimes I wonder if the people of 	Sometimes I wonder if the people of the 1960s (i.e the people who came up with lisp, multics, unix) had the right idea: to use a computer you should program it.There are many programs, each does a different thing, you program your final product by composing programs. Users of the final product are the programmers.I found myself being frustrated recently at Lifx smart lights. I had wanted to put a slider widget on my home screen of my phone. There is no way to do that. The only way is for me to write my own program. I started work on it, then had to wade through ridiculous amounts of documentation on the lifx api site, android docs. I still haven't finished it.Consider on the other hand, if android were a massive lisp environment where every API is available in the global scope - think emac	chewxy	15.121594	-3.9566915	comment	4.0	15.0	1572009651	-10.376563
21560061	I do have some testing that showed m	I do have some testing that showed me the Common Lisp was roughly the same speed as the C, when testing against a file of a few dozen megabytes.  As I explain, I wasn't interested in optimizing it further, as I feel showing this achieved in just a few minutes to be valuable on its own.  I also note that a C programmer may boast about being a small fraction of a second faster, ignoring everything else that goes into the program, which I find foolish.The reason I didn't strictly adhere to the POSIX behavior was because I don't know where this is documented and don't feel like scanning through the C to find out.  On all of the files I've tested, which include a wide array of punctuation and other such things, the results were identical, but I'm merely not making any promises.  I'd prefer to n	verisimilitudes	15.104603	-3.976636	comment	4.0	16.0	1574024982	-10.395257
21643626	I think the appeal of the syntax for	I think the appeal of the syntax for those who get used to it is the regularity, like you said.The advantage of the regularity isn't its human readability, but its ability to macro, no?What I'd like to see is better tools for reading and editing such a regular syntax. Probably I should just learn emacs, but I'm thinking someone could make a more intuitive structured editor for LISP syntax. No need to mush around blobs of text when everything is nested lists.	manifestsilence	15.115264	-3.9812486	comment	4.0	16.0	1574809230	-10.405188
21644574	The issue is that code is read more 	The issue is that code is read more often than it is interpreted, written, or compiled.All the beautiful aspects of lisp make it decidedly unwieldy in production software. There’s a tendency of projects written in lisps to be unwritten in lisps as they mature.	unlinked_dll	15.136121	-3.9560778	comment	4.0	12.0	1574818863	-10.459304
21644697	I have designed a programming langua	"I have designed a programming language that borrows an important part of its architecture from Lisp(s) (maybe mostly Scheme, but also Kernel: http://klisp.org). However, I have always opposed to the concrete syntax of S-expressions (being mostly unable to be productive with it).My arguments are not on the familiarity side (with the infix notation), but on the psychological one:1. S-expressions are not the most simple, natural, or uniform surface form (as they claim); they do have syntactic sugar (quote, even lists themselves!, etc.), so why not to add some more sugar (but sufficiently abstract of course)?2. Humans' brain has limited ""stack"" space (especially when closing parentheses); infix forms may ""cascade"" and do not consume the stack (equally machine on human, due to possibility of ""t"	rusini	15.097905	-3.99965	comment	4.0	15.0	1574820414	-10.370754
21671994	I've always wished Emacs would have 	I've always wished Emacs would have been written in Common Lisp.  It would already support this, and it's all around just a better language (IMO).There's Climacs, but it's so far behind...	jlarocco	15.111066	-3.9644098	comment	4.0	41.0	1575145942	-10.378506
21729447	Lisp in Vim with Slimv or Vlime	Lisp in Vim with Slimv or Vlime	susam	15.089809	-3.96468	story	4.0	8.0	1575713346	-10.389031
21736828	What would be a good resource to lea	What would be a good resource to learn Lisp in terms of problem solving or doing projects? I feel I only learn something when I use it to solve a problem in the real world.	nafizh	15.148093	-3.9357097	comment	4.0	12.0	1575824479	-10.478012
39097681	Self-contained Linux applications wi	Self-contained Linux applications with lone Lisp	goranmoomin	15.129404	-3.947263	story	4.0	114.0	1705970047	-10.378256
39142380	I’d argue modern languages have take	I’d argue modern languages have taken many of the attributes of LISP, not least the garbage collector, development tools, higher-order functions, etc.  The difference is that other languages use parsing technology based on Chomsky’s grammar whereas blub languages like Lisp can’t see the value in it.  But I’d say if you are programming in Java or Python you are most of the way to LISP from Pascal or C.For that matter,  Common Lisp had what was probably the first modern language specification,  that,  as much as it pretended to be machine independent,  was carefully designed to be implementable on the 32-bit microprocessors that were then coming online.  There was a time when I thought Java was the first programming language to be specified by adults but know I know they were following in th	PaulHoule	15.136637	-3.95516	comment	4.0	22.0	1706275802	-10.435553
39256864	This is one of the hills to climb wh	"This is one of the hills to climb when learning a lisp. Seasoned lispers don't edit text, or traverse text; they edit and traverse lisp forms (AST nodes). In my experience, vim/neovim work very well for this, due to their notion of ""text objects"". With a couple of plugins, text objects end up aligned directly with the lisp AST, but even better is that the AST is visual and tangible, since it's encoded in the text.It makes sense to benefit from this sort of thinking in other languages, but this is just another reminder, to me, of the beauty of lisps.A fun language idea would be to take the exact semantics of an existing language, like C++, and encode them within a lisp, losslessly. I suspect it would end up quite verbose. However, add in a macro system and then you can start building a DSL "	Jeaye	15.097559	-3.97752	comment	4.0	16.0	1707102711	7.540985
39298252	> I've enjoyed reading about FORTH a	"> I've enjoyed reading about FORTH and LISP over the years and I think LISP advocates have a similar philosophy.Want to make a hacker laugh? Say ""Forth is the dual of Lisp"" to someone familiar with both languages. It seems they reach the same goal of a totally programmable programming language through completely opposite approaches."	bitwize	15.138035	-3.941688	comment	4.0	17.0	1707367346	5.9443717
39344263	We actually need to talk about lists	"We actually need to talk about lists. The single reason why Lisp uses parentheses is the list notation -> programs are actually lists, not just text.The same code which runs    CL-USER 10 > (let* ((foo 10)
                       (bar (+ foo 32)))
                  (* foo bar))
    420

becomes data, when quoted:    CL-USER 11 > (quote
                  (let* ((foo 10)
                         (bar (+ foo 32)))
                    (* foo bar)))
    (LET* ((FOO 10) (BAR (+ FOO 32))) (* FOO BAR))

A typical Lisp function can then substitute all * symbols to + symbols:    CL-USER 12 > (subst '+ '* '(LET* ((FOO 10) (BAR (+ FOO 32))) (* FOO BAR)))
    (LET* ((FOO 10) (BAR (+ FOO 32))) (+ FOO BAR))

EVAL can execute lists:    CL-USER 13 > (eval (subst '+ '* '(LET* ((FOO 10) (BAR (+ FOO 32))) (* F"	lispm	15.082954	-4.021417	comment	4.0	15.0	1707742640	-10.389041
39345999	Programming languages are user inter	Programming languages are user interfaces. The syntax of a programming language is part of that user interface. Some choices are poor by virtually any measure (stropped keywords come to mind; as visually hideous as they are unpleasant to type), but most choices represent tradeoffs that favor certain usage patterns over others.Lisp de-prioritizes legibility at a glance and concision in order to give maximum priority to simplicity in metaprogramming. I'm not convinced this is a good tradeoff; I would no sooner choose to drive to work in an amphibious tank that got 0.2 miles per gallon to be able to cut across a single river along the way.Lispers say that I could use specialized tooling to compensate for poor ergonomics, but in many contexts- someone else's computer, a text box or static text	RodgerTheGreat	15.140244	-3.9531233	comment	4.0	22.0	1707752151	-10.418189
39347388	Parens are powerful in lisp(s) becau	"Parens are powerful in lisp(s) because it means the syntax is its own AST and can be manipulated by itself (macros). It's one of those exploding head moments that you (including me) can get totally ensorceled by. But--as with all language features--I think pragmatism demands that we ask ""what incredible software has this produced"", and I can't think of any standouts."	camgunz	15.119287	-3.9776535	comment	4.0	18.0	1707757755	-10.324706
32824468	Ask HN: Lisp Macros for Self-Improvi	Ask HN: Lisp Macros for Self-Improving AI?	behnamoh	15.108029	-3.982211	story	4.0	17.0	1663078049	-10.233236
32840420	After years of reading Lisp articles	After years of reading Lisp articles, my take is that the macro system is what sets Lisp languages apart. I was surprised then that the author didn't find them that useful.[Paul Graham] describes Lisp as his “secret weapon”. OK, so what’s the secret? He says “program­ming languages vary in power”. Fine, but what exactly makes Lisp more powerful? ...Lisp’s macro facility, which he describes as its ability to make “programs that write programs”. After four years using a Lisp language, I’d agree with Graham that macros are great when you need them. But for someone new to Lisp languages, they’re not neces­sarily a bread-and-butter benefit.Further down...Paul Graham calls Lisp a “secret weapon”. I would clarify: Lisp itself isn’t the secret weapon. Rather, you are—because a Lisp language offers	michaelwww	15.123469	-3.9711099	comment	4.0	19.0	1663176582	-10.406992
32881788	As author of the Binary Lambda Calcu	"As author of the Binary Lambda Calculus (BLC), I find this quite fascinating.
It implements LISP in 163,654 bits of BLC.
For comparison, minimal esoteric languages like BLC itself can be implemented in 232 bits of BLC, and Brainfuck in 893 bits.I'm still reading the document, but one thing that caught my eye is the List encoding with cons and nil, which is claimed to be a Mogensen-Scott one.Rather, cons \x\y\c. c x y is the Scott encoding of infinite lists that have no nil terminator (also known as streams) and thus only one constructor, while nil is the Scott encoding in nil-terminated lists with 2 constructors.Thus the given encoding is some non-standard hybrid of streams and lists that helps BLC achieve its conciseness. In Wikipedia [1] it's described as> Alternatively, with NIL := FALS"	tromp	15.1085005	-3.9925666	comment	4.0	15.0	1663450292	-10.499714
32882462	Let's not sell Lisp short here.  LC 	Let's not sell Lisp short here.  LC might be mathematically foundational, but I think it's fair to say that Lisp is computationally foundational.  Mathematics and computation are related, of course, but they are not identical.  Computation is the study of mechanical processes for doing math.  As such, Lisp's identification of CONS/CAR/CDR/COND as a sufficient set of primitives for a universal Turing machine is important because it's obvious (or at least it was obvious by 1958) how those primitives can be implemented as a mechanical process.  Implementing LAMBDA in all its generality is far less obvious, which is why it took 20 years of further research to go from Lisp 1 to Scheme.	lisper	15.123077	-3.9736428	comment	4.0	63.0	1663455591	-10.397888
32883213	LC is only computationally foundatio	"LC is only computationally foundational; it describes recursive functions. It's just another universal turing machine.LC has a great disadvantage: it's difficult to write a LC interpreter in LC.  This project shows exactly what that means. To write an LC interpreter, you need a data structure for representing expressions. You need a symbolic data type.LC does not know what a LC expression is. Papers about LC know what that is, but they are not executable.In Lisp we can say, okay, lambda calculus can be represented sort of like this:  (lambda (x) x)

and so on. That's a nested list. It contains symbols.   We can use an assoc list to associate symbols with the terms that are their values. And so on ...Lisp has the programmatic vocabulary to talk about lambda calculus formally, in a way that "	kazinator	15.108042	-3.99311	comment	4.0	37.0	1663462022	-10.337552
33061224	Ok, you can use libraries, of course	"Ok, you can use libraries, of course - so shouldn't say that there is no reuse. But libraries are not the same as built-in syntax. Built-in syntax for the basic things, as in the Algol-family is a) standard so everybody uses it. b) optimized for the right mix of efficiency as well as redundancy (error detection, skimmability by humans). Talk about ""oatmeal with fingerclippings mixed in"" - more parens don't add useful redundancy, but keywords and delimiter tokens do.Too much power for its own good is one thing, but being just not optimized for the common thing is another. How would the following function, randomly picked from what I have open on github right now, look in ""Common"" Lisp? And if I ask 3 persons to do it, what is the likelyhood that they would pick more-or-less the same approac"	jstimpfle	15.114054	-3.9528854	comment	4.0	15.0	1664751161	-10.455102
31785113	A lexically scoped, dynamically type	A lexically scoped, dynamically typed, s-expression language, with no macros.Why?	samatman	15.090445	-4.0073576	comment	4.0	12.0	1655504160	-10.31702
31816455	Sunstone – the last unreleased Lisp 	Sunstone – the last unreleased Lisp machine architecture from Symbolics [pdf]	mepian	15.124725	-3.9504187	story	4.0	76.0	1655761503	-10.327286
31866041	The Key of Lisp (1987)	The Key of Lisp (1987)	mr_tyzic	15.154087	-3.9311519	story	4.0	80.0	1656091253	-10.468011
39376571	I disagree. I have no problem with l	I disagree. I have no problem with lists obsession in other languages like OCaml.The parentheses are just too much. I get how elegant and unambiguous they are for computers but I am not a computer. It's like RPN. It's elegant and easy for code to parse and unambiguous and all these nice things.... except it isn't easy for me to parse.Compilers are perfectly capable of compiling readable code like Rust so I don't see why I should have to do the tedious work of figuring out all the parentheses manually.Lisp is like a really great IR. But I don't want to program in an IR.	IshKebab	15.105438	-3.992771	comment	4.0	39.0	1707950416	-10.381773
39377161	You want to learn programming. Lets 	"You want to learn programming. Lets get started - how long does that take to bang out 10 exercises? Order the estimated results from quickest to slowest. Here's my estimates (don't like them, show yours! It'll be interesting):  - Scratch
  - python/perl/ruby/javascript
  - C/Java
  - Swift/Rust
  - Anything else running on the jvm
  - 
  - a whole lot of daylight
  -
  - common lisp.

And many if not most will fail to get to the first exercise, those that do will start it well after all the rest have completed 10.Land of lisp seemed to be the best learn lisp book and it couldn't even manage to limit itself to one implementation of common lisp that you could use for the entire book.The situation is ridiculous."	harry8	15.14248	-3.945096	comment	4.0	21.0	1707954086	-10.449613
39377649	I didn't see mentioned in the thread	I didn't see mentioned in the thread (maybe missed it) the #1 reason, IMO, that Lisp can't be popular in companies.Everyone should take the time to learn Lisp and do a handful of personal projects with it. It'll help your growth as a software engineer. Just do it!But that doesn't make it a great corporate language. Lips is infinitely flexible, you can mutate it to be what you want. That's cool and feels awesome.Also: a maintenance nightmare as soon as you have more than ~1 person working on the codebase!Everyone surely has heard the joke/truism how C++ can be great as long as you only use a sane subset. But every team uses a different subset. Now imagine something like Lisp where every developer & team morphs it in a different way and you have a product with hundreds of developers on it. T	jjav	15.136107	-3.9558249	comment	4.0	41.0	1707957593	-10.461289
39379693	I'm tackling a significant lisp proj	I'm tackling a significant lisp project right now, and the thing that holds me up right now is that the code is difficult to organize. Python, java, rust, go etc have well-defined patterns to figure out where code lives and where you might expect certain behaviors to occur. With lisp you can really shoot yourself in the foot very easily by using abstractions that are difficult to follow and are spread out across many files.	breather	15.1282835	-3.9627788	comment	4.0	14.0	1707978041	-10.434178
39619009	Ask HN: A Lisp with Cargo/NPM like b	Ask HN: A Lisp with Cargo/NPM like build system?	nate-sys	15.110736	-3.974953	story	4.0	3.0	1709748858	-10.367857
39667323	Lisp is not the language for that un	Lisp is not the language for that unfortunately, it is very much an imperative language with better syntax and _some_ macros.Scheme is close but quotation isn't thought about nearly enough. It is generally a CS problem as logic systems with quotation are very much an open problem. I think that types have gotten too much attention and quotation way too little.Macros are basically a way to deal with the fact that neither lisp nor scheme have first class quotation which you can evaluate at leisure. I understand why they've done it for efficiency reason, but I think we should have at least one language that gets quotation right.https://imps.mcmaster.ca/doc/qe-in-church.pdfThe above paper is the state of the art and the author there is pretty much the only person I know who has been working on 	llm_trw	15.109035	-3.991685	comment	4.0	18.0	1710160122	-10.341967
39671413	"You think lisp is ""weird and siniste"	"You think lisp is ""weird and sinister or ghostly"" and that 'we' are still wrestling with something 66 years later?This sounds more like someone getting caught up in the pageantry of a niche that pragmatic people have left behind a long time ago. Lisp was very influential, but those advancement have made their way into practical languages and lisp has been impractical for many decades at this point."	CyberDildonics	15.150974	-3.9411058	comment	4.0	19.0	1710180155	-10.472921
32030579	Antimony – computer-aided design too	Antimony – computer-aided design tool from the Lisp machine parallel universe	pabs3	15.123766	-3.9441023	story	4.0	31.0	1657331956	4.056809
32043740	>> One thing I do have to mention th	">> One thing I do have to mention though is that the workflow in Lisp allows me to create these support libraries much faster than I can in other languages.I'm at that stage in my lisp journey (~18 months) where i know enough to be dangerous to others around me, i.e. i'm still a lisp n00b but have completed a few lisp & scheme books and written enough projects that i feel fairly productive. BUT i haven't reached, never mind come out the other side of, the ""trough of disillusionment"" yet. So everything lisp is unreasonably tainted with a positive glow in my mind.TL;DR i still think lisp is pretty awesome. It's my newest hammer and everything looks like a lisp-shaped nail these days. So i have to be deliberate and careful not to over-use lisp but it's totally changed how i write js for examp"	CraigJPerry	15.137675	-3.949786	comment	4.0	21.0	1657452661	-10.478878
32102376	"All these ""small lisps / lisp-in-go "	"All these ""small lisps / lisp-in-go / lisp-to-xyz"" are great and I do applaud the exercise and what is produced, and I also appreciate many of of these projects are for learning or fun projects.BUT if by chance you or your project is one of the more ""serious lisps or next-lisp-vibes"" hear his:Before you even think about speed or benchmarks(size,spec,speed,lang) remember we live in a connected world that is multi-core.First prize for your home-brew lisp that would make me sit up and take notice is if it has very easy net-libraries built-in (http (client + server), websocket, sse, json etc) I think that is one of the things Go(yes I know not every like it, but the real world usage is real) got right, the std lib was very ""modern"" at least to the point of real-world usability. Multicore is a "	rawoke083600	15.092419	-3.9932897	comment	4.0	17.0	1657839334	-10.43564
32216520	The point is that these computers do	The point is that these computers don't come with development tools installed by default and made available in the default environment. They don't provide any equivalent to the BASIC interpreters of old, or to the REPL of a Lisp Machine workstation.  You can install e.g. Linux distributions that do provide the means to code and rebuild nearly any part of the installed system, but these are very much the exception not the rule.> And Scratch is ubiquitous in (UK) schools, my son picked it up without any prompt from me.Scratch is a huge downgrade from the likes of LOGO (a real LISP implementation, with a few syntactic conveniences to help novices) and even BASIC on the BBC Micro, which used to be taught in UK schools.	zozbot234	15.12822	-3.9548113	comment	4.0	21.0	1658689236	-10.427556
32361051	This exactly matches my thoughts. It	This exactly matches my thoughts. It seems that machine language and LISP are the only two languages (that i know anyway) where code and data are fundamentally the same kind of thing.	aap_	15.09433	-3.9871202	comment	4.0	22.0	1659728817	-10.327041
32364456	266 pages of well-written, edited, f	266 pages of well-written, edited, fact-checked electronics and computer programming. Monthly. Let that sink in.There is so much good info packed into this one issue, it is worth terabytes of crap on stack overflow. Clearly there was less information back then, but it was far higher quality.I'd like to understand how C came to dominate the world when LISP could replace all of the scripting languages we used today. Was it tooling on cheaper machines that made C so popular? Or that it was closer to ASM than LISP? I never really formed a good opinion on this, I'm missing lots of history.	sbf501	15.121727	-3.96293	comment	4.0	24.0	1659755530	-10.349123
32390685	Lisp also really benefits from an ed	Lisp also really benefits from an editor that colourizes ( ) in matching pairs.  Even C benefits from colour-matching {} in my experience.  I'm surprised it's not more common.	retrac	15.11798	-3.979658	comment	4.0	16.0	1659990982	-10.39394
32459246	It is interesting how almost none of	It is interesting how almost none of these paradigms/principles are relevant to what we think of as AI today. Lisp, a language specifically formulated for AI applications, is now mostly relevant in the context of programming language theory (and essentially irrelevant to the statistical programming/linear algebra toolkits that underpin modern AI applications). Instead, Fortran and its descendants are actually what power today’s AI programs. Nobody could have foreseen this in the 50s!	MontyCarloHall	15.127478	-3.948136	comment	4.0	16.0	1660485119	-10.484051
22035317	1. no garbage collector2. No tail re	1. no garbage collector2. No tail recursion3. There is no cons, cdr or car stuff. Lists are just vector objects and you use push, cat, slice etc to manipulate elements.Only this much is radical enough to say that it isn't a Lisp but disguised in Lisp syntax.  Lisp is as much about semantics as the syntax.  The power of Lisp to do amazing things comes from the language capabilities.  If you cannot reasonably translate powerful programs from Lisp textbooks, then is it a Lisp?Some languages (example: JavaScript, Python) make it easy to create an inefficient Lisp interpreter that could execute common textbook programs.  Minimax, A-star search, unification matching, etc.	DannyB2	15.1246805	-3.9684718	comment	4.0	23.0	1578929772	-10.45588
22067685	"As far as ""Lisp lacks visual clues"","	"As far as ""Lisp lacks visual clues"", after many heated debates on this, I've concluded that the ugliness and rigidness of ""production"" languages enforces certain visual and syntactic standards that makes reading others' code easier. Indentation of Lisp won't ""solve"" this because production languages also can be indented. It's not a difference maker.Parameter lists are wrapped in parenthesis and separated with commas, while code blocks are wrapped in curly braces and separated with semi-colons.Lisp won't do this because it's then harder to blur/merge/change the distinction between code and data, which is the very power of Lisp.Building architectural eyesores is probably not a rational plan for a city, but dammit, those eyesores help you know and remember where you are.Some people have a cer"	tabtab	15.124259	-3.9700472	comment	4.0	32.0	1579201220	-10.465116
22087624	"they’re practically two sides of
the"	"they’re practically two sides of
the same coin. I keep thinking it should be possible to build a toy language that has both a forth-like mode and a lisp-like mode, that use the same standard library"	jes5199	15.137426	-3.9511168	comment	4.0	14.0	1579385215	6.0400763
22088209	zerr's post reads like Lisp is some 	zerr's post reads like Lisp is some kind of terminal disease that will cause spacecraft to slowly get cancer or something.  It sounds like completely irrational hostility.But the article reads like blatant fanboy-ism, as if Lisp turned spacecraft into unicorns that magically distributed rainbows around the solar system or something.  It's completely oblivious to the organizational cost (except, oddly, at Google).What's the organizational cost of Lisp at JPL?  Somebody's got to maintain these tools for decades.  Over the lifetime of a spacecraft mission, people leave.  People even die.  If nobody understands the software (or the tools the software depends on, including the build chain), then when someone other than the original magician has to fix something, you're stuck.  JPL really doesn'	AnimalMuppet	15.1459875	-3.9422517	comment	4.0	19.0	1579390924	-10.431081
22101700	>Lisp based contenders ready for sci	>Lisp based contenders ready for scientific computingAny examples?	forgotpwd16	15.14856	-3.937491	comment	4.0	12.0	1579550728	-10.444157
22207227	> spiritI think it would be a good n	> spiritI think it would be a good name for the new language (if it ever shows; it will probably be a lisp).	Koshkin	15.138172	-3.940625	comment	4.0	12.0	1580514728	-10.462801
35829010	I bought this book in paper time ago	I bought this book in paper time ago, put it aside (I bought half a dozen at the same time) and when I finally got to read it, I found out that I had brought the wrong version. Too late to return it...A question: is any of the currently hot software written also in Lisp? I mean the LLMs, SD, etc.	narag	15.151381	-3.9341345	comment	4.0	17.0	1683293599	9.764677
35852931	The article seems like mostly about 	The article seems like mostly about Common Lisp, but how many of the points are applicable to rest of Lisps? (Scheme, Emacs Lisp, Janet, etc)	eimrine	15.148105	-3.9352806	comment	4.0	28.0	1683475984	-10.456573
35853318	After learning Python, I wanted to t	After learning Python, I wanted to take the next step and find what was better. I looked into a lot of languages reading books on Haskell and Lisp and many others. At least for my use cases (desktop scripting, numerical work... etc) I didn't find Lisp to be superior. Most of what I actually needed to do could be done simpler in Python. Python's REPL isn't near as good as CL, but it's good enough. Then the batteries included was huge. So practically any task I could whip something up pretty quick. There are definitely some areas where Lisp is obviously superior to Python such as performance of plain code or things such as grammarly that would've likely been harder in python. I just think for the vast majority of programmers, enough good parts were pulled from lisp.	7thaccount	15.115675	-3.9740272	comment	4.0	19.0	1683478494	-10.325514
35853652	This thread may be as good as any to	"This thread may be as good as any to ask: the code I write has to deal with a huge amount of state. To summarize, my code receives millions of ""change commands"", which update state in memory. Data structures are hash tables, lists, etc. And some commands, once in a while, are queries like ""how many of these are there now, of what does this element now point to?"".I guess I'm describing some kind of custom in-memory database engine.Anyway, I'm confused as to how the purity of Lisp functions would or would not prevent me from writing this code? Is this a use case that is bad for Lisp, or am missing something?"	alain94040	15.104173	-3.9844718	comment	4.0	12.0	1683480671	-10.440766
35927790	MGL: Common Lisp machine learning li	MGL: Common Lisp machine learning library	oumua_don17	15.139292	-3.9363008	story	4.0	216.0	1683981529	-10.444095
35936856	Is Lisp being used today for anythin	Is Lisp being used today for anything particularly significant, like C and JavaScript are, or is it merely a niche academic language, like Haskell and Rust?	bhiply	15.1354885	-3.9606698	comment	4.0	13.0	1684059000	-10.483482
35936965	Which alternatives?  Sbcl:- Requires	Which alternatives?  Sbcl:- Requires manual type annotations to achieve remotely reasonable performance- Does no interesting optimisations around method dispatch- Chokes on code which reassigns variables- Doesn't model memory (sroa, store forwarding, alias analysis, concurrency...)- Doesn't do code motion- Has a decent, but not particularly good gcHotspot hits on all of these points.It's true that if you hand-hold the compiler, you can get fairly reasonable machine code out of it, same as you can do with some c compilers these days.  But it's 80s technology and it shows.	moonchild	15.099643	-3.975233	comment	4.0	26.0	1684060596	-10.398942
35942527	I think you’re looking for this:http	I think you’re looking for this:https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule> Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.	tshaddox	15.120269	-3.960033	comment	4.0	15.0	1684108901	-10.359351
36017748	> And I’ve not seen anything like th	"> And I’ve not seen anything like that in the, albeit casual, contact I’ve had with the Lisp community since then (mostly IRC).I spent a lot of time in an IRC channel with a Scheme guy who would get mad whenever anyone mentioned JavaScript, because it'd given up its Scheme syntax, and insist on calling it ""ECMAScript"". I dunno though, that was probably just him.Most of the internet's experience with Lisp comes from famously abusive people like Stallman and Erik Naggum though. Everyone else decided, like Norvig, that JS and Python were ""enough like Lisp"".The most useful things I know of built in a Lisp are Crash Bandicoot games and the sandbox system in Mac OS X. But both of those left out the garbage collector, which is one of the main things Lisp programmers would always act endlessly sup"	astrange	15.094057	-3.9902859	comment	4.0	23.0	1684639384	-10.44275
36034003	Looks cool but the install instructi	"Looks cool but the install instructions fail on my mac m1:   Aborted during step [1/3].
   Unhandled UIOP/LISP-BUILD:COMPILE-FILE-ERROR in thread # 
   <SB-THREAD:THREAD ""main thread"" RUNNING
                                                          
   {7005274C13}>:
     COMPILE-FILE-ERROR while
     compiling #<CL-SOURCE-FILE ""log4cl"" ""src"" ""naming-sbcl"">

I'm now 0/5 on the last interesting common lisp programs/libs I've tried to load on this machine: cl-cffi-gtk, cl-sdl2, nyxt, mgl, and now lem. CL is not m1-friendly it seems."	BaculumMeumEst	15.095722	-3.958538	comment	4.0	12.0	1684775471	-10.275772
36194906	I write Lisp professionally and love	I write Lisp professionally and love s-expressions, but the comparison with ALTER TABLE's grammar is pretty unfair. Postgres can detect many invalid ALTER TABLE formulations by checking the grammar, whereas in Lisp it's much easier to have grammatically-correct but semantically-wrong formulations.A major saving grace here (which was not covered in the section on macros) is that you can write clever macros that do appropriate checking at macroexpansion time, not runtime. This lets you use Lisp to write checkers for your Lisp code, which gives you a Turing-complete language you already know to do the checking instead of the (formally and practically) more limited checking of a grammar.	tsm	15.113144	-3.9843392	comment	4.0	63.0	1685964788	-10.356358
36194983	> Lisp’s unusual syntax is connected	> Lisp’s unusual syntax is connected to its expressive power. [...] It’s because of uniformity.Okay...> Lisp (and XML) have a uniform syntax... ookay. The rest of the arguments, and the conclusion, can then be equally applied to XML, specifically the:> I maintain that Common Lisp is the gold standard of DX for macrosDoes (s)he also maintain that XML is the gold standard of DX for macros? I guess that'd mean XSLT?...Or the article is just trying to be too clever for its own good.	senko	15.128806	-4.0242743	comment	4.0	20.0	1685965473	9.050838
36195236	Okay, other than Skyscanner, Grammar	Okay, other than Skyscanner, Grammarly, HackerNews, Emacs, CircleCI, Metabase, Crash Bandicoot, Nubank, other Clojure projects etc, what has Lisp done for us?	kirubakaran	15.154938	-3.9381855	comment	4.0	22.0	1685967700	-10.524165
36198226	If a kid were to learn Lisp purely f	If a kid were to learn Lisp purely for the joy of recreational programming, with no intentions of ever building production software with it, what Lisp would they pick?	sssilver	15.145124	-3.940099	comment	4.0	12.0	1685980671	-10.470763
36282798	Csexp: S-Expressions over the Networ	Csexp: S-Expressions over the Network	thefilmore	15.0776005	-4.0123973	story	4.0	109.0	1686500881	-10.311609
36283867	Is there anything similar for Common	Is there anything similar for Common Lisp?For now, I’m using JSON because I’m paranoid about code injection attacks around print/read.I’ve seen a handful of libraries, but each one claims to protect against a different kind of attack, so that makes me think they might be vulnerable to the ones they don’t mention.Edit: I’m not sure if I understood this submission properly, but I’ll leave my question up since I’m still interested.Edit again: looks like someone asked this exact question on SO: https://stackoverflow.com/questions/34813891/how-do-you-secu...	schemescape	15.135882	-3.946399	comment	4.0	18.0	1686506668	-10.421165
36545026	SBCL is an implementation I love wor	"SBCL is an implementation I love working with because updates are steady and the software is stable.But the real superpower, in my opinion, is that, because the compiler and standard library are written in Common Lisp, you can reach in into the internals of SBCL for your own projects—as if SBCL were just another Lisp library. Is it advised to use unsupported APIs? Definitely not. But it's nice to be able to have seamless access to the same facilities and optimization tools (e.g., DEFTRANSFORM, DEFINE-VOP) that the SBCL uses for its own implementation. You can build impressively clear and highly efficient code this way, essentially by extending the compiler ""in userspace""."	reikonomusha	15.128264	-3.9424617	comment	4.0	16.0	1688173287	-10.404269
28694771	I’ve always wanted something like th	I’ve always wanted something like this extension, but where the brackets aren’t colorized, but rather change size depending on their nesting level, with the outermost brackets becoming increasingly large as the total nesting level of the expression increases — exactly the way brackets do in maths.Ideally, unlike in TeX, additions to nesting levels wouldn’t require a re-flow (i.e. typing a bracket wouldn’t make the code constantly shimmy around on the screen), but rather these would just be changes in the perceived size of these characters, while keeping them where they are on a monospace grid (since a lot of code assumes a pure monospace layout for indentation et al.)In my imagination, this would work by just having a set of bracket/paren/brace/etc. graphemes in each font, that have increa	derefr	15.068402	-4.027254	comment	4.0	14.0	1632928393	-10.370682
28730568	I like Common Lisp but I no longer u	I like Common Lisp but I no longer use it. I'm pretty much completely burned out on dynamic typing. It feels like building on sand. I want calmer programming, even if it's less powerful. At present I'm building a new language[0] with that goal in mind.[0]: https://github.com/austral/austral	zetalyrae	15.117294	-3.9704266	comment	4.0	13.0	1633197530	-10.427588
28816860	> There are lots of standard functio	"> There are lots of standard functions still missing, but rather than implement them as built-ins, they can be implemented from the primitives already available.I'd be interested in reading more about this.  For example, how was that set of primitives chosen?  How does the author know that the set of primitives is sufficient?A couple relevant (and interesting) links:What is the ""minimal"" set of primitives needed for a Lisp interpreter?  https://www.cs.cmu.edu/Groups/AI/html/faqs/lang/lisp/part1/f...What is the smallest definition of Lisp?  https://www.reddit.com/r/lisp/comments/aklz0x/what_is_the_sm..."	WalterGR	15.129184	-3.9610486	comment	4.0	22.0	1633855697	-10.403728
23426023	I think this is close, but sort of m	I think this is close, but sort of missing the point: it’s possible to extend Common Lisp to take code in the form of Python source code (clpython), JavaScript source code (cljs) or many other textual syntaxes: originally, the iconic s-expression syntax of lisps was intended to be a sort of IR dump for m-expressions.What makes CL homoiconic has nothing to do with the textual syntax, but rather the existence of a function READ that takes _some_ textual syntax and produces the code to be evaluated in the form of the language’s ordinary datastructures: EVAL and friends consume a representation of the code that is neither just a blob of bytes nor some exotic AST objects, it’s lists, hash-tables, strings, vectors, and all the types of things programmers manipulate every day.The implication of t	fiddlerwoaroof	15.111222	-3.9911492	comment	4.0	29.0	1591342998	-10.37271
23552998	Interesting: https://github.com/robp	"Interesting: https://github.com/robpike/lisp/blob/master/lisp1_5/parse.go...    // Expr represents an arbitrary expression.
    type Expr struct {
        // An Expr is either an atom, with atom set, or a list, with car and cdr set.
        // Car and cdr can be nil (empty) even if atom is nil.
        car  *Expr
        atom *token
        cdr  *Expr
    }

Instead of using interface types for expressions, there is a simple expression structure type with fields that may or may not be set depending on what type of value it is.I probably never would have done it that way, I would probably use an interface type instead. This way actually saves space in cons objects… in the above version, a cons is 24 bytes, and below it would be 32:    type Expr interface { }
    type Cons struct { car, cdr "	klodolph	15.0908375	-4.017646	comment	4.0	18.0	1592410027	-10.461094
23699710	What are the fundamental differences	"What are the fundamental differences that are ""difficult or impossible to 'just' teach over""? Looking at a language like Racket, you have classes and objects, (first class) functions, recursion, ""for"" iteration, threads, mutability, etc. Aren't these features found in plenty of languages?Anecdotally, there seems to be a dislike of Lisp just because of the parens-based syntax. Do you think the different syntax counts as being such a fundamental difference for 90% of developers? Is it really so bad to have to write:(define x 1)instead oflet x = 1;That difference makes it ""left-handed scissors""?"	evdubs	15.126055	-3.968943	comment	4.0	21.0	1593596985	-10.403399
23766685	I use my own preprocessor for Chez S	"I use my own preprocessor for Chez Scheme. Comments begin flush left, code is indented. Indentation implies the parentheses that it can. ""|"" opens a group that self-closes at the next unbalanced "")"" or the end of the line. ""$"" is a placeholder where there's no Lisp symbol, when one needs to imply several opening parentheses at once. Together this avoids Lisp's signature 17 car pileup at the end of every expression.I look for the ""$"" or equivalent in any proposal out there, to see if the author has written lots of code or is just talking. It's like looking for bone marrow in beef stew, evaluating a cookbook. Marrow is central to the story of Lisp; we got our start being able to wield tools to crack open bones after lions and jackals had left a kill. The added nutrition allowed our brains to"	Syzygies	15.113198	-3.9802434	comment	4.0	13.0	1594179692	-10.365202
23800777	Common Lisp Elitism is a real thing.	"Common Lisp Elitism is a real thing. This person appears to be from the ""Clojure is not Lisp"" clan of gatekeepers."	divs1210	15.120646	-3.9922671	comment	4.0	30.0	1594460303	-10.9921665
23845798	Let me answer by posting an introduc	Let me answer by posting an introduction to the condition system by Kent M. Pitman. It is the first subchapter of the book.------There have been many attempts to declare the Lisp family of languages dead, and yet it continues on in many forms. There are many explanations for this, but an obvious one is that it still contains ideas and features that aren't fully appreciated outside the Lisp community, and so it continues as both a refuge and an idea factory.Gradually, other languages see the light and these important features migrate to other languages. For example, the Lisp community used to be unusual for standing steadfastly by automatic memory management and garbage collection when many said it couldn't be trusted to be efficient or responsive. In the modern world, however, many languag	phoe-krk	15.117425	-3.976042	comment	4.0	51.0	1594823957	-10.414541
23885208	There seems to be no mention of the 	There seems to be no mention of the Common Lisp condition system, which allows for handling of exceptional situations actually done right. Is this omission purposeful?See https://news.ycombinator.com/item?id=23843525 for a recent long discussion about my upcoming book on the topic. (Disclosure: this is a shameless plug.)	phoe-krk	15.125962	-3.962914	comment	4.0	15.0	1595109667	5.9413753
24032243	Yep, sorry.This is a matter of feeli	Yep, sorry.This is a matter of feeling, completely irrational, but just my experience.When I program in lisp I get the same feeling when I'm solving an ODE by hand, or a Diophantine equation, or designing a numerical method to approximate the solution of a PDE, or finding the Euler-Lagrange equations of a physical problem.  The thing is real and it gets shit done really fast; it is just exhilarating.  Moreover, lisp macros are so dirty and fun that using them feels like kinky sex.Haskell is like category theory.  Sure, it is pure and general, and you can create set theory and the rest of math from it.  But it is certainly the most boring thing that I can  think about.But hey, whatever floats your boat.	enriquto	15.121647	-3.9807007	comment	4.0	18.0	1596406455	-10.477877
24330620	You're missing the forest for the tr	You're missing the forest for the trees. What's the tiniest x86-64 code generator that can bootstrap John McCarthy's meta-circular evaluator, as it is written in his original paper. Now that's something I'd love to see. What he accomplished there is so profound and has served as the center of gravity that's attracted folks to LISP ever since. Also if you build it with APE your distributables will run on all platforms https://justine.storage.googleapis.com/ape.html	jart	15.132493	-3.9434123	comment	4.0	19.0	1598875929	-10.389165
20182564	Common Lisp: Numbers	Common Lisp: Numbers	tosh	15.14312	-3.943748	story	4.0	148.0	1560516942	-10.418853
20216105	It demonstrates that Quake could wel	It demonstrates that Quake could well be written in Lisp.	stcredzero	15.137646	-3.9406276	comment	4.0	20.0	1560880512	-10.4735155
20375720	Sorry but that's just wrong. He is c	"Sorry but that's just wrong. He is complaining about DSLs making things hard to read. That's not fixed by switching to another language or a package manager. That's purely a software engineering problem - nobody forces you to write code in that style.And LISP code being unreadable to others - sorry, that's bull. Seen e.g. some ""modern"" Javascript stuff recently? Good luck making heads and tails out of some of the frameworks - it often doesn't even look like a Javascript anymore! And nobody seems to be claiming that it leads to the demise of the language. Or numerical calculations in Fortran - still a gold standard for scientific stuff.To me the article is very much an output of someone who couldn't have been bothered to learn the language griping about things he doesn't really understand w"	janoc	15.13272	-3.9581447	comment	4.0	17.0	1562515199	-10.434798
20375988	Unpopular opinion, but I find readab	"Unpopular opinion, but I find readability really hard on lisp projects. Everything has to be read backward, and just because you can nest 10 lambdas doesn't mean that you need to nest 10 lambdas all over the place. So the code you end up with is write-only nested-over-nested-over-nested backward-reading code.Can clean lisp be written? For sure, and it's magnificent. But in practice, it's a total shit show. Basically, what I'm saying is when it's great, it's amazing, and when it sucks it's the worst.. whereas other languages like java/javascript/python have less variance in code quality and range from [""pretty-meh to ""good-enough""].And what's happening these days is the great features of lisp are integrated with ""good-enough"" languages, and then they become ""pretty-good"" languages."	grumpy8	15.134022	-3.9636428	comment	4.0	13.0	1562517815	-10.446667
20376979	There've been so many attempts at re	"There've been so many attempts at removing the parentheses from Lisp, to make it look more like C/C++/Java, or (more recently) Python, or other.FWIW, there've been many attempts in Scheme (and Racket), including one by the core Racket developers (Honu [1]), but they've never taken off.  New people decide to use parentheses.There's a phenomenon with Lisps, in which, speaking loosely, half the people who first see a Lisp think the parentheses are a problem, and immediately start to propose ""solutions"" for ""acceptance"".  But then they try the Lisp with the parentheses, in an editor with at least simple indenting support, and they very quickly get used to it, and maybe even value it.  (A small percentage of them will still put each close-paren on its own line, for a substantially longer period"	neilv	15.102399	-3.995899	comment	4.0	20.0	1562525643	-10.354171
20378241	Lisp has never been noticeably bette	Lisp has never been noticeably better overall.- In the past, it was better at abstraction, but slow and niche and you needed to shell out for hardware.- In the present it is not better. Common Lisp is about on a par with Python in what it has built in, inferior in its ecosystem, and for some modern stuff (threads, sockets) you will have to go outside the language standard into the wild west of implementation extensions or third party libraries.Lisp's one big selling point is macros. Macros are magic that lets you reprogram the language. Reprogrammed languages break the ability of a programmer to drop in and read the code. Languages that need reprogramming to get basic shit done are unfinished or academic (Scheme). Languages that can get stuff done, but tempt you to reprogram them are attra	JulianMorrison	15.130497	-3.9558606	comment	4.0	35.0	1562537026	-10.449676
20377122	"""a god like language"" Such hyperbole"	"""a god like language"" Such hyperbole can only be found in the lisp world. You guys need to take lisp off its pedestal."	AlexanderDhoore	15.144252	-3.9404864	comment	4.0	14.0	1562526746	-10.492445
20433429	Because it can easily solve or altog	Because it can easily solve or altogether eschew a lot of the issues that object-oriented JavaScript developers are struggling with and that's barely scraping the tip of the iceberg of problems which Lisp doesn't suffer from.Alas one of the problems Lisp does quite acutely suffer from is that SBCL has become a defacto standard and its support for anything that isn't GNU/Linux (like Solaris / illumos) is dismal.	Annatar	15.130914	-3.9542935	comment	4.0	35.0	1563113049	-10.411037
20481355	>  s-expressions have no central spe	">  s-expressions have no central specification on precise syntaxThere is: https://people.csail.mit.edu/rivest/Sexp.txtIt's imperfect, but it does get the job done.  Among its advantages is that it's both pure text and binary: there's a canonical representation which is binary, and an advanced representation which is textual, and they map 1:1 to one another.Examples:    (session
     (capabilities
      (urn:ietf:params:jmap:core
       (max-size-upload 50000000)
       (max-concurrent-upload 8)
       (max-size-request 10000000)
       (max-calls-in-request 32)
       (max-objects-in-get 256)
       (max-objects-in-set 128)
       (collation-algorithms (""i;ascii-numeric""
                              ""i;ascii-casemap""
                              ""i;unicode-casemap"")))
      (urn:ietf:par"	zeveb	15.057681	-4.0305414	comment	4.0	21.0	1563561742	-10.33738
20495609	Kind off-topic but related: sometime	Kind off-topic but related: sometimes I wonder how web development would be if Lisp had somehow won as standard, since we can use to do everything the stack HTML+CSS+JS+Backend-language does, in addition to standardized syntax and standard everything.Oh, standards. Standards.	Pmop	15.104248	-3.979397	comment	4.0	20.0	1563774629	-10.481187
20551457	Can anyone recommend an editor like 	Can anyone recommend an editor like Emacs that doesn’t use LISP?  I find the syntax to be an abomination.	new_realist	15.096488	-3.9724648	comment	4.0	15.0	1564373560	-10.337694
20590967	You realize the person whose code yo	You realize the person whose code you are criticizing wrote one of the classic books on Lisp right?	sansnomme	15.137996	-3.949623	comment	4.0	15.0	1564726734	-10.387624
20697881	It's elegant. It's (relatively) easy	"It's elegant. It's (relatively) easy to write a basic parser. LISP code is readily expressible in the same basic data structures provided in the language so you get meta programming almost for free and thus extending LISP is (relatively) easy too. Whereas C feels like an abstract machine language, LISP feels like an abstract 'mathematical computation' language. It's, like all languages, a different way of thinking about computation in the same way that human languages also seem to be (at least marginally) different ways of representing or expressing thought.And once you've come to appreciate it, jokes like ""HAVE YOU READ YOUR SICP TODAY?"" will be funny to you.In terms of 'getting shit done', it's not so 'good', not that one can't get shit done with LISP, but that it's not necessary nor, gi"	aeorgnoieang	15.133243	-3.9627662	comment	4.0	25.0	1565804164	-10.394854
20697842	- you can make your own domain speci	- you can make your own domain specific language in Lisp (e.g. imagine that you want to create a custom 'for' statement, or some kind of a new pattern matching operator)- you can easily write programs that edit themselves	kolinko	15.087927	-3.9901588	comment	4.0	19.0	1565803961	-10.341916
20698745	I think the general consensus is tha	"I think the general consensus is that it's great for ""getting big shit done"" – in other words, it's hard to beat for creating large, complex programs, but relatively crap for scripting or smaller tasks. I'm still kind of amazed how difficult it is to create a Lisp program that isn't hundreds of MB in size."	girzel	15.133826	-3.953442	comment	4.0	14.0	1565808850	-10.456195
20782512	It's pretty easy to write dreadfully	It's pretty easy to write dreadfully unmaintainable lisp.	miloshadzic	15.146258	-3.9432309	comment	4.0	17.0	1566594059	-10.47795
20821434	This sounds kind of like an absolute	This sounds kind of like an absolutely miserable experience. Can someone point out why a company would choose lisp over some other language which is just as fast performance wise?	Exuma	15.145371	-3.9459114	comment	4.0	20.0	1567010477	-10.487081
20921468	> Lisp allows you to just chuck thin	> Lisp allows you to just chuck things off so easilyLisp people (like Paul Graham) say that a lot, but they also admit that there’s a pretty steep learning curve before you get to that point - at least, I’ve never heard anybody say that Lisp is both easy to use and easy learn.  I actually do believe them.  I used to hear the same thing about vi: it’s quick and powerful, once you get over the learning hump.  I actually did take the time to get over the hump and found that I _was_ faster and more productive with it, but it took some time to get there.  The time spent was worth it, but it was slow going getting there.  I’ve dabbled enough in Lisp and functional programming in general on my own to believe that there’s something very powerful hiding in there… but there’s work to be done and unl	commandlinefan	15.14017	-3.9465444	comment	4.0	22.0	1568057275	-10.433885
13902098	It is even better. They also have co	It is even better. They also have code guidelines. Easing the choosing of technologies (open source!) and configuration.Less opportunities for that crazy developer who wants to implement your costumer facing site in Common Lisp.	neves	15.143163	-3.9309049	comment	4.0	14.0	1489855478	-10.457153
13933620	Lisp does support more than just lis	Lisp does support more than just lists as data structures.Arrays are also available, including specialized versions that hold value types.https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node15.htmlYou can also stack allocate if required, via dynamic-extent, http://clhs.lisp.se/Body/d_dynami.htmAlso not all Lisps have a tracing GC, some variants had a RC with tracing GC for collecting cycles.RAII like patterns can be achieved via the with-.... functions, or macros.I don't know the actual performance of commercial Lisps like Allegro Common Lisp and LispWorks, but I imagine it is quite good, given that they stay in business.On the other had, given the amount of money spent in C and C++ optimizers vs the lack of industry wide adoption of Lisp, probably still not as good as current leading C++ c	pjmlp	15.083367	-4.0118456	comment	4.0	21.0	1490208710	-10.487321
13949936	Seriously. I just started looking in	Seriously. I just started looking into Common Lisp last weekend, and if it weren't for the active communities on Reddit and IRC, you'd get the impression that the language was abandoned some time in 2012.	nerdponx	15.140445	-3.9484096	comment	4.0	24.0	1490372185	-10.501371
13950481	This is nice to know. Do Quicklisp p	This is nice to know. Do Quicklisp packages typically come with test suites? At least then I can check if a package will work before I commit to using it.	nerdponx	15.094379	-3.9542181	comment	4.0	12.0	1490375633	-10.442135
13950659	Does Lisp Suck?If HN had a FAQ this 	"Does Lisp Suck?If HN had a FAQ this might be near the top.  As new people go into CS they seem to be aesthetically drawn to, or repulsed by, Lisp.  The irony is there is no objective truth so these two groups of people spend a lot of time supporting their arguments (google search will amaze you, even Paul Graham has been sucked into this) but it's not very common for people to change sides after their initial indoctrination.I have come to view this as one of few (only?) metaphysical topics seriously discussed in computer science.Someone on SO once said:
'the correct Lisp answer is more gnomic. Something like: ""If you have to ask, you are not ready.""  Then if anyone questions further, the correct answer is either ""yes"" if it's an either/or question or ""You are not ready.""'"	WhitneyLand	15.154517	-3.9345832	comment	4.0	31.0	1490376928	-10.459868
13980822	"""Dear windows user, tell us how this"	"""Dear windows user, tell us how this is done for SBCL""Watch YouTube video from Baggers. It's a lot more complicated than your average windows user will want to go through. Than you have to setup EMACS, quicklisp...etc. I never really new what quicklisp was doing and it made me nervous (I trust VS nuget)."	throwaway7645	15.115479	-3.950376	comment	4.0	12.0	1490735868	-10.367869
13981539	I have a couple REPLs for specific p	I have a couple REPLs for specific projects that I routinely keep running for months at a time.The idea that user = programmer was part of the MIT AI Lab culture before there were Lisp Machines.  For example, the top level of ITS, the PDP-10 OS they used, was the debugger.  Imagine if the default Linux shell was GDB!	ScottBurson	15.095124	-3.9513776	comment	4.0	14.0	1490741238	-10.349951
14072121	Mezzano – Common Lisp OS: Demo 3 rel	Mezzano – Common Lisp OS: Demo 3 released	phoe-krk	15.115848	-3.9395907	story	4.0	48.0	1491743683	-10.270772
14167668	"It's too bad, since being a ""standar"	"It's too bad, since being a ""standard"" has helped CL to grow so much, despite some warts that the language inherited from old times habits.Without a standard, it seems most efforts to build a new Lisp come to a naught (think Racket and Clojure and Arc and ...)"	behnamoh	15.1449	-3.9633675	comment	4.0	20.0	1492796933	-10.456833
14248232	It's been stated a number of times, 	It's been stated a number of times, butx.f(y, z) has just as many parens as (f x y z). And Haskell particularly comes with so many syntax quirks. There is a lot of cruft you need to learn to get to the underlying functional core of haskell. Lips you can get 100% of the cruft out within a few days / 1 week. And the rest is just understanding programming concepts.I don't use any LISP on a regular basis, but it still amazes me how often people are willing to dismiss a language based on parens.It reminds me of a friend who would never try food from any other country because: Look at all the weird colors and ingredients. I'm not trying that.In the end, no one will ever force anyone to try something - but my view in life is if everyone raves about something, and my main concern with it is by (my	BoiledCabbage	15.114159	-3.990709	comment	4.0	16.0	1493744849	-10.449052
14250107	>> 1 - All those parenthesis. (Still	">> 1 - All those parenthesis. (Still a top objection)> If you actually count parens fairly you will find that Lisp has no more than any other languageBull. For example, compare the Lisp factorial function from the article:    (define (fact x)
      (if (zero? x)
          1
          (* x (fact (- x 1)))))

with the corresponding F# implementation:    let rec fact x =
        if x = 0 then 1
        else x * fact (x - 1)

That's 7 vs. 1 pair of parens.Also, the problem isn't just that Lisp has so many parens, but that they nest so deeply and quickly. Five nested levels of parens for factorial alone."	brianberns	15.063285	-4.0320606	comment	4.0	45.0	1493755751	-10.35332
14249480	To me the hard part about lisp is th	To me the hard part about lisp is that every programmer that uses lisp tailors it so to their own taste that it can become quite hard to read the 'top level' of a lisp program without first having gone through all the lower layers. It is as if every project in lisp somehow magically develops its own DSL. That's a high hurdle for newbies to clear.	jacquesm	15.135662	-3.9565413	comment	4.0	16.0	1493751601	-10.340313
14251684	Yeah, you know what else I'm realizi	"Yeah, you know what else I'm realizing?  All the different kinds of punctuation let my eyes skim over different parts of code so easily, and lisp doesn't give me that.You know how, when you're reading natural language, you don't actually read individual letters, not once you have any reading fluency?  That's how I read code, too, I'm realizing.  When I see the parentheses in C#, my brain just goes ""oh that's a method/function call"" and I can either skip over the contents of the parens or read them if I need to.  Reading comprehension is pretty quick.Looking at all the parens of even that simple lisp factorial, and I realize that I'm feeling a lot of cognitive load that would simply never go away, because the punctuation doesn't let me filter any of it out.  I'd have to read everything more"	Frondo	15.101426	-3.9927356	comment	4.0	12.0	1493768020	-10.358814
14258004	To any lisp enthusiasts who wonder w	"To any lisp enthusiasts who wonder why the language family isn't more popular: this is 99% of why. You have to use an editor where ""copy"" is called ""Kill-ring-save"" is invoked with ""Meta-w"". Any attempt to use any other tool will be met with incredulous responses to ""just use Emacs"".It's such a shame because the development environment for Lisp could be so much better than other languages. It could be mindblowingly futuristic, instead of mindblowingly archaic."	dTal	15.120189	-3.9575398	comment	4.0	15.0	1493832516	9.311911
14311996	Yeah right.Elisp was dynamic-scoping	Yeah right.Elisp was dynamic-scoping-only until version 24.1. That means elisp code written before that (i.e., 99.999% of emacs code that's not in C) as well as most of the code written after that, has essentially the feel of hacky cruft which will drown a modern programmer into an abyss of cognitive pain and headache when (s)he attempts to understand, modify, or debug it. (not unlike GOTO ridden spaghetti)How many programmers have you come across that claim to use elisp as their primary programming language?(to give you an idea, enough of emacs users/hackers are sick of elisp enough that emacs is now offered in two configurations: based on elisp or based on guile)	fizixer	15.094524	-3.964443	comment	4.0	14.0	1494452587	12.9501705
14347100	Lisp 1.5 Primer (1967) [pdf]	Lisp 1.5 Primer (1967) [pdf]	tjalfi	15.149597	-3.9338915	story	4.0	103.0	1494904287	0.056814637
14445549	Slight tangent: Am I the only one th	Slight tangent: Am I the only one that's a little bit annoyed that it seems like you need to start using the complex beast that is Emacs to get first class Lisp support? There are one-off apps, but everyone swears by SLIME mode or similar.Yes, I get it. The editor itself is written in Lisp. It's the most hackable thing out there. Yes, fine. It is a masterpiece of technical achievement. That's all well and good, but...I just want to learn the language, not the language and an editor that seems entirely alien at the same time. If I had to learn vim as a prerequisite to learning and writing Python (specifically using the debugger and a REPL), I probably would have never learned Python.	Karunamon	15.105719	-3.9674826	comment	4.0	14.0	1496154053	-10.393727
14481514	> I don't doubt that you can write p	"> I don't doubt that you can write productive systems in CL (bit of a fan myself), but the ""oh we have smart compilers that just make it as fast as C"" just isn't true.But 50% of C is great. Imagine in Lisp you can achieve 50% performance of C. That means you can write large amounts of your code in Lisp, without the need to use C.Actually it is both better and worse. One can achieve better than 50% and in many cases one is slower than 50% of C. For example you can optimize your code at runtime using the Lisp compiler. But in many cases you will be slower, since C compilers and libraries tend to have better support for hardware.For many many applications 50% performance of C is completely sufficient. Zillions of lines of code are written in much slower environments..."	lispm	15.1230135	-3.9668026	comment	4.0	30.0	1496583426	-10.374963
14558524	>In reality, it's more likely that t	>In reality, it's more likely that those 100 lines of boring Java are easily written in 10 lines of just as boring Lisp, the only difference being the removal of 90 lines of boilerplate getters and setters, iteration logic, exception declarations, class definitions and instantiation, and so on.I hear this sort of thing from Lisp advocates all the time, but have never seen it in practice.  Understandable Lisp isn't that compact.	gozur88	15.12708	-3.969996	comment	4.0	12.0	1497511521	-10.499994
14657119	D-Edit was already around when I got	D-Edit was already around when I got to PARC in late 1983.  The first thing I worked on was an Emacs in Interlisp-D.I think ITS Emacs (written in TECO) had paren matching before the CADR Lisp machines (what you call Zmacs, but it was EINE originally).The first Emacs written in Lisp was Multics Emacs (written by Bernie Greenberg) and it had paren matching when I used it but that was 81/82 timeframe.What do you call paren matching by the way?  Emacs always had structure navigation (c-m-F/B and c-m-U etc) in which case that support went back into the 1970s.(BTW the first Emacs-like editor for the lispms was EINE (Eine Is Not Emacs); it was replaced by ZWEI (Zwei Was Eine Initially).  Look at a German dictionary if that is not funny.  IIRC Zmacs was a renaming by Symbolics as part of their eff	gumby	15.124483	-3.956464	comment	4.0	12.0	1498675932	-10.3855915
31014780	Excuse my ignorance but could lisp b	Excuse my ignorance but could lisp be considered concatenative?	account-5	15.135629	-3.9560194	comment	4.0	12.0	1649858688	-10.4930105
31056266	I have been using Common Lisp profes	I have been using Common Lisp professionally for over a decade. Largest codebase was probably ~100k lines for an embedded optical fingerprint analysis and booking system for US law enforcement agencies. The largest Lisp team I've worked on was about 30 people for satcom hardware.Every time I've described to people on the internet what makes Lisp nice, I've been met with a riposte that such aspects aren't unique to Lisp—be them interactive/incremental development, macros, efficient machine code, editor integration, whatever—or that a laundry list of features means nothing and instead Lisp's value should somehow be proven through its (hitherto comparatively dismal) popularity with employers and software engineers. I myself have definitely given up on an academic approach to proselytizing the	reikonomusha	15.143465	-3.9415388	comment	4.0	29.0	1650144675	-10.463231
31056711	how do you go about producing static	how do you go about producing static binaries for sbcl?	someguy101010	15.125337	-3.9440906	comment	4.0	22.0	1650148678	-10.400955
31057725	You don't. As others noted, you can 	You don't. As others noted, you can save a core image. Cross compiling, tree shaking, and other such things don't exist in the sbcl world and (from what I've read in the past) the people developing it have little or no interest in those features.If you need those sorts of features paired with common lisp you could give embeddable common lisp a try. Otherwise if any lisp language will work for you then chicken scheme and gambit scheme both compile to c.	d110af5ccf	15.130903	-3.9408112	comment	4.0	17.0	1650160183	-10.367081
31120359	Common Lisp Resources	Common Lisp Resources	oumua_don17	15.145063	-3.9413788	story	4.0	200.0	1650627066	-10.442344
31123987	First-class functions, lambdas, and 	First-class functions, lambdas, and closures are mostly unheard of in the top 20 programming languages. Aside from JS, you're pretty much out of luck.Proper tail calls. Technically not part of the CL spec, but implemented by the best CL variants (and by scheme), they allow a lot of expressive power. You won't find this ANYWHERE on the top 20 except for JS where it is technically part of the spec, but Google and Mozilla refused to implement leaving just Safari/JSC to have 100% ES6 spec compliance 7 years after the spec was finished.Macros get overstated perhaps, but there are almost zero non-lisp languages that implement them and none of them implement macros ergonomically. In a language like JS, you'll often see a kind of DSL where they attempt to use closures and super-dynamic objects to 	hajile	15.088023	-4.0175395	comment	4.0	22.0	1650645444	-10.370948
31179399	Good to see, but at this point in it	Good to see, but at this point in its lifecycle I don't really believe a lack of good tutorials is a barrier or even impediment for CL.The problem is after the tutorial is done, all the libraries (look (like (this))) and the language is so powerful it is difficult to know if this 10kb contains a life-changing insight into the nature of programming or a half-hearted implementation of half of something that was a bad idea to start with. Knowing the syntax and technical semantics of the language doesn't help with that.The topic has been done to death, but the lisps seem to have a social organisation problem that the community never quite managed to get a grip on.	roenxi	15.145795	-3.9386766	comment	4.0	25.0	1651065033	-10.439753
31181866	Practical Common Lisp gets you up to	Practical Common Lisp gets you up to speed very fast.I wish there was something similar for scheme. Most scheme books focus on teaching  you compsci with the language and not on teaching you how to build practical things with it.It's quite hard to onboard someone to a scheme codebase, despite scheme's reputation of being a simple language.	latenightcoding	15.1185465	-3.9612103	comment	4.0	13.0	1651076026	-10.434101
31187093	I wonder how difficult it would be t	I wonder how difficult it would be to port elisp to Common Lisp and then get GNU Emacs running hosted in SBCL or whatever. I really like the idea of my editor running in the image.	User23	15.109292	-3.9569478	comment	4.0	15.0	1651102117	-10.3952875
31202614	Lisp macros are really cool. Program	"Lisp macros are really cool. Programming is not satisfying to me without a similar feature.But, most people are happy with just typing and copy pasting stuff around. They don't care. I've shown them before and after macro refactoring code comparisons and they just stare blankly, they don't see the point.They code stuff like this on a daily basis:    Var stuff() As Stuff
    stuff.Add(New Stuff(""foo""))
    stuff.Add(New Stuff(""bar""))
    stuff.Add(New Stuff(""baz""))

And they really don't have a problem with it :)"	TurboHaskal	15.103837	-3.9929283	comment	4.0	22.0	1651219520	-10.366773
31207476	I love that we now live in an age wh	I love that we now live in an age where older languages can suddenly start seeing a renaissance. I hope something similar comes to common lisp.	cultofmetatron	15.141606	-3.9406574	comment	4.0	16.0	1651250629	-10.418174
31250191	Hy is a false promise.  It looks lik	Hy is a false promise.  It looks like a lisp; depending on your idea of a Platonic lisp, it may be a lisp --- but it preserves Python semantics, including its odd scoping rules, and it doesn't feel like writing actual lisp.  Scheme or Common Lisp simply feel more coherent, having semantics that make sense with the language.	JasonFruit	15.096826	-3.9949446	comment	4.0	18.0	1651595128	-10.087074
31288761	Why is Emacs lisp absurd ? It’s an e	Why is Emacs lisp absurd ? It’s an editor that is widely popular .	zitterbewegung	15.132249	-3.946052	comment	4.0	15.0	1651864763	-10.392589
31494983	I find it's better to think in terms	"I find it's better to think in terms of ""familiar"" vs ""not familiar"" rather than ""easy"" / ""hard"". Lisp syntax to me is the easiest -maybe with Forth and Smalltalk- syntax around, certainly orders of magnitude easier than Python's. And I don't mean just semantics, but also conceptual beauty. There's something about it that feels so elegant that other languages do not possess (again with Forth / Smalltalk exceptions). I can take a young curious kid with no previous exposure to programming, and teach Lisp syntax in under 5 minutes.But a kid with no previous exposure to programming is nothing like your average developer with strong pre-existing conditioning about how programming languages must look like. And this is the issue I feel with a lot of folks complaining about Lisp syntax. It's easy "	metroholografix	15.124936	-3.9704008	comment	4.0	30.0	1653413118	-10.384944
31561240	Nonrecursive Lisp Reader	Nonrecursive Lisp Reader	eklitzke	15.141669	-3.9443264	story	4.0	39.0	1653931197	-10.434678
31587250	People really underestimate how much	People really underestimate how much RAM a Lisp/Scheme needs.Building lists out of pairs and then using them as your intermediate format creates a lot of garbage.	bsder	15.100737	-3.9930687	comment	4.0	18.0	1654113749	8.900298
31637415	Lisp advocacy (for the last few deca	Lisp advocacy (for the last few decades) is always about how you can write anything in 10 lines of macros, but I never see anyone discuss security or whether the result actually does what you meant it to do.	astrange	15.119726	-3.9730875	comment	4.0	32.0	1654492520	-10.383964
31637532	The irony of the 2 + 3 = 5 example i	The irony of the 2 + 3 = 5 example is that it shows how domain-specific languages work best with iconic forms. Paralinguistic symbols as constituency tends toward mismatched metaphors and visual sameness. However, crafted carefully, such tools represent the best available to tame complexity.There is a level of metaprogramming even more fundamental than Lisp macros - the ancient and maligned fexpr [0]. They are almost as if you took lambda and just didn't evaluate the args when called by default. In fact, this is what Kernel [1] elegantly showed, bringing along with it the pure notion of a vau calculus, which can help restore optimization techniques who's absence resulted in the original defamation of the fexpr.[0] https://fexpr.blogspot.com/2011/04/fexpr.html[1] https://web.cs.wpi.edu/%7Ej	rileyphone	15.115422	-3.976978	comment	4.0	33.0	1654494126	-10.331082
28847916	As unsatisfying as it may sound, Com	As unsatisfying as it may sound, Common Lisp taught me that, truly, none of this function binding capture stuff really matters in practice. Millions of lines of Common Lisp code have been running for decades without running into problems with capture. So I purport solving this problem is akin to solving a 0.00000001% issue if we measure the frequency of encountering this error writing thousands of lines of Lisp per day for a sizable chunk of one’s lifetime. The explanations by Pitman et al. are wise. If someone on my team were regularly writing macros that expanded into non-externalizable, non-PRINTable function objects, I’d probably be irritated. You’re hindering my pretty-printer, you’re hosing my debugging tools, and you’re breaking my expectations of interactive development. What? One 	reikonomusha	15.089883	-4.0056653	comment	4.0	29.0	1634095663	-10.3339615
28875903	I was thinking of building my own LI	I was thinking of building my own LISP-like language, but seeing so many pop up on here I don't think I'll bother.	billpg	15.133666	-3.9473379	comment	4.0	18.0	1634290394	-10.445034
28962833	>  Lisp allows us to scale dramatica	>  Lisp allows us to scale dramatically and manage a large code base.Wow, really? How big is your company?> Right now, in our core company we have three people, two here in Virginia and one in Mexico City.	pphysch	15.140837	-3.9457002	comment	4.0	18.0	1634937319	-10.449355
29007312	> Getting Lisp to run as fast as C t	> Getting Lisp to run as fast as C takes major effort when at all possible.The Computer Language Benchmarks Game shows Lisp Code as generally being between 2x and 10x slower than C++[1]. As fast as C? No. Way faster than Python, and more than fast enough to be used in almost every single application, modulo hard-real-time systems and AAA video games? Yes.> Lisp needs a lot of space to do it's thing; and while it's certainly possible to downsize it, you're left with something that's not really Lisp anymore.Again, while a 13MB SBCL image might be significantly larger than a 100KB C program, given that that's the entire compiler and runtime bundled in, and the size of additional code scales also like C/C++, that still makes it viable for almost every kind of program (and still an order of mag	throw10920	15.123754	-3.958362	comment	4.0	33.0	1635288152	-10.383279
29007501	Can I be extremely shallow? Because 	Can I be extremely shallow? Because the language feels like it's from the 60s. Like writing Fortran or Ada or Algol in 2021. C is timeless, it doesn't count.I love lisps, but Racket, for example, feels more modern than Common Lisp to me. And for shallow people like me, feel and ergonomics are very important when writing code.	1_player	15.128861	-3.9564698	comment	4.0	26.0	1635289428	-10.449347
29007642	That article partially validates my 	That article partially validates my idea on why some people think that Lisp is such a force multiplier. The idea would be that compilers are one of the most important tool productivity-wise, and that Lisp allows you write your compilers yourself.That would also explain why not Lisp: First, libaries are the new important tool for productivity, and any language can have that. Second, a shared understanding is very important, either for building programs, or building the libraries. Writing your own compilers may reduce that shared understanding. You can see this in some ecosystems where there is a split between people using the language in different ways (OCaml with Async and Lwt, the few alternative standard libraries; Scala with Zio, Cats, the base language; C++ with C with classes, the sta	Zababa	15.135994	-3.9573448	comment	4.0	16.0	1635290285	-10.434051
29008148	> ... AAA video games? Yes.One of my	"> ... AAA video games? Yes.One of my favorite stories of the ideas of lisp commercially is a dialect that Naughty Dog developed for their game development.It started as being developed for Crash Banicoot on the PS1.Which is really interesting given how limited the system was (1mb to 2mb of ram depending on what you were doing with the system!)They later iterated on it for Jak and Daxter on the PS2. To quote the wikipedia page:> GOAL does not run in an interpreter, but instead is compiled directly into PlayStation 2 machine code to execute.
> ...
> GOAL has extensive support for inlined assembly language code using a special rlet form,[1] allowing programs to freely mix assembly and higher-level constructs within one function. 
> ...
> It supports a long term compiling listener session whic"	spicybright	15.119012	-3.944869	comment	4.0	21.0	1635293954	-8.076944
29006889	Performance:Getting Lisp to run as f	Performance:Getting Lisp to run as fast as C takes major effort when at all possible.Resources:Lisp needs a lot of space to do it's thing; and while it's certainly possible to downsize it, you're left with something that's not really Lisp anymore.Ecosystem:Finding solid libraries is tricky since it's not very popular professionally.Power:Unleashing the full power of Lisp in a diverse team is a recipe for an adventure, if not disaster.	codr7	15.133261	-3.9517376	comment	4.0	43.0	1635285618	-10.493349
29202207	Having never used Common Lisp, it's 	Having never used Common Lisp, it's one of the languages I wish I've used for a long time.However, working with Clojure and Scheme, I understand the power of repl driven development that is difficult to explain outside the experience of it.	jmkr	15.08098	-4.035763	comment	4.0	85.0	1636738862	-10.724762
29204449	> I would spend a lot of time trying	"> I would spend a lot of time trying to figure out the actual type of the thing that I a given functionThat's just because your were a noob. You hadn't learned and internalized the standard library yet, and you hadn't learned to understand flow and structure of types and functions and variables.I too when I started with Lisp had the same struggles, but they go away with expertise.That's why you'll hear people talk about ""training wheels"", when you program in a statically typed language with an extensive IDE doing a lot of static analysis for you, you basically operate constantly with training wheels on. You never really learn what class does what, what methods they have, what types things are, you rely heavily on your IDE.For example, ask an experienced Java developer to write some Java in"	didibus	15.141988	-3.948295	comment	4.0	22.0	1636750713	-10.457928
29205265	Lisp code I write today may run 10 y	Lisp code I write today may run 10 years from now, but would I be able to read it a month from now? Maybe I just never got familiar enough with it, but code I wrote for my AI class was meaningless to me 6 months later.	jmugan	15.14115	-3.941849	comment	4.0	13.0	1636756021	-10.405432
29247392	Are there any pictures of the hand-w	Are there any pictures of the hand-wired LISP Machine online?I searched, but couldn't find it.Also - when LISP was invented (1958) - what was the state of computers at the time? Doing some research - it seems like direct keyboard input to computers was only available for 2 years prior. It seems like languages were decades ahead of hardware.I guess I'm having trouble fathoming how languages were so far ahead while computers were seemingly VERY primitive.Are there any articles on the process for how LISP was designed and implemented??	onlyrealcuzzo	15.144937	-3.9397762	comment	4.0	14.0	1637103923	-10.42621
29259436	My point is that Forth's general goa	My point is that Forth's general goal is to be a higher-level assembly language for embedded systems.Common Lisp and Scheme's general goal is to be a high-level programming language for application development (also PL research in Scheme's case).By general goal I mean what you could ultimately guess the focus is based on the implementation decisions and how the community uses the implementations.They both do a good job but in very different situations.	eatonphil	15.140466	-3.9384432	comment	4.0	16.0	1637186530	-10.427677
29285006	Did anything ever become of the lisp	Did anything ever become of the lispy language that was being built using Ion as its homoiconic syntax?  I'm afraid I can't recall what it was called.   Fusion maybe?	Eelongate	15.136157	-3.9542315	comment	4.0	12.0	1637374470	3.2430813
29292788	That's hilarious, because the Wolfra	That's hilarious, because the Wolfram Language is actually quite lispy.  Or, at least you can write it in a very lispy style.	actually_a_dog	15.134279	-3.9534535	comment	4.0	14.0	1637451358	-10.421297
29310278	> The establishment of protocols is 	"> The establishment of protocols is a sort of before-the-fact hedge against the ""prisoner's dilemma""; that is, it creates an obvious way for two people who are not directly communicating to structure independently developed code so that it works in a manner that remains coherent when such code is later combined.Sounds very cool, and the article seems to edify wrt functionality and abstract benefit, but how does it really help? See: the more-or-less complete abandonment of resumable conditions in other languages.The practical differences between conditions and c++-style exceptions seem to be:1. The stack is followed back, looking for a handler, rather than being destructively unwound- 'restarts' don't necessarily 'try again', they can continue from where the condition was thrown.2. While un"	smegsicle	15.045962	-4.040611	comment	4.0	13.0	1637607578	-10.247138
29630890	Am I the only one who dislikes S-exp	Am I the only one who dislikes S-expressions and prefers XML or JSON or even YAML? The parenthesis are way too confusing when editing manually and the format doesn't have enough semantic information to always correctly parse into common structures in any language besides lisp. I enjoy writing lisp myself but I really think it is a mistake to use them for common formats everywhere that I've seen it tried.	shatteredgate	15.069689	-4.0250506	comment	4.0	16.0	1640037589	-10.343878
29638068	Counterpoint to your counterpoint: t	Counterpoint to your counterpoint: the standard is still the best way, and ligitures are non standard.	Something1234	15.130663	-3.9456139	comment	4.0	12.0	1640099408	-10.465355
34157441	Write it in Lisp and don't tell the 	Write it in Lisp and don't tell the boss! I wonder if anyone has ever gotten this to work. I sure hope so.	djha-skin	15.147478	-3.9359837	comment	4.0	15.0	1672200502	-10.387558
34203240	The syntax is probably the only thin	The syntax is probably the only thing left that other languages haven’t copied/implemented? Directly exposing the AST to the programmer is a truly unique Lisp feature as far as I know.Maybe the ability to reprogram the Reader is another one that other languages haven’t copied?	deterministic	15.08921	-3.9966342	comment	4.0	13.0	1672543146	-10.253289
34285535	3 months ago you described yourself 	"3 months ago you described yourself as a ""non-techie"", and you come here of all places, and cry about too much Lisp? You've taken a wrong turn, pal. This house was built with parens.Sent from my Lisp Machine."	sph	15.140621	-3.945538	comment	4.0	17.0	1673069403	-10.455944
34327461	The problem with almost all LISP tut	The problem with almost all LISP tutorials, books,... is there's no guide on how to install toolings at the beginning. Instead, there's just praise and praise.Such a missed opportunity.	revskill	15.146088	-3.9351642	comment	4.0	31.0	1673368623	-10.479756
34525986	I think you're maybe just a little c	"I think you're maybe just a little confused, or I'm missing something. Kebab case is in general not viable to implement unless you have very a special/quirky syntax, because there is no way differentiate to `a-b` from `Id(""a-b"")` and `Subtract(Id(""a""), Id(""b""))` from syntax alone. Now, there are of course options that introduce trade-offs.First obvious option is to get rid of the infix ""-"" operator, which is what Lisp does. In lisp-like languages you don't write ""a - b"" instead you write ""- a b"", this way there is nothing to confuse ""a-b"" with.Another option is to require a space between operators. E.g. you are not allowed to write ""a+b"" to mean ""add a to b"". You have to write ""a + b"". This is used in Agda programming language. This is very useful because then you can have identifiers like"	gnulinux	15.096874	-3.994744	comment	4.0	21.0	1674691202	-10.325343
34558009	And how nice when those scouts lay g	And how nice when those scouts lay groundwork that is useful for others, rather than creating something only they can use?Yes, you may think better in lisp than c++, but that doesn't help your team when you created something and moved right along. Better to speak the same language.	jvanderbot	15.131063	-3.9605784	comment	4.0	17.0	1674917868	-10.423979
34675510	"This article doesn't use the name ""L"	"This article doesn't use the name ""Lisp"" enough. The language with the best chance of lasting a long time is the one with the simplest syntax. That is Lisp. It is already one of the oldest programming languages and the lisp family of languages are still mutually intelligible to each other despite being large. The language core hasn't settled and the rest of the programming community has nearly caught up with the Common Lisp standard library.Will a Lisp ever be the most popular language? Probably not. Maybe. Will they last 100 years? Easily. One or multiple of the current Lisps will still be there. If computers exist in 2123, someone will be making money using a current Lisp. Hopefully they'll be using one that has discovered the words ""first"" and ""rest""."	roenxi	15.137444	-3.951757	comment	4.0	31.0	1675678204	-10.452595
34675834	What is Lisp used for in production 	What is Lisp used for in production these days? The wiki didn’t really specify, just that it’s connected to mathmatics and AI research.	prox	15.142059	-3.9443464	comment	4.0	16.0	1675681445	-10.471523
34844881	I love Lisp (particularly Scheme), a	"I love Lisp (particularly Scheme), and heard that Janet was strongly inspired by Lisp and is ""really Lisp underneath"", but is really fast and strong at math, so I thought I'd give it a try, and after learning it I started wondering to myself, ""why am I not simply using Lisp?""Though arguably lispy, Janet just wasn't lispy enough for me. It was missing the simple, elegant sexp syntax I dearly loved, and I started to wonder what huge win I was getting from using it instead of just using Lisp or Scheme? Having not found a good answer, I did just that.That was the last time I bothered trying to learn a ""Lisp-like"" language that wasn't actually a Lisp, and decided to just stick to Lisp/Scheme. They do everything I need, are good at math, and are plenty fast enough for me."	pmoriarty	15.137626	-3.9566774	comment	4.0	41.0	1676706160	-10.442098
34845505	"vaguely kinda related.
I want to lik"	"vaguely kinda related.
I want to like lisp for its features but the syntax is too much for me to pick up without serious time investment, which I am not sure I want to make.are there any other languages that support for example lisp-like interactive REPL, eg analyzing program state while it is running?"	return_to_monke	15.111384	-3.970005	comment	4.0	13.0	1676713403	-10.43418
34863107	I've been digging into Common Lisp a	I've been digging into Common Lisp again lately. I'm really enjoying some parts: CLIM is weird but interesting, and the fact that I'm basically developing inside a debugger makes testing and iterating on stuff pretty straightforward. On the other hand, library documentation frequently feels more like the programmer was making notes to himself rather than illustrating how the code might actually be used. I was also pretty shocked when, after using a quick shell script to generate a file containing a big list (~80MB on disk, 800k items) defined in s-expressions, reading it into SBCL exhausted the heap. After telling SBCL it could allocate two gigabytes I was able to read the file, but doing anything with it was a sure-fire way to run out of memory again. I would never think twice about readi	floren	15.09749	-3.9663537	comment	4.0	14.0	1676850281	-10.338314
34863848	which is a terrible shame and a less	which is a terrible shame and a lesson. of the 10 or so lisp like languages i've used extensively, elisp is by far the worst. it succeeds because it interfaces with something important, and its carried along everywhere.	convolvatron	15.129767	-3.9558103	comment	4.0	12.0	1676856095	-10.44368
34910371	Are there any serious attempts at re	"Are there any serious attempts at reworking the Common Lisp standard for more modern problems?I know the space is active, but when I see the old bright yellow CLHS linked to from documentation sites, I just frown a bit. The Lisp community very nearly goes out of its way to be unhospitable to the younger generation of coders, and downright dismissive of modern techniques like containers and DevOps practices.Not that the Scheme community is doing a radically better job, but at least the RnRS standard is marching forward at an acceptable pace.A few years ago there was CL21, but it didn't really garner enough support from the community to really take form into anything worthwhile. I think we need a ""Lisp for 20XX"" council or something to gather up ideas and begin a reconstruction era for Lisp "	l_theanine	15.142465	-3.9479942	comment	4.0	13.0	1677159382	-10.497362
34939356	LISP is worth learning for a differe	LISP is worth learning for a different reason – the profound enlightenment experience you will have when you finally get it. That experience will make you a better programmer for the rest of your days, even if you never actually use LISP itself a lot. (You can get some beginning experience with LISP fairly easily by writing and modifying editing modes for the Emacs text editor, or Script-Fu plugins for the GIMP.)It’s best, actually, to learn all five of Python, C/C++, Perl, and LISP. Besides being the most important hacking languages, they represent very different approaches to programming, and each will educate you in valuable ways.http://www.catb.org/~esr/faqs/hacker-howto.html#skills1	teddyh	15.137597	-3.9516633	comment	4.0	18.0	1677351437	-10.422077
34950848	To each their own. There are obvious	To each their own. There are obviously very smart people choosing Lisp so I’m not trying to knock it down or anything, I just never got the appealEvery now and then I try to check out a Lisp project and this is my reaction the moment I see the code: https://giphy.com/gifs/seinfeld-bye-jerry-106PwpLIIXJnXi	brap	15.14757	-3.9431682	comment	4.0	12.0	1677453925	-10.438682
34951048	We (professional developers using li	"We (professional developers using lisp-like languages daily) don't have the reaction of ""ewww"" as soon as we see something foreign, but instead we think ""hmm, that looks different, I wonder why it looks different?"" and then we start to try to understand it. Then you give a lisp-like language a try (Clojure in my case) and suddenly it's really hard to program in any other language, because they're not as good as a lisp language.If you have a knee-jerk reaction to everything that looks different, you'll lose out on lots of fun stuff. You should give lisp a try, I'm sure you won't regret it."	capableweb	15.132328	-3.9580653	comment	4.0	18.0	1677455238	-10.538338
35019317	It seems dirty to use parser combina	It seems dirty to use parser combinators and a tokenizer generator for lisp instead of just... writing the parser. That's part of the beauty of lisp.Maybe a different syntax would have fit this sort of post better.	eldenring	15.098961	-3.9947762	comment	4.0	20.0	1677919467	-10.285802
16830856	I think most modern programmers pref	I think most modern programmers prefer explicit destructuring and taking an element from a collection by its key rather than excplicitly traveling node links using car and cadr. The 'original' lisp has some really arbitrary naming conventions. Languages are cognitive tools and as such they should be able to evolve, rather than dogmatically stick to a specific formulation laid down in the formative years of a field.It does not manner how you name your tokens or how you choose to destruct your data structures. It's still lisp.	fsloth	15.125918	-3.970079	comment	5.0	19.0	1523633191	4.731267
16861362	I wrote some high-performance lisp a	I wrote some high-performance lisp applications in production. My main was was a threaded queue worker, driven off beanstalkd, that processed large volumes of data. This was highly successful and didn't require overly-provisioned servers (was using CCL/linux x64/linode VPS).That said, I don't think I'll ever use lisp for front-facing web stuff again. I wrote cl-async, and afterwards and used it in production in a few places, then a bit later started using node heavily. The tooling for CL is just not there. Quicklisp is great, but not being able to pick and choose package versions is limiting, and having to rewrite every single thing for async was a pain (since CL doesn't have continuations, any sort of async that avoids CPS is impossible). I was hoping I would get more community support on	orthecreedence	15.1167555	-3.9703124	comment	5.0	25.0	1523992338	-10.413892
16861062	> While the industry waits for Light	> While the industry waits for LightTable and similar tools to mature, Lisp programmers have been silently and haughtily enjoying such capabilities with SLIME for many years.Were a significant number of Lispers really waiting for LightTable to be usable for them?	aeorgnoieang	15.143095	-3.9307837	comment	5.0	23.0	1523990181	-10.443068
17037027	"What exactly is meant by the line ""D"	"What exactly is meant by the line ""Design patterns disappear as you adapt the language to your problem domain.""The word ""disappear"" is a hyperlink to a pdf, which refers to domain-specific design-patterns. I don't quite seem to grasp what is being implied on the home-page.Is it something like Lisp is very customizable and allows you to easily overload operators? (I am primarily a Java programmer and have never used Lisp).EDIT: I mean, e.g. this page asks ""Are Design Patterns Missing Language Features"" http://wiki.c2.com/?AreDesignPatternsMissingLanguageFeaturesIs this what's being referred to, and if so, what makes Lisp especially good for adding language features?"	pure-awesome	15.13759	-3.9549172	comment	5.0	19.0	1525937512	-10.443269
17037511	What confused me a lot is that nobod	What confused me a lot is that nobody seems to give an example on how to build a binary out of a Lisp program/make it runnable from command-line.Also most tutorials/books I found don't guide you on how to build an application/structure your code – which is rather confusing for a beginner. You have to spend a lot of time and try and error to get things working using Quicklisp. I got often the impression, that since Lisp is so old, everyone using it knows how to do things and forgot to document for newcomers their knowledge.	thibran	15.128547	-3.9568264	comment	5.0	16.0	1525946055	-10.424865
17038107	This is a very nice web site describ	This is a very nice web site describing a programming language with unparalleled expressiveness, power and permanence.I am heavily invested in Common Lisp. We are developing a programming environment for designing new materials and molecules called Cando (https://github.com/drmeister/cando) using Common Lisp as a scripting language. Cando is running on Clasp (https://github.com/clasp-developers/clasp), a new Common Lisp implementation that interoperates with C++ and is based on LLVM.What attracted me to the language, after 35 years programming in almost everything else, was how organically it lets one write software and how I don't have to worry about it fading like the next programming fad.	drmeister	15.120242	-3.9675198	comment	5.0	77.0	1525953989	-10.39723
17106874	The older I become the more I realiz	The older I become the more I realize how influential Lisp is/was. The Lisp memory model presented here looks like object oriented data structures, if you squint a little. Java dragged C++ programmers 'halfway to Lisp' [1]. I now do a lot of programming on Python, which is so obviously like Lisp that MIT teaches it instead of Scheme. We don't have continuations and macro yet in mainstream languages, but we'll get there.[1] http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/m...	AlexanderDhoore	15.13008	-3.9644127	comment	5.0	22.0	1526710426	-10.415101
17115728	Symbolics Lisp Machine Museum	Symbolics Lisp Machine Museum	ghosthamlet	15.130587	-3.9484444	story	5.0	52.0	1526867895	-10.3444395
17388266	Ask HN: Why aren’t libraries inter-c	Ask HN: Why aren’t libraries inter-callable by default?	abrax3141	15.124584	-3.9593434	story	5.0	14.0	1529872499	-10.403333
17439988	It's been so sad to see that while t	It's been so sad to see that while the AI winter ended, the Lisp winter that started around the same time never did.  Maybe it's coming back after consolidation on the languages end:  SBCL and Clojure are coming ahead as clear winners, and are quite powerful.I'm sure I'm not the only guy who started learning Lisp after reading Paul Graham's essays, and I'm going to keep using Lisp for several reasons, but the momentum just isn't there.	daniel-cussen	15.140421	-3.9468474	comment	5.0	32.0	1530518406	-10.505235
17440013	The guys that wrote this piece have 	The guys that wrote this piece have drunk the kool aid of Lisp.To say that library support for bioinformatics is on the early stages is quite a misunderstanding. Lisp was one if not the first language to be used in everything, including bioinformatics. If it is not used anymore is because people have abandoned it.People have abandoned it once its flaws became evident. The main flaw of Lisp is using linear data for everything. It is obsolete, it was designed for linear memory like tapes or punched cards, not random access to memory like we have today.Languages like Clojure has not this limitation but they have others, like forcing you to use the java virtual machine, good if optional, terrible if mandatory.In current systems with huge amount of RAM, when you could have 128GBs on a developer	hevi_jos	15.121859	-3.9839303	comment	5.0	17.0	1530518807	-10.817414
17535534	Anarki – Community-managed fork of t	Anarki – Community-managed fork of the Arc dialect of Lisp	christianbryant	15.143379	-3.94406	story	5.0	126.0	1531667233	-10.452576
17625363	Slightly off the topic: if I have to	"Slightly off the topic: if I have to start using Lisp now, how do I start?
I tried curating things on my own but felt overwhelmed with the alternatives and resources.Will appreciate your take on this."	aryamaan	15.149931	-3.935303	comment	5.0	15.0	1532693616	-10.465625
17644580	Ferret: a Lisp implementation for re	Ferret: a Lisp implementation for real time embedded control systems	tosh	15.119859	-3.9501183	story	5.0	135.0	1532960895	-10.401038
17720488	This is not particularly accurate, a	"This is not particularly accurate, and doesn't seem maintained. Just looking at the start of the first column, Common Lisp, for a bit:- ""command line program"" is empty, but should contain    sbcl --eval '(+ 1 1)'

- ""identifier"" says ""case insensitive, cannot start with digit"", but identifiers can start with digits just fine. 1+ is a built-in function that proves it. It just can't look like a number.- ""identifier"" also says some characters are ""reserved for user macros"", but that's not actually a thing. ?![]{} is a valid identifier, you just shouldn't use it.There's probably much more. There are also plenty of things that are inaccurate, but would need more explanation than there is room for."	jorams	15.120033	-3.9569101	comment	5.0	19.0	1533770535	-10.358619
17797149	The premise of the title is a bit od	The premise of the title is a bit odd, because technically anything a lisp can do assembly language can do. The bar on being able to do 'anything' is so low that many things accidentally become Turing complete.Can lisp programmers still feel smug about using lisp? No, because it never was and never will be productive to feel smug.Is lisp still the best language for expressing a programmers thoughts? Yes, because it has basically no syntax, so any program will be a direct representation of a programmer's mental model for how their program works. No language with syntax will do that, but the average programmer is probably best actively discouraged from utilising this freedom because they probably have flawed mental models of what is going on.	roenxi	15.140047	-3.9503262	comment	5.0	37.0	1534727943	-10.445675
17797184	>> because it has basically no synta	">> because it has basically no syntax, so any program will be a direct representation of a programmer's mental model for how their program worksThat's actually a problem with Lisp, because every programmer would have different mental model and without some syntax rule imposing at least basic structure most of Lisp programs would be PITA to maintain by the unlucky next programmer. It also seriously limits the scale of teams of Lisp programmers (is that even a thing?), because every one of them will have their own ""right way"" of doing things."	mamon	15.136811	-3.9539223	comment	5.0	32.0	1534728457	-10.429584
17823846	Makes one wonder if an OS should be 	"Makes one wonder if an OS should be built using LISP these days to make available that kind of hackability.  Or port Genera OS [1] to x86 or arm.  The languages used by the VPRI project were bootstrapped on lisp if I recall correctly [2].  It would be great if that projects code was released as open source too.[1] http://wiki.c2.com/?GeneraOs
[2] http://www.vpri.org/writings.php"	kristianp	15.129065	-3.945232	comment	5.0	17.0	1534988263	-10.33567
17853496	In Freenode's #mercurial, sjl said t	"In Freenode's #mercurial, sjl said this about common lisp:   <sjl_>	CL code from the early 90's runs just fine on SBCL from a month ago
   <sjl_>	But trying to run five-year-old python/ruby/scala makes me hate life.

This echoes his earlier blog post, volatile software:http://stevelosh.com/blog/2012/04/volatile-software/I kind of have the feeling that fighting bitrot is sjl's main motivation for CL."	jordigh	15.1285715	-3.951326	comment	5.0	29.0	1535396365	-10.416002
19079943	MIT went with the Berkeley editor. A	MIT went with the Berkeley editor. A lost opportunity to introduce programmers to the beauty of using Emacs and Lisp.	melling	15.12545	-3.9489026	comment	5.0	18.0	1549309730	-10.425206
19263550	A Lisp machine isn't just some hardw	A Lisp machine isn't just some hardware with Lisp on top. You can do that today with x86. A Lisp machine is supposed to have support for lisp primitives at a hardware level.	mruts	15.132583	-3.9509878	comment	5.0	25.0	1551278980	-10.437786
19317133	Do you think it is useful for a Lisp	Do you think it is useful for a Lisp noob?	damsdu78	15.144467	-3.9404438	comment	5.0	21.0	1551859406	-10.457164
19317622	Still, its a trip to hell to maintai	Still, its a trip to hell to maintain any lisp codebase -- especially if it contains macros. I think it is actively hostile to collaborative programming, and that is a structural problem where there is no remedy but obscure programming patterns (which are amplifying these problems in some instances). With that in mind -- boasting about 'the most advanced language' is a bit of a stretch -- to say the least...	maze-le	15.124988	-3.9642754	comment	5.0	30.0	1551865643	-10.431277
19319451	Is there a prominent open source pro	Is there a prominent open source project written in Common Lisp? Something like Pandoc for Haskell or RabbitMQ for Erlang?	rhizome31	15.135055	-3.9502652	comment	5.0	18.0	1551885254	-10.457928
19479039	Only if you don't consider a forest 	Only if you don't consider a forest of parens to be noise. I do. I'm sure I could get used to it after a while, but at first glance, Python code is definitely cleaner than Lisp.	istjohn	15.125927	-3.9662201	comment	5.0	20.0	1553464940	-10.443587
19547065	People talk about forth having no sy	People talk about forth having no syntax the same way people talk about lisp having no syntax: not entirely correctly. Of course, every textual representation of anything has a syntax, but when people talk about something not having a syntax what they really mean is that the syntax is uniform: there is only one global (uniform) syntax.	mruts	15.0915365	-3.9951515	comment	5.0	15.0	1554146299	-10.260662
19683320	I would love to get my hands on an o	"I would love to get my hands on an old Lisp machine, just to play with it.  While there's obviously nothing pragmatic about using one of them nowadays, I think they're an incredibly interesting footnote in computing history, and I always like to think about the ""what if?"" universe where Lisp-centric architectures were the norm."	tombert	15.142116	-3.940223	comment	5.0	30.0	1555514320	-10.461411
19953823	More lines of prose praising lisp ar	More lines of prose praising lisp are being written than lines of lisp these days it seems.I recently asked how to write a tree shaker in #sbcl because I thought it’d be cool. All I got was a “why would you do that?” and “ok fine your time to waste” and no substantial answers. The Common Lisp community is small and curmudgeonly. Who needs this?	gaze	15.150899	-3.9382808	comment	5.0	35.0	1558280579	-10.458126
37840482	How does Common Lisp compare with el	How does Common Lisp compare with elixir. I'm trying to find a good functional language to learn.	movingmovie	15.1353	-3.9555645	comment	5.0	15.0	1696994036	-10.4418545
37840410	Steel Bank Common Lisp is what I bui	Steel Bank Common Lisp is what I built my businesses on. Interactive software building is the work of magic.Nothing comes close.Once I retire and have some more free time I want to make videos and make open source contributions to make it more palatable and sexy for beginners.Folks are really missing out on a lot of joy and happiness by not programming in Common Lisp but I also understand why.	ilrwbwrkhv	15.13716	-3.9458349	comment	5.0	31.0	1696993389	-10.482664
38024477	so... there's no lisp or forth.  i g	so... there's no lisp or forth.  i guess that means you can't write security bugs in lisp, right?	retrocryptid	15.131651	-3.956645	comment	5.0	16.0	1698322242	-10.461986
38168680	Very cool project. Not commenting on	Very cool project. Not commenting on that. Lisp and it's derivatives often hits the front page of HN and I always wonder why. What is it about lisp that is so powerful? so much so that some see it as the platonic ideal of programming languages or so it seems?	gigatexal	15.150533	-3.9362743	comment	5.0	17.0	1699303317	-10.451847
38275661	The odd lack of verbs (in the title 	The odd lack of verbs (in the title and the text) made me immediately suspect this was an unfortunate AI submission.  Is omitting verbs part of the inside joke of Lisp communities?	ezekiel68	15.127511	-3.9496794	comment	5.0	18.0	1700048400	-10.437559
38343933	Interactive Common Lisp Development	Interactive Common Lisp Development	billiob	15.1341715	-3.9477394	story	5.0	118.0	1700465262	-10.4151125
38400175	I often fantasize about a world wher	I often fantasize about a world where lisp or smalltalk machines took off instead of the Windows/Linux we have now. I know things weren't perfect, but it just seems like such a cool system and that we've evolved in a much less powerful direction.	7thaccount	15.116621	-3.9567192	comment	5.0	34.0	1700793786	-10.375168
38570491	Every once in a while I come back to	"Every once in a while I come back to this, and walk away feeling like it's not worth my time to learn.The language might be ""objectively"" simple, but it's not at all a simple language. There is no user guide, nor is there a nice readable language spec like R7RS. There's a reference manual, and a bunch of StackOverflow examples that look like Perl with S-expressions. I'd love to sit down and work through a reference manual, but who has time for that nowadays?I love the idea of a Lisp purpose-built for data processing, but practically I don't know what I'll gain by learning this that I don't already have with Python, Zsh, and Gauche Scheme.Can someone convince me otherwise? What's the killer feature of TXR that makes it worth the effort of learning it the hard way?Also, what's with the leadi"	nerdponx	15.115576	-3.9734075	comment	5.0	28.0	1702051045	9.241473
38586002	I've heard this about Lisp, but I do	I've heard this about Lisp, but I don't really get how this doesn't apply to other languages. How is writing special operators in Lisp different from writing special functions in any other language?	smlavine	15.125899	-3.9705737	comment	5.0	20.0	1702155376	-10.521496
33194389	Shared structure is overrated. The c	"Shared structure is overrated. The cases where you need a tree-like mutable structure are vanishingly small in modern times. Mostly it boils down to ""just use hash tables.""This isn't just a dismissive observation. It's the heart of why Lisp is so hard to implement. When I ignored mutable cons cells, I realized I could just implement bel in Python by using actual Python lists.    t = True
    nil = None

    def car(l):
        if l:
            return l[0]

    assert car(nil) == nil
    assert car([]) == nil
    assert car([1]) == 1
    assert car([[1]]) == [1]
    assert car(car([[1]])) == 1
    assert car(car([(1, 2)])) == 1

    def sequence(x):
        return isinstance(x, (list, tuple))

    def cdr(l):
        if l:
            if v := l[1:]:
                if v[0] == ""."":
        "	sillysaurusx	15.07146	-4.024984	comment	5.0	37.0	1665684208	-10.341142
33194570	You're right, I was imprecise. I mea	"You're right, I was imprecise. I meant specifically shared list structure in Lisp contexts, not shared structures in general.There's a fascination in the Lisp world for cons cells. Specifically the cell aspect. If you represent lists as:   l = [x, [y, [z]]]

Then you can implement car as l[0] and cdr as l[1].If you require mutable cons cells, that's pretty much the only way to do it. Because if you want to set the car of cdr(l), how do you do it? You can just do   cdr(l)[0] = t

Because that's the same as   l[1][0] = t

Which of course makes the list become   l = [x, [t, [z]]]

But this sucks. It's always sucked, and Lispers go out of their way to ignore the fact that it sucks. I wince at having such a dismissive attitude here, but it's been the source of years of frustrations.It's a frust"	sillysaurusx	15.099151	-4.002728	comment	5.0	28.0	1665685289	-10.573151
33349329	The Importance of Lisp	The Importance of Lisp	veryniceborat	15.150499	-3.9328423	story	5.0	39.0	1666817829	-10.471127
33463117	I can see why someone would learn Li	I can see why someone would learn Lisp as learning a different paradigm than what you are currently using helps you see thing in different ways and improves your overall ability to solve problems.What I miss is what classes of problems Lisp helps you to solve better and faster. Why use Lisp in production?If you want functional programming there's ML, F#, Haskell and even Javascript. If you want to develop fast, there's Go, C#, Python and so on.I am not trying to denigrate Lisp here or to say something is better, I am genuinely asking what advantages Lisp has, what are the cases for which is it best suited in production.	DeathArrow	15.140994	-3.9521785	comment	5.0	50.0	1667545970	-10.457852
33463363	I've been hearing similar arguments 	I've been hearing similar arguments from lisp advocates for decades but lisp is still a tiny niche in the programming world. Is this because programmers are just slow to catch on to superior technology or because infinite malleability is not that helpful in actually building shipping software?A lot of important ideas originated in the lisp world that are now mainstream like garbage collection, functions as values etc. But I think there are good reasons that most of us don't use s-expression syntax at work.	cageface	15.100886	-3.9942715	comment	5.0	15.0	1667548727	-10.378944
33464215	> There is this list https://common-	> There is this list https://common-lisp.net/lisp-companiesIf you have so few that you can maintain a list, it kinda proves OP's point.Also as an addendum to his point, what about projects being written in the last decade or two?Emacs is cool, but it was created in 1976...	iLoveOncall	15.122891	-3.9391088	comment	5.0	36.0	1667556996	-10.433802
33521792	My windmill is simply I still can't 	My windmill is simply I still can't think in prefix for math.It's trivial for me to write x = (-b + sqrt(b^2 + 4 * a * c)) / (2 * a).But writing (setf x (/ (+ (- b) (sqrt (+ (* 4 a c) (* b b)))) (* 2 a))).That's a mind bender. Were this my source code, I'd probably put the (* 2 a) on the next line (properly indented) so it stood out as the divisor.All that said, honestly, the physical task of writing Lisp code is just so much better than anything else. There's something satisfying closing up all of the parens. And I just love using-hyphens-for-identifiers vs CamelCase or using_underscores.	whartung	15.101263	-3.9940372	comment	5.0	21.0	1667929210	-10.3429985
33573108	"""Ur-Lisp"" – what is the exact defini"	"""Ur-Lisp"" – what is the exact definition of this?"	dustingetz	15.1456785	-3.9317496	comment	5.0	25.0	1668261659	-10.421458
33573215	"""Ur"" is a German prefix meaning ""old"	"""Ur"" is a German prefix meaning ""old"", ""original"", ""predecessor"".So Ur-Lisp would be the old original Lisp that is predecessor to all other Lisps.Other examples include Urrind (Rind == Bovine) which would be the predecessor of all species of bovine. Urzeit (Zeit == time), which is a generic very ancient time period before all humans (where the Urrind or even the dinosaurs might have lived). Ur-Computer might be one of the first computers, like the original Zuse or ENIAC."	throwaway294566	15.132859	-3.9353504	comment	5.0	16.0	1668262471	-10.444387
33680238	Great timing. It's my turn to write 	"Great timing. It's my turn to write a Lisp, and I was just thinking about implementing reader macros this morning :-)My goal is to create the barest-metal Lisp OS (basically Lisp REPL with full ring-0 access, the OS) with an asm reader macro to write low level assembly opcodes you can jmp into.    (defn add1 (x)
      (declare x int64)
      #asm(
        mov rax, %x
        add rax, 1
      ))

(Just thought of this syntax on the spot, I'm a few dozen hours away from that still.)"	sph	15.101485	-3.9749792	comment	5.0	21.0	1668945272	-10.3265295
33746528	Haven't quite reached the ceiling ye	Haven't quite reached the ceiling yet. Go parenless. https://www.draketo.de/software/wisp	arboles	15.13746	-3.9399827	comment	5.0	17.0	1669408914	-10.417859
33747077	Anyone have any recommendations (boo	Anyone have any recommendations (books, courses, videos, etc.) on learning LISP? I've been intrigued by it and want to integrate it into a game I'm building as a development tool but not sure where to start on learning the language.	throw149102	15.149973	-3.9341826	comment	5.0	20.0	1669412203	-10.442099
33747277	Dunno if I'm in the minority, but I 	Dunno if I'm in the minority, but I just can't warm to [], either in lieu of or augmenting, () in SEXPRs. Just never felt they were necessary and, if anything, I find them distracting. Likely because I'm not used to them (baby duck syndrome and all), but the regularity of Lisp syntax, to me, is a boon, and the [] just mess that up for me.	whartung	15.110647	-3.9859345	comment	5.0	20.0	1669413507	-10.408746
33891064	> And Lisp is not that hard to learn	> And Lisp is not that hard to learn anyway.Lisp is much, much harder to learn than JS is. Aside from that JS is a very transferrable skill, but Lisp is not.	shepherdjerred	15.094974	-3.9843829	comment	5.0	22.0	1670392255	-10.448923
35387370	So the word LISP does not appear in 	So the word LISP does not appear in the entire introduction. If you’re introducing a language thats a LISP, that’s really the kind of thing you’ve got to state up front.You can define the term for those unfamiliar, and you don’t have to dwell on it, but people who are turned off by LISPs will feel a little swindled if they get 3 book-pages in before finding out. And people who specifically like LISPs might pass this over without realizing what it is and miss out.	Uehreka	15.146395	-3.9424434	comment	5.0	18.0	1680271648	-10.486755
35388178	"As a wise programmer once said: ""Lis"	"As a wise programmer once said: ""Lisps are created by those who are lazy to write proper parsers""Homoiconicity does not mean your syntax should be backwards. Look at Io language: it is basically a Lisp, but it has parens in the familiar places.Same with Forth: it is a small and powerful language, but it's good for implementing low-level stuff. You will quickly run into desire to have normal(language(with, familiar, syntax)) for writing non-trivial programs."	oleganza	15.115657	-3.9838893	comment	5.0	15.0	1680275094	-10.398307
28113434	Lisping at JPL (2020)	Lisping at JPL (2020)	signa11	15.153997	-3.9302142	story	5.0	56.0	1628492151	-10.493867
28186131	Ask HN: Common Lisp for Startups in 	Ask HN: Common Lisp for Startups in 2021?	exdsq	15.141617	-3.9385753	story	5.0	6.0	1628999586	-10.410918
28209633	Ask HN: What are the current state-o	Ask HN: What are the current state-of-the-art Lisp implementations doing?	sfgweilr4f	15.119546	-3.9682555	story	5.0	13.0	1629207156	-10.42389
28349355	The thing is, if you start with Comm	The thing is, if you start with Common Lisp, it's pretty easy to write a DSL that adds the constraints and provides the guarantees that you need.  If you start with Rust or Haskell, it is impossible to remove the constraints those languages impose short of invoking Greenspun's Tenth Law and re-implementing big parts of Common Lisp.	lisper	15.085071	-3.9952006	comment	5.0	44.0	1630262679	-3.3178408
12706986	Let’s Run Lisp on a Microcontroller	Let’s Run Lisp on a Microcontroller	gattilorenz	15.133256	-3.941108	story	5.0	135.0	1476437696	6.36241
12799227	Technical Issues of Separation in Li	Technical Issues of Separation in Lisp Function Cells and Value Cells (1988)	adgasf	15.13076	-3.948838	story	5.0	85.0	1477507453	-10.499915
13074640	Why do Lisps separate these related 	"Why do Lisps separate these related semantics? Are there implementation reasons, or is it mostly ""the way it's always been""?Edit: thanks folks! You've helped me get over the facepalm from years ago :)"	AceJohnny2	15.136777	-3.9568324	comment	5.0	26.0	1480539579	-10.435135
13096906	The biggest problem in spreading lis	"The biggest problem in spreading lisp nowadays is the fragmentation of the documentation.""Lisp"" means so little when you're writing real code.Each implementation has its own quirks and even venerable books fall when confronted with real world code at learning.For example: I was reading the SICP and using racket that looks like an interesting runtime nowadays. Turns out that a while a go the dev team made cons immutable and that's okay I guess but it broke (at least for me) the experience of reading SICP because I now have to pause and learn this quirk of this specific lisp implementation.And don't even get me started on common lisp. There are at least 5 or 6 major common lisp runtimes, each of them incompatible somehow (try and read some of the StumpWM ""makefiles"" and you'll have a taste o"	znpy	15.1334	-3.9557612	comment	5.0	19.0	1480791093	-10.497899
13193457	If you like everything being an expr	If you like everything being an expression, check out tcl. A lot of ideas from lisp show up in tcl, especially the idea of everything as an expression. Tcl embodies this idea while also having the look of an algol-like language. Funny it can pull this off while having basically no syntax.	mroll	15.110586	-3.9840379	comment	5.0	91.0	1481898914	-10.388193
13195068	It's interesting, I'm reading Black 	"It's interesting, I'm reading Black Swan at the moment by Nassim Taleb, and one of his big rants is about how we get blinded by idealized, platonic forms and ideas when the real world is messy and inherently unpredictable. E.g. trying to explain the forms of nature with platonic archetypal shapes like circles, rectangles and triangles. Lisp and the community around it kinda has that flavor - getting lost in a world of ""pure forms"" and grand ideas, but downplaying the important but messy practical reality of hardware, useful libraries, and getting cool stuff done with a minimum of fuss. I'm periodically fascinated by Lisp (I wrote an interpreter or two in C) but I wonder if its ""Platonicity"" is part of its downfall."	QuadrupleA	15.1445265	-3.9433932	comment	5.0	49.0	1481910031	-10.51124
13197479	ANSI Common Lisp is rather a design-	"ANSI Common Lisp is rather a design-by-committee monstrosity which was forced on the unwilling Lisp vendors by the Defense Department.Most of the feature set was designed via backroom political horse trading (""We'll let you include pet feature X if you support us for our pet feature Y"".) There is no coherent overall plan or design to it at all.(Source: personal communication from a member of the committee that designed it.)It's based on actual use on real computers of the late 1970s and early 1980s -- e.g. the file opening mechanism is a complex abstraction designed to support filesystem paradigms that nobody has used for 30 years, yet there is no standard way to open a TCP socket.I heartily recommend Clojure (clojure.org) as an alternative: a modern, pragmatic Lisp designed for 2016-era s"	pjlegato	15.080113	-3.9519165	comment	5.0	29.0	1481927353	-10.251362
13226387	One of these days I going to release	"One of these days I going to release my web framework for Common Lisp.I call it ""Railth""."	StevePerkins	15.124635	-3.9546769	comment	5.0	16.0	1482287761	-10.469307
13255826	I want to learn compiler development	I want to learn compiler development.  My goal is to get enough of an understanding to be able to work on other people's compilers, such as SBCL.I'd like to:-Build a lisp that targets LLVM IR-Build an HDL out of lisp that can be compiled into a simulation, as well as be compiled to a netlist for synthesis.-Build a testbench toolkit out of that same lisp.	DigitalJack	15.11002	-3.9634714	comment	5.0	20.0	1482706256	-10.2989855
13466597	I'm still struggling with my own leg	"I'm still struggling with my own legacy code problem. I'm reviving an old LISP program from the early 1980s. Parts of it were written for the original Stanford AI Lab SAIL system in the 1970s.  It last ran under Franz LISP in 1986.My current struggle is with one line of code:   (defun getenode (l) (cadr l))

That ought to be simple enough. But it's being applied not to a list, but a ""hunk"". A ""hunk"" is an obsolete MacLISP concept.[1]. It's a block of memory which has N contiguous LISP cells, each with two pointers.  This is the memory object underlying structures and arrays in MacLISP. Macros were used to create the illusion of structure data objects, with hunks underneath.  However, you could still access a ""hunk"" with car, cdr, cxr, etc.I'm converting this to Common LISP, which has real "	Animats	15.107534	-3.9862666	comment	5.0	20.0	1485209552	-10.470806
13475566	This article is in the same vein as 	"This article is in the same vein as that execrable Lisp article that showed up today: ""Alas, poor brilliant misunderstood me, cursed by my genius and unwillingness to ~play the silly games of the lesser people who surround me~"""	jff	15.15557	-3.9303184	comment	5.0	21.0	1485292673	-10.458951
13570965	Licecap definitely changed how I wor	Licecap definitely changed how I worked. If you want the rest of your frontend development team to think you're a god, include licecap or other gifs of features/bugfixes on code reviews. It's a thing most developers don't even think of doing (at least most didn't in my experience). Makes it easy for stake holders (if they're allowed near your code reviews/tickets/whatever), devs, qa, to easily see how functionality has changed.I first learned of it from a young QA at a company I previously worked at, and I am so grateful I met him and was able to learn from him.	hardwaresofton	15.150409	-3.9370077	comment	5.0	16.0	1486271020	-10.439574
27570975	How can I learn enough Lisp to under	How can I learn enough Lisp to understand Emacs well?	sudhirkhanger	15.143518	-3.9351046	comment	5.0	16.0	1624202978	-10.44604
27599708	I like this tutorial, but it's worth	I like this tutorial, but it's worth noting that you're building your own lisp with the author's bespoke parser generator.	EamonnMR	15.105721	-3.9761474	comment	5.0	19.0	1624412022	-10.305016
27720813	Unpopular opinion here - and maybe i	Unpopular opinion here - and maybe it’s because I’m jealous of the Lispers.But is Lisp used for anything real?I mean, even teaching - is it worth it to learn lisp? Aren’t other languages more practical to learn?Isn’t learning lisp like learning a a dead language that once you leave the lisp class you’ll never use again?Wouldn’t you learn the exact same things you learned in lisp using a more widely used (practical)language?	eric4smith	15.148056	-3.939014	comment	5.0	15.0	1625310877	-10.445647
12004614	The difference between adding symbol	"The difference between adding symbols to a language with product types (i.e. consing) and simply having algebraic data types in your language is that symbols are untyped, and so you're allowed to compare apples and oranges (they're inequal).This isn't terribly useful, as it's almost always a mistake to do it. If you do have a context in which you want to compare apples and oranges, algebraic datatypes force your hand to declare which types of things you'd like to compare across (e.g., specify that you're comparing any fruits, and that apples and oranges are fruits). This clarity helps form a clear mental model of how your software works and avoid bugs.Lisp is the ""hold my beer, I know what I'm doing"" of functional programming languages. It, like other languages that take this stance, shoul"	gue5t	15.118909	-3.974319	comment	5.0	39.0	1467232427	-10.311016
12113393	"It's all about the read.
But a diffe"	"It's all about the read.
But a different one.
The human ability to read code.You can write very dense code in Lisp (and the author makes the point several times on how little lines of code you need for this vs. that).
However, who's going to read that and understand it?Especially problematic with code that looks like a regular s-expression but has a completely different semantic thanks to macros.Lisp is great if you want to write code. 
Reading it...you mileage may vary"	beders	15.125604	-3.974357	comment	5.0	19.0	1468820376	-10.357599
12456111	In the early 2000's, Teemu Kalvas cr	"In the early 2000's, Teemu Kalvas created ""Lisp 500"": 500 lines of C (plus a .lisp file that provides a library and goes as far as featuring a compiler, which works by emitting C).I can't find the sources for this.Incomplete, no .lisp file: http://www.s2.org/~chery/projects/lisp500/Doesn't connect: http://modeemi.cs.tut.fi/~chery/lisp500/The most accessible source for this currently seems to be a ""lisp5000"" project in GitHub: https://github.com/jackpal/lisp5000This is a derivative work whose C code has been blown up to 1600+ lines."	kazinator	15.132093	-3.9560387	comment	5.0	20.0	1473360959	-10.323092
12470108	I really like the growing interest i	I really like the growing interest in making lisps that compile to C, and one that is purely function is even better. I'd be curious how the GC in this compares to the fascinating work in Chicken for novel GC in C environments.	hellofunk	15.132495	-3.9512355	comment	5.0	24.0	1473528129	-10.3804245
12470929	Python users are essentially discove	Python users are essentially discovering what Lispers have known all along - code is data. Once you fully comprehend that idea, you'll never be bothered by Lisp's odd syntax because of the freedom in expressibility it gives you.There are some fantastic Python hackers out there (some who know Lisp, others who don't) and this is a logical step in the progression of any developer. Eventually, they'll rediscover continuations too. But, as long as Python is not homoiconic, it will never be as simple to express these ideas as it is in Lisp.	madmax96	15.10446	-3.9903479	comment	5.0	25.0	1473542362	-10.306355
12471017	I'm glad to see this, and even more 	I'm glad to see this, and even more interested that it was  written in 2005. I've read lots of rants about how awesome Lisp is supposed to be from Paul Graham and Steve Yegge and all. But I never see anything significant being written in it or using it, so I haven't felt all that tempted to try learning it.Meanwhile, I've been using Ruby for a while, and the metaprogramming capabilities are pretty cool. It sounds a lot like what all of the Lisp enthusiasts are saying is so awesome about Lisp to me. So I've always wondered what it is that's so awesome about Lisp that Ruby doesn't already have.	ufmace	15.150296	-3.9470663	comment	5.0	40.0	1473543935	-10.45766
12513710	I've said it before and I'll say it 	"I've said it before and I'll say it again: go and learn Brainfuck. Just write a program that outputs your name or does FizzBuzz or something trivial, that's enough to get a grasp of it.Brainfuck is to Turing machines what Lisp is to Lambda calculus. Minimum viable amount of syntactic sugar (and a bit of ""semantic sugar"" as well, it's nicer to work in bytes than bits) to make it usable as a programming language.Lambda calculus is just a bit more practical formalism than Turing machines, that's why Lisp is genuinely useful as a programming language, unlike Brainfuck. That doesn't make learning about Turing machines any less useful as a brain teaser exercise."	exDM69	15.125692	-3.9572887	comment	5.0	28.0	1474031580	-10.237098
22412937	This doesn't scratch my itch at all.	"This doesn't scratch my itch at all. I love Lisp but boring old Python has the libraries I need.EDIT: Based on a comment and downvote I suppose I didn't make my point clear above. I am saying that myths are not the only thing holding Lisp back. (I may be wrong. I hope I'm wrong. Big thank-you to people who are linking ways to get libraries in Lisp, especially Python libraries.)I care 10x as much about libraries as about all these red herrings (EDIT: or myths, as you like) combined: 
"" * Common Lisp does not have compile-time type checking.
* Common Lisp is for imperative, object-oriented programming.
* Common Lisp is too specialized, it’s not for general-purpose development.
* Common Lisp applications are hard to deploy. """	tom-thistime	15.129028	-3.9632235	comment	5.0	23.0	1582636897	-10.422495
22580085	Something they don't tell you when y	"Something they don't tell you when you start learning lisp is the sense of calm it bringsIt's such a elegant thing, it ruins me for doing ""professional"" programming"	slifin	15.138707	-3.9502003	comment	5.0	90.0	1584233405	-10.46402
22581379	Erm.. I think it's a bit overrated T	Erm.. I think it's a bit overrated TBH. Don't get me wrong - lisp is quite simply magical (and very ahead of the curve). However, when you look back at code, those written in Python just seem much nicer. The AIMA/PAIP code in Common Lisp, for instance, are ugly as hell, while that in Python (for AIMA) is far far elegant. No doubt this stems, in part, from CL's legacy, but I haven't found things to be much better in Scheme land either.	thrw34234	15.133569	-3.957767	comment	5.0	15.0	1584248045	-10.40426
22683735	TXR Lisp	TXR Lisp	chrispsn	15.144789	-3.9348915	story	5.0	77.0	1585137507	9.1630335
22809876	I never had a lisp class, so I'm sit	I never had a lisp class, so I'm sitting here wondering why there is one single quote.	onionisafruit	15.156812	-3.9317868	comment	5.0	15.0	1586317960	-10.513361
23041360	Peter tech-reviewed the second editi	Peter tech-reviewed the second edition of my Java AI book and made the comment that Java was half as good as Common Lisp for AI and that was probably good enough (we had both written Common Lisp books). He then went to Google and I had lunch with him; I was surprised that he was using Python.I like his poem in the article!A little off topic, but I retired (that is a bit of a joke) and at the age of 69, this year I decided that for maximum programming enjoyment I would only use Lisp languages (linking in Python and TensorFlow on occasion). I am approaching 40 years using Common Lisp and using the language is so much fun. I bought a license for LispWorks and using it for developing a semantic web app.	mark_l_watson	15.132246	-3.9546654	comment	5.0	44.0	1588336535	-10.407898
23166006	This looks so awesome! It's got the 	This looks so awesome! It's got the best parts of a lot of languages. This is what sticks out to me:- Really simple lisp like scheme, but reminds me of lua (and not bloated like CL)- Has resumable fibers, no callcc like scheme- Not missing the lack of lists tbh- A module system that doesn't feel awkward like CL- A built-in package manager (unlike CL)- Good lua and C support- Threads have a shared-nothing approach with message passing (reminds me of Erlang actors)- Destructuring- Good PEG support, encourages it over regex- (Im)mutable versions of data structures (ie tuples vs arrays, structs vs tables) for maximum flexibility- Prototypal inheritance- Docs are clean and easy to readI'll definitely have to try this out, it looks really cool.Some stuff I'd like to see:- Pattern matching suppor	ristos	15.11071	-3.9721377	comment	5.0	29.0	1589371863	-10.418449
34062350	I thought lisp was supposed to be Ub	I thought lisp was supposed to be Uber functional. This code all looks very OO and imperative to me. It looks very intuitive.	gigatexal	15.123579	-3.9511251	comment	5.0	18.0	1671517727	-10.430323
34101160	Kind of amazing they are still a goi	Kind of amazing they are still a going business. I didn't realise any companies really used lisp for anything. I assume whoever is paying them money is doing so for some really niche or legacy?	morelish	15.144131	-3.9376245	comment	5.0	16.0	1671757865	-10.454345
26502568	So many programming languages poppin	"So many programming languages popping up like mushrooms overnight...That does it - I'm creating my own programming language (again) which is going to be a mashup of C++ and Lisp; I shall call it ""Thee-Pluth-Pluth""."	lelanthran	15.134328	-3.94711	comment	5.0	16.0	1616074874	-10.384752
26512384	Ask HN: Gnu Guile or Racket for Perf	Ask HN: Gnu Guile or Racket for Performance?	gypsyharlot	15.131175	-3.9578485	story	5.0	7.0	1616156172	-10.477437
26584752	I advise you to check Common Lisp CL	I advise you to check Common Lisp CLOS and Dylan.	pjmlp	15.154135	-3.9301898	comment	5.0	25.0	1616702803	-10.439437
27038201	This is really cool, I would love to	This is really cool, I would love to program my fleet of ESP8266s with anything but C. And I’ve been passively interested in using Lisp for many years. Using Lisp for my program as glue for the normal ESP C libraries would be awesome. I’ve read the documentation of uLisp a bit, two main questions remain:1. What’s the workflow? REPL for development is super cool, but how do I persist my programs? How does »flash this code onto the microcontroller« work?2. How can I interface with the large amount of C libraries out there? For example, uLisp does not provide an OTA library (for updating the software over Wifi), or one for MQTT. I don’t want to rewrite those myself, so how do I call existing C from uLisp?	quchen	15.136871	-3.944048	comment	5.0	20.0	1620139799	-10.420893
27141979	From the article:> But if you need s	From the article:> But if you need some complex algorithms — particularly algorithms that do a lot of heavy mathematical lifting — then Lisp is the ideal choice.Is this right? I never thought of LISP as good fit for numerical processing.	rowland66	15.138264	-3.9494376	comment	5.0	15.0	1620913396	-10.438872
27251265	Re: your edit, I've heard people say	Re: your edit, I've heard people say similar things about Lisp. I wonder if that applies to functional languages in general?	Karunamon	15.129334	-3.9652019	comment	5.0	18.0	1621727386	-10.421079
27281068	X has been the bane of McCLIM for th	X has been the bane of McCLIM for the last 20 years. It limited adoption and delivered horrible first impressions to not-hardened Lisp users / McCLIM developers: Basic-level functionality that's supremely important for a positive experience such as font rendering, absence of graphical glitches, tearing, smoothness and overall look&feel was bottom-of-the-barrel for very long periods of time. Maybe it still is, I don't know since I no longer use X.Hopefully that is about to change. Daniel Kochmanski seems willing to push McCLIM forward with alternative rendering backends. Moreover, Luke Gorrie (of SLIME and Distel fame) is working on an Emacs McCLIM backend: https://mobile.twitter.com/lukego/status/1387747747864973312	metroholografix	15.1054945	-3.948609	comment	5.0	21.0	1621969814	-10.393777
27296685	Is there anything new, since.... say	Is there anything new, since.... say 2014? Anyone familiar with the project care to comment on how viable a sicl is today, as a common lisp?	e12e	15.143622	-3.934925	comment	5.0	15.0	1622066667	-10.485057
27306500	And this is how LISP is invented.Any	And this is how LISP is invented.Any sufficiently complicated program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp. (Greenspun's tenth rule)	ktpsns	15.133271	-3.955403	comment	5.0	15.0	1622140710	-10.326313
27306842	A lot of shallow, smug snark coming 	A lot of shallow, smug snark coming into the comments section from people who know what s-expressions are and I guess want to brag about that for some reason. S expressions are cool but that's just _a syntax_, there are other possible syntaxes for expressions, and it's perfectly fine that somebody chooses to embed a language in JSON rather than s-expressions. Everyone suggesting to use Scheme or Clojure or Common Lisp and dropping the meme-quote that everyone eventually reimplements Lisp are missing the fact that this language is designed to be evaluated deterministically, so it does not support looping or functions and is Turing-Incomplete, unlike Clojure/Scheme/CommonLisp.	joshlemer	15.053771	-4.0460773	comment	5.0	31.0	1622142458	-10.445436
27310769	Well, also give up infix functions/o	Well, also give up infix functions/operators, operator precedence, readable equations, etc.Most Lisps have syntax anyways, in order to make the language less verbose.There's a reason people like syntax, because it is expressive.	smabie	15.104441	-3.990664	comment	5.0	18.0	1622165500	-10.395127
14726332	Professional and open source impleme	Professional and open source implementations of Common Lisp are stable but nonetheless under active development.Many hobbyists and professionals use Lisp to solve their problems and make money.IDEs are in a sorry state. If you're an Emacs user, you'll be happy. Otherwise, unless you spend hundreds of dollars for a professional IDE, you won't have much. Editing Lisp requires a good IDE.	reikonomusha	15.088714	-3.977559	comment	5.0	22.0	1499535760	-10.393723
14755251	I don't think it's as easy as that. 	I don't think it's as easy as that. In fact there's probably no single reason accountable for Lisp's lack of popularity. Here's my own personal pet peeve: Declaring local variables creates a level of nesting. Local variables are a great tool for improving code clarity. Having to wrap your logic with `(let [value (...)] ...)` in order make a new local variable is unnecessarily painful.	soberhoff	15.096328	-3.9991727	comment	5.0	20.0	1499884691	-10.338113
15229736	Whatever.I learned how to implement 	Whatever.I learned how to implement Lisp by reading the source code for multiple compilers. Started with Franz Lisp, then KCL and CMUCL. I don't feel that a toy interpreter is going to teach the same things.	rjsw	15.107957	-3.9718447	comment	5.0	16.0	1505239710	10.848566
15360045	I really wish the GNU project would 	I really wish the GNU project would standardise on Common Lisp rather than Scheme.  Lisp-2, false NIL, full-powered macros — Common Lisp has a lot going for it.An emacs written in Common Lisp, running in StumpWM, running atop a CL Guix, Shepherd & GuixSD would be a thing of beauty.	zeveb	15.149303	-3.9343405	comment	5.0	29.0	1506627207	-10.384468
15360236	About a year ago or so I was bitten 	About a year ago or so I was bitten by the Lisp and Smalltalk bugs, and since then I've become very interested in Lisp machines, particularly Symbolics machines running the Genera operating system.  I'm in my late 20's and thus I wasn't around when Lisp machines were in their heyday; however, I believe that it's sad how the proverbial baby (Lisp OSes such as Genera) was thrown out with the bathwater (Lisp machines) when Lisp machines were gradually replaced with Unix workstations in the late 1980s and early 1990s.  It would have been nice had Genera or another Lisp OS been ported to the x86 instead of Lisp users having to switch to Unix.  Sometimes I even dream of an alternative history where RMS embarked on a GNU-licensed Lisp operating system instead of GNU.I wonder what type of legal ch	linguae	15.131785	-3.9418235	comment	5.0	16.0	1506628779	-10.333816
15366796	This still doesn't solve the problem	"This still doesn't solve the problem of upstream security,
since it requires clients trust the Quicklisp repository
which is centralized rather than the individual package authors. The chain of trust is now bigger and more fragile.Quicklisp works by periodically pulling packages from their official (or unofficial) repos into a centralized repository controlled by Xach. Xach then creates a Quicklisp ""release"" based on the set of pulled packages.Quicklisp users end up pulling from Xach's repository rather than upstream directly.This PGP verification update only applies to the second path: Quicklisp user to Xach's centralized repository.In terms of actual security of Quicklisp, the situation is still not at all good, since Xach is using unsafe methods to pull code from upstream into his centr"	armitron	15.079319	-3.9668694	comment	5.0	21.0	1506703129	-10.370961
15464340	A Lisp that runs Python (2016)	A Lisp that runs Python (2016)	malloryerik	15.099277	-3.9894676	story	5.0	81.0	1507889243	-10.29654
15572385	Lisp, Scheme, and Racket and related	"Lisp, Scheme, and Racket and related languages have many distinct syntax forms, just like other languages. The syntax forms appear visually similar due to the use of parentheses, but the forms themselves are distinct.For example, here are some of the distinct syntax forms in Racket (Scheme):    (+ 3 4)                  # Procedure call
    (lambda (x) (+ x x))     # Lambda expression
                             # See also case-lambda
    (let ((x 23) (y 42))     # Variable binding
         (+ x y))            # And also:
                             # let*, letrec, letrec*, let-values,
                             # let*-values, let-syntax, letrec-syntax, local
    (set! x 4)               # Assignment (mutating)
    (define x 23)            # Defined value
    (define (f x)            # "	jcrites	15.144706	-3.9502087	comment	5.0	20.0	1509139852	-10.411728
15592756	Please forgive some ignorance here, 	Please forgive some ignorance here, but I thought that LISP couldn't have a proper type system since it would muck with homoiconicity.  Clearly I'm wrong about this, but now I'm curious why more LISPs aren't typed.Can anyone here enlighten me?	tombert	15.13571	-3.9668345	comment	5.0	18.0	1509453671	-10.336321
28722835	Is it weird that I don’t like Common	Is it weird that I don’t like Common Lisp at all but I like Scheme a lot? I just never liked Lisp 2s and separate name spaces for functions and variables. But really that is the biggest issue for me. I’m sure if only Common Lisp existed it wouldn’t bother me at all.That being said, I think CL is a fantastic language and there is a lot more libraries out there to do useful things than in scheme. My C programming is really weak so I find it challenging whenever I come across a library in c that isn’t already wrapped	Decabytes	15.136324	-3.9480937	comment	5.0	19.0	1633118732	-10.464584
28728200	That's my personal opinion, but I th	"That's my personal opinion, but I think that programming language pages should have more information density. I also think that using your average ""startup template"" for Common Lisp is a bit weird. A good example of what I like might be the OCaml homepage https://lisp-lang.org/, the Go homepage https://golang.org/. The Haskell homepage has a REPL with a tutorial, which encourages you to play around with the language, I think that's a good idea https://www.haskell.org/. TypeScript's page is also nice https://www.typescriptlang.org/. For something a little bit different, Dhall is also good at quickly demonstrating how it works https://dhall-lang.org/.That might just be a consequence of my time on Hacker News, but I think the insistance on Paul G"	Zababa	15.138897	-3.9493513	comment	5.0	18.0	1633179219	-10.430763
28915478	Ask HN: Do you still use JSP?	Ask HN: Do you still use JSP?	roschdal	15.1123085	-3.977165	story	5.0	7.0	1634626208	-10.470398
28961987	Kina Knowledge, using Common Lisp ex	Kina Knowledge, using Common Lisp extensively in their document processing stack	p_l	15.136872	-3.9410727	story	5.0	192.0	1634932911	8.319007
28963788	I can’t imagine the choice of langua	I can’t imagine the choice of language being strongly correlated with programmer skill (it would be elitist to think so, and everybody feels best in the language they spend the most time in).I think C) Lisp is well suited to certain applications, from what I can see, web development or niche areas where exploratory programming is required. The downside of Lisp is lack of good GUI (CAPI is the best they can offer, but this is not as good as other language implementations for various reasons) and not having the backing of Apple, Microsoft, Google or Facebook, and thus lacking in APIs.But given its dynamic development (its a real joy), its very well suited to exploratory programming.Web Development is an undiscovered gem for Lisp. It doesn’t face the issue of GUI / lack of APIs, since you can	math-dev	15.132973	-3.9567003	comment	5.0	24.0	1634943541	-10.452849
28966966	> The only language where macros are	> The only language where macros aren't just C's #define to replace text. You're working directly with the ASTIt's hardly the only such language. In my experience, Haskell, Rust, Common Lisp, and Scheme all have macros that operate by syntax trees rather than text substitution, and I have no doubt that there are several more that I'm not aware of.	thewakalix	15.044832	-4.0409675	comment	5.0	21.0	1634981741	-10.21731
28980074	Wow, mouse-over the Lisp code in thi	Wow, mouse-over the Lisp code in this article.  The coloring of nested expressions is awesome.  I wish my editor could do that.	tempodox	15.100118	-3.983747	comment	5.0	18.0	1635096529	-10.354119
29006736	Lisp probably was invented in the ag	Lisp probably was invented in the age of the typewriter.If you look at mathematical notation, written with quill pens and paper…it’s even more concise. Functions are like lisp, f(x). Vectors are laid out on the page in an array and surrounded by two strokes. Matrices are a 2d array surrounded by two straight lines.This whole approach seems as archaic as Roman numerals is for representing numbers (they were based on lines and slashes like a tally system).Maybe there is an even better notation for representing code which will be as much a leap forward as the positional number system (which represents every number as a power series with base 10) was to numbers.	hasmanean	15.129521	-3.959405	comment	5.0	21.0	1635284767	-10.431743
29008339	I started my programming in the more	"I started my programming in the more ""traditional"" way i.e., C/C++ and then later python. When I started doing python, I was flabbergasted to find that I could just do 100**100 and get a complete number without using any additional libraries. Similarly, reversing string was trivial using the [::-1] notation. Heterogeneity of Lists, Dictionaries and the resulting versatility blew my mind. I now understand that I was discovering, at that time, what dynamic language had to offer over static languages.I say all this because I would really like some great examples and use cases which would sort of highlight what LISP has to offer over the, for the lack of a better word, non-LISP languages. All of the articles that pop up in hacker news or other portals only seem to highlight the fact that LISP "	pddpro	15.124067	-3.9657753	comment	5.0	16.0	1635295453	-10.451011
29107859	Ah, but Javascript is a profoundly t	Ah, but Javascript is a profoundly terrible language to do anything in, while Lisp is a joy to write in.Being a Lisp machine is core to the value of Emacs.  Emacs-without-Lisp is just another editor.	eadmund	15.041417	-4.026207	comment	5.0	17.0	1636037199	-10.337299
29159258	Elisp is a really poor language comp	Elisp is a really poor language compared to almost anything else, more work should be done to allow Emacs to be configured in other languages.	deworms	15.096729	-3.948639	comment	5.0	19.0	1636448200	-10.364838
29292522	Ironic, considering that Stephen Wol	Ironic, considering that Stephen Wolfram insisted in the 80s that Lisp was 100x slower than C, and so a fast mathematics package could not be written in it.	bitwize	15.13765	-3.9534466	comment	5.0	21.0	1637448592	-10.401202
29309082	Condition Handling in the Lisp Langu	Condition Handling in the Lisp Language Family (2001)	Jtsummers	15.126858	-3.96326	story	5.0	52.0	1637602259	-10.429481
25531871	Vacietis, a C compiler targeting Com	Vacietis, a C compiler targeting Common Lisp	reikonomusha	15.125232	-3.9611928	story	5.0	97.0	1608847387	-10.382631
25562553	I think I understand the sentiment o	I think I understand the sentiment of the above commenter. I feel it with Lisp too.There are amazing claims about how Haskell (or Lisp or Erlang or ...) give you these amazing superpowers and allow you to write immensely more correct programs immensely faster. That could be true (and I personally do believe it’s true). But then where are all of these immensely-correct fast-written programs? I don’t buy the pg-inspired secret-weapon lurking-in-the-shadows argument unfortunately.In C, C++, Java, and Python—even Pascal!—it’s not even funny how many examples there are. It’s nearly limitless. The superpower languages struggle to come up with just a handful of examples.What I personally observe in the Lisp and Haskell world is that people like to write purportedly useful “reusable” libraries, an	reikonomusha	15.132494	-3.9687696	comment	5.0	23.0	1609185164	-10.449811
26070651	I just don't get the appeal of Lisps	I just don't get the appeal of Lisps. They look so ugly and the syntax seems crazy((((((((((((((((( by the way	pid_0	15.13871	-3.9522967	comment	5.0	18.0	1612820999	-10.414002
26261098	Static Executables with SBCL v2	Static Executables with SBCL v2	todsacerdoti	15.12638	-3.944196	story	5.0	113.0	1614244260	-10.416521
26262545	Back when I programmed in CL and par	Back when I programmed in CL and participated in comp.lang.lisp, the topic of Static Executables was a recurring thing. I never understood why people were so obsessed with it, but somehow this became the Major Showstopper for wider CL adoption, in the eyes of some users.Most people who actually used CL for building stuff were somewhat amused, and tried to find out what was so important about encapsulating everything into a single executable and why other languages didn't have to do it, but CL absolutely did.I thought this was a red herring, but indeed for some reason it did affect acceptability. Glad to see a solution that looks fairly good.	jwr	15.071123	-4.0050397	comment	5.0	25.0	1614260073	-10.202009
13888407	One of the things that slows me down	One of the things that slows me down is that whenever I see Lisp code, my mind goes to the equivalent Haskell code, and the comparison is basically never favorable.I'm a firm believer in the value of learning a functional language, and I totally understand that from a historical perspective Lisp is important, but does it really have much to recommend it over modern functional langauges?	nolemurs	15.117925	-3.987508	comment	5.0	16.0	1489693046	-10.474192
13951006	I've always wondered why LISP was su	I've always wondered why LISP was such a hot-topic of discussion for CS people. I'm not technical myself, but the idea of different computing languages being more/less efficient in certain tasks is interesting.I don't know how valid this is, since I've only spoken with a handful of Lispers, but it seems that they appreciate the freedom and lack of boundaries/rules/limits that Lisp provides. They talk about it like a language that can do anything, because it has no rules on what it can or cannot do.But at the same time, my friends also remind me that the lack of limits means that they are more accountable for every line of code, and that as a beginner, it'd be best for me to use something more structured (they always say Python) until I'm comfortable taking off the training wheels.Can anyon	acalderaro	15.133777	-3.9593766	comment	5.0	23.0	1490379617	-10.436162
13980113	Some notes based on my (brief) exper	Some notes based on my (brief) experience toying with Common Lisp:* Why hasn't anyone made a more eye-frendly version of the Common Lisp Hyper Spec ? Having good, easily-browsable documentation is a core-problem.* The relation between the various native data-types were quite unclear to me.* dealing with the external world was quite a mess. Many project/libraries implementing only half of something and then got abandoned.* some libraries had a compatibility matrix... with common lisp implementations. that seemed weird to me.	znpy	15.147578	-3.9426122	comment	5.0	19.0	1490731151	-10.458051
14145297	Lisp macros for C	Lisp macros for C	wooby	15.084081	-4.007585	story	5.0	113.0	1492573656	-10.3208275
14244641	Simplified Common Lisp reference	Simplified Common Lisp reference	macco	15.134154	-3.9512763	story	5.0	74.0	1493710825	-10.484185
14368319	Writing a Lisp: Continuations	Writing a Lisp: Continuations	reinvdwoerd	15.127987	-3.9642124	story	5.0	136.0	1495123004	-10.346331
14480712	All this poetic non-sense about flex	All this poetic non-sense about flexibility and writing prototype programs is irrelevant. Lisp has real technical flaws that prevent its use:1.GC that prevents it from using real-time and performance-oriented code.2.Pervasive use of inefficient lists and dynamic typing, which puts steep memory requirements on top of performance costs.3. Arcane write-only syntax which becomes context sensitive with Domain-Specific Languages which Lisp programs devolve to, creating unreadable and overly condensed spaghetti code(especially macros), making existing code inaccessible for developers.4. Huge runtime which is embedded in every executable, that makes it less competitive with scripting languages. Lisp requires eval() and runtime interpretation which other languages optimize out and replace with fixe	FrozenVoid	15.12832	-3.9648457	comment	5.0	62.0	1496572343	-10.420309
14511355	I've been working on a Lisp for the 	"I've been working on a Lisp for the last couple of years. There's one major downside to reader macros / syntax extension: Your editor probably won't understand it, and in extreme cases won't know how to indent or read it.Note that Lisp macros do not suffer this problem because it still uses the standard `'(,""foo"") syntax. (In fact it's somewhat remarkable that Lisp syntax can be described in shorthand so compactly.)Reader macros are a different beast. Let's say you want to add support for [] as indexing. You can do this:  > (let l '(a b c)
     l[1])
  ""b""

And this:  > (let l '(a (b) c)
      l[1][0])
  ""b""

And since the reader is under our control, it's easy to use a dynamic expression as the index:  > (let (l '(a (b) c)
          i 0)
      l[(+ i 1)][i])
  ""b""

If you try this, you'll"	sillysaurus3	15.101673	-4.0000706	comment	5.0	24.0	1496887529	-10.388563
14582142	> It's solving a problem people don'	"> It's solving a problem people don't really have.Isn’t ""I want to script Emacs but I don’t like LISP"" a problem to solve?"	hk__2	15.1296625	-3.9553523	comment	5.0	39.0	1497811375	-10.412116
14609526	I keep hearing this kind of talk abo	I keep hearing this kind of talk about lisp. I've never actually written anything in it, but if you asked me why, it would have nothing to do with parens or syntax. It has everything to do with the fact that, for most purposes, Python suits me just fine, and for almost all other purposes, I want a language that compiles to machine code.Lisps just don't bring much to the table. Their dynamic-ness brings overhead that is not justified unless you're doing crazy macro stuff, and ad-hoc crazy macro stuff is not easy to put into code without hurting readability and comprehension.	Retra	15.114593	-3.9824803	comment	5.0	22.0	1498095642	-10.337623
23731142	If you're starting from scratch, why	If you're starting from scratch, why not design a new Lisp? CL has never struck me as a particularly inspired language, and neither has the kind of code people write with it.Or, if the idea is to leverage existing CL code, I'm sure with a little bit of effort SBCL could run as a unikernel and provide a good base for the system.Awhile ago there was a standalone Lisp implementation called Movitz. What are your thoughts on that?	smabie	15.129721	-3.9495716	comment	5.0	28.0	1593853946	-10.415515
23731306	> why not design a new Lisp?Hell no.	> why not design a new Lisp?Hell no.  Here is why:1. The Common Lisp standard is brilliant.  If your new Lisp is designed by anything less than a committee with people like Kent Pitman, Guy Steele, and Richard P. Gabriel, chances are that you will end up with something worse.2. Common Lisp has one feature that people often forget about, but that is crucial for an operating system - you can rely on the fact that the semantics doesn't change.  Lisp programs written in 1960 can usually be run on today's Common Lisp without modification, so there is hope that programs written today will still run properly even in centuries.3. Common Lisp has the most powerful object system and the most powerful condition handling system.  Both these features are invaluable for an operating system.  This is act	heisig	15.097247	-3.9955978	comment	5.0	23.0	1593856811	-10.482118
24387166	I always wondered why we rarely see 	I always wondered why we rarely see more efforts like an LLVM based Lisp or Scheme language, especially when some projects like Racket are looking to improve performance by switching their runtimes (and I assume other benefits that come from consolidating underlying programming efforts across multiple projects).	giancarlostoro	15.132502	-3.9556396	comment	5.0	22.0	1599342977	-10.496111
20071357	Of course if you'd use Lisp in the f	"Of course if you'd use Lisp in the first place you could make a new syntax to input those things in the visually safest manner without waiting for a language revision.Compile-time computing is precisely about this, e.g. 
https://medium.com/@MartinCracauer/a-gentle-introduction-to-..."	cracauer	15.115427	-3.9734714	comment	5.0	22.0	1559419857	-10.364177
20071756	Note that this appears to be yet ano	Note that this appears to be yet another Webkit shell, and not an implementation of parsing/rendering pages in Lisp.	userbinator	15.094819	-3.9691727	comment	5.0	25.0	1559423831	-10.380035
20195740	Cl-cpp-generator – A Common Lisp lib	Cl-cpp-generator – A Common Lisp library to generate C/C++ code	eatonphil	15.115309	-3.96231	story	5.0	60.0	1560696758	-10.25967
20207532	I guess this applies for Java and C+	"I guess this applies for Java and C++ style ""classes"". This does not precisely apply to the first ANSI-standardized OOP system, Common Lisp's. Standard classes do not own methods, instead methods are specializations of a generic function that stands alone and dispatches on the class types (or EQL values) of all its arguments.I'd really like it if Uncle Bob eventually has his fill of Clojure and moves on to explore what Common Lisp built decades earlier, then blogs about that too."	Jach	15.1213875	-3.9793785	comment	5.0	17.0	1560806636	-10.488965
20311817	The Evolution of Lisp (1993) [pdf]	The Evolution of Lisp (1993) [pdf]	steven741	15.149758	-3.9361672	story	5.0	91.0	1561804395	-10.43571
20358163	I'm new to LISPs. What's the differe	I'm new to LISPs. What's the difference between LISP-1 and LISP-2?	wishinghand	15.143039	-3.9469457	comment	5.0	25.0	1562277852	-10.444788
20377200	Lisp, as McCarthy proposed it in 195	Lisp, as McCarthy proposed it in 1958, actually had an alternate syntax called M-expressions that would be perfectly readable to any JavaScript programmer: (foo a b) became foo[a,b].It never took off. From the earliest days -- before video terminals were a thing, let alone video-terminal editors that could match parens and indent automatically -- people just preferred working with sexprs. I think it has to do with the fact that while mexprs are easier to read with prior ALGOL experience, sexprs are easier to transform, and to reason about their transformation.I think Lisp is one of those things where, you either get it or you don't, and once you do get it parens are a non-issue. There's a fundamental leap of insight that requires enormous activation energy to achieve.	bitwize	15.10841	-3.989485	comment	5.0	23.0	1562527512	-10.397619
20516351	Tutorial on Good Lisp Programming St	Tutorial on Good Lisp Programming Style (1993) [pdf]	fanf2	15.138601	-3.9445167	story	5.0	121.0	1563982983	-10.40784
20521482	> to write code for human readers fi	> to write code for human readers first, and compilers second.I find this very ironic in this context. After all lisp is a language where the human does half of the job the compiler is doing, because you need to write directly in AST instead of higher level language.	zaro	15.125897	-3.9662619	comment	5.0	24.0	1564013900	-10.378365
20606941	No one actually likes the parens of 	No one actually likes the parens of Lisp. I mean, just look at Racket2. Even the dedicated lispers who work on Racket think they suck.I’ve written both Racket and Common Lisp professionally and consider myself very competent in both. In fact, I think they’re both great languages and one of the best around.It’s not because of the parens though, it’s because what the parens give you: namely homoiconicity and easy macros.Without these things, the increased syntax burden of parens don’t buy you anything except visual noise and being forced to type extra characters.	mruts	15.128113	-3.9682307	comment	5.0	28.0	1564931110	-10.334786
20614878	I don't know why no one seems to thi	I don't know why no one seems to think about symbolic programming which was the original killer feature of lisp, and one of the main reasons for doing macros.In math oriented programming this should be one of the most powerful features and skills in order to simplify and modify calculations. Sure you can implement that with macros and AST but that is not at the level of S-Expressions.Everything else is not more important as any other competition of DSLs.	nudpiedo	15.11815	-3.9797297	comment	5.0	18.0	1565018506	-10.357942
20614888	Common Lisp folks should really star	Common Lisp folks should really start designing a more modern version of CL.I'm pretty sure some old Lispers would come and say, 'Common Lisp's stability is a great feature', 'There are lots of new dialects', and while they are right in some aspects, Common Lisp isn't appealing to anyone these days. (I mean, even C and C++ is improving. Why shouldn't CL?)Even for people who 'get' the ideas of s-exps and macros, there are too many quirks in CL to appeal to people, and most go to Clojure (where the interactive experience is at best moderate, debbuging support/error handling is a mess, e.g.).I believe the hypothetical CL++ should at least:* Straight out incompatibilites between implementations, especially the numerous opinions to make an image or binary, and the FFI parts.* Design a better CL	pcr910303	15.106057	-3.998842	comment	5.0	39.0	1565018615	-10.618137
20669336	"How about ""defining"" homoiconic to m"	"How about ""defining"" homoiconic to mean that it's easy to manipulate programs? More specifically, say a programming language is homoiconic if (1) the standard library for the language includes a parser, and (2) the parser returns data structures that are easily manipulated by functions in the standard library.Point (2) can be achieved by having the parser return generic data structures such as lists, arrays and hashtables for which the standard library will probably have lots of convenient functions (this what Lisps do); or by having a dedicated AST data type, but including a bunch of AST manipulation functions in the standard library (like Template Haskell).Of course, this isn't a very precise definition because it relies on the undefined terms ""parse"" and ""easily manipulated"". Does read_"	omaranto	15.107851	-3.9902394	comment	5.0	25.0	1565545380	-10.383859
20695550	Visible Lisp Computer	Visible Lisp Computer	lispm	15.136922	-3.9363039	story	5.0	97.0	1565790829	-10.40801
20697414	"The post quotes McCarthy:""one of the"	"The post quotes McCarthy:""one of the myths concerning LISP that people think up or invent for themselves becomes apparent, and that is that LISP is somehow a realization of the lambda calculus, or that was the intention. The truth is that I didn't understand the lambda calculus, really"" - John McCarthySo there are a two issues here, 1) whether or not it was McCarthy's intention to realize the Lambda Calculus in LISP, and 2) whether or not LISP is such a realization. Or at least some kind of close realization.The answer to 1 is clearly no. This doesn't imply an answer to 2 one way or another.If 2 isn't true, what explains the widespread belief? Is it really just that he, McCarthy, borrowed some notation?"	vga805	15.136207	-3.95745	comment	5.0	66.0	1565801773	5.6903625
20733134	But in the last 60 years, simply gra	But in the last 60 years, simply grab­bing these dissenters by the lapels and fumi­gating them with the stinky garlic breath of paren­the­sized S-expres­sions has not been a winning strategy.If Lisp parti­sans want different results in the next 60 years, we need to try some­thing new.Given the rapid increase in programmers across the globe, I'd bet on there being more LISP programmers now than at any other time in human history. So why the obsession with popularity?	lacampbell	15.145001	-3.9470868	comment	5.0	24.0	1566164822	-10.462547
20820798	Does anyone in the HN crowd know of 	Does anyone in the HN crowd know of any other brand-name orgs using Lisp?	reaperducer	15.137419	-3.9376764	comment	5.0	22.0	1567006391	-10.457586
20837214	Lisp as a Vehicle for Rapid Prototyp	Lisp as a Vehicle for Rapid Prototyping (1997)	deepaksurti	15.129614	-3.9476216	story	5.0	78.0	1567159810	6.1115527
14663867	If you want your brain stretched, I 	If you want your brain stretched, I recommend Common Lisp.The #1 issue for folks in my experience had been getting an environment set up. Emacs, SLIME, encodings, paredit, ... . It's a big barrier to entry.	reikonomusha	15.10976	-3.959492	comment	5.0	25.0	1498748757	9.058271
31183920	I don't like REPL driven development	"I don't like REPL driven development. REPLs are celebrated as some sort of achievement in interactivity, but they're hopelessly puny, barely imitating a UNIX shell.When I write Emacs Lisp, I don't have a REPL. I just put point at the end of a random s-expression in a random Emacs-mode buffer, hit C-x C-e, and it gets evaluated. Or I do ""eval-print-last-sexpression"" to get the output on the next line. If I put my emacs in an org-mode code block, I'll get the output nicely formatted by org-mode. I can get close to this in Common Lisp with SLIME, but I've never found it as tight as Emacs Lisp.But Emacs lisp is still puny. Common Lisps had much higher aspirations than SLIME and a crappy UNIX-based Lisp executable. Allegro and Lispwerks still run on the philosophy that your IDE is just some liv"	momentoftop	15.072691	-4.0033803	comment	5.0	27.0	1651084362	-10.598701
31183993	What are people using LISP for? Othe	What are people using LISP for? Other than the Emacs flavor, and some companies using Clojure, I'm not really sure what I'd use it for?  Would I use it to replace Python or Shell scripting for my custom CLI tooling?  Anyway, I've seen a lot of people talking about the Lisps lately, and trying to figure out what I'm missing.	taude	15.12498	-3.974142	comment	5.0	16.0	1651084633	-10.608029
31242479	Can someone help me understand the b	Can someone help me understand the benefits of a Lisp or Lisp-like language? To me they feel overly verbose and make it more difficult to read code. What is the point of all the parentheses? I get that other languages have some weird syntax, but Lisp seems masochistic. Is there some actual advantage or purpose to it?	encryptluks2	15.1224985	-3.9759235	comment	5.0	19.0	1651534187	-10.3909855
31257740	I always thought the main reason lis	I always thought the main reason lisp did not become the world's dominant language (or, at least, dominant language with garbage collection) is that writing(/ (+ (- b) (sqrt (- (* b b) (* 4 (* a c)))) (* 2 a))is a pain in the neck, and even more so when you have to read it, while(-b + sqrt(b*b - 4*a*c))/(2*a),can be checked on the fly.I am kind of amazed this hasn't finally sunk into programmers' hearts.	casualrandomcom	15.124254	-3.9675472	comment	5.0	15.0	1651649514	-10.435132
31291215	Roll a Lisp in C – Evaluation	Roll a Lisp in C – Evaluation	swatson741	15.131736	-3.9516158	story	5.0	86.0	1651885263	-10.371068
31637723	I'm wanting to learn lisp, can someo	I'm wanting to learn lisp, can someone eli5 metaprogramming?	account-5	15.149483	-3.9379861	comment	5.0	27.0	1654496587	-10.428194
26470868	The Emacs community, like the Lisp c	The Emacs community, like the Lisp community with which it overlaps, is very conservative, in the sense that it doesn't throw things away quickly or make huge changes lightly.  For that reason, I'd be very surprised if this took off — even though it sounds like it would be mostly backwards-compatible.  I think Emacs types would shy away from building JavaScript into their editor, having V8 be the engine, adding more layers of abstraction to understand and maintain, and splitting the extensions between Emacs Lisp and JavaScript.  I'm also not convinced that a significant part of the community really wants this.	JasonFruit	14.974968	-4.059794	comment	5.0	66.0	1615851776	-10.397287
35552197	Strongly disagree. SBCL is not embed	Strongly disagree. SBCL is not embeddable. It produces huge binaries. Managing and versioning dependencies is very difficult.Newer dialects like Janet and Fennel address these deficiencies.	BaculumMeumEst	15.127449	-3.9437377	comment	5.0	18.0	1681370963	-10.368348
35726033	Learn C and build your own Lisp (201	Learn C and build your own Lisp (2014)	pelasaco	15.134319	-3.9513352	story	5.0	151.0	1682591951	-10.377938
35830316	Does anyone have any other free Comm	Does anyone have any other free Common Lisp book recommendations?I decided to give CL a try after reading about REPL-driven development, especially CL’s interactive condition/debugging experience. I’m almost done going through Practical Common Lisp. It’s been a fun experience so far!Edit: thanks, everyone!	schemescape	15.146341	-3.9385617	comment	5.0	18.0	1683299768	-10.450884
35855415	You could write safe-ish C++ and Rus	You could write safe-ish C++ and Rust that is both readable and fast.Could you point me to some benchmarks of Lisp being comparable to C?Also, unless I am mistaken, Common Lisp doesn't have strong types. How can you make either fast or safe language without compiler knowing the types?	eterevsky	15.107943	-3.977331	comment	5.0	18.0	1683491917	-10.380081
36017110	I really don't understand how this c	I really don't understand how this company fell so far from grace. Their product was excellent. Don't get me wrong, I've read the history and understood how they failed to pivot from hardware Lisp machines, but they have completely vanished without even chugging along as a legacy systems provider (think OS/2).Does any of their influence survive in modern hardware or software design? I hardly ever see Genera cited.	thrtythreeforty	15.134618	-3.942425	comment	5.0	23.0	1684631772	-10.399179
36043102	As a rule of thumb, I find that the 	As a rule of thumb, I find that the quality of a language’s LSP server is strongly indicative of how suitable that language is for a serious software project.If you’re curious about what that means for Haskell, try opening a Haskell project, starting LSP, and hovering a few variables while watching the HLS process’s memory usage.	BaculumMeumEst	15.123119	-3.9754684	comment	5.0	34.0	1684843362	10.361332
36155815	Hygienic macros and a strict phase s	Hygienic macros and a strict phase separation are not distinctive to scheme, many languages have this now, most importantly Rust. And just like Rust macros scheme macros are not really an organic part of the language but some extra edifice bolted on top. Scheme definitely deserves credit  for pioneering work here, but the only aspect that's of enduring distinctiveness that I'm aware of is Racket's #lang, which basically gives you a less messy and more powerful version of what you could do in Common Lisp with macros and read-tables.My impression is that hygiene itself (which the scheme community tended to obsess over) is of minor practical benefit, but the fact that you get good error locations (because not using plain lists and symbols makes it easy to carry sufficient contextual informati	patrec	15.122715	-3.9825017	comment	5.0	16.0	1685646214	-10.298297
36239944	I once wrote a tiny DSL language. I 	"I once wrote a tiny DSL language. I used LISP (S-Expressions with parenthesis) because it semantically fit and made the parser much easier to write. I was laughed at and ridiculed by my peers. Everyone hated it that I had to attempt two other language styles just to compensate.
I had a chuckle seeing fe syntax is LISP like and I was like “See? I’m not the only one.” Many just can’t give LISP and S-Expressions their due regard. Same for Reverse Polish Notation. I was born on the wrong planet."	sirsuki	15.098296	-4.0047903	comment	5.0	22.0	1686222706	-10.299726
36519663	"""It can generate an executable"" ; bu"	"""It can generate an executable"" ; but how slow will this executable be ? Compared to something compiled with SBCL or a non-LISP ?"	phtrivier	15.124201	-3.955764	comment	5.0	47.0	1688042872	-10.367559
36545207	What is the dominant flavor of Lisp 	What is the dominant flavor of Lisp these days?	tiffanyh	15.151995	-3.934603	comment	5.0	40.0	1688174473	-10.443711
34181401	Honestly I think that for many, Fort	"Honestly I think that for many, Forth may be a bit too much of a green field to build upon.Out of the box, out of the standard, there no real structured data type ala records, there's no strings, there's no modular coding construct. All of those can be added, but that's the trick. They have to be added. You also start getting into implementation specific stuff that, potentially, makes that kind of infrastructure not portable across implementations.Not that portability is a huge concern, but it's a factor if you want to import someone else's implementation.All of that can be overcome, but that they have to be overcome is part of the problem. Original scheme suffered from this as well, but look how far it's come over time. To the point that all ""usable"" schemes aren't really the 50 page R5RS"	whartung	15.125571	-3.9483943	comment	5.0	15.0	1672370361	-10.433412
34326897	From just reading the TOC, and the f	From just reading the TOC, and the first bit, this looks great. Like the author, I have been into Common Lisp “forever.” I do sometimes feel conflicted when I can get something done in Python much faster because I can find a library that solves the problem I am working on. Probably my most honest advice to people is that Common Lisp is very good for research programming, but for many use cases other programming languages are better.	mark_l_watson	15.126646	-3.9616857	comment	5.0	20.0	1673366608	-10.420265
34414968	I've been learning lisp this past we	"I've been learning lisp this past week. I think I get the main idea of ""code is data and data is code"", but I struggle to understand how it's more powerful than, say, making a function factory in Python."	halkony	15.125337	-3.9739718	comment	5.0	22.0	1673974602	-10.449986
34419067	Maybe I've just been blind to it but	Maybe I've just been blind to it but feels like CL has been getting mentioned more on HN lately (I do remember the early days when Lisp/Scheme/Arc were mentioned a lot since this site runs on Arc). Actually gone through some of that Common Lisp the hard way that was linked here not terribly long ago.	runevault	15.144739	-3.9433446	comment	5.0	34.0	1673989396	-10.508499
34909393	I just spent months working on a lar	I just spent months working on a large piece of software and could say without a doubt, Lisp is awesome! But I also want to say that most implementations are hashing out a spec written decades ago and not trying to improve what's obviously lacking -- a full modern standard library! Trying to piece together functionality from here and there (and Quicklisp which is an unversioned mess) will only take you so far and in the end you will realize the amount of time wasted chasing this great language! AFAIK Lisp needs more backing from the heavyweights to make any reasonable progress which I'm sure won't happen.	u89012	15.130426	-3.9525523	comment	5.0	29.0	1677153856	-10.423739
34909570	The commercial aspect is not a probl	The commercial aspect is not a problem in my opinion (but again english is not my main language so I might have conveyed the wrong tone). The issue is the pricing model which may work for established company ready to invest money from the start, but is simply out of touch with independant developers and small companies exploring the possibility of using Common Lisp.Open sourcing Lispworks and selling support contracts and an enterprise version (with CAPI, CORBA, etc.) would make more sense. The world has changed: all other languages have open source implementations; most servers are open source, most databases too. It is hard to convince a company to use Common Lisp, but even harder to justify paying for a proprietary implementation.And for me personally, Lispworks would force me to buy tw	galdor	15.13387	-3.941663	comment	5.0	46.0	1677155276	-10.416654
34909678	I would like to learn Lisp but am ea	I would like to learn Lisp but am easily confused with where to start. What implementation do I use? On a general level do I start with CL, schema, racket, etc (apologies I know this thread is about common lisp). It's all very confusing.I'm like this with most things, like I want to learn Forth too but have that same problem. I learned vanilla JavaScript because I didn't know where to start with the 1000+ frameworks; and as a result am learning flutter/dart for cross platform apps.Any advice would be much appreciated!	account-5	15.149632	-3.9345255	comment	5.0	28.0	1677156094	-10.520235
35033741	This seems like an easy fix, re-rele	This seems like an easy fix, re-release LISP with cleaner syntax. Lexers have come so far this seems like an easy fix.I can't say i've ever read the opinion that LISP's syntax allows more expressive programming; rather LISP itself allows more expressive programming at the tradeoff of the syntax.	CrimsonCape	15.1202135	-3.9712114	comment	5.0	21.0	1678048958	-10.347456
35129898	I know the basics of Emacs as an edi	I know the basics of Emacs as an editor, and I understand that it is possible to use Lisp to extend it, but I have not come in contact with a good resource to teach me the fundamentals of how to do so. I know a bit of Lisp, I am more curious about how to expose the existing interfaces (API), where and what to look for. Does anybody have any suggestions? I like learning more by seeing somebody do it than by reading reference documentation if that helps.	jwrallie	15.111734	-3.9567459	comment	5.0	15.0	1678673370	-10.44461
35131256	Emacs Lisp is probably the worst lan	"Emacs Lisp is probably the worst language for ""programming in the large"". (After Javascript.)Sorry, but it has to be said. Using a more sane language would cut down on the bugs and dependency problems in Emacs in a huge way.P.S. Been using Emacs for over 25 years."	otabdeveloper4	15.077931	-4.0000486	comment	5.0	32.0	1678683303	-10.386101
39376323	Package management kind of sucks, th	Package management kind of sucks, the ecosystem sucks, other languages continually improve but nobody will ever advance the CL standard. There is nothing compelling about the language to people who aren't already Lisp people.	BaculumMeumEst	15.1117	-3.9740682	comment	5.0	19.0	1707948850	-10.369678
39380581	> I think you might be on to somethi	> I think you might be on to something. Symbolics was very much in danger of making large software projects possible by one person or a small team of people. It seems as if the corporate world has responded to the proliferation of more powerful software development tools -- not only in Lisp, but certainly Lisp and Smalltalk had an outsized influence -- by lowering the skill ceiling to make devs more fungible, and creating more and more process to hobble their productivity so as to justify larger teams of devs and dev-adjacent personnel: PMs, POs, scrum masters, etc.This is a ridiculous LISP conspiracy theory that really needs to die. What world are you living in that corporations actively want their employees to work slowly or to have too many employees? Who does that benefit?If lisp were 	Capricorn2481	15.138985	-3.946232	comment	5.0	21.0	1707988200	-10.410461
39453887	Seems cool. But I'm not convinced ex	Seems cool. But I'm not convinced extensible languages benefit from adding a variety of syntactic forms. As your ability to extend the feature-set increases, the need for a single regular syntactic form increases. Lisp may not be appealing to beginners because of its parenthesis, but they absolutely are what makes it work so well for its intended use cases.Really, all use cases. I'm actually a fan of the parenthesis. Lisp feels like aesthetic perfection to me. Languages like Haskell and XL here just look like line noise to my brain.	netbioserror	15.121099	-3.9798417	comment	5.0	35.0	1708524064	-10.432522
39490341	Only tangentially related; but tree-	"Only tangentially related; but tree-sitter, lsp and friends are actually some of the most exciting developments for lisp programmers because we are finally seeing a model where Emacs and IDE support for lisp can properly decouple. One of the in-practice problems I've seen a lot of in Clojure is that people aren't sure how to get a REPL set up and all the local experts are using Emacs. Which is lovely but ""you'll need to learn Emacs for me to be able to set you up!"" is not exactly the battle cry of easy adoption."	roenxi	15.126086	-3.9723628	comment	5.0	18.0	1708767306	-10.695039
39655535	This made me think of Kernel, a prog	This made me think of Kernel, a programming language of the Lisp family where the main primitive is vau rather than lambda, defining a fexpr rather than a function.Juste like lambdas, fexprs are lexically binded closures. The difference is that a fexpr arguments are not evaluated before it's called, instead, the arguments syntax is passed to the fexpr (so it's not call-by-name either, more like a macro), except that the fexpr also receives the dynamic environment (the one from the call site) so that it can eval its arguments in this context if it wants to.This makes fexpr a kind of all powerful form that can do both what macros and functions can do. Even primitives like lambda or quote can be written as fexprs. Quite fascinating.See https://web.cs.wpi.edu/~jshutt/kernel.html about Kernel :	p4bl0	15.12268	-3.9781184	comment	5.0	26.0	1710027635	-10.337783
38964465	How does it compare to Lisp for symb	How does it compare to Lisp for symbolic programming?	Zambyte	15.135973	-3.9541852	comment	5.0	17.0	1705038864	-10.489777
32628812	Common Lisp Wiki: Naming Conventions	Common Lisp Wiki: Naming Conventions	susam	15.180228	-3.9673362	story	5.0	81.0	1661698117	-10.435052
15757685	I don't understand your post at all.	I don't understand your post at all. Can you give some examples maybe?>In most languages you end up with large configuration files and huge number of strings as parameter.Not in the languages I'm familiar with at least. I don't understand what configuration files and macros have to do with each other.>Growing the language towards the problem you have is great opportunity to make the programming interface simpler to understand.Simpler to use, not to understand. You know what it does, you don't know how it does it or how it can be extended because it doesn't play by the language's usual rules. It's nice if you're copy/pasting stack overflow snippets or your use case is very standard, it sucks if you want to modify the code to do something a bit different and out of the box because now you ha	simias	15.115484	-3.9813633	comment	5.0	16.0	1511365879	-10.363524
16256222	Isn't Lisp particularly good at maki	Isn't Lisp particularly good at making your own DSL?Anyway, the majority of the programming community tends to dislike that sort of freedom, preferring maintainability and the ability to work as a team where every team member isn't off creating their own dialect.	goatlover	15.106509	-3.9858258	comment	5.0	32.0	1517215330	-10.318606
16313646	Is it impossible to improve on s-exp	Is it impossible to improve on s-expression notation?https://srfi.schemers.org/srfi-110/srfi-110.html#cant-improv...	mitchtbaum	15.062182	-4.0234284	comment	5.0	50.0	1517878635	-10.331611
16388578	> The point is that code is dataThat	"> The point is that code is dataThat's the popular slogan, but there'a actually quite a lot more to it than that.  After all, strings are data too, and C programs are represented as strings, so ""code is data"" in C too.  But that is obviously missing the point.What's really going on is that, in Lisp, code is a particular kind of data, specifically, it's a tree rather than a string.  Therefore, some (but not all) of the program's structure is represented directly in the data structure in which it is represented, and that makes certain kinds of manipulations on code easier, and it makes other kinds of manipulations harder or even impossible.  But (and this is the key point) the kinds of manipulations that are easier are the kind you actually want to do in general, and the kind that are harder"	lisper	15.1165905	-3.9791887	comment	5.0	19.0	1518736008	-10.408671
16393254	I theorize lisp isn't used more beca	"I theorize lisp isn't used more because of the massive amounts of parenthesis.I think the concepts are great, and it's a great language for certain task, but my right pinky finger hurts just looking at it.New programmers and developers look at that and compare it to something like Go, Python, or JavaScript, and all those look easier to write (although deceptively complex in places) and are 1000x easier to read.A prettier lisp would do the world good, but things like sweet expressions are confusing for absolutely new devs to implement and veterans feel like they don't need them.Short version: Lisp wallows in obscurity thanks to it's ""look"""	oregontechninja	15.114768	-3.9782197	comment	5.0	19.0	1518797018	-10.404259
16459477	Ergonomics of the Symbolics Lisp Mac	Ergonomics of the Symbolics Lisp Machine (2012)	icc97	15.137601	-3.9447627	story	5.0	29.0	1519574066	-10.359992
16584094	I came to Lisp (Scheme/Racket) from 	I came to Lisp (Scheme/Racket) from that another side (C++, Java, Perl) and it was an enlightening experience.Now I use Lisp nearly everywhere in a form of a small .NET runtime module.Lisp is excellent at templating tasks. Just for comparison: StringTemplate for .NET is a whooping 400 kB of compiled binary code while my implementation of Lisp is just 35 kB (!). Sure enough, Lisp does the very same thing as StringTemplate, but in just 1/10 of the code. There is more: Lisp is Turing-complete while StringTemplate doesn't. I can add a .NET function to Lisp environment and then call it in my template. I cannot do that with StringTemplate. I repeat, this is a 35 kB Lisp David vs 400 kB StringTemplate Goliath.Isn't Lisp beautiful?But wait, there is more. Lisp is excellent for natural language pro	garganzol	15.1270685	-3.9662719	comment	5.0	27.0	1521028854	-10.417463
21287218	1. I have a vague idea what the seco	"1. I have a vague idea what the second ""do"" is for. I don't have the slightest idea what the first ""do"" does.2. I have some idea what ""$"" is, but I have no idea what it does in this context.3. param ""uri"" is presumably extracting a parameter, presumably from the result of an incoming HTTP request. How is that request passed into ""app""? How is it passed into the ""get""? How is it passed to ""param""?4. Why does ""parsedURI"" need a type signature?5. ""Just/Nothing"" more or less makes sense, but ""Left/Right"" (used outside the excerpt I quoted) is a notation that makes about as much sense to communicate meaning as ""car/cdr"" does in Lisp.6. A response is generated. How does that response get back to the client?7. What does liftIO do?8. The overall syntax is just a pile of wrongness. There are left p"	microtherion	15.0953455	-3.988221	comment	5.0	21.0	1571353955	-10.419409
21559955	Do you have actual benchmarks compar	Do you have actual benchmarks comparing the the runtimes to justify the competitiveness between the two programs? With no types declared and no optimization declarations, I feel it would still be around 2-10x slower than C. (I have no quantitative evidence for that feeling though, except that I write Common Lisp in my day job. I have no doubt the program could be within 1-2x of C with appropriate massaging.) That’s certainly “good enough” in most cases, as evidenced by Python running so much of the world.The blasé attitude toward adhering to POSIX/GNU wc behavior was a bit dissatisfying to me. Those additions are “trivial” and probably don’t change the shape of the program too much, but are nonetheless complicating and time-consuming factors. I would prefer that Lispers strive to complete 	reikonomusha	15.12396	-3.9640214	comment	5.0	29.0	1574023385	-10.360875
21638293	Lisp had this kind of interactive pr	Lisp had this kind of interactive programming support for a long time using SLIME and Emacs. Why isn't this a more common feature in the more recent languages?	jimws	15.120682	-3.959508	comment	5.0	22.0	1574776896	-10.434337
21662893	Fleck: A Lisp that runs wherever Bas	Fleck: A Lisp that runs wherever Bash is	rcarmo	15.093623	-3.9706986	story	5.0	148.0	1575015078	-10.27258
21730973	String Algorithms in Lisp	String Algorithms in Lisp	tosh	15.1207905	-3.95866	story	5.0	70.0	1575735162	-10.381201
21734624	An unrelated question. For those usi	An unrelated question. For those using Vim, what plugins do you use to get a SLIME-like development environment?I have read great things about SLIME and how it helps in hot-reloading code into a Lisp REPL using Emacs. But is it necessary to learn Emacs to do Lisp? Are the plugins for Vim good enough?	foo101	15.081237	-3.9679692	comment	5.0	18.0	1575786505	-10.388731
21758359	I'm amazed it literally has a class 	"I'm amazed it literally has a class    public final class Cons extends LispObject
    {
      public LispObject car;
      public LispObject cdr;
    }

I would have thought it would provide that abstraction to the programmer but use another representation internally. Chasing pointers like this on modern hardware is surely crazy?"	chrisseaton	15.11656	-3.9747674	comment	5.0	23.0	1576024489	-10.402216
39183357	I feel like I say this a lot, but if	"I feel like I say this a lot, but if you like Guile you should really check out Gauche. It has more ""batteries"" included than Python, several of the ""alien technology"" features that people expect from Common Lisp, and good documentation to help you navigate it all.Scheme itself has a reputation for being very ""minimal"", and R7RS itself is great, but it also shines as a base for bigger languages like Guile and Gauche.Clojure is pretty cool too though. I love that it really has a life of its own as a ""third"" dialect to complement Common Lisp and Scheme.Can't speak for Elisp, not enough room in my brain to learn Emacs after years of Vim.If you like Python, I'd also like to shout out Hy (https://hylang.org/), which compiles to Python, and like Fennel is to Lua, it does a reasonably good job of"	nerdponx	15.112275	-3.9823236	comment	5.0	18.0	1706565842	-10.484443
39183258	While I agree with the author that t	While I agree with the author that there's something about Rust (my day-job lang & goto personal lang these days) that just lacks... elegance... I've also never found the Lisp (and many other FPs) emphasis on recursion all that compelling. Aesthetically or computationally. I find the programs written this way hard to reason about and read. Personally.For me, the underutilized gold mine feels like logic languages (Prolog et al.) Though I know recursion is used there a lot, too.	cmrdporcupine	15.096551	-3.9939816	comment	5.0	36.0	1706565321	-10.41728
39219062	Well, the funny thing is that for ba	"Well, the funny thing is that for base Common Lisp, it's less dynamic than you think.The functions and symbols in the core packages (e.g. COMMON-LISP package) are considered fixed and immutable. For example, out of the box, the compiler can assume that things like '+' aren't going to be redefined behind its back. It's assumptions like that can lead to very efficient code. But, at the same time, the core lisp language is actually not very dynamic, its more like your typical, compiled language in that sense.In contrast to say, Scheme, which has no presumptions. Out of the box, naive Scheme compilers can not make such assumptions. So, if you have something like:    (set! a (+ x (- y (+ z w))))

The compiler actually has to look up (dispatch) '+' twice! Did '-' change the definition of '+'? Ma"	whartung	15.121671	-3.973939	comment	5.0	20.0	1706810618	-10.421918
39343743	> humans can’t immediately parse str	"> humans can’t immediately parse structure with a glance, and sometimes we have to count parentheses by hand.This is why automatic indentation is important when working with Lisp. This is mentioned later in the article, but I consider it mandatory because of the multitude of problem this approach resolves.For example, upon pasting the below snippet into emacs:    (let* ((foo 10)
           (bar (+ foo 32))
      (* foo bar))

The editor 1) notifies me that there is a missing paren somewhere, 2) automatically* reindents this code into:    (let* ((foo 10)
           (bar (+ foo 32))
           (* foo bar))

At this moment, it's obvious that we have three variable bindings, one of them malformed, and the programmer can correct this by planting a missing paren in the proper place. I wrote abou"	phoe-krk	15.064562	-4.0370436	comment	5.0	28.0	1707737574	-10.382825
39346909	This comes off more as a series of r	This comes off more as a series of rationalizations than a compelling argument. Lisp is easy for a computer to parse, not great for humans. There other languages with comparably rich metaprogramming that syntactically have a better tradeoff between computer and human legibility.	norir	15.129013	-3.966305	comment	5.0	17.0	1707755853	-10.359761
17945431	Lisp for the Web (2008)	Lisp for the Web (2008)	wheresvic1	15.131993	-3.9484885	story	5.0	90.0	1536493058	-10.455745
17959272	Yes! I've been fascinated with GOAL 	Yes! I've been fascinated with GOAL / GOOL for nearly a decade. I ripped a copy of Last of Us and tore through the game data looking for the lisp code, but unfortunately they only ship the compiled output.What I wouldn't give to see the source... And Viaweb's source, and HN's source, and gosh there are so many amazing Lisp systems out there.	shawn	15.152656	-3.9342296	comment	5.0	19.0	1536670592	-10.44538
18017684	> There's already a blazing fast lis	> There's already a blazing fast lisp with a large library ecosystem... It's called Common Lisp.sorry what ? where does this meme comes from ? Most CL implementations are at best multiple times slower than your average JITted language	jcelerier	15.125858	-3.958182	comment	5.0	25.0	1537294074	-10.408971
18226369	Lisp is a powerful language that all	Lisp is a powerful language that allows one to mix multiple logical levels within a program (especially through it's homoiconicity).Shrdlu is perhaps the most classic illustration of Lisp's power[1], A classic program from 1968-70 that allowed natural language communication about a micro world. It was written in a version of Lisp even more free-form than today. When I looked at the source code a while back, it's parsing of natural language involved a wide-variety of on-the-fly fix-ups and such to take into account the multiple irregularities of human language.The thing about Lisp's power is it allows the production of complex program quickly but doesn't particularly have a standard way of gluing these programs together. The other classic Lisp work, The Bipolar Lisp Programmer[2], describes	joe_the_user	15.130805	-3.9611707	comment	5.0	76.0	1539662520	-10.435875
18335893	C++ has a whole scripting language e	C++ has a whole scripting language embedded into itself. They're trying to reinvent lisp, of course a much less efficient lisp.	gnulinux	15.109615	-3.9760065	comment	5.0	31.0	1540902800	-10.390555
18351635	Great post! A few observations.- It 	"Great post! A few observations.- It seems like the difficulty level ramps up really quickly starting with the ""So, what makes the lisp example different?"" section. This was jarring enough that I pretty much glossed over it (too much effort required to process all the definitions at once).As a more meta point, I wonder if symbolic differentiation is in fact a good example of highlighting lisp's differentiating features? One could write the same code in python/javascript with using lists and strings and recursion in a similar way, no?Not that I have a better example to highlight lisp's differences, which I understand to be macros. I've read SICP and have written a fair amount of elisp and still have not once identified a good use case for writing a DSL nor even a macro for myself."	meken	15.125417	-3.971844	comment	5.0	16.0	1541049589	-10.456399
18373350	Beside the REPL, another impressive 	Beside the REPL, another impressive feat of Common Lisp is meta-programming. You can write software to write software. Say what? Yeah, that was my initial reaction too, but Common Lisp’s macro system allows you to write functions that return code snippets. It completely redefines the word. Or more accurately, re-redefines, since Lisp is much older than MS Office, which is what most people associate macros with, sadly.The article could be improved by including an example. Pick one in which Java makes the problem to be solved tedious, verbose, repetitive, or error-prone and where Lisp macros do not. Bias the example as much as possible to a problem where Lisp can shine. It should, however, be a real problem most programmers are likely to face in some form.Then present the source for both sol	apo	15.124618	-3.9723125	comment	5.0	24.0	1541292396	-10.377369
18405888	Is there some lisp that has offers n	Is there some lisp that has offers nearly as powerful and fast data processing and tensor algebra facilities like Pandas and Numpy of Python? I would love to use a lisp but am not sure how well are they going to manage with huge 2-3D arrays.	qwerty456127	15.117895	-3.9699445	comment	5.0	32.0	1541681637	-10.386959
18415146	Lisp:- Avoids the use of gratuituous	Lisp:- Avoids the use of gratuituous special characters: (a b c)- use-dashes-in-symbol-names-instead-of-underline-so-its-easier-to-type (you can still use underlines or most any special character, but we like to keep it simple and easy).- has a simple prefix syntax, that makes it easier to read and understand complex expressions: (loop (print (read (eval))) So no risk of confusing special characters or syntax: the meaning is clearly labelled by the first symbol of each expression!- is not whitespace-sensitive, how can you see the size of whitespaces when you're blind?- includes a reader and a pretty printer, so the code can be processed and formated automatically easily for either sighted or blind programmers.- time-sharing was invented for the lisp REPL by the authors of lisp!- as a good 	informatimago	15.1302395	-3.9577782	comment	5.0	28.0	1541777828	-10.449171
18461756	> SourceKit-LSP is built on top of s	> SourceKit-LSP is built on top of sourcekitd 23 and clangd 23 for high-fidelity language support, and provides a powerful source code index as well as cross-language support.That's pretty much been Apple's motto for a while: need language support for anything other than compiling the language, like IDEs or documentation generation? Why not add it directly into the compiler? This has pros and cons, but personally I like the direction Microsoft has gone: rewrite everything in JavaScript (actually TypeScript) so that it's super portable and more easily embeddable.	sdegutis	15.076133	-3.9726672	comment	5.0	19.0	1542305848	-10.433767
18668735	I think we see more posts about Lisp	I think we see more posts about Lisp community drama than we see posts about people actually doing things with Lisp.	Semiapies	15.151267	-3.9332294	comment	5.0	18.0	1544658989	-10.477097
18741263	Lessons Learned Implementing Common 	Lessons Learned Implementing Common Lisp with LLVMhttps://www.youtube.com/watch?v=mbdXeRBbgDM	blojayble	15.143466	-3.9373713	comment	5.0	16.0	1545497087	-10.424671
29775771	I have the same response to this as 	I have the same response to this as I do to every other lisp article. It’s cool, but how have you personally leveraged this advantage that everyone talks about? What big lisp project has the author contributed to, such that they have enough data to sing it’s praises?	gaze	15.150495	-3.9318895	comment	5.0	39.0	1641169534	-10.478725
29800067	Intriguing idea. This would be very 	Intriguing idea. This would be very interesting to try with a Lisp or Scheme like language. Does it have any support for S-exp based languages?	rajandatta	15.106341	-3.9854763	comment	5.0	20.0	1641328572	-10.36787
29855044	Having learned a number of Lisp syst	"Having learned a number of Lisp systems in the past, I wouldn't necessarily recommend ANSI Common Lisp as a first choice for a Lisp unless your needs are very particular, because it is an enormous design-by-committee language having a draft standard of about 1360 pages:  https://lisp.com.br/archive/ansi_cl_standard_draft_nice.pdf

This means that in addition to the time spent doing the programming that solves your technical problem, you also have to devote considerable time to language lawyering, investigating if the interpretation of a Lisp expression your Common Lisp produces is or is not standard conforming, using only the frequently ambiguous English of that enormous standard as your guide.The Java JVM was carefully designed to give identical results on all hosts for the Java platform "	dandotway	15.121915	-3.968942	comment	5.0	20.0	1641669127	-10.575854
29889984	The Art of Lisp and Writing	The Art of Lisp and Writing	signa11	15.144317	-3.9362168	story	5.0	91.0	1641899211	-10.451837
29945235	Lisp Badge (2021)	Lisp Badge (2021)	tosh	15.146454	-3.9329588	story	5.0	112.0	1642241273	-10.469874
29950782	"Maybe a twist on the ""why is this us"	"Maybe a twist on the ""why is this useful"" question ...Users of lisp often are enthusiastic about the idea that lisp is at its core a minimal wrapper around the untyped lambda calculus (e.g. plus naming, primitive values and operations, etc).Why do we not generally see languages which are minimal wrappers around these typed lambda calculi? Perhaps intermediate languages are built closely around these formal systems (e.g. I'm aware that Haskell Core is closely based around System FC), but languages which are intended for human authors and readers seem to introduce a lot of extra machinery. Why is that?One guess is that lisps cope with being minimal through use of macros and metaprogramming, it's difficult for a typed language to support that level of metaprogramming while maintaining the var"	abeppu	15.129039	-3.970662	comment	5.0	17.0	1642284071	-10.384034
29953289	It's hard to tell but it looks like 	It's hard to tell but it looks like they have open- and close-parenthesis on the base (un-shifted) layer, which is awesome.That always puzzled me about the Space Cadet on the Symbolics Lisp Machines... you designed a machine from scratch that is ostensibly intended to be used and programmed with an awful lot of lisp code, but you expect the programmer to hit Shift+0 and Shift+9 each time they want a paren?  C'mon.Anyways this looks awesome; wish I had a use case for it.	na85	15.148442	-3.931725	comment	5.0	16.0	1642306875	-10.361831
29964013	Building a neural network in pure Li	Building a neural network in pure Lisp using only atoms and lists	signa11	15.136029	-3.9380367	story	5.0	107.0	1642402275	-10.386223
30139142	SBCL: New in Version 2.2.1	SBCL: New in Version 2.2.1	susam	15.126116	-3.9434588	story	5.0	107.0	1643564118	-10.377962
30173610	I hear sentiments like this often wi	I hear sentiments like this often with lisp, but if this were the case, why isn't everyone using lisp?	ducharmdev	15.143273	-3.941581	comment	5.0	56.0	1643775045	-10.465391
30173966	Much like the sibling comment I have	Much like the sibling comment I have heard variations of this proposition before. But instead of wondering why don’t more groups take this approach, I want to know what make it possible in the first place. So, in your experience, or even just via some passes down stories, etc., what is it about Lisp that allows for this efficiency?I have heard, although it is always just a quick statement with no explanation that it is the macros. And then one of siblings children comments seems to support the idea that Lisp programmers as a whole may be more experienced/better/more well rounded developers in general, so maybe that’s it. I am genuinely interested in peoples thoughts on this matter and am not being flippant or sarcastic.	throwaway17_17	15.139108	-3.951231	comment	5.0	34.0	1643778518	-10.411242
32724839	How do you use SLIME in Vim? Isn't S	How do you use SLIME in Vim? Isn't SLIME written in Emacs Lisp which runs only in Emacs? Honest question how you could run an Emacs package in Vim?	ctrlmeta	15.09173	-3.95619	comment	5.0	16.0	1662388897	-10.397878
32795085	Ask HN: Is Lisp code _too_ verbose a	Ask HN: Is Lisp code _too_ verbose and hard to read?	behnamoh	15.095324	-4.0068846	story	5.0	2.0	1662849080	-10.434187
32958314	Hmm, many languages but no common li	Hmm, many languages but no common lisp.	gibsonf1	15.136701	-3.9476433	comment	5.0	17.0	1663975994	-10.430212
36548914	My impression is that language innov	My impression is that language innovation in lisp dialects is largely stagnant at present.Common lisp is flexible enough that it's reasonable for projects to stay within the immutable standard, so only library progress happens.Scheme has given up on the minimal side to the design and become over-obsessed with complicated macros and static compilation. I suppose that's change, if not progress.Clojure I can't say much about. I like the hashed trie and do not consider the JVM connection a feature. Maybe that is still changing over time.Racket is still doing its thing, but the current push (Rhombus) seems to mostly be about removing S expressions.Kernel is a different lisp. Tragically we lost the author too young. Kernel deletes most of the limitations and cruft of _scheme_. It would benefit f	JonChesterfield	15.161904	-3.9373598	comment	5.0	18.0	1688210322	-10.695986
36887220	Steel Bank Common Lisp is the workho	Steel Bank Common Lisp is the workhorse which led me to build profitable software companies. I don't think I would be as productive without it. The repl driven workflow is amazing and the lisp images are rock solid and highly performant.	ilrwbwrkhv	15.13905	-3.9440918	comment	5.0	152.0	1690418210	-10.445151
36888797	The reason for this is quite simple:	The reason for this is quite simple: portability. Quicklisp also uses plain TAR files to distribute dists. Why? Because quicklisp has a built-in TAR extractor written in 100% standard/portable CL. This allows Quicklisp to run on just about everything, from your computer to real LispMs and operating systems like Mezzano.TLS comes up every time someone discusses Quicklisp, but nobody bothers to go ahead and actually implement it portably (and even if they did, have fun with performance and side channel attacks, both of which require you to break portability to implement well for every platform you want to target).If you would like a more stereotypical package manager, consider using CLPM. Though one of the big reasons to use CLPM is not encryption IMO, but versioning. ASDF supports locking v	koito17	15.085236	-3.963482	comment	5.0	21.0	1690431049	-10.30684
37124846	"Ask HN: ""Lisp can be written in Lisp"	"Ask HN: ""Lisp can be written in Lisp.” Why is it a big deal?"	behnamoh	15.139538	-3.949547	story	5.0	4.0	1692038281	-10.450398
37507878	I wonder why there aren't more tools	I wonder why there aren't more tools to allow structural editing like Lisp has. This way the file can never be in an unparsable state.	aeonik	15.118085	-3.9673553	comment	5.0	16.0	1694693641	-10.376933
24581607	Ask HN: Why were people crazy about 	Ask HN: Why were people crazy about Lisp during 70s and 80s?	luizfzs	15.139439	-3.9549603	story	5.0	5.0	1600971061	-10.458186
24729874	This might sound harsh, but Common L	This might sound harsh, but Common Lisp fans should stop whining about what everybody else is doing and start making some killer apps to bring back some life into their language. Hearing all about Lisp's past glories is far less convincing than working code. It's just off-putting to hear complaints about what someone else did. As always in free software, the one who puts in the hours gets to call the shots.	kryptiskt	15.142378	-3.9370542	comment	5.0	18.0	1602251381	-10.473634
24871547	To what extent is the CL condition s	To what extent is the CL condition system inherently tied to Lisp(s)? Is there anything about it that makes it a natural fit for Lisp but not for other languages?Macros, for example, are a natural fit for Lisp because of the parentheses. It would be difficult to add Lisp-style macros to a language like Python because Python doesn't have Lisp parentheses. In contrast, there's nothing about multiple namespaces that is particularly tied to Lisp. Common Lisp and Emacs Lisp have multiple namespaces, but Scheme doesn't. Python doesn't have them, but it just as easily could.So is the condition system more like macros or more like multiple namespaces?	nickdrozd	15.1317425	-3.9621596	comment	5.0	33.0	1603472575	-10.411908
24897724	I've been wondering this for a while	I've been wondering this for a while, and this seems like a reasonable time to ask it:If I understand correctly, you use macros to change the syntax of Lisp.  But if I'm trying to write a DSL, why would I need new syntax?  Why aren't new functions and data structures enough?	AnimalMuppet	15.10546	-3.9907591	comment	5.0	20.0	1603728771	-10.274771
25442267	There are obviously many possible pa	"There are obviously many possible paths, so I can only really tell you what I've done. I can't say it's necessarily the best approach.For me, I decided to start with Common Lisp. I installed SBCL, Slime for Emacs, and started working through the book Practical Common Lisp. By and large this seems to be a workable approach, but I will offer up this caveat. The PCL book is very much ""project based"" in that the author walks you through building a couple of actual applications. This is a Good Thing™ for the most part, but it does mean that you don't necessarily get things in the order you might expect.There's a part of me that almost wishes I'd started with a book that takes more of an approach of ""programming is ultimately sequence, selection and iteration. Here's how you do sequence in Lisp."	mindcrime	15.130847	-3.9468205	comment	5.0	26.0	1608125559	-10.440423
33046482	While Lisp had to have some path fro	While Lisp had to have some path from then to now, it is interesting to ask how important the mathematical foundations really are. Lisp is really a celebration of the humble function - everything bar nothing is some variant of (function arg arg arg). While the mathematicians were the first people to isolate that it seems quite likely it would have been naturally discovered from the engineering branch of programming when someone started trying to push the bounds of a macro system and realised that all the syntax was getting the way.I suspect Lisp has incredible longevity because it is nearly impossible to simplify down from functions. The approach also seems to breed a certain level of flexibility that other languages struggle to match - I have seen software that does a better job of editin	roenxi	15.126149	-3.9707465	comment	5.0	29.0	1664631298	-10.439839
31775821	As an old lisp fan, I never got this	"As an old lisp fan, I never got this. (f x) and f(x) have the same number of parenthesis.and the nice thing about (f x) is that the parenthesis group f with x; so you have the whole call inside the (). Consistent and simple to understand.vs i.e. print(f""a string""), where it isn't even clear that the ""f"" is a function call."	mellavora	15.0686655	-4.026791	comment	5.0	37.0	1655457258	-10.177546
31998149	I loath these and related libraries.	I loath these and related libraries.  They promote a style that diverges from regular Emacs Lisp code that makes it hard to read if you are not familiar with the additional language, and on top of that frequently promote a wasteful and inefficient style (e.g. instead of searching a buffer it is converted into a string, split on newlines, filtered and then checked if the filtered list is nil).  I've sent out numerous patches to remove these leftpad-esque dependencies from projects that often only make use of one or two functions, that more often than not are just alii for built-in functions.  Of all these libraries dash has some kind of a legitimation, but all the rest I consider code smell and makes me question if using the package is even worth it.Also note that (besides dash), emacs-deve	daptaq	15.101353	-3.9716465	comment	5.0	23.0	1657095409	-10.378839
32159798	My theory is this is also why Lisp n	My theory is this is also why Lisp never took off. Powerful macros are wonderful for the solo programmer but difficult for a large team to reason about.	klipt	15.120735	-3.9756477	comment	5.0	19.0	1658277097	-10.381759
32285632	Lisp in Vim (2019)	Lisp in Vim (2019)	susam	15.1098	-3.9566689	story	5.0	42.0	1659176556	-10.413661
32288193	Paredit.vim – Paredit Mode: Structur	Paredit.vim – Paredit Mode: Structured Editing of Lisp S-Expressions	susam	15.089098	-4.0007343	story	5.0	38.0	1659199642	-10.319965
32288472	SBCL – New in Version 2.2.7	SBCL – New in Version 2.2.7	susam	15.126863	-3.9408264	story	5.0	86.0	1659201389	-10.418899
32360378	The first article in this issue of B	"The first article in this issue of BYTE has a very interesting characterization of Lisp that I have not come across before. I mean, famous quotes like ""Lisp is a programmable programming language"" by John Foderaro and ""The greatest single programming language ever designed"" by Alan Kay are often mentioned in articles about Lisp. But in this issue of BYTE, the article ""An Overview of LISP"" by John Allen at page 10 has something very interesting to say. Excerpt from the article:""The best description of the LISP programming language is that it is a high level machine language. That is, it shares many of the facets of contemporary machine language --the necessity for attention to detail and the freedom to manipulate the machine's data and programs without restriction-- yet LISP is high level i"	susam	15.135703	-3.9525046	comment	5.0	32.0	1659725832	-10.439008
32461425	The Blub-paradox is that everyone th	The Blub-paradox is that everyone thinks those other languages are blub but their own favorite language is the non-blub pinnacle of creation.	goto11	15.136021	-3.9380004	comment	5.0	22.0	1660500319	-10.455149
32470833	> > there is a very real sense in wh	"> > there is a very real sense in which programming languages haven’t really progressed since the early 80s.> 1980 is the debut of Smalltalk.1972, actually!> Standardisation of CommonLisp happened sometimes in the mid 1980s.Finished in the mid 90s.  But Lisp was around well before the 80s, and CL was in a lot of ways a standardisation of the practices developed in the 70s & 80s.> 80s. The 1990s is the ""Interpreters Renaissance"", when Python and Ruby (and other less elegant siblings) came outI don’t really count that as progress.  Python is just an unacceptable Lisp (1958), and Ruby is by analogy an unacceptable Smalltalk (1972).> … the JVM and the proto-beginnings of the CLR.The JVM is just refinement of ideas dating back to UCSD Pascal (1977), and the CLR is just an embraced and extended "	eadmund	15.118179	-3.9778135	comment	5.0	18.0	1660576870	-10.534081
22033759	This is cool, but the code is... str	This is cool, but the code is... strange? https://github.com/vygr/ChrysaLisp/blob/master/gui/canvas/tg...The code doesn’t look like Lisp at all. Is this some sort of lower assembler language that Lisp is implemented on top of?	smabie	15.129621	-3.9507828	comment	5.0	17.0	1578917825	-10.424131
22067628	Which is the better introduction to 	Which is the better introduction to Lisp: On Lisp (by pg), SICP, or another text (maybe on Common Lisp)?Or is it better to just go straight to Clojure these days?	jammygit	15.138843	-3.9681427	comment	5.0	17.0	1579200840	-10.790634
22075979	I remember when people were claiming	"I remember when people were claiming Common Lisp community is toxic, but I find that it is the languages which tend to focus on ""building community"" with Community Managers and Codes of Conduct that end up becoming truly toxic cesspools in the end. See also node.js. The focus on community attracts people who aren't interested in programming, but rather those who want a playground for gaining clout and trolling. You never hear about C++ drama, why is that?"	Grue3	15.141381	-3.9430249	comment	5.0	15.0	1579278149	-10.441846
22084755	I want to give Common Lisp a try. My	I want to give Common Lisp a try. My previous experience with Lisp (any variant) is almost nil. Would this be a good book to start with?	elteto	15.148618	-3.9320526	comment	5.0	21.0	1579359650	-10.444453
22088539	LISP is weird - I used it a lot in t	LISP is weird - I used it a lot in the late 80s and enjoyed it a lot but then moved on and, looking back, never missed it. I think it has a hypnotizing effect on programmers brains, feeding the endorphin feedback cycle, but ultimately there are just too many damn parens.	zwieback	15.148587	-3.9427722	comment	5.0	24.0	1579394615	-10.451091
22088781	> Why is lisp always rejected?My bes	> Why is lisp always rejected?My best guess is performance.In the 70s, computers were slow. When the decade started, the competing languages of the time were Fortran, Algol and Cobol. All were imperative languages with manual memory management that would compile directly to hardware and had semantics very close to that of the hardware. On the other hand, at that time, Lisp was this high level thing, garbage collected, dynamic types, semantics more removed from the hardware, etc. Meaning Lisp was much less performant.Then in 1972, came C. A language inspired by Algol and Fortran, using very similar imperative semantics and constructs, but changing the syntax slightly to what is now the common syntax most programming languages use.The whole point of C was to be crazy fast, and for compilers 	didibus	15.1308365	-3.959627	comment	5.0	23.0	1579398399	-10.438147
22101583	Oh, goody, another tiny LISP (I've b	Oh, goody, another tiny LISP (I've been keeping track of them at http://taoofmac.com/space/LISP, will add this one ASAP).	rcarmo	15.138162	-3.9436486	comment	5.0	19.0	1579549747	-10.456028
22189944	I find it a bit strange that the pos	"I find it a bit strange that the post lists both LISP and Python as ""truly elegant software system[s]"". To me Python is a super-pragmatic language that sacrifices intellectual elegance to allow people (even, but not necessarily) without a CS/Math background to ""get stuff done"". I also wonder how software ""artists"" should be different from other artists. For example, in music, there are great teams of artists, like Lennon/McCartney."	timkam	15.120734	-3.9722612	comment	5.0	18.0	1580374698	-10.397489
39376451	Because most programming is done by 	Because most programming is done by people trying to do a job and it requires broad tooling support and familiarity, LISP is a language that has neither.LISP, (similarly to Haskell) requires you to bend your mind and pay an upfront mental cost in order to access it's benefits, which are that everything is equally easy to describe. No construct in LISP feels like it requires you to bend the language in an awful way because LISP is a fantastically generic tool, some things that are common and easy in other languages are more difficult in LISP, but as you get into the weeds building more complex constructs it will never get in your way.(and since i mentioned it, the benefit of Haskell is that you can make a LOT of statements about your code you know to be true)	thot_experiment	15.126864	-3.9711893	comment	6.0	51.0	1707949657	-10.451067
39377602	I like python significantly more tha	I like python significantly more than lisp.There are so many ways to express yourself in python that are troublesome in lisp.I actually think list manipulation is easier in python than lisp.I don't know, is there a lisp dialect that makes common data structures available in a multitude of ways?I seem to be able to manipulate lists quite easily in python, and switch back and forth to sets or hashes.but in lisp you have to dig in to find (for example):- how to prepend to a list- how to append to a list- how to remove an element from a lisp- how to do slices of listsit seems to me like a lot of operations in lisp are needlessly efficient too.Like instead of copying a list, you have to modify the list in place.if my list will only have 10 elements, and my machine does millions of instructions 	m463	15.111987	-3.990014	comment	6.0	20.0	1707957275	-10.450586
39574240	Interlisp-D and MIT CADR Lisp Machin	Interlisp-D and MIT CADR Lisp Machine demos for IJCAI Conference (1981)	lispm	15.106912	-3.9621289	story	6.0	63.0	1709401766	6.264236
39666610	What I find promising about LISP is 	What I find promising about LISP is the ability to do term rewriting and macros.But people write lisps in imperative style rather than definitions of desired behaviour declaratively. I don't think we've sufficiently solved how to define desired behaviour to a computer.Term rewriting behaviours. What are your thoughts?I started trying to implement term rewriting into my LISP parser, which is the idea that we can match on trees and transform them, subsume branches or move branches around arbitrarily. You kind of want the matching function and transformation function to be imperative or sometimes like a query.So use ASTs for behaviour and relationships and imperative LISP macros for transformations and rewriting.The reason I say this is because I dream of a compositional language where I can 	samsquire	15.111259	-3.9884481	comment	6.0	41.0	1710155477	-10.335762
36595669	I used to like Lisp's homoiconicity.	I used to like Lisp's homoiconicity.  These days, I'm not even sure the concept makes any sense?  What is it even supposed to mean?Lisp has (simple) syntax for creating literals and writing code.  But when you inspect your data from the inside of Lisp, they don't have any more (or less) relation to that syntax than eg Python does.Eg no modern Lisp stores a function as an S-Expr of its syntax.  You get an opaque piece of data that you can do certain operations on, just like in eg Python or Haskell.Lisp using S-Expressions is an interesting syntax choice, but that's it.  It doesn't by itself have any deeper impact on the language.  (Of course, socially it does have a deeper impact, because it makes it simple for language users to write macros that look exactly like built-in parts of the lang	eru	15.106596	-3.98955	comment	6.0	52.0	1688533239	-10.366486
36890569	>Common Lisp programs run by default	>Common Lisp programs run by default in a way that calls to undefined functions are detected.Cool so what you're telling me is that by default every single function call incurs the unavoidable overhead of indirecting through some lookup for a function bound to a symbol. And you're proud of this?	mathisfun123	15.113543	-3.976382	comment	6.0	31.0	1690446327	-10.353331
36891734	LISP continues to be a very interest	LISP continues to be a very interesting language.But REPL development is a mixed blessing. There are many situations where you want to start from a blank slate with no previous state.LISP would be a more practical language if it included a trivial option to make that possible.	TheOtherHobbes	15.128577	-3.9614244	comment	6.0	24.0	1690455364	-10.57279
37002021	Sharpscript: Lisp for Scripting	Sharpscript: Lisp for Scripting	behnamoh	15.112058	-3.9771252	story	6.0	64.0	1691165725	-10.191195
23491462	The Lisp 2 Project (2018)	The Lisp 2 Project (2018)	mhdhn	15.152602	-3.9427323	story	6.0	83.0	1591897969	-10.436456
23674517	> emacs outshines all other editing 	> emacs outshines all other editing software in approximately the same way that the noonday sun does the starsWhat makes Emacs genuinely great? Not that it was built a long time ago and withstood the test of time. Not the fact that it is absolutely free to use, distribute and extend. Not that it doesn't have tons of bugs (it does), or has superb support for every known programming language (it does not).To understand what makes Emacs so awesome, to learn and master it, one simply needs to embrace the single fundamental truth about it. Emacs based on Lisp. And please don't make a mistake - I am not talking here about a programming language. I am talking about an idea - one of the most magnificent ideas in computer science. Embrace the awesomeness of that idea, the fluidity, and malleability	iLemming	15.061009	-3.9830382	comment	6.0	37.0	1593407068	-10.359765
23738587	Ask HN: Is Lisp still used as a prog	Ask HN: Is Lisp still used as a programming language?	abhayhegde	15.132601	-3.9660678	story	6.0	3.0	1593956703	-10.45445
23878612	Typed Lisp, a Primer (2019)	Typed Lisp, a Primer (2019)	jedimind	15.147615	-3.9394655	story	6.0	107.0	1595042357	-10.3885145
24180879	Can someone direct me to some code w	Can someone direct me to some code where I can see the full potential of Lisp?I have programmed in Scheme before while taking a course using SICP. Final project was a Scheme interpreter. But I didn't have any epiphany/awakening like many others seems to have.	hackingthenews	15.138452	-3.9457076	comment	6.0	26.0	1597609009	-10.458312
24276881	Creating a Common Lisp implementatio	Creating a Common Lisp implementation, part 1 [video]	zeveb	15.1483755	-3.9382718	story	6.0	127.0	1598393865	-10.379951
24328998	Writing a Lisp to x86-64 compiler	Writing a Lisp to x86-64 compiler	tekknolagi	15.136503	-3.943492	story	6.0	81.0	1598855647	-10.366853
20104655	Of note is that these are all associ	"Of note is that these are all associations. It's possible the associations are all due to selection effects (or even that the ""better"" language are actually worse but their effects are reversed by selecting for programmers who are better).In the early days of Python, some employers used it as a way to filter for candidates who were ahead of the curve. I believe Paul Graham mentioned Lisp being good for attracting better programmers, although I can't find the reference anymore [1]. If there's any value in this kind of filter, the effects will show up in the programmers' output.1. I'm having a hard time finding references for these assertions; the best I've found is some Reddit posts and Joel Spolsky's post on finding great developers: https://www.joelonsoftware.com/2006/09/06/finding-great-"	salmonellaeater	15.130412	-3.9564095	comment	6.0	24.0	1559744620	-10.475792
20196027	Ultralisp: A fast-moving Common Lisp	Ultralisp: A fast-moving Common Lisp software distribution	lerax	15.129421	-3.9508162	story	6.0	164.0	1560699903	-10.417443
19245739	Or Greenspun's Tenth Rule of Program	"Or Greenspun's Tenth Rule of Programming:    Any sufficiently complicated C or Fortran program contains an ad-hoc,
    informally-specified, bug-ridden, slow implementation of half of CommonLisp."	BerislavLopac	15.10373	-3.9697342	comment	6.0	18.0	1551104382	-10.30221
19273567	you obviously know lisp and might be	"you obviously know lisp and might be biased but i have a serious question, if i was going to waste a bunch of time learning a functional language in 2019 and wanted to use it in production (I am in consulting, so I would be recommending this to my clients) would you learn1. LISP
2. Haskell
3. Erlang
4. Something elseNo wrong answer, just a question I always like to hear answers to."	misiti3780	15.125123	-3.9817939	comment	6.0	26.0	1551377801	-10.467856
19439051	What are lisp macros for if not to d	"What are lisp macros for if not to delay evaluation? I assume you're making a distinction between purpose and mechanism here?I've always understood the semantics to be:fn:
(a b c) => (call a (eval b) (eval c))mac:
(a b c) => (eval (call a b c))"	reitzensteinm	15.084305	-4.0162253	comment	6.0	57.0	1553056815	-10.300829
19626018	Ask HN: Should I learn (E)Lisp befor	Ask HN: Should I learn (E)Lisp before switching to Emacs?	rooam-dev	15.1455555	-3.9390848	story	6.0	8.0	1554912258	-10.4526825
19727982	Absence of syntax!  I really wish ev	Absence of syntax!  I really wish every language were a lisp.  Like, Rust, the lisp, Swift, the lisp.  Who needs rules of precedence and associativity and statements vs expressions and all the other stuff that languages that aren't lisps impose on you?  Just stick an expression in some parentheses! And then put that in another expression!	paultopia	15.111558	-3.9863162	comment	6.0	40.0	1556023312	-10.398926
19905793	Sympathetic, but as long as lisp req	Sympathetic, but as long as lisp requires one to write math as function composition it won't catch on with computational types. Of course, I imagine that sort of thing could be a set of macros away...then that would be awesome, familiar infix mathematical expressions with common lisp in the rest of the code.	noobermin	15.116383	-3.9811282	comment	6.0	40.0	1557795870	-10.421901
15756996	>as a project grows and grows you en	">as a project grows and grows you end up inventing your own little dialect of the language which is opaque to any 3rd party reading your code unless they take the time to unravel your macros.This is bad use of macros, or an ugly macro system.Macros, at least in Lisp, made code even clearer to understand; because they let you create the constructs that make the problem domain map more directly, straightforwardly, easily, to the programming language.So they reduce line count, they reduce need for kludges or workarounds. They allow more straight code.But this is within the Land of Lisp, where writing a macro isn't something ""advanced"" nor ""complex"" nor ""esoteric"". In the Lisp world, writing a macro is 95% similar to writing a run-of-the-mill function."	flavio81	15.084472	-4.00682	comment	6.0	34.0	1511361111	-10.346649
15882989	Do you like Python? Python is basica	Do you like Python? Python is basically simplified Lisp. Common Lisp is Python plus first-class lexical closures (rather than second-class) plus true multithreading plus a real compiler so it runs much faster.Plus parentheses rather than indentation to delimit expressions; parentheses are much more versatile once you get used to them.	dreamcompiler	15.109539	-3.9836988	comment	6.0	27.0	1512775421	-10.352211
15973324	A Common Lisp REPL on Android	A Common Lisp REPL on Android	zeveb	15.134679	-3.949734	story	6.0	74.0	1513800724	-10.504687
17946855	“Lisp is actually a family of langua	“Lisp is actually a family of languages discovered by John McCarthy 50 years ago.”McCarthy was deep in the Amazon when suddenly out of nowhere...	melling	15.1441965	-3.947379	comment	6.0	33.0	1536513936	5.7031054
18184406	Not an Emacs user, so forgive me if 	"Not an Emacs user, so forgive me if I'm being dense, but is this (from the README) really true?  Emacs will change how you think about programming.

  Emacs is an incremental programming environment. There's no 
  edit-compile-run cycle. There isn't even an edit-run cycle. You can 
  execute snippets of code and gradually turn them into a finished 
  project. There's no distinction between your editor and your 
  interpreter.

I'm assuming what it means is ""Emacs will change how you think about programming Emacs Lisp"". Which is a rather narrower proposition, and much less of an incentive to switch, since I doubt many non-Emacs users are particularly interested in programming Emacs Lisp."	mrec	15.0686035	-3.9873688	comment	6.0	28.0	1539176461	-10.397851
18193009	As someone new to Lisp. The followin	As someone new to Lisp. The following thing has always fascinated me. I've read some older posts on comp.lang.lisp and people insist on buying a 'high performant' Lisp. I think what they mean is Allegro CL or Franz Lisp.But why is it 'high performant' compared to other implementations? Like say CMU CL(now SBCL).For example, in this case why would one use Clozure CL instead of SBCL?	kamaal	15.139383	-3.9528465	comment	6.0	39.0	1539261993	-10.432511
18203260	When you have Lisp, why do you still	When you have Lisp, why do you still need a so called filesystem?The idea of flat text files sounds odd, when you can have structured S-exp's.	jxy	15.096378	-3.972846	comment	6.0	59.0	1539366790	-10.469833
18227515	Having spent months learning Haskell	Having spent months learning Haskell, I'm interested to pickup another mind-expanding language. If I read SICP (and also watch the MIT lectures), what dialect should I follow along in? Ideally I would learn something people are using today so there would be usable libraries. I mostly write website backends and APIs.Clojure? Common Lisp? Something else?	ancarda	15.133502	-3.9674928	comment	6.0	18.0	1539676677	-10.538072
18226879	> Lisp is a powerful language that a	> Lisp is a powerful language that allows one to mix multiple logical levels within a program (especially through it's homoiconicity).Statement like these are what make me suspect Lisp code would be a maintenance nightmare. I am regularly refactoring code to separate multiple logical levels so we can more easily maintain our codebases. If this is a misunderstanding, can someone clarify?	tunesmith	15.133099	-3.9669096	comment	6.0	59.0	1539668619	-10.44565
18338884	Ask HN: I want to learn Wolfram Lang	Ask HN: I want to learn Wolfram Language	gsaga	15.038148	-4.025182	story	6.0	13.0	1540919368	-10.420986
18551097	Alternatively - you can choose to pr	Alternatively - you can choose to program in Common Lisp - an industrial strength language that has been demonstrated in large projects like the QPX flight search engine (Google Flights).For anyone who doesn't know - a big difference that Common Lisp brings to the table is that it has separate namespaces for variables and functions. This may not sound like much but it makes it much easier to write macros (code that writes code) and facilitates compile-time computing.Another big difference between Scheme and Common Lisp is that the Common Lisp specification is _much_ larger and it comes with a much larger collection of standard built-in functions and macros and a standard object-oriented programming facility, among many other things.I know this because I've spent the last six years implemen	drmeister	15.130517	-3.9619708	comment	6.0	30.0	1543410165	-10.459216
18635600	I have a few software packages in mi	I have a few software packages in mind:1.  The Genera operating system for Symbolics Lisp machines.  Ever since I've gotten bitten by the Smalltalk and Lisp machine bugs, I've been wanting to use Genera, but I was born at the beginning of the last AI winter, and unfortunately the operating system is still proprietary, with no word about whether or not it will become open sourced.  It's regrettable that the proverbial baby was thrown out with the bathwater when Lisp machines lost out in the marketplace to RISC workstations and the x86 running Lisp on other OSes; there are a lot of interesting lessons we can learn from Genera in today's operating systems and programming environments, and an entire generation of computer scientists and software engineers are unfortunately completely unfamilia	linguae	15.111772	-3.949461	comment	6.0	22.0	1544282331	-10.383431
18662321	Ask HN: Lisp in 2018?	Ask HN: Lisp in 2018?	Zeyad	15.138022	-3.9488885	story	6.0	6.0	1544603910	-10.45108
18854849	It's kind of interesting in the 2001	It's kind of interesting in the 2001 essay that invented blub it was suggested as a hypothesis as to>And if Lisp is so great, why doesn't everyone use it?Suggesting programmers in a blub language don't realise it's power. I get the impression in the 18 or so years subsequently that the main reason for the low uptake of Lisp is it's power enables people to write clever code that other programmers have quite a job to understand while languages like Python let you do much the same stuff while being easier to read.So it's not that people don't realise the power so much as they don't want it.	tim333	15.144746	-3.945028	comment	6.0	48.0	1546947545	-10.521173
29722417	Bass – Lisp dialect for scripting th	Bass – Lisp dialect for scripting the infrastructure beneath your project	yjftsjthsd-h	15.095176	-3.9618564	story	6.0	77.0	1640758549	-10.352108
29751506	> Lisp is the most expressive and fl	> Lisp is the most expressive and flexible language. You can reach a flow-state where ideas can freely flow from your mind into codeThis kind of claim typically comes from someone pretty new to the world of software development.You can say this of any language, really, and any developer who's reasonably proficient in language X will also claim that with X, their ideas flow directly into code.> The Lisp programming language Racket is used to teach programming fundamentals in modern Computer Science courses.Unsurprising cherry picking. How many universities teach Racket compared to, Javascript C/C++, or Java?The rest of the article is of the same cloth, raving about Lisp and Clojure as the best programming languages ever invented.You should learn Lisp, no matter what kind of developer you ar	hota_mazi	15.137541	-3.9586334	comment	6.0	21.0	1640978495	-10.524929
29947768	This is an interesting article, but 	This is an interesting article, but it unaccountably fails to say what an fexpr is. As fexprs are not present in either Common Lisp or Scheme, only aficionados of the history of Lisp will know. Here is the definition from the Wikipedia article:> A fexpr is a function whose operands are passed to it without being evaluated. When a fexpr is called, only the body of the fexpr is evaluated; no other evaluations take place except when explicitly initiated by the fexpr.	foldr	15.127809	-3.971673	comment	6.0	25.0	1642264794	-4.350861
30054081	Why does everything about Lisp immed	Why does everything about Lisp immediately make the front page?I've seen many interesting submissions about Java or C# - arguably much more popular languages; unlike with Lisp most of those we'll never see on the front page.Why is HN so biased towards this one language. Can we please give other topics the same treatment?	bitcharmer	15.146309	-3.941198	comment	6.0	28.0	1643002853	-10.451148
30139736	Yes. I have deployed mobile applicat	Yes. I have deployed mobile applications using native UI (SwiftUI, etc.) with all the shared logic in Lisp. To me, this was a better alternative than the usual C/C++ shared logic approach.My current application is a music hardware device that is mostly Lisp. As to why, this could be a lengthy post, and I am sure I have made one elsewhere on HN. It is a very good language, has many of the features that are being re-discovered and implemented in other languages, has an interactive model of development (REPL driven) that I find very productive and I can deploy an application across multiple platforms with little to no modifications.I do pay for LispWorks and it is more than worth it. I make a living developing applications and devices that use Lisp and the cost is covered by a fraction of a p	diskzero	15.019726	-4.0172405	comment	6.0	33.0	1643567674	-10.415388
30174596	I wonder why do developers use CCL. 	I wonder why do developers use CCL.  I haven't work with SBCL and Lisp in general for years, but Emacs + Slime + SBCL worked very good.	comonoid	15.129203	-3.94801	comment	6.0	18.0	1643784695	-10.408352
30656709	I don’t understand why old programme	I don’t understand why old programmers are so much fascinated by lisp. If it would have been good it would have survived today.	master_yoda_1	15.142836	-3.9458086	comment	6.0	19.0	1647132497	-10.470427
16409204	I absolutely love lisp. It's crazy h	I absolutely love lisp. It's crazy how it's one of the oldest language around, yet it still has more features than many other newer mainstream languages.At the same time, one of the reasons I don't like it too much for daily work, is how it encourages cleverness. This sounds silly, I know. But sometimes when there's opportunities for cleverness -- such as with C++ (meta) template programming -- I become too tempted to make my own code more clever instead of, you know, making it do whatever it's supposed to do. That makes me appreciate the relative dumbness of say, Go and Python (not that you can't be clever with Python, but it's not encouraged).	dimatura	15.137205	-3.953336	comment	6.0	28.0	1518992990	-10.43806
16448156	"""Why on Earth would anyone want to u"	"""Why on Earth would anyone want to use a language with such horrific syntax?!""What is it with statements like this?  It just sounds like a 'meme' to me, that everyone hears (even from advocates like this one) at first that the 'syntax' (of which there is a lot less than most languages in a Lisp) is 'horrible'?Of course, we, the learn-ed of Lisp, say that after a while the 'parens just disappear', which they don't, but they sure help (when combined with Paredit) in defining code like structures that can be manipulated with ease in your editor.I know the author is just trying to do a bit of a 'sandwich' with the article, but please, advocates and enemies of Lisp, just give up on picking on the parens.  It's stupid and been done a million times. It's like 'why do we have to type so much to en"	kruhft	15.1017	-3.9940877	comment	6.0	79.0	1519410063	-10.303415
16583845	> knowing Lisp made me all too keenl	"> knowing Lisp made me all too keenly aware of Java's shortcomings, and I had a very hard time not being angry at how stupid it was that I was being forced 
to use it.I would take this as a the thing to remember from this. When you are too angry at something, you cant learn it. I have seen the emotional refusal to learn new inferior thing (or read comments that amounted to the same) many times already.It is something to be aware of and avoided."	watwut	15.143159	-3.9497662	comment	6.0	26.0	1521025972	-10.463174
16941133	Slightly unrelated, but to those who	"Slightly unrelated, but to those who have never tried Lisp because of the parenthesis (like me until recently), here's my take:I've recently started hacking with Elisp, and I really like it. Parenthesis are obviously pretty awkward at first. But now I wouldn't leave them for anything else. As it turns out, the brackets make it easy for your editor to understand the semantics of your code, to a whole new level. So your editor is now actively helping you navigate and edit your code. You go from expressions to expressions, add one after an other, transpose them and their parameters, absorb other expressions, insert them etc. It's true magic. I thinks that's why some don't like the fact that CL-loop is not ""lispy"" enough: you lose your editor's help inside a CL loop.So the parents are actually"	globuous	15.095482	-4.0048623	comment	6.0	43.0	1524840465	-10.361864
17041348	Thing is, except for CS theory evolv	Thing is, except for CS theory evolving, the programming language environment from 30 years ago is in my opinion irrelevant from a maturity perspective. The number of practitioners was probably 1 million or so worldwide, now there’s probably 20-40+ million programmers worldwide. We didn’t have widespread internet access, barely a handful of Open Source communities, compilers were generally commercial and extremely expensive, companies behind technologies were extremely volatile, etc.While that made for very nice war stories, it also meant that you’d have the “ship” sinking under you completely. Now a tech still stays around to some degree.A C developer from 1990 could still be a C dev in 2018. A Java dev from 1998 could still be a C dev in 2018. And a programmer in your average mainstream 	oblio	15.089148	-3.9851117	comment	6.0	39.0	1525975081	-6.679971
17110819	History of Symbolics Lisp Machines (	History of Symbolics Lisp Machines (2007)	kristianp	15.130242	-3.9496508	story	6.0	108.0	1526782782	-10.279826
17259814	I've been shat on HN before for sayi	"I've been shat on HN before for saying this but I stand by it: you're not a programmer/developer/""whatever it's called now"" until you have done a parser for something at least as complicated as lisp in whatever the lex/yacc equivalent is in your language of choice.The difference between people who get regular languages, pretty much everyone who codes, and the people who get context free grammars is more than $100k a year."	zeth___	15.133729	-3.9553397	comment	6.0	42.0	1528402538	-10.377465
17440323	What's a good lisp ide other than em	What's a good lisp ide other than emacs?To me, learning lisp and Emacs at the same time seems like a tall order	wodenokoto	15.120758	-3.957659	comment	6.0	21.0	1530523395	-10.413868
17443076	Is SBCL winning in anything? One of 	Is SBCL winning in anything? One of my acquaintances, a Lisp zealot, convinced me to jump in and make my next project in SBCL. Short story, it was a joke. Nobody seems to have done any serious work in SBCL in over a decade. Basic things are either completely missing or broken. Clojure I can at least make working software in. The fact that you are putting SBCL up there with Clojure makes me wonder if you've ever used SBCL.	workinfunk	15.114389	-3.9691124	comment	6.0	22.0	1530549121	-10.53411
17853172	Yes. I don't mind the parens (syntax	Yes. I don't mind the parens (syntax highlighting can subdue them), but every time I actually fire up Common Lisp to try it, I see all caps somewhere, like someone even older than me is shouting at me, or I stumbled across a box of my Fortran punched cards from before I switched to APL in the 1970's. That's an ugliness not addressed by this guide.	Syzygies	15.117136	-3.9688642	comment	6.0	24.0	1535393823	-10.440253
21104414	SBCL 20: Steel Bank Common Lisp's 20	SBCL 20: Steel Bank Common Lisp's 20th Anniversary Workshop	kristianp	15.1432	-3.9367163	story	6.0	157.0	1569720900	-10.451937
21231303	I can't say I'm familiar with Lisp (	I can't say I'm familiar with Lisp (or its dialects).How does one get started learning a Lisp variant (in terms of learning resources/guides), and why use Lisp over other languages?	applecrazy	15.14426	-3.9379292	comment	6.0	19.0	1570866014	-10.453413
21231768	I remember reading pg's article on L	I remember reading pg's article on Lisp and startups, and at the time questioned if it was just mere luck. Then having a cursory look at Lisp, I questioned its relevance to the modern world.... fast forward a decade later and I'm reading books on functional and logical languages for work. After the first chapter of The Little Schemer, I was at first blown away with the content, but then sad after I realised I had put off reading it late in my life.If you're reading this comment and thinking Lisp and what's the point? Take a deep dive. It you're still questioning why, I highly encourage you to read The Little Schemer (and then all the others in the series). Scheme, Lisp, and now Bel, are a super power... pg's article was spot on.	alfiedotwtf	15.143323	-3.9462566	comment	6.0	92.0	1570873134	-10.531195
21670442	Mal – Make a Lisp, implemented in 79	Mal – Make a Lisp, implemented in 79 languages	tony-allan	15.136358	-3.946884	story	6.0	218.0	1575129136	-10.413793
21758098	A bit off topic, but is Common Lisp 	A bit off topic, but is Common Lisp still a good choice?I spent a lot of time learning and coding CL during the last decade. I love lots of things about the language. Overall, it's great it's true multiparadigm. Few languages achieve that.However, the implementations are too fragmented which makes the standard quite stagnant. And libraries are falling a bit behind.I love Clasp is putting CL on top of LLVM. I wish we could have something with the best ideas of Racket, Clojure and CL on the LLVM.	nextos	15.129624	-3.9742858	comment	6.0	23.0	1576021729	-10.576028
39075390	Gah, another Lisp post to tempt me t	Gah, another Lisp post to tempt me to add yet another mini project to my plate...I always am curious about trying more Lisp because I keep seeing commentary about how powerful it is to actually build applications once you get moving on building things.Anyone here have any recent practical experience in this direction who would confirm this in Lisp vs in other programming languages? Does effort in Lisp really compound/produce great code and great applications that much faster than other languages? (For web development primarily)	wait_a_minute	15.1359	-3.9536285	comment	6.0	47.0	1705809554	-10.473569
39218584	It's always amazes me how common lis	It's always amazes me how common lisp is so much more dynamic than, say, python, and is still compiled down to native code, and has running speed in the same ballpark as java/go/c#.Unfortunately it's not a simple language, and has much historical baggage (the standard has mandated Roman literals in formating, really guys?..)	dgan	15.127846	-3.9659126	comment	6.0	32.0	1706808581	-10.445625
12583965	I'd think Common Lisp is the Lisp be	I'd think Common Lisp is the Lisp beyond Clojure.Also, I just see slides that have (googleable) terms, is there a recording of this presentation?EDIT: see mkozlows' comment (THANKS!!!)	noobermin	15.138821	-3.9635031	comment	6.0	73.0	1474912198	-10.736091
12790042	...or Java or C# or Scala or Haskell	...or Java or C# or Scala or Haskell or Rust or OCaml or...There's a whole lot to the programming world than disproportionately popular dynamic languages.What is so great about Lisp that other languages don't have? Macros? Simple syntax? I mean, that's basically it, right?This is just fanboyism for a language he has nostalgia for. Nothing else.	sdegutis	15.115413	-3.977651	comment	6.0	28.0	1477418270	-10.4128065
12923171	When I think about writing my own la	When I think about writing my own language, I think of something with as few parenthesis as possible and all the examples use Lisp.	k__	15.107457	-3.988728	comment	6.0	26.0	1478804548	-10.358391
13137172	One of the things that has made me o	"One of the things that has made me old (52) and crotchety is that I learned Lisp very early in my career.  That gave me the ability to see that 99% of ""new"" technologies were really just poor re-inventions of (parts of) Lisp.  Even today, Common Lisp -- despite (or, as some would argue, because of) the fact that it hasn't been officially updated in decades is still not only a viable language but one of the best choices for many applications.  But no one knows it because it's not the shiny new thing, and even young people still can't seem to get their heads around the fact that the parens are a feature, not a bug.  And that makes me grumpy sometimes.The good part was that I was able to build a very successful career while not having to suffer nearly as much pain as many of my contemporaries"	lisper	15.145484	-3.9440584	comment	6.0	101.0	1481266583	-10.452951
13184391	Pretty good advice, along with some 	Pretty good advice, along with some good pointers about what NOT to do when learning a languages (ex. reading some instructional book cover-to-cover, forgetting most of the stuff along the way).I often suggest the read-a-chapter-write-a-program-based-on-it route, just to get the practice that is really important, and to solidify some intuition as to what the machine (whether interpreter or bare metal) is doing, and to make writing future programs easier.Side note: While I definitely applaud the idea of trying to create a language that is geared towards beginners and good for learning on, I don't know if I can get behind recommending such a language that is still under development being suggested to beginners.Then again, I'd consider recommending lisps to beginners (if not python), so maybe	hardwaresofton	15.072248	-4.0030093	comment	6.0	34.0	1481808376	-10.375023
13193244	Does anybody have a few examples of 	"Does anybody have a few examples of DSLs people make in a lisp (ideally clojure because I have worked with it a tad)? I've seen plenty of cases where people make a pseudo-dsl via optional arguments, but not seen this so-oft mentioned ""yeah we just wrote a dsl for it because lisp"" sort of deal."	bpicolo	15.093202	-3.9918764	comment	6.0	24.0	1481896808	-10.288098
13317836	Portacle – A Portable Common Lisp De	Portacle – A Portable Common Lisp Development Environment	AlexeyBrin	15.107402	-3.9315104	story	6.0	136.0	1483534559	-10.347146
13441793	This illustrates the power & the pro	This illustrates the power & the problem of Common Lisp: the power is that it really is easy to add channels (and pretty much every other feature) to the language yourself; the problem is that it's generally easier to write your own code to do this than to use (or fix …) someone else's.I've experienced exactly this: I too looked at ChanL.  In my case it had a bug for one of my use cases, and it was honestly easier to roll my own channels (with, of course, their own bugs) than to understand & fix ChanL's bug.The problem is that this leads to a proliferation of different libraries, all doing similar things.  The power is that one really can write just about anything, and it will work well enough for your use case.	wtbob	15.141265	-3.948842	comment	6.0	38.0	1484887775	-10.452433
27699793	Homoiconicity isn't required for tha	Homoiconicity isn't required for that, all you need is to be able to map between source and AST enough to identify expression boundaries.Plenty of development environments for non-homoiconic languages provide the ability to evaluate a selected expression (not just the last one) in a linked REPL on demand.I love the Lisp family, but I don't know why its advocates often sound like they haven't seen a dev environment for a non-Lisp language since the early 1980s when pointing to “unique” advantages of Lisps.	dragonwriter	15.111578	-3.9854128	comment	6.0	34.0	1625151974	-10.344601
27715081	Lisp machines were an interesting id	Lisp machines were an interesting idea. Unfortunately they were very expensive and fairly slow compared to other machines at the time.	aliasEli	15.13529	-3.9367943	comment	6.0	42.0	1625250874	-10.431725
27950040	Many newer programming languages hav	Many newer programming languages have focused on reducing hidden control flow and ugly text macros in favor of more transparent metaprogramming, which may help to illustrate one of the bigger issues with Lisp. Lisp itself is simple and elegant, but that doesn't mean it's easy to write simple and elegant Lisp code. Imperative programming is maybe less elegant and beautiful than functional programming, but imperative programming is easy to understand by humans. Sure, C code may not literally execute line by line, but this is how C programmers mentally model execution, to the point where sometimes people are befuddled to learn it’s not the case. It's such an effective approach that CPUs also provide an as-if illusion of in-order execution. And sure, Lisp macros are powerful, but it feels like	jchw	15.122792	-3.9760113	comment	6.0	31.0	1627228164	-10.438896
12197533	> emacs & slime[1]I've spent a lot o	> emacs & slime[1]I've spent a lot of time with emacs, and slime was what I used when I was exploring Common Lisp: both SBCL and CLISP. Emacs is really powerful and I'm fairly at home with it, but I've come to prefer more graphical IDE's. Judging from the popularity of Eclipse, Visual Studio, NetBeans, etc...I'd say I'm not alone. Telling programmers it's emacs+slime or the highway is not a strength; it discourages everyone who prefers those other environments.> I'd even go as far as saying that targeting a specific implementation is usually a sign of bad coding style.I was suggesting ABCL because it is a full implementation of CL on the JVM. If there are other CL's with ABCL's level of maturity on the JVM, then they would work just as well.Beyond that, I imagine that many programming proj	claystu	15.102743	-3.958946	comment	6.0	27.0	1469981845	-10.408492
12200164	"""The question is where will we be in"	"""The question is where will we be in five years, the answer is using Common Lisp, because of language features"" says the author in the comments.  This was 8 years ago.Kind of rude of me to take that potshot, but it's there.  I've been reading these ""Why Lisp?"" Arguments for years and yet it still remains pretty niche.  The longer this goes on the more I am unable tell Lisp advocates apart from Perl advocates.  They both sound like write-only languages.  They make a lone programmer feel very productive and Free, but it results in essentially unmaintainable code.  I've written and attempted to maintain much more Perl than Lisp, many years ago, so please tell me if I'm wrong."	krupan	15.134283	-3.9528103	comment	6.0	52.0	1470024976	-10.410137
12200301	Okay, I've spent a lot of time writi	Okay, I've spent a lot of time writing Common Lisp and even more time reading about Common Lisp, and to be honest, I'm just a little tired of the cult around it. People who know it well gloat about how great Common Lisp is, which just so happens to make them look great too. And people who don't know Common Lisp all talk about the little Common Lisp they know, because they don't want to seem like they aren't in on it, and because they don't know better.Let's talk about this fabled exchange between Norvig and McCarthy, where McCarthy asks if Python can gracefully manipulate code as data, and Norvig said no, and supposedly a thousand words were said in the ensuing silence.Here's the thing; a thousand words weren't said. I don’t know what Tilton thinks was said there, but it certainly wasn’t a	unpop-opinion	15.130596	-3.9609177	comment	6.0	27.0	1470028015	-10.431447
12200526	Well, no, I'm not confusing powerful	Well, no, I'm not confusing powerful and popular.  I'm asking why, for all lisp's power, there's almost no examples of that power actually doing anyone any good.Is it because most projects don't need something powerful?  The benefits of that power aren't actually that great compared to the rest of the lisp baggage?We have this trope of the smug lisp weenie and there's definitely a whiff of high wizardry around lisp, but who's actually shipping anything with it?	Frondo	15.147705	-3.9413447	comment	6.0	26.0	1470032599	-10.461759
12327051	I guess I'm never to actually “get L	"I guess I'm never to actually “get Lisp” to appreciate its syntax.>Aside from the prefix ordering, Common Lisp’s syntax is already a bit more elegant because you can set arbitrarily many variables without repeating the assignment operator over and over again:    ; Have to type out `=` three times
    x = 10
    y = 20
    z = 30

    ; But only one `setf` required
    (setf x 10
          y 20
          z 30)

I utterly fail to see the aforementioned elegance, although I certainly can't miss the line where it happens."	expression	15.100623	-3.9934032	comment	6.0	45.0	1471707849	-10.418336
35323915	Funny to see this now, when AI is do	Funny to see this now, when AI is done by using Python to orchestrate numeric kernels written in C++ or Fortran. GOFAI lost, big time, and the key to success in AI is the ability to perform matrix multiplications as fast as machinely possible -- which means the central data structure you should be using is the array or vector, to ensure data locality so you don't blow up your cache.Lisp is, almost, the opposite of a language you would choose to do AI in today.It may be a more powerful language for other applications, but that will hardly matter because the productivity gains from using AI will dwarf those from programming language choice.	bitwize	15.127906	-3.9512863	comment	6.0	30.0	1679902497	-10.463146
28353454	HN loves the toy Lisps. I don't unde	HN loves the toy Lisps. I don't understand what this is good for.Implementing a toy Lisp is a great exercise, a meta circular evaluator is a great way to see how simple an implementation of Lisp can be... but to do anything serious with Lisp requires a serious implementation.and if you want to do the simple types of exercises shown in this example to play with Lisp, you can do them just as easily in a real Lisp, and you'll get better tools for correcting errors.	fsckboy	15.141681	-3.9433725	comment	6.0	25.0	1630308446	-10.455929
28393031	Ask HN: Is there an easy example of 	Ask HN: Is there an easy example of a Lisp pretty-printer?	jonathanstrange	15.135017	-3.950897	story	6.0	14.0	1630595519	10.346188
28450473	SBCL: Assembly code breadboard (2014	SBCL: Assembly code breadboard (2014)	isaac21259	15.1183605	-3.9432192	story	6.0	134.0	1631052070	-10.339229
22886889	A book on algorithmic programming in	A book on algorithmic programming in Lisp	vseloved	15.128931	-3.9430444	story	6.0	141.0	1587020629	-10.4091215
22887293	Is there consensus on the most commo	Is there consensus on the most common and advisable tooling setup for newcomers in Common Lisp?	traderjane	15.143764	-3.9440742	comment	6.0	19.0	1587025376	-10.462092
23296851	"Can you elaborate on the part ""Lisp "	"Can you elaborate on the part ""Lisp as a great code generating language""? Just curious. I tried to learn Scheme for SICP but then switched to the Python version."	markus_zhang	15.134972	-3.9474347	comment	6.0	18.0	1590370749	-10.46785
33162722	Format is awesome, it is a domain sp	Format is awesome, it is a domain specific language for printing things. It can walk across lists, print all sorts of number radixes, make tables of data, and has its own condition system. I don't get the hate. It is not lispy at all in style, but isn't making a DSL just about the most lispy thing you could do?	mtreis86	15.113945	-3.9782019	comment	6.0	47.0	1665492625	-10.29542
33197202	I think building everything out of c	I think building everything out of conses held Lisp back. It was possible, and it was deemed to be elegant, so people went too far with it. YMMV since my adventures with Lisp were around twenty years ago, but reading code, you'd see somebody constructing a list with a bunch of nested lists inside it, or some other complicated structure with conses, and you'd have no idea what it was or how they intended to use it, and you'd just have to read the code until you figured it out. It's much easier to read code that uses named data structures.Of course in Lisp your code can and should have clearly named functions that encapsulate your use of conses to build data structures, but casually violating that encapsulation, or better yet doing without encapsulation at all, just playing with conses, was 	dkarl	15.137934	-4.0112486	comment	6.0	25.0	1665699567	-10.492645
33464197	What significantly else? These seems	What significantly else? These seems to be many reasons why people dont use Lisp.	_s_a_m_	15.149349	-3.93709	comment	6.0	19.0	1667556847	-10.4507475
33576615	I think S-expressions are fundamenta	I think S-expressions are fundamentally too difficult to work with, without good editor support, to make Lisp anything other than a niche power tool for the highly motivated. I love CL, Scheme, Clojure, Janet, Fennel, etc. but I don't blame anyone for finding them inaccessible.I think Python, JavaScript, and Go have caught on for somewhat similar reasons, compared to Java and C#: they are easier to get started with, and you can still scale them up to fairly large applications.On the other hand, I think S-expressions are a sadly underexplored format for data serialization and storage.	nerdponx	15.08357	-4.0108275	comment	6.0	70.0	1668284262	-10.376743
33601688	I don't get it.  I am a Smug Lisp We	I don't get it.  I am a Smug Lisp Weenie.  Lisp is not a syntactic sugar - the only reason it looks like it does is for metaprogramming.  Those parens are not syntax - they indicate the underlying structure of the code, a tree which may be manipulated by Lisp macros.Why would anyone pretend to program in Lisp without any benefit?  Also, Python is the worst imaginable engine for running Lisp. [correction: I see there are some kind of macros...]	giantdude	15.122147	-3.972008	comment	6.0	37.0	1668462518	-10.429548
33681361	I'd love to learn (a) Forth. As a be	I'd love to learn (a) Forth. As a beginner, where do you begin? Like Lisp there seems to be different variants. I always struggle with where to start.	account-5	15.145166	-3.9303787	comment	6.0	28.0	1668956378	-10.44983
34011770	Kilo Lisp: A Kilo Byte-Sized Lisp Sy	Kilo Lisp: A Kilo Byte-Sized Lisp System	KnuthIsGod	15.131772	-3.9412286	story	6.0	140.0	1671175726	-10.411899
34036825	The fact that about 10% maintains an	The fact that about 10% maintains an elisp package, and that about 90% can program in elisp, makes me suspect the outcomes are skewed. Either that, or emacs is doomed.	tgv	15.100557	-3.9635677	comment	6.0	47.0	1671364025	12.913731
34097967	One thing that puts me off about Com	One thing that puts me off about Common Lisp is functions that do multiple different things depending on a flag passed to them. (format nil s) formats a string, whereas (format t s) formats a string and prints it to stdout. This doesn't look like good design.	xigoi	15.133361	-3.9574294	comment	6.0	34.0	1671739730	-10.4379835
34102604	Ask HN: Is structural editing consid	Ask HN: Is structural editing considered mandatory for Lisp?	HexDecOctBin	15.113562	-3.9789054	story	6.0	9.0	1671773466	-10.354857
27157663	It seems that as interesting as Fort	It seems that as interesting as Forth is, the community of such languages is very niche and small, even smaller than Lisp. Can anyone speak to recent changes in velocity or energy?	threatofrain	15.137131	-3.9499524	comment	6.0	34.0	1621015791	-10.455079
27431180	Embedding Lisp in C++ – A Recipe	Embedding Lisp in C++ – A Recipe	pieterk	15.127186	-3.9628477	story	6.0	84.0	1623132767	-10.390435
38303694	> The main advantage Emacs has over 	> The main advantage Emacs has over other, more modern IDEs is ELisp, and the vast ecosystem built around it.Ecosystem yes, and also it's architecture and culture. ELisp I would say no. If we ignore the specific flavor, then 99% of what's realistically done with with elisp, is also covered by other dynamic languages like JavaScript. And the rest is so esoteric that it's probably not that worth the trouble.> I don't see how supplementing ELisp with JS would make Emacs more attractive;Not everyone likes lisp, not everyone is willing to learn a new strange language for unknown benefits. And JS has a vast ecosystem of its own. Far bigger even that Emacs heritage, but on different areas. A well working combination of both, with no side making significant sacrifices, could be very alluring for m	PurpleRamen	15.015496	-4.0115547	comment	6.0	39.0	1700229914	-10.381348
38352926	Great resource! Forgive my ignorance	Great resource! Forgive my ignorance but why do so many modern functional programming courses use Standard ML instead of a Lisp dialect? Is it because of its built-in type-checking, or is it just how it's always been taught?	agomez314	15.1058655	-3.9890618	comment	6.0	34.0	1700507657	-10.288357
38509258	When I tried to introduce s-expressi	When I tried to introduce s-expressions to a DSL my co-workers nearly lynched me. The parenthesis were so violently hated I sunk into a deep hole and still haven’t came back out of it.	sirsuki	15.086722	-4.005098	comment	6.0	64.0	1701626919	-10.29696
14726594	Any recommendations for a Lisp IDE o	Any recommendations for a Lisp IDE outside of Emacs?Also, aren't there any other OSS or free Lisp IDEs outside of Emacs? Or are they all crap?	oblio	15.091205	-3.9743478	comment	6.0	19.0	1499538840	-10.399639
14879556	What is even more amazing is to star	"What is even more amazing is to start a web server from the Lisp command line (the ""REPL""), and then change the definition of a function. The app will use the new function without stopping and/or restarting. And this includes the intermediate step of compiling the whole function!!You can also update the definition of a class and then force all instances of this class to use the updated definiton... all of this while the program keeps running.I always tell my friends to try some Common Lisp. The runtime environment is rather amazing. The exception handling system (""condition"" system) is also another thing that is impressive on CL. It is so far beyond what Java (or C++) brings to the table, that it isn't even funny to compare them."	flavio81	15.1147785	-3.976836	comment	6.0	26.0	1501304056	-10.416784
15057273	What are some examples of open sourc	What are some examples of open source Lisp projects and codebases whose features and elegance could have only been executed as well as they are in the language, or are just great codebases in general to study?	olewhalehunter	15.126955	-3.9564548	comment	6.0	21.0	1503211849	-10.45418
15078326	The author, a famous and well-liked 	"The author, a famous and well-liked lisper,  is not consider ing portability features. CL is an ANSI standard and code often runs with no changes in many distinct CL implementations/compilers/interpreters.Also, related to that point: There are many different CL implementations out there that satisfy different use cases, like for example JVM deployment (ABCL), embedded systems (ECL), speed(SBCL), fast compile times (Clozure), pro-level support (LispWorks, ACL), etc. So the same code has a huge amount of options for deployment. It really makes Common Lisp be ""write once, run anywhere"".Then speed is also never mentioned. Lisp can be seriously fast; under SBCL it is generally 0.3x to 1x C speed; LispWorks might be faster, and there's a PDF out there called ""How to make Lisp go faster than C"", "	flavio81	15.136631	-3.9506996	comment	6.0	45.0	1503459308	-10.40236
15419799	When I discovered lisp several years	When I discovered lisp several years ago, it was indeed the textbook moment of enlightenment that you've heard about. This book was a part of that introduction for me (along with Practical Common Lisp). After working in C-like languages, I had no idea that programming could work this way as in lisp, the idea of code and data being inseparable, I even had dreams at night about run-time data structures getting expressed as quoted lists! (I kid you not!)It is now several years later and I have earned my living ever since by working in another lisp, Clojure. And I have indeed learned a lot along the way and what I've learned does indeed translate to how I work in other languages (even C++, which I also love).However -- it is not all roses and nicely-flavored toothpaste after a savory feast. Th	hellofunk	15.140252	-3.9526143	comment	6.0	29.0	1507319034	-10.482979
15571619	There seem to be two big camps that 	"There seem to be two big camps that preach a ""learn this weird new programming paradigm because it'll help you see things from a new perspective and will make you a better engineer"" message: the lispy languages, and the ML-like languages. Both of these languages categories give you functional programming as well as metaprogramming, which is great. Having tried both, I've found that the ML-derived languages tend to have a stronger type system that's more rigorously enforced at compile time. I personally find this much more valuable in practice than some of the dynamic magic that you can do with lisp.There are some notable exceptions, of course, but part of this is just inherent to the design of lisp, and I think it's easy to end up with a type safety system that feels more like it's bolted "	ohazi	15.05626	-4.046686	comment	6.0	65.0	1509133676	-10.379745
20368880	I've never used Common Lisp, I know 	"I've never used Common Lisp, I know some Clojure, used emacs-lisp, tried Racket, Fennel. I love Lisps. But I always wondered: What happened to Common Lisp? Some of the opinions I heard:- CL is too big (compared to Racket and Clojure)- Lisp-1 vs Lisp-2- recursion discouraged (is that even true?)- There is a thing called ""Lisp Curse""And then seemingly language's popularity decreased. Let's ignore the fact that I really like Lisps, aside that, are there any compelling reasons for an average Joe programmer like me to start learning Common Lisp in 2019? Honest question."	iLemming	15.142763	-3.9511478	comment	6.0	18.0	1562407723	-10.484665
20433419	Oh really, that's interesting.  Is t	Oh really, that's interesting.  Is that sort of info widely known among the HN user base and I'm an ignoramus or is it a case of some of the users of longer standing being vocal about Lisp?	s_Hogg	15.116965	-3.9725463	comment	6.0	32.0	1563112937	-10.471571
20922124	The curse of Lisp is not its power, 	"The curse of Lisp is not its power, elegance, flexibility, etc. The curse of Lisp is its syntax! Both ""all those parentheses"" and what they represent is the curse of Lisp.Lisp forces coders to think in terms of infix trees. These trees need to be carried around in the front of the mind. This mental model is very difficult unless your mind is wired to be able to process code this way. For Lisp aficionados this either comes naturally or with coding practice. The ""parentheses"" fade into the background. For most people this wiring never comes. It remains too difficult to keep the nested trees straight in their heads. To put it colloquially, it's too difficult to juggle all those parenthesis.If you're a Lisper you'll want to believe that with use comes the familiarity to overcome this hurdle. I"	cy_hauser	15.108112	-4.00005	comment	6.0	32.0	1568061030	-10.363747
13858367	besides, that shows me how well read	besides, that shows me how well readable lisp code is. even better than python.	raocah	15.115293	-3.975814	comment	6.0	22.0	1489417450	-10.351589
13858332	Code is not literature the same way 	"Code is not literature the same way equations are not mathematics. Take any math or physics book, extract all of the equations, and throw away the text. That's how we write programs... just the equations.However, look at Physically Based Rendering (http://www.pbrt.org/). It won an Academy Award. It should win a Pulitzer. All of the actual source code is in the book and the book is quite readable.Or look at Lisp in Small Pieces (https://pages.lip6.fr/Christian.Queinnec/WWW/LiSP.html). There you will find a complete lisp system surrounded by enlightening text.Your confusion stems from the coding constraints of the 1970s. My first machine had 8k of memory, 4k of which was operating system. So programs could not exceed 4k, requiring #include statements. As programs grew they adopt the ""pile of"	daly	15.109038	-3.9632144	comment	6.0	23.0	1489417243	-10.375244
13949951	If you are really in a hurry and can	If you are really in a hurry and can't commit to learning the hundreds of forms in Common Lisp, Scheme is a minimalist alternative. The entire language has only a few forms on which make up everything else.	daliwali	15.133159	-3.9523072	comment	6.0	29.0	1490372267	-10.435491
13953086	What are some compelling examples of	What are some compelling examples of Lisp languages in use today in apps/situations/use-cases that we might all know about?A lot of people (likely mistakenly) think that it's just a language you learn in CS classes and then leave behind.	plg	15.144792	-3.945512	comment	6.0	21.0	1490398158	-10.468653
13979721	Can someone point me at an argument 	Can someone point me at an argument for why I'd want to write CL in 2017, given all the great alternatives available now?	AlexCoventry	15.098768	-3.9662938	comment	6.0	36.0	1490728598	-10.509379
13981037	I started a big project at work usin	I started a big project at work using Common Lisp in 2017 and could not be happier. Sure, most nice features have trickled down to other languages, but they are rarely as nicely integrated. And Lisp still has many advantages that are not found elsewhere: Unmatched stability, on-demand performance, tunable compiler, CLOS, condition system, and Macros to name a few. It has its warts too but which language does not?I found lack of high quality library documentation a bit annoying, but a non-issue, there were tests and/or examples included in practically all of the libraries I have used so far.Lastly, this rarely gets brought up, but I think Common Lisp has some of the best books available out of any programming language. The fact that it is so stable means that most of material, and code, fro	hydandata	15.132713	-3.9577236	comment	6.0	71.0	1490737749	-10.450964
14167428	Ask HN: Will the committee that buil	Ask HN: Will the committee that built Common Lisp make a new one in the future?	behnamoh	15.152107	-3.9351156	story	6.0	41.0	1492795150	-10.514848
14249271	_My_ main objection to lisp is that 	"_My_ main objection to lisp is that it's confusing.I don't mean the syntax is hard to grasp. I mean the way it looks. It becomes very confusing when the program grows in size.This is not unique to Lisp. It applies to all dynamic languages that don't have strong tooling support (IDE's with intellisense).(Maybe I am wrong about Lisp being dynamic; my only experience has been with ""arc""; and I have had someone tell me before that common-lisp has static types)I used to be happy about programming python and javascript in a plain text editor (vim).However, as I was doing my first intermediate size project, I realized that I've hit a limit.My project was in Javascript (frontend) and I couldn't keep track of what was going on anymore. Each unit of code is understandable on its own but the whole th"	hasenj	15.123375	-3.968554	comment	6.0	19.0	1493750561	-10.415865
14512018	Lisp syntax is like no syntax at all	Lisp syntax is like no syntax at all, it's all just direct parse trees. It is unviable without more secondary formatting than syntactic forms since it is really difficult for the eyes to balance parantheses on their own.That LISP-style (non) syntax is successful just goes to show how little syntax really matters (I.e. the null case works), I guess.	seanmcdirmid	15.1167555	-3.983718	comment	6.0	23.0	1496898306	-10.369616
14609412	This is pretty incredible work wrapp	This is pretty incredible work wrapped in an unassuming name. It basically presents an entirely new way to interact with any programming language. You could make an emacs mode that worked this way, for example.I could see this being one of the fundamental ways of overcoming Lisp bias. Lisp still isn't mainstream. Clojure was a nice attempt, but it fell short. You can find companies that use Clojure, but it's not the lingua franca of any domain (except perhaps text editors).If you were to expose a way to write Lisp without dealing with any parens at all, it might have a chance of sparking the interest of younger programers long enough to seduce them to Lisp's other benefits: when you write in Lisp, you're writing in the abstract syntax tree normally generated by other languages. This allows	sillysaurus3	15.117524	-3.9966085	comment	6.0	37.0	1498094037	-10.695232
14661927	For a more modern and up to date gui	"For a more modern and up to date guide, Edi Weitz's ""Common Lisp Recipes"" is a great reference: https://www.amazon.com/Common-Lisp-Recipes-Problem-Solution-...The more I use Common Lisp, the more disappointed I am that it hasn't become more popular.  It really is higher level than Python, Ruby, or Perl but with nearly the performance of C and C++."	jlarocco	15.145097	-3.9417818	comment	6.0	124.0	1498729517	-10.414414
30776878	Statistical Analysis with Lisp-Stat	Statistical Analysis with Lisp-Stat	ngcc_hk	15.14423	-3.934015	story	6.0	101.0	1648030379	-10.4322195
30812939	"> We don't ""need"" Lisp machines. We "	"> We don't ""need"" Lisp machines. We ""need"" Lisp software. What made a Lisp machines extraordinary wasn't the hardware, it was the software. Nothing today is impeding one from writing such software, except time, energy, willpower, and/or money.Discussed here https://news.ycombinator.com/item?id=30800520 The main issue is that Lisp, for all its inherent ""power"", has very limited tools for enforcing modularity boundaries in code and ""programming in the large"".  So everything ends up being a bespoke solo-programmer project, there is no real shared development.  You can see the modern GC-based/""managed"" languages, perhaps most notably with Java, as Lisps that avoided this significant pitfall.  This might explain much of their ongoing success."	zozbot234	15.135309	-3.9514937	comment	6.0	53.0	1648310071	-10.432461
31115221	New blog about my journey to develop	New blog about my journey to develop a Common Lisp 3D software	kaveh808	15.143867	-3.9327312	story	6.0	115.0	1650575366	-10.446671
31244753	A recent comment from LWN on that no	A recent comment from LWN on that note:https://lwn.net/Articles/893608/I asked about this on their IRC channel and got this response from oriansj:Well we did bootstrap a FORTH from hex: https://github.com/oriansj/stage0/blob/master/stage2/forth.sand we did bootstrap a garbage collecting Lisp from hex: https://github.com/oriansj/stage0/blob/master/stage2/lisp.sbut if you notice: https://github.com/oriansj/stage0/blob/master/stage2/cc_x86....writing a C compiler in assembly that supports structs, unions, arrays, inline assembly and a bunch more was done in	pabs3	15.060729	-3.976215	comment	6.0	28.0	1651553323	-7.703233
31340595	I hate to break it to you, but sayin	I hate to break it to you, but saying your favorite language is Scheme would get A LOT of interviewers to laugh, especially in the enterprise world where Java and C# are dominant. These aren't usually Hacker News browsing people, and if they have any association with Lisp, it's through a college course, rarely independent interest.Are you sure he didn't just walk out because he had other things to do and knew the others could take over?	pipeline_peak	15.140552	-3.9428074	comment	6.0	27.0	1652279892	-10.416462
25493495	Getting Started with Lisp (2019)	Getting Started with Lisp (2019)	wheresvic4	15.145603	-3.937	story	6.0	82.0	1608544695	-10.434345
25541919	Manga Guide to Lisp	Manga Guide to Lisp	_zhqs	15.147902	-3.935957	story	6.0	137.0	1608965868	-10.44208
25760381	A rabbit hole full of Lisp	A rabbit hole full of Lisp	mpereira	15.123084	-3.9876235	story	6.0	218.0	1610534615	-10.455824
25768360	I don't have anything against Lisp, 	I don't have anything against Lisp, I program Emacs with it, but wouldn't you get mostly the same features if Emacs used Javascript for its programming, for example?	dmortin	15.086611	-3.994664	comment	6.0	27.0	1610574288	-10.414503
25774173	I've seen a lot of embedded Forth st	I've seen a lot of embedded Forth stuff recently but I don't get the appeal. Clearly there is some benefit over writing assembly, but why is it preferred over portable C, or even higher level languages such as Python on more powerful mcus?FWIW I felt the same way about LISP for a long time until I fell in love with it via Emacs. So please educate me!	sandwell	15.097585	-3.939551	comment	6.0	26.0	1610616933	-10.415096
26066411	Hi, I'm the author.For those who hav	Hi, I'm the author.For those who haven't heard about the book yet: it is a practical description of the main data structures and algorithms in use today. The book is also featuring a presentation of the most important algorithm development techniques, as well a examples of the real-world use cases in each chapter. It uses Common Lisp as an implementation language, and also contains a crash course into the language if you are not yet familiar with it.For those who have already seen or even read the previous version published on Leanpub, here is a summary of the updates: http://lisp-univ-etc.blogspot.com/2021/02/programming-algori...As usual, AMA.	vseloved	15.133798	-3.9340081	comment	6.0	28.0	1612800864	-10.442248
35853634	Appreciating what Lisp is capable of	Appreciating what Lisp is capable of doing (think macros), and having worked through SICP some twenty years ago, and after having tried to make a deep dive in CL and Emacs Lisp two years ago, I come to the conclusion that there is no silver bullet in Lisp-land. Python is a good enough Lisp, as Peter Norvig has concluded. And it’s got all batteries included. Ain‘t nothing it can’t do. Building websites, doing maths, automating, except building compilers and OSes. But Lisp won’t compete in that field anyway.Programming languages are there to express ideas and solve problems. I can think of more elegant ways to express ideas (functional languages for instance), but Python is an excellent ecosystem for solving problems.	submeta	15.118799	-3.9675782	comment	6.0	22.0	1683480567	-10.374243
35856351	Here's a question the article doesn'	"Here's a question the article doesn't answer: why Common Lisp?  I.e. why not Scheme?  Scheme is a plenty powerful language these days with all the libraries it has available.  Granted, it doesn't have history going back to the 1950s, but it does date back to the 1970s. There are also multiple implementations, each with its own set of strengths.  And there are some solid standards written for the language that have good implementations.It seems to have all the exact same features they're saying make CL a good choice (e.g. it's hard for me to imagine that a language older than most working programmers doesn't have ""longevity"" or ""staying power."") Besides, if you click through to https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/#s8... (linked in the article), it shows a picture of the"	Paul-Craft	15.118458	-3.9740465	comment	6.0	32.0	1683499766	-10.4669695
35947217	CMU Common Lisp 21e	CMU Common Lisp 21e	mepian	15.140327	-3.9347982	story	6.0	115.0	1684154382	-10.42521
35973000	Ocicl – An ASDF system distribution 	Ocicl – An ASDF system distribution and management tool for Common Lisp	gjvc	15.141001	-3.9407306	story	6.0	41.0	1684315698	-10.435069
36017368	Lisp was always such an odd animal, 	Lisp was always such an odd animal, kind of the rotary engine of computer science.  Although provably superior in every respect, no one ever seemed to build anything with it.Programmers in the thread, when was the moment you bailed on lisp? For me it was when I saw some lisp longbeard on a message board answer a newbie's question by pasting a script that would have deleted their filesystem. I think it was meant to be some kind of teaching moment. At that point I decided this was maybe too hardcore a language community for me.I'm curious to hear what broke others, particularly since this message board infamously began as a lisp fan site.	idlewords	15.143086	-3.9428313	comment	6.0	49.0	1684634913	-10.479057
36163969	Has any lisp like language become po	Has any lisp like language become popular ? I think the most popular was Dylan and o know the racket team is doing something similar.	zitterbewegung	15.140035	-3.9462283	comment	6.0	27.0	1685707203	-10.431512
28722523	Some weeks ago I tried to start lear	Some weeks ago I tried to start learning Lisp too.I found it odd, but I’ve seen weirder. Then I tried the simple example of writing a function to compute the nth fibonacci number (it’s almost the first example). After testing some numbers, I thought it seemed slow, so I quickly implemented the same function in Rust (with recursion too).Rust took less time in compiling, and computing fib(n) for n 1..50 than Lisp to compute fib(50). Maybe I did something very wrong, but for now I’d rather learn Rust better.	xondono	15.084726	-4.004143	comment	6.0	51.0	1633116907	-10.466275
28728644	I feel inspired to start with Lisp a	"I feel inspired to start with Lisp after being disappointed with the ""open"" source scene of 2021. I'd rather pay LispWorks a yearly fee and be left alone than dealing with unbalanced people in the Python space. The free Lisp implementations also look somewhat isolated from the ideological wars.However, a C interface is required. Is this one the recommended solution? Is it really portable?https://common-lisp.net/project/cffi/What is the speed compared to a Python C extension? Are implementation-specific C interfaces faster (I guess they are)?Sorry for so many questions, but these can usually only be answered by people who have actually used the interface."	cnbland	15.13315	-3.9524817	comment	6.0	19.0	1633183521	-10.391773
28816849	One of these days I'm gonna sit down	One of these days I'm gonna sit down and properly learn Lisp. My career as a programmer is still relatively young ( < 5 years), and learning lisp won't provide any value in my day-to-day work. But understand the concepts and paradigms of Lisp certainly has to have some value.	lprd	15.147587	-3.9389672	comment	6.0	30.0	1633855561	-10.454126
28979482	Controlling the terminal with Common	Controlling the terminal with Common Lisp (2020)	winkywooster	15.150774	-3.9358733	story	6.0	91.0	1635093362	-10.316979
29006469	Better question: why not Lisp?	Better question: why not Lisp?	firebaze	15.144534	-3.943408	comment	6.0	82.0	1635283479	-10.464638
29494255	Lessons learned after working one ye	Lessons learned after working one year as a Common Lisp Developer (2018)	xept	15.14961	-3.9367552	story	6.0	194.0	1639028866	-10.436637
29630875	Author here. You know it when you se	"Author here. You know it when you see it. LISP is a tool that people want to use. People write production software using it. For example, this website (Hacker News) was written in LISP. Languages like BrainFuck are usually only called programming languages if the word ""esoteric"" is attached. There's a real consensus of opinion around this this being a generally held view.There should ideally be a more compelling explanation of why Brainfuck is an esoteric toy and LISP isn't, than me simply saying ""but that's what people believe"". I considered going into more depth on this subject. I found a C to Brainfuck compiler written in OCaml and used it to compile a Brainfuck metacircular evaluator into Brainfuck. It ended up being 88,439 bytes of code, and it sadly didn't work, because the compiler "	jart	15.134638	-3.955363	comment	6.0	19.0	1640037472	-10.421557
34322401	I was /that guy/ at my last place an	I was /that guy/ at my last place and I agree that it's not well received.Though once I was writing some lisp to fix a problem we were having and I had a developer beside me and he was blown away by what was happening. I think that the interactivity is something which must be experienced to be fully appreciated.I use it at my current start up and could not imagine using another language. I've become too used to this kind of workflow.	smcn	15.124374	-3.9576304	comment	6.0	40.0	1673343326	-6.4563885
34515137	Ask HN: What's Your Story with Lisp?	Ask HN: What's Your Story with Lisp?	divyaranjan1905	15.151358	-3.9311192	story	6.0	4.0	1674628632	-10.4314995
34541212	I'm going to straw man a bit, but it	I'm going to straw man a bit, but it feels like lisp enthusiasts are desperate to find stories of commercial software being written in lisp.I'm sure there's many examples I haven't heard of that are legitimate (using lisp for almost all of a specific domain at scale and having a mature codebase, tho that's arguable) but I've yet to see any example that has meat on it's bones, besides the company that did crash bandicoot on the PS1.And even that one I'm unsure of as I feel it's been mythologized with how often it's pointed to.I don't blame them though, I root for lisp very much. I'd rather see this articles like this posted and picked apart for validity vs not hearing about them at all.	spicybright	15.152272	-3.930394	comment	6.0	30.0	1674781762	-10.4507065
34564155	LispMe – the Scheme system for PalmO	LispMe – the Scheme system for PalmOS (2008)	app4soft	15.13485	-3.9414978	story	6.0	94.0	1674958095	-10.378369
34846737	I went there, saw the Lisp syntax, a	I went there, saw the Lisp syntax, and noped back out.	mike_hock	15.137963	-3.9472456	comment	6.0	36.0	1676726466	-10.411677
34903985	    define('ISEMAIL_STRING_AT'  , '@	"    define('ISEMAIL_STRING_AT'  , '@');
    define('ISEMAIL_STRING_BACKSLASH' , '\\');
    define('ISEMAIL_STRING_DOT'  , '.');
    define('ISEMAIL_STRING_DQUOTE'  , '""');
    define('ISEMAIL_STRING_OPENPARENTHESIS' , '(');
    define('ISEMAIL_STRING_CLOSEPARENTHESIS', ')');

I find it hard to believe people seriously still do this. This is satire, right?"	puffoflogic	15.097366	-4.000012	comment	6.0	21.0	1677105404	-10.282278
35009355	Just use vim. Yes, emacs has a lisp 	Just use vim. Yes, emacs has a lisp engine, but so does nvim[1]. Really, though, using vim properly means that it doesn't need to swallow the kitchen sink[2]. Just use vim.1: https://github.com/Olical/aniseed2: https://blog.djha.skin/p/emacs-users-im-okay-i-promise/	djha-skin	15.075161	-3.9678986	comment	6.0	27.0	1677850401	-10.287127
37323435	"    (h1 :disabled Hello world!)
    "	"    (h1 :disabled Hello world!)
    (div :class=""alert""
          So long, and (b thanks) for all the (em fish))

I hate that syntax for attributes.:class=""alert"" is strictly worse than ((class . ""alert"")) or any other variation that actually leverages s-expressions instead of merging key and value into the same symbol. Ew.Not a fan of the bare words instead of strings either, which means this cannot be naively evaluated by a Lisp.I wouldn't say this is producing html from s-exps, rather that it is vaguely inspired by them."	sph	15.062459	-4.018235	comment	6.0	47.0	1693408431	10.2511425
24430272	As a non Emacs user, is the speed of	As a non Emacs user, is the speed of Emacs Lisp a frustration in typical day to day  usage?	5h	15.066444	-3.999647	comment	6.0	20.0	1599728327	-10.390347
25147970	Archive of Lisp Machine, Inc	Archive of Lisp Machine, Inc	kristianp	15.145172	-3.9323661	story	6.0	130.0	1605780870	-10.378529
25319819	If  CL had only two namespaces, it w	If  CL had only two namespaces, it would be odd and random, but not unique.   It's like writing `./foo` vs `foo` in shell. Common Lisp is naturally more like operating system than programming language anyway.But once you realize that CL has more than two namespaces (I think it has at least nine in the language itself, unlimited in user programs) it's easier to understand how it can be more than historical accident.  People are used to  thinking words in context.I do mostly numerical programming today. Common Lisp would have been my preference and IMHO much better than Python I have no time to rewrite numpy or R libraries in CL.	nabla9	15.127011	-3.9729338	comment	6.0	32.0	1607214942	-10.449871
32604484	Corman Lisp development environment 	Corman Lisp development environment for MS Windows	eggy	15.12104	-3.9499693	story	6.0	62.0	1661501023	-10.4100275
32616396	So fun to see this — I worked on 3-L	So fun to see this — I worked on 3-Lisp for Brian at PARC back in the early 1980s.A simple way to state the proposition is: in any language there are things you cannot write in the language itself: they have to be supplied by your interpreter (or the compiler generated code which is “interpreted” by the CPU).  For example you can’t write OR because if the first case is true the second case is not evaluated — you can’t write that as a function.But you know: if you know what your interpreter is written in, what if you could pass some code to it to execute on your behalf?  You could write new kinds of control structures (beyond the standard IF, OR, etc).It has a mathematical elegance and really makes you think about the semantics of programming language execution.As an analogy, consider o/s s	gumby	15.097398	-3.9938128	comment	6.0	34.0	1661582275	-10.307645
32632468	Lisp is inspiring at first glance, b	Lisp is inspiring at first glance, but when you need to solve complex problems like references, pointers, macros, byte-compilation and native compilation it just is not expressive enough like C, C++, or Rust. Neither is Javascript. Lisp could not replace all other languages	cjohansson	15.090528	-3.9949648	comment	6.0	20.0	1661723753	-10.451681
32699983	SBCL 2.2.8	SBCL 2.2.8	susam	15.131627	-3.9360342	story	6.0	112.0	1662194730	-10.394825
32913301	GTK4 Bindings for Common Lisp	GTK4 Bindings for Common Lisp	oumua_don17	15.132804	-3.949185	story	6.0	125.0	1663688570	-10.378087
33003614	What Makes Lisp Unique?	What Makes Lisp Unique?	socialdemocrat	15.156808	-3.9301984	story	6.0	33.0	1664332104	-10.445213
33054430	Emacs-like editors written in Common	Emacs-like editors written in Common Lisp	ducktective	15.095932	-3.968781	story	6.0	120.0	1664703244	-10.359797
31812084	"[speaking broadly about any ""easy Li"	"[speaking broadly about any ""easy Lisp"" type projects]- Because you've not created anything even remotely for production use- Because you're getting any/all of the following from a host language. - garbage collection. - I/O. - numbers. - exception handling. - containers, objects, strings, regexes, unicode, .... - concurrency gizmos. - even some syntax: is it your own code that scans and converts floating-point tokens?- Perhaps you just made a parenthetical sugar that just reflects into the host language, with more or less its semantics (yes Lisp read syntax is easy-ish).- The host language you're using was hacked on by many people over many years who produced tens of thousands of commits; all you have to do is call things in it.- And/or, possibly:. - your stuff segfaults when the program h"	kazinator	15.117092	-3.966919	comment	6.0	20.0	1655741722	-10.379977
32114757	Rob Pike famously explained that C n	"Rob Pike famously explained that C needed its space-insensitive braces and semicolons in case code was transmitted through a channel that mangled whitespace.Those days predate most people reading this, yet many new language syntaxes opt for ""familiarity"". I wish that all language design went through a filter where every character mattered like the designer was in an episode of Squid Game.Bill Joy famously explained that syntax matters, a dense syntax puts more on screen. This is true even now. I struggle with this; my favorite syntax is a preprocessor that eliminates the need for most Lisp parentheses. The result is code poetry. Nevertheless, Haskell is more expressive.(Here's an easy test: Anyone who proposes a way to minimize Lisp parentheses, who hasn't introduced a symbol for missing o"	Syzygies	15.098795	-3.9988563	comment	6.0	31.0	1657938403	-10.305791
32390085	Part of the formative process of eve	Part of the formative process of every true Lisp programmer is at some point to spend 2 months creating a parens-free lisp dialect, and then abandoning it.	drcode	15.127621	-3.9614556	comment	6.0	27.0	1659987706	-10.386099
22063860	"""Some good concepts""?It was the firs"	"""Some good concepts""?It was the first language to add ""if/else"" constructs, GC, closures, first class functions, reference semantics, and recursion.It took between 5 to 40 years before these became available in mainstream languages (conditionals like if/else were adopted early, GC not so much, closures took even more). Add to that macros and the flexibility of runtime evaluation / code creation, which most mainstream languages still lack.And of course, Lisp's rules remain (and will always be) the most succinct way to define a full blown programming language with meta-programming facilities to boot -- as opposed to a mere Turing machine like thing or assembler.>IMO Lisp is just overrated, it lacks visual clues, reads right to left with horrible nesting etc..This doesn't make any sense...The"	coldtea	15.12782	-3.9662209	comment	6.0	52.0	1579177702	-10.464448
22069064	I would like to ask a genuine questi	I would like to ask a genuine question (not trying to provoke anyone!).  Where is a good use case for Scheme these days (in any form?).  I really love the idea of the language but I can't figure out where it really does a _better_ job that these things:-- JavaScript/Typescript for in-browser or even some server-side stuff (e.g., NodeJS)-- Python seems to be dominant for non-browser code that doesn't need to be fast (or which needs to call Python libraries)-- C/C++/Rust/C# in the performance space-- And then the workhorse Bash/ZSH etc for command-line script-fuI am sincerely asking, what's the nice good fit for a Lisp these days?  I know Emacs uses it as its internal language -- fair enough.  But other than that.Thanks and I did not mean to hurt anyone's feelings, I just really am curious.	wsgeek	15.087741	-4.002932	comment	6.0	18.0	1579209516	-10.389286
23729970	Lisp Badge: A single-board computer 	Lisp Badge: A single-board computer that you can program in uLisp	lnyan	15.140896	-3.936871	story	7.0	162.0	1593834849	-10.483389
23761955	> You must not use INTERN or UNINTER	"> You must not use INTERN or UNINTERN at runtime.I.e. you must not read Lisp data at run time, if it contains symbols, because that will call intern.> You should avoid using a list as anything besides a container of elements of like type.Good-bye, code-is-data.I could reduce this guide by a good 30% with ""You should avoid using Lisp as anything as Go or Java"".But that could be seen as defining a macro, which you must seldom do."	kazinator	15.120183	-3.9754336	comment	7.0	80.0	1594144158	-10.350742
23843525	The Common Lisp Condition System – U	The Common Lisp Condition System – Upcoming Book	phoe-krk	15.130661	-3.9590647	story	7.0	183.0	1594810581	-10.434924
24386826	Compiling a Lisp to x86-64: primitiv	Compiling a Lisp to x86-64: primitive functions	tekknolagi	15.131481	-3.9513686	story	7.0	126.0	1599339827	-10.378142
20059513	Lisp System Implementation	Lisp System Implementation	nils-m-holm	15.136344	-3.9468033	story	7.0	195.0	1559296004	-10.424534
20145734	Common Lisp: The Untold Story (2012)	Common Lisp: The Untold Story (2012)	tosh	15.146403	-3.9355762	story	7.0	100.0	1560166964	-10.4603405
20231749	> PG's ANSI Common LispWould you say	"> PG's ANSI Common LispWould you say PG's ANSI Common Lisp is better or worse (as a zero-to-hero intro to CL for an ""experienced"" programmer in other languages) than Peter Seibel's Practical Common Lisp?I'm curious because I'm currently teaching myself CL (slowly, as a leisurely hobby), mainly because I realized that I need a hyper-flexible un-opinionated language in my toolkit for some types of experiments I want to try on and CL seems to fit the job. But I found the ""practical"" part missing from Practical Common Lisp with the non-plausible problems/examples and also missing stuff about packaging/ecosystem and little on modern concurrency patterns..."	nnq	15.130286	-3.9691827	comment	7.0	27.0	1561030352	-10.495564
20239234	I kind of wish there was a lisp with	"I kind of wish there was a lisp with the ""recompile on error and continue"" feature of Common Lisp but without a massive standard library. A standalone SBCL program seems to be around 40MB at minimum. It feels like it would be doable if only CL wasn't designed with the kitchen sink included. Recently I've gotten into Janet[0] and really like the language, although I do miss CL's recompilation magic at times. It feels like a Lisp dialect with similar style to Lua: tables, coroutines, small language core, embeddable as a single C file, etc.[0] https://www.janet-lang.org"	nonbirithm	15.125645	-3.9522364	comment	7.0	31.0	1561082413	-10.398126
20365490	SBCL – Past, Present, Future [pdf]	SBCL – Past, Present, Future [pdf]	tosh	15.129307	-3.9417257	story	7.0	206.0	1562357692	-10.390527
20369522	Lively Linear Lisp – 'Look Ma, No Ga	Lively Linear Lisp – 'Look Ma, No Garbage' (1992)	tosh	15.153786	-3.931356	story	7.0	124.0	1562419374	-10.458062
20628987	C-mera – Lisp syntax with C semantic	C-mera – Lisp syntax with C semantics	lukego	15.093473	-3.9912033	story	7.0	59.0	1565122025	-10.32551
20631407	Programming Algorithms in Lisp: Data	Programming Algorithms in Lisp: Data Structures	nafizh	15.124611	-3.956101	story	7.0	124.0	1565143280	-10.406609
20647009	Don't take it bad, but here is my at	"Don't take it bad, but here is my attempt in creating a new ""Lisp dialect"" compiling into BASIC:  (main
    (linenumber 10 (print ""hello world""))
    (linenumber 20 (print ""Hey!""))
    (goto 10))

More seriously, is Hy anything more than writing Python with some parentheses there and there?Coding in Lisp has nothing to do with putting parentheses everywhere but rather with thinking in some specific way. For instance, I know that I am ready to code something in Lisp when I see my whole task as a sequence of CONS, but how could Hy truly implement such a thing as long as it relies on Python lists?"	baruchel	15.078853	-4.0130787	comment	7.0	24.0	1565287929	-10.061043
20789547	It’s a romantic idea but it’s simply	It’s a romantic idea but it’s simply not true. I have two examples.The first example is easy: Implement an O(1) jump table in Common Lisp that respects the lexical environment. (You can’t, unless CASE is itself optimized to a jump table, which it usually isn’t.)The second example: Consider the SAME-FRINGE [0] problem. You’ll have a hard time macro-ing your way out of that unless your Lisp implementation has a built-in API for coroutines [1], or you write extraordinarily difficult macros to CPS-convert the entirety of Common Lisp to allow for CALL/CC. The latter is itself a hefty project to do well.This is not to say SAME-FRINGE can’t be solved in Lisp. It can. The page I linked has several solutions in Common Lisp. But idiomatic solutions are consy and inefficient. For instance, the usual 	reikonomusha	15.122886	-3.9727805	comment	7.0	46.0	1566678884	-10.353242
25579236	SBCL: New in Version 2.1.0	SBCL: New in Version 2.1.0	susam	15.128905	-3.9423385	story	7.0	174.0	1609310414	-10.415528
25623118	To not go absolutely insane with Lis	To not go absolutely insane with Lisps, you need some kind of parentheses tool with your editor such as ParEdit. The up side is once you get used to your tool, you can do really cool things and navigate/change code in higher level ways. But the massive downside (in my experience), is convincing coworkers to adopt a Lisp is practically impossible. The language itself being so foreign, and when they ask about the parentheses bringing up a tool they need to learn on top of the language is a double whammy.	city41	15.106843	-3.984621	comment	7.0	42.0	1609694256	-10.340606
25623151	While I would agree that paredit in 	While I would agree that paredit in Emacs is fantastic, the real shock comes when you have to go back to editing code in those languages that have the weird arbitrary punctuation. I mean, your editor can't even properly manipulate those expressions most of the time. In order not to go absolutely insane when dealing with JavaScript, C++, Java, you need absolutely top-notch editor support, and even then you can't do everything that paredit does.This gets even worse with languages where indentation matters (Python, and the horrible abomination that is YAML) — which aren't even auto-indentable, because the editor has no idea what you actually mean. I'm not sure if you can avoid going insane with those.	jwr	15.072066	-4.004917	comment	7.0	32.0	1609694530	-10.293233
25940439	A Shell Language in Lisp	A Shell Language in Lisp	todsacerdoti	15.109082	-3.9682553	story	7.0	83.0	1611831357	-10.185388
26222374	Python for Lisp Programmers (2000)	Python for Lisp Programmers (2000)	optimalsolver	15.095499	-3.993641	story	7.0	78.0	1613985354	-10.167429
26297854	I must admit that I never understood	"I must admit that I never understood what these particular examples had to do with Lisp being such a great programing language given that you can implement exactly the same logic in basically any programing language, including for instance C (although you'd have to cheat a bit for the `deriv` function, admittedly):    #include <stdio.h>

    #define DX 0.0001

    #define DERIV(_f) float deriv_##_f(float x) { return (_f(x + DX) - _f(x)) / DX; }

    float cube(float x) { return x * x * x; }

    DERIV(cube)

    int main(void) {
        printf(""%f\n"", deriv_cube(2));
        printf(""%f\n"", deriv_cube(3));
        printf(""%f\n"", deriv_cube(4));
    }

Any language supporting closures or generics could get rid of the unsexy DERIV macro.What sets Lisp apart is its ""code as data"" approach whic"	simias	15.109531	-3.9811187	comment	7.0	32.0	1614552551	-10.346753
35521327	Conversation with Larry Masinter abo	Conversation with Larry Masinter about standardizing Common Lisp	djha-skin	15.150547	-3.9336317	story	7.0	110.0	1681192168	-10.457918
36103946	Build Your Own Lisp	Build Your Own Lisp	curious16	15.139121	-3.94101	story	7.0	115.0	1685281467	-10.448056
36155900	Which Lisp is the most practical and	Which Lisp is the most practical and easy to pick up for a programmer? I already tried emacs lisp but the experience of running emacs was not great, so I gave up	akkad33	15.114386	-3.9664648	comment	7.0	26.0	1685646550	-10.413757
36195055	But other than a Skyscanner predeces	But other than a Skyscanner predecessor (VIA), a computer algebra engine, and Grammarly, are there any other modern high profile lisp powered products?	KRAKRISMOTT	15.1397505	-3.9415534	comment	7.0	52.0	1685966254	-10.417009
36367922	So I've read that they wrote it in L	So I've read that they wrote it in Lisp at Paul Graham's request or to win favor. Does anyone know if writing your startup code in Lisp still has that benefit?	mchaver	15.135131	-3.9428184	comment	7.0	36.0	1686984411	12.083978
36478908	"Are there ""conversions"" for other la"	"Are there ""conversions"" for other languages as well? I know it's almost required reading for any software developer worth their salt, but I have several failed starts with the original version and have sworn to never have to read Lisp code. I get the gist. I get that Lisp elegantly represents the close tie between data and programs in a way that procedural programs never will, which is probably why it is chosen for the book. But no matter how perfectly suited for the task it is, I won't squint at lines ending in ))))) to try to see that meaning."	alkonaut	15.111646	-3.973397	comment	7.0	33.0	1687782919	-10.397124
36520985	Clog – The Common Lisp Omnificent GU	Clog – The Common Lisp Omnificent GUI	marcodiego	15.126953	-3.942778	story	7.0	157.0	1688049617	-10.386727
36522360	When I read things like the second p	When I read things like the second paragraph above, I start to wonder if maybe I am actually a terrible programmer because I only ever learned what you might generously call “applied computer science” aka only the languages commonly used in typical workplaces (Java, PHP, Ruby, JS) and none of the CS classics. Does anyone else without the so-called ‘academic’ languages foundation ever feel this way when you see people on HN always writing about Lisp and its peers?	xp84	15.136288	-3.9507277	comment	7.0	22.0	1688054915	-10.419319
29008699	Why does it feel like there’s more p	Why does it feel like there’s more prose about lisp being written than lisp code? I swear there’s like 15 people writing Common Lisp — Nikodemus, Shirakumo, Stylewarning, Christian Schafmeister, Borodust, the ITA folks, and maybe 2 startups.	gaze	15.140256	-3.9489434	comment	7.0	29.0	1635299161	-10.475783
12640736	No. Stop it. I don't want to hear th	No. Stop it. I don't want to hear that we should be re-writing all of our systems code in Rust, or that Oberon and the Wirth family should have won, or that C is crap, and Linux should die, and be re-written, or that this wouldn't have happened if we had all just adopted the Lisp Machine.We've all heard it already, we all know what you'll say. So skip the smug post, and go do something productive. Like writing a really cool piece of new code, or fixing a use-after-free, or posting something more insightful, or inventing a new type of shoelace that doesn't come untied until you want it to.	qwertyuiop924	15.115495	-3.9576569	comment	7.0	60.0	1475626840	-10.30901
12658145	From a Lisp POV, the only thing wron	"From a Lisp POV, the only thing wrong with NewLisp is the name.It flouts McCarthy's wish that no language be called just Lisp. Well, okay, it's not literally called Lisp; it has the ""New"" in front. On the surface, it seems to be sticking to the letter of the wish. Does it conform to the spirit, though? Is a common English adjective enough? Is ""New"" a sufficient qualifier?The mere prefixing of ""New"" looks like it's claiming to be a new version of something that is just Lisp, unqualified. A ""New Lisp"" is plausibly something that was ""Lisp"" before, and was then enhanced to create a new version derived from ""Lisp"". Lots of projects get rewritten, or otherwise revampd and called ""New Whatever"". But NewLisp certainly has no such lineage.One historic dialect was called NIL which stood for ""New Im"	kazinator	15.142712	-3.9464574	comment	7.0	56.0	1475813955	-10.454188
13193218	Is there a kind of walkthrough/tutor	"Is there a kind of walkthrough/tutorial about how to develop a little Lisp interpreter? 
That sounds like a fun experiment.PS: Sorry, I am a Java OO developper. But I like to learn :)"	lolive	15.1387005	-3.9486768	comment	7.0	22.0	1481896586	10.820735
13311952	Many folks have said it here but I'l	Many folks have said it here but I'll say it again: Common Lisp.I have been using it professionally for 5+ years as a full-time employee at various companies. Some big-name ones, some smaller start-up ones. The mean Lisp team size has been around 4, but I did work on a project of 15 Lisp programmers. None of these projects were legacy code. Some were in places you wouldn't expect (embedded, multi-processor systems on custom-designed boards, for example). In every single case, we had no additional trouble hiring a Lisp or Lisp-capable programmer as compared to hiring for any other language, including Python. (In fact, Python was more difficult to hire for because the market is saturated with beginners who claim expertise.)Lisp is one of those languages where the ratio of long-term benefits 	reikonomusha	15.123591	-3.966537	comment	7.0	30.0	1483470095	-10.488683
13355731	When I started working in bioinforma	When I started working in bioinformatics I was excited to use Lisp for my work. I wrote a considerable amount of library code and programs at first. But I always found resistance when it came to other people using my programs and even more if the program was to be published and released for general use.There is a large amount of really, really bad Perl code still in use in biology. Trust me when I say to those outside of the field, I've seen things you people wouldn't believe. I try to discourage Perl use between it makes it so easy for biologists to write terrible code.I've found a compromise in Python. People will happily use it because it's trendy and ubiquitous. And I think it makes it easier to write OK code. But I miss using Lisp. The style of programming when you have a REPL is perf	torrent-of-ions	15.118387	-3.979038	comment	7.0	46.0	1483963578	13.144873
13441272	Channels in Common Lisp	Channels in Common Lisp	codr4life	15.152631	-3.933586	story	7.0	94.0	1484878594	-10.457964
13447571	Joxa – A concurrent, distributed Lis	Joxa – A concurrent, distributed Lisp	emidln	15.118443	-3.953747	story	7.0	122.0	1484952300	-10.393093
27640984	BLisp: A Statically Typed Lisp Like 	BLisp: A Statically Typed Lisp Like Language	agentofuser	15.109629	-3.9816208	story	7.0	121.0	1624706804	-10.307843
12060734	Ask HN: Which Lisp/Scheme to go for?	Ask HN: Which Lisp/Scheme to go for?	ngeek_13	15.1258135	-3.9476297	story	7.0	8.0	1468055057	-10.462265
19174236	A Common Lisp Interpreter Built in C	A Common Lisp Interpreter Built in Cobol	abrax3141	15.135062	-3.9422538	story	7.0	88.0	1550261230	-10.223022
15782849	Writing your own Lisp-ette is a bril	Writing your own Lisp-ette is a brilliant evening or weekend project, regardless of the language. It's some of the simplest non-toy parsing you can attempt, a bit of light data structure work, and understanding eval/apply is 80% of the work in implementing it. I would highly recommend anyone to have a go, and try not to follow existing code too closely: figure out the problems in your language of choice.The post identifies some of it's own weaknesses (memory handling, errors), which are quite C specific. Or at least easier to handle in other languages, where you can punt those issues to the host language runtime. But it will be a fun extension to fix them (a job for the second evening / weekend of coding ;) )But, imho, the beauty of writing a Lisp is that there are a bunch of things you ca	sago	15.061833	-4.0028367	comment	7.0	35.0	1511728808	-10.323303
16009280	I've programmed a lot in various dia	I've programmed a lot in various dialects of Lisp, and I like car and cdr. Using names like first and rest might make a language more attractive to new users, but there is something to be said for designing at least some languages for experienced users rather than new ones, and it doesn't take much experience (a week?) for the words car and cdr to mean the left and right halves of a cons cell to you.  And once they do, they're better than first and rest, because1. They're shorter.2. They're the same length, which means in practice that a lot of code lines up in a way that's easier to read.3. They look similar to one another, which telegraphs that they're part of the same set of list access tools. Code that munges lists looks like it munges lists.4. Their meaning is precise: car just takes 	montrose	15.090489	-4.0096345	comment	7.0	41.0	1514305916	-10.551759
16387603	The languages I know typically have 	The languages I know typically have a fairly standard way of implementing functions - either values or references to values are passed as arguments and then the function does something. Maybe it returns a value. That means a construct that short circuits, such as:`if is.open(file) && read(file) { ... }`can't actually be implemented by a function. That is, you can't write a function:`special_and(is.open(file), read(file), ...)`Because the `read` is automatically evaluated before the function is called.This means a programming language with lisp-style macros can very easily implement constructs that behave like `&&` and short circuit, because they are implemented as a macro instead of a function. This opens up new (& fast) ways to control program flow that aren't available to a lot of people	roenxi	15.117175	-3.9797316	comment	7.0	22.0	1518728578	-10.359546
16387820	I'm starting to think that the reaso	I'm starting to think that the reason Lisp has never taken off outside a minority of users is that homoiconicity is a downside for the human readers of the language; computers are happy to count brackets, but humans prefer either different types of brackets or other separators like ';' or 'newline'.	pjc50	15.109782	-3.987156	comment	7.0	29.0	1518730235	-10.374197
16447905	The Nature of Lisp (2006)	The Nature of Lisp (2006)	peterkelly	15.149643	-3.9356222	story	7.0	109.0	1519407938	-10.462182
17038246	Type declarations in Common Lisp are	Type declarations in Common Lisp are unsafe. Violating a declaration at runtime is UB.What SBCL is doing to Common Lisp is similar to what C compiler vendors did to C. In order to win at benchmarks, C compiler vendors started to use UB as a license to miscompile optimized code, which got them better benchmarks.Common Lisp has very little UB, so the C strategy is harder to execute.SBCL basically first needs to sucker their users into overusing one corner of the language that does have UB, type declarations.They get their benchmarks, at the cost of saturating the ecosystem with code that overuses UB, basically poisoning the ecosystem.	YouAreGreat	15.127645	-3.9554038	comment	7.0	45.0	1525955741	-10.333634
17440046	I don't get the downvote. This is my	I don't get the downvote. This is my experience too. You browse a code source, unable to understand some of it. You google it and find nothing. Only to realize that the author defined it's own little world. As usual, zero unitest or tutorials. It makes lisp a terrible experience for beginers.	sametmax	15.14879	-3.940151	comment	7.0	40.0	1530519280	-10.429121
17534603	My problem with Haskell is that it i	"My problem with Haskell is that it is not pragmatic and the reason I stopped using it. The philosophy of separating pure and impure code – and to enforce it – does more harm than good. Often its difficult to understand what your ""forth level of abstraction code"" above the usual abstraction levels really does. Haskell is fun to learn. Haskell has a lot of interesting concepts to explore and it will make you a better programmer. Haskell code can be really dense. And Haskell code can be totally unreadable, using concepts which take weeks to learn – which is... not so great.Lisp (Common Lisp) is what you get when you reduce the rules and syntax to a minimum and try at the same time to be a maximal flexible programming language. This simplicity and applied pragmatism is what makes it so great. "	thibran	15.114399	-3.9932387	comment	7.0	60.0	1531649697	-10.477375
17534828	The ability to come up with new synt	The ability to come up with new syntax in LISP is in my opinion vastly overrated.Yes, LISP code can be easily parsed for as long as you stick to lists. However the ability to do anything complicated with LISP code is simply not there because LISP code loses type info, which is extremely important for anything you’d want to do with code, like all kinds of non-superficial transformations and refactorings.So here are some facts given as examples:(1) LISP code does not make the job of IDE authors easier; just ask the authors themselves(2) in terms of macros, anything more complicated than lazy evaluation of thunks and kiddie examples is out of reach; for example .NET’s LINQ cannot be expressed in LISP, not unless you add a static type system, but at that point you’re no longer talking about LI	bad_user	15.118521	-3.9779859	comment	7.0	36.0	1531655344	-10.418925
17644067	Practical Common Lisp (2009)	Practical Common Lisp (2009)	tosh	15.140176	-3.9443257	story	7.0	144.0	1532955415	-10.421607
17645275	Can anyone please comment what advan	"Can anyone please comment what advantages and short-comings Common LISP has over ""modern LISP"" (i.e. Clojure)?"	m0skit0	15.125561	-3.974799	comment	7.0	76.0	1532965644	-10.622659
21757201	ABCL – Common Lisp on the JVM	ABCL – Common Lisp on the JVM	simonpure	15.133435	-3.9551175	story	7.0	145.0	1576014343	-10.515903
39183613	The problem with CL is not that it d	"The problem with CL is not that it does everything, but that it does everything with a mish-mash of inconsistent idioms, thick layers of jargon, and implementation-specific behavior in places where you wouldn't really expect, leading to a combination of implementation lock-in and dependence on 3rd-party libraries that is stronger than one might expect at first.My (least) favorite example:  (nth needle haystack)
  (aref haystack needle)

Ugh! But then again, what other language provides both AREF and ROW-MAJOR-AREF?And of course CL tooling is just weird if you aren't used to it.Quicklisp is amazing! But it has no CLI and doesn't use HTTPS for package downloads.Swank and Slynk is amazing! But clients other than Slime and Sly are second-class citizens.SBCL can generate a compiled binary, cool"	nerdponx	15.114569	-3.9551926	comment	7.0	25.0	1706567153	-10.372707
18193015	It’s interesting seeing lisp try and	It’s interesting seeing lisp try and make a comeback, I wonder if it’ll work.As one of the few programmers who has worked in CL commercially in this century, my general analysis is that the language has way too much rope. The code base I worked on wasn’t too clever by half, it was too clever by leaps and bounds. I’d genuinely never start a multi engineer project in Lisp ever.	village-idiot	15.132595	-3.9518294	comment	7.0	81.0	1539262041	-10.438495
18202863	Interim OS: minimalist OS influenced	Interim OS: minimalist OS influenced by Lisp machines and Plan 9	pmoriarty	15.120858	-3.942703	story	7.0	197.0	1539363926	-10.296002
18267897	If you are used to any reasonably mo	If you are used to any reasonably modern programming language, writing any serious Elisp is an exercise in frustration, it is hard to even find out at all how to accomplish basic things, and once you do, there are tons of pitfalls, it is a legacy platform and it feels like its evolution over time was largely accidental. I am talking about doing basic things, working with lists, maps and strings, opening files, running processes, making HTTP requests, etc.For example, if you want to use a map, you have three choices: you can use alists, plists or hash maps. There are no namespaces in Emacs Lisp, so for each of the three data types you get a bunch of functions with weird names. For alists get is assoc and set is add-to-list, for hash maps get is gethash and set is puthash, for plists get is 	stiff	15.099466	-3.993026	comment	7.0	38.0	1540128914	-10.455072
18428683	> Even after a short while, you'll f	"> Even after a short while, you'll find these brackets seem to become automatic and mentally disappearIs this really true? It's by far the most off-putting thing about Lisp dialects to me. Trying to get nested parentheses to match is extremely tedious when I have to do it in non-Lisp languages. It seems horrific if my whole programming experience is one long exercise in ""why doesn't this bracket match!?!?!!"". I know it can't be this bad because too many people have no problem with it, but it's the only thing I can think when I see some Lisp source code with 50 nested parentheses ..."	zmmmmm	15.0664	-4.028734	comment	7.0	34.0	1541971458	-10.294295
30043224	Llisp: Lisp in Lisp	Llisp: Lisp in Lisp	stopachka	15.141534	-3.9452696	story	7.0	86.0	1642907102	-10.427848
30053293	How to make Lisp go faster than C (2	How to make Lisp go faster than C (2006) [pdf]	marinesebastian	15.137038	-3.9516127	story	7.0	84.0	1642993911	-10.440746
33194162	I’ve been meaning to read Practical 	I’ve been meaning to read Practical Common Lisp for some time. Would you recommend this even for complete beginners to Lisp?	cepher	15.153451	-3.9378467	comment	7.0	22.0	1665682774	-10.455435
33201363	Zero Feet: a proposal for a systems-	Zero Feet: a proposal for a systems-free Lisp	contrapunctus	15.13255	-3.942285	story	7.0	148.0	1665739507	-10.430402
33559198	The one about Lisp interactivity	The one about Lisp interactivity	lycopodiopsida	15.147326	-3.9375126	story	7.0	107.0	1668164073	-10.432733
33765735	Emacs Lisp shorthands as namespacing	Emacs Lisp shorthands as namespacing system	gjvc	15.116079	-3.9723282	story	7.0	102.0	1669576696	6.6500854
34012632	Neat, another one to add to my colle	Neat, another one to add to my collection: https://taoofmac.com/space/dev/lisp(you can find most small LISPs there, reply here if you know more to add)	rcarmo	15.119594	-3.9444356	comment	7.0	23.0	1671183470	-10.451673
34022276	I think John Carmack made a good poi	I think John Carmack made a good point on this topic which I did not think of before.He stated that albeit he spent years working with Lisps (CL and Racket mostly) or Haskell he stated that jumping on projects in those languages instantly requires you pay the price of having to learn the abstractions and DSLs that the users wrote for the project before being able to understand anything.He compared it with C or Go, where he realized that it was easier to him to read kernel code without any context, because there is no abstraction price to pay. What you see is what there is to understand.He basically says that those languages (MLs, Lisps) are great for personal projects or very small teams but they don't scale well, this also reflects on open source where many will build their libraries and 	epolanski	15.12174	-3.965617	comment	7.0	26.0	1671234445	-10.453267
26527415	This is pretty tangential, but I don	This is pretty tangential, but I don't understand why there isn't a roguelike framework available for Emacs. It seems like the perfect roguelike platform for playtesting and hacking on and would on-board a lot of new people into the Emacsen ecology without any real difficulty. The standard roguelike library libtocd has bindings for every other language--why not elisp?	cheezymoogle	15.107581	-3.9543502	comment	7.0	21.0	1616290330	-10.406787
26527996	"I've been hearing the ""code is data"""	"I've been hearing the ""code is data"" mantra often, but the reason I never thought this was a desirable property is that it seems trivial to define any number of languages as their own AST.  But there is a good reason that we don't program by writing out ASTs - it's relatively hard to read and manipulate.  Does the Lisp implementation just happen to be particularly readable?"	foobarian	15.111919	-3.9789014	comment	7.0	22.0	1616299007	-10.330149
26663135	Bash-LSP: A language server for Bash	Bash-LSP: A language server for Bash	ducktective	15.073028	-3.985562	story	7.0	224.0	1617296386	-10.227371
26722907	We programmers are very picky someti	We programmers are very picky sometimes. I wonder if the Lisp would have taken off better if it had parentheses free syntax. It could have been easier to sell for uninitiated that way.I just found out that there exists Wisp [1], that basically removes the parentheses for indentation.https://www.draketo.de/software/wisp	Ciantic	15.105186	-3.990019	comment	7.0	29.0	1617791917	-10.338099
27035731	I learned programming around 1985 on	I learned programming around 1985 on one of these Casio pocket computers. It ran Basic interpreter not lisp. Incredible little machine. It looked like this: https://www.ebay.com/itm/143595147094 I probably would not be a software engineer at a top company today without it.	flowerlad	15.122303	-3.9480326	comment	7.0	22.0	1620122468	-10.378813
27039048	I love lisps, but isn't using a garb	I love lisps, but isn't using a garbage collected language on a micro a bit bizarre? I'm sure in lots of cases it won't matter, but then you could probably can use some cheap ARM SBC and IO pins (and a full dev environment).the Venn diagram of situations where a SBC won't do and you don't care about random pauses seems kinda small.. I could be wrong	geokon	15.137668	-3.9392939	comment	7.0	25.0	1620144154	-10.417161
27298110	Does the Common Lisp standard need t	Does the Common Lisp standard need to be revamped? I remember seeing stuff about CL21 a while back...I keep my eyes peeled for anything Scheme on GitHub, I love reading Scheme code, and seeing R7RS march eternally forward has brought me a lot of joy over the past few years.But try as I might, and I HAVE tried, I just don't see Common Lisp as dealing with modern computing that well. It looks crufty and tired where Scheme continues to refine and sharpen. And then there's Clojure, which has become what I always kinda thought Common Lisp should've tried to become.This isn't a very good comment, I guess it just always amazes me how much innovation is still happening from simple, unfancy s-expressions. Thank God.	adenozine	15.13031	-3.9671404	comment	7.0	40.0	1622077114	-10.600351
27307024	Ultimately it’s all data. The differ	Ultimately it’s all data. The difference between this and lisp is just a bunch of extra characters and noise in the stream.What is really the meaningful difference between this and an s-expression language? “” and {}, really. It’s a different way to serialize the same thing.So I’d argue a lot of the criticism is valid.We do, as an industry, tend to run in circles.	whalesalad	15.097379	-4.0022783	comment	7.0	27.0	1622143313	-10.414367
14725878	Show HN: A notebook-style Common Lis	Show HN: A notebook-style Common Lisp environment	cddadr	15.118178	-3.9486804	story	7.0	180.0	1499530101	-10.04692
15033769	Lisp is the only high-level programm	Lisp is the only high-level programming language that has no syntax. In Lisp, s-expressions are used to encode both form (data structures) and function (algorithms) of computer programs. Since code and data are seen for what they are (two sides of the same coin) the distraction of a real PL syntax is eliminated, and the programmer is able to think more coherently.	idibidiart	15.097265	-4.000774	comment	7.0	38.0	1502943289	-10.394948
15057548	McCLIM: A GUI Toolkit for Common Lis	McCLIM: A GUI Toolkit for Common Lisp	tosh	15.127956	-3.9453433	story	7.0	165.0	1503218580	-10.450127
15418762	This book is destined to be a classi	"This book is destined to be a classic programming book, just as ""The C programming language"", ""The Little Schemer"" or ""Operating systems: Design and implementation"".I would really like to meet Conrad Barski and give him a great hug. And invite him a good beer.Be sure to read the comic that is on the bottom of the page!!Now, to be honest, a quicker or more practical introduction to Lisp would be the ""Practical Common Lisp"" book which is also superb. However, Land of Lisp is a charming book that makes you smile and feel like a nerdy (in a good way) 12 years old kid in 1982 who just got as a birthday present a brand new Commodore-64 and is eager to read the manuals!"	flavio81	15.147463	-3.9328525	comment	7.0	35.0	1507312207	-10.446118
15571286	Counterpoint:The words he says are n	Counterpoint:The words he says are nice, and his depth of knowledge is profound, but he hasn't actually provided any evidence making the case that lisp is better and/or in what scenarios it is better.That this sort of rhetoric is the way almost all programmers and language designers try to find truth and communicate ideas is probably why we ended up all programming in javascript.  We have no rigor, we are like Freud era psychology with flowering and impressive sounding prose but no real data.  And while psychology still has a long way to go, we have even further.	jackmott	15.148995	-3.937982	comment	7.0	36.0	1509131352	-10.44259
35208166	CIEL is a ready-to-use collection of	CIEL is a ready-to-use collection of Lisp libraries	gjvc	15.131216	-3.9444091	story	7.0	65.0	1679139093	-10.412603
28109398	I am Ron Garret (f.k.a. Erann Gat), 	I am Ron Garret (f.k.a. Erann Gat), the author of the followup study mentioned in TFA.  I am, frankly, amazed that this work is getting the amount of attention that it is over 20 years after it was published.  I have a couple of comments about this latest critique.> Given that the participants were recruited from internet groups, I doubt that the subjects were monitored in place, which makes me think that the Development time data collected should be taken with a giant grain of salt.> Based on a small study like Garret’s, I find that the premise that Lisp is so great is unwarranted.That's a fair criticism.  In my defense I will say that I didn't actually claim that Lisp is great, only that it seems plausible that it might offer the development speed and runtime safety advantages of Java an	lisper	15.142714	-3.944224	comment	7.0	48.0	1628451024	-10.448809
22429496	Market share, maybe.Mindshare - Lisp	Market share, maybe.Mindshare - Lisp has its zealots. C++ is tolerated rather than adored, because it's more of a Katamari Damacy of stray CS than a language with a coherent focus.How many other languages have a Turing complete sublanguage built into them just to handle templating?	TheOtherHobbes	15.117904	-3.9733372	comment	7.0	30.0	1582767112	-7.001327
34374033	Agree with the parent, it's a langua	"Agree with the parent, it's a language worth knowing like LISP is worth knowing, but (unlike LISP) it is not a good language choice for almost all use cases in 2023 (almost all use cases are not that memory constrained any more, even embedded systems), for the same reason you shouldn't use Perl (it is very hard to read code).I was going to say ""its main disadvantage is that the only way to find out what a piece of code does is to execute it mentally"" (non-declarative) but one may say that of every language to an extent. Instead I will say it feels like using a macro-assembler for a stack VM.Clifford Stoll, author of ""The Cuckoo's Egg"", in which he described how he chased a hacker, allegedly used FORTH to control a radio telescope (https://www.amazon.co.uk/gp/product/1416507787) back in the"	jll29	15.12571	-3.953095	comment	7.0	32.0	1673644848	-10.436661
34909975	There's a weird spike in new account	There's a weird spike in new accounts with what appear to be AI generated comments in this thread.One problem I run into when learning Common Lisp is ASDF. For some reason I can't figure out how to use it properly. For example, when I open a system definition in a new REPL, what's the expected workflow? I'm using emacs and slime by the way. Maybe my environment is set up wrong. I also have to prefix the `defsystem`s with `asdf:`. When I look at examples in open source projects they just straight up use `uiop` functions and `defsystem` in their `.asd` files without the package.	147	15.138332	-3.9453752	comment	7.0	26.0	1677157458	-10.409531
34950743	What makes people see Lisp-like lang	"What makes people see Lisp-like languages and think to themselves ""yep, this is how I want my code to look like"" is beyond me"	brap	15.129388	-3.961261	comment	7.0	39.0	1677453310	-10.427413
35077738	Sorry if I am being ignorant, but ca	Sorry if I am being ignorant, but can someone explain to me Hackernews' obsession with Lisp? I don't hear anyone talk about Lisp or use Lisp anywhere except on Hackernews.	Arbortheus	15.148782	-3.9340637	comment	7.0	28.0	1678329489	-10.464908
13626074	Lisping at JPL (2002)	Lisping at JPL (2002)	gkya	15.153891	-3.9304807	story	7.0	71.0	1486863686	-10.475629
13933762	"""Modern C++ has shifted focus from a"	"""Modern C++ has shifted focus from an emphasis on type (objects) which accommodate algorithm to an emphasis on algorithms parametrized over types.""That may be a bug, not a feature. The Boost crowd won the battle, making extremely complex templates an essential part of the language.  But they may have lost the war, as C++ loses market share.LISP backed into typing, and it shows.  Both typed variables and objects are painful in LISP.  By the time LISP got both, the era of LISP was over.  LISP is really dead now; there hasn't been a release of GNU Common LISP (""clisp"") in 7 years."	Animats	15.13074	-3.9633968	comment	7.0	37.0	1490209747	-10.380407
14013797	But all those parentheses!I know it 	But all those parentheses!I know it sounds like a lame reason to dislike a language, but I've always found staring at Lisp to be so much more difficult and distracting than C-style syntax.	bluejekyll	15.105413	-3.988762	comment	7.0	23.0	1491076085	-10.3661785
14480736	He writes a seductive argument, but 	"He writes a seductive argument, but it isn't very satisfying to conclude ""this language is so powerful that it defeats itself"". Likely there are other, more mundane reasons why the theoretical purity of the lisps isn't useful in practice.For example, the endless (bracketing). My understanding is that the power of lisp macros comes from this questionable, but distinctively lispy, syntax. And I say questionable compared to natural human scripts - none of them work from inside to out. I've seen left to right (eg, English), right to left and up to down (eg, Chinese). If there were some better known examples of what lisp macros were good for then maybe it would get better traction. But lisp macros don't seem to have an example of why they are worth that trade.Also, in the early days, C was a pr"	roenxi	15.135802	-3.9568655	comment	7.0	23.0	1496573075	-10.423417
14511771	I know at first it looks confusing, 	I know at first it looks confusing, but the lisp syntax is pretty much the best. I can teach it to someone in 1 minute:(<function or macro name> arg1 arg2 ...)That's it. This is 100% of the syntax.If dealing with a function, the evaluation will always be arguments from left to right are evaluated first, and then the function is called with the result of evaluating the args. This is 95% of the cases.If dealing with a macro, go read the documentation for it, because every macro is a DSL, and evaluation can happen in different ways. This is the 5% case.All the complexity of learning a lisp comes from knowing more functions, what they do and how to use them, and learning each macro's DSL.Can this syntax be improved on, I'm not so sure. Clojure added some special syntax for some more literals, 	didibus	15.09133	-4.0207524	comment	7.0	75.0	1496893493	-10.472873
30812626	I'm as big of a Lisp fan as can be. 	I'm as big of a Lisp fan as can be. I'm a proud owner of Symbolics and TI hardware: a MicroExplorer, a MacIvory, two 3650, and two 3620. Not to mention an AlphaServer running OpenGenera.Today, we have computers that run Lisp orders of magnitude faster than any of those Lisp machines. And we have about 3–4 orders of magnitude more memory with 64-bits of integer and floating point goodness. And Lisp is touted to have remained one of the most powerful programming languages (I think it's true, but don't read into it too much).Yet, it appears the median and mean Lisp programmer is producing Yet Another (TM) test framework, anaphoric macro library, utility library, syntactic quirk, or half-baked binding library to scratch an itch. Our Lisp programming environments are less than what they were in	reikonomusha	15.138184	-3.9546442	comment	7.0	80.0	1648308245	-10.39991
31054796	Using SBCL Common Lisp as a Dynamic 	Using SBCL Common Lisp as a Dynamic Library	goranmoomin	15.127542	-3.9418461	story	7.0	167.0	1650133826	-10.401489
31153702	The Mysteries of Lisp (2015)	The Mysteries of Lisp (2015)	wslh	15.148114	-3.934349	story	7.0	106.0	1650890988	-10.441354
31292715	What language constructs should a (T	What language constructs should a (Turing complete) Lisp have to be considered one? Is there a spec somewhere, a minimal conformance guide? I don’t think it’s just the parens that make the Lisp.I suppose it needs:* car and cdr* if* list* eval* quoting and quasiquotingWhat else?	sph	15.123605	-3.97011	comment	7.0	28.0	1651907012	2.9333968
39575127	I said this in another thread too, b	"I said this in another thread too, but the problem with Lisp is that it's sorta bundled with Emacs, so if you want to use LISP's powerful REPL you really have no choice other than learning Emacs. Essentially, Lisp is not just a ""language""; it's a whole system designed to explore programming ideas. It includes the IDE, the minimal syntax, REPL, compiler, etc. All of this together makes ""Lisp"" the powerful and enlightening tool that people talk about.I think the other ""inconveniences"" of Lisp could be more tolerable for beginners if learning the language didn't require learning a new IDE (or OS, depending on how you define Emacs!). But at that point you'd have to forego a major benefit of using Lisp (its REPL); you'd be back to writing ""dead"" programs, not image-based ""live"" ones.Another pro"	behnamoh	15.147396	-3.9380422	comment	7.0	21.0	1709407941	-10.469004
36665498	Sounds like it’s mostly lisp. How ma	Sounds like it’s mostly lisp. How mathematically correct and proven (in the math sense) is lisp?	ianai	15.137244	-3.9503565	comment	7.0	26.0	1688992941	-10.374117
36704396	The LISP 2 Project (2017)	The LISP 2 Project (2017)	mepian	15.140368	-3.937559	story	7.0	61.0	1689215757	-10.418271
36844673	Mark Watson's Lisp books	Mark Watson's Lisp books	KRAKRISMOTT	15.148781	-3.9330292	story	7.0	235.0	1690187951	-10.433399
36888454	I have some cons!Last time I checked	I have some cons!Last time I checked on it, QuickLisp doesn't support fetching packages over anything except for plain http, with no encryption and no verification mechanism in place to detect files that may have been tampered with during transmission.I think not supporting encryption or authentication for something as important as fetching source code makes QL a non-starter for me and hopefully for anyone else who cares about security.Another issue I have ran into, is that SBCL is hosted on sourceforge, which has in the past injected malware into projects downloadable archives! I consider this to also be a security issue, and sourceforge in general is not pleasant to work with. I don't think there are any valid reasons to continue to use sourceforge today, so why such an important project	chlorion	15.084668	-3.950436	comment	7.0	37.0	1690427588	-10.402907
36926227	> First, read a textbook about progr	"> First, read a textbook about programming in some language, then manuals for several programming languages including Lisp. If they make natural intuitive sense to you, that indicates your mind is well-adapted towards programming.> If they don't make intuitive sense to you, I suggest you do something other than programming. You might be able to do programming to some degree with a struggle, but if you find it a struggle you won't be very good at it and you won't enjoy it. What's the point of programming if it is a struggle instead of a fascination?I find this gatekeeping at odds with RMS's insistence that all software should be open source. What is the purpose of open source, if you can't do anything with the source code?Whether or not you agree with the ""open source everything"" mantra, I "	Wowfunhappy	15.13602	-3.9427214	comment	7.0	30.0	1690675625	-10.456428
37416544	I would bet that He writes Lisp. Ult	I would bet that He writes Lisp. Ultimately everything is the same. Particles. Above it: particles made of particles.	galfarragem	15.153776	-3.932008	comment	7.0	31.0	1694078658	-10.453947
37443200	It is still fascinating that lisp la	It is still fascinating that lisp languages lost to python for AI and data processing and now pretty much everything else. In a perfect world , we would be using lisp or lisp like languages for everything	anoy8888	15.134927	-3.9511795	comment	7.0	31.0	1694246327	-10.43331
24652842	Compiling a Lisp to x86-64: Let expr	Compiling a Lisp to x86-64: Let expressions	todsacerdoti	15.13439	-3.9473515	story	7.0	131.0	1601569585	-10.394658
24653390	In this I agree with Paul Graham (an	"In this I agree with Paul Graham (and note I don't worship the guy). When talking about some lisps, he wrote [1]:> As names, car and cdr are great: short, and just the right visual distance apart. The only argument against them is that they're not mnemonic. But (a) more mnemonic names tend to be over-specific (not all cdrs are tails), and (b) after a week of using Lisp, car and cdr mean the two halves of a cons cell, and languages should be designed for people who've used them for more than a week.In particular, the last sentence. I find arguments that go ""but this looks confusing to a beginner!"" unconvincing. Language syntax and notation should be aimed at actual practitioners, not beginners.----[1] https://news.ycombinator.com/item?id=21256727"	the_af	15.133498	-3.9560075	comment	7.0	57.0	1601571807	-10.484082
24729547	Common Lisp has had multiple dispatc	"Common Lisp has had multiple dispatch for decades. Yet another Lisp feature ""taken"" by another language - why not just start with a Lisp and improve it (e.g. Typed Racket, for performance) rather then repeatedly creating new languages and just adding a tiny piece of Lisp to them each time?"	fouric	15.129722	-3.9608803	comment	7.0	42.0	1602249174	-10.458097
24809293	Lisp from Nothing	Lisp from Nothing	nils-m-holm	15.152581	-3.9341269	story	7.0	182.0	1602935297	-10.4554825
25440690	Show HN: Emacs4CL: 35 line .emacs to	Show HN: Emacs4CL: 35 line .emacs to turn Emacs into Common Lisp dev environment	susam	15.102555	-3.960757	story	7.0	80.0	1608111928	-10.304007
32592492	Lisp can be “hard” real time [pdf] (	Lisp can be “hard” real time [pdf] (2000)	ducktective	15.1462755	-3.932455	story	7.0	154.0	1661428591	-10.474059
32631702	I don't buy that, when you do the sa	"I don't buy that, when you do the same in other languages you get:    for (var i = 1; i < 101; i++) {
        if (i % 15 == 0) {
          console.log(""FizzBuzz"");}
        else if (i % 3 == 0) {
          console.log(""Fizz"");}
        else if (i % 5 == 0) {
          console.log(""Buzz"");}
        else {
          console.log(i);}}


Why do you think nobody other than lispers writes code like this? Is it really necessary to write code that way? If it is better, why not does nobody else do it? They can also use colored bracers and tooling, while lispers has written code that way forever.I'm sure a big reason people call lisp a ""write only language"" is because of this strange convention of stacking all parentheses in a big clump instead of formatting like normal."	Jensson	15.123323	-3.9720178	comment	7.0	22.0	1661718088	-10.372773
32763525	By the way, I always wondered why no	By the way, I always wondered why not just take a lisp, put every single thing (even an operator) on a separate line and indent every level of parentheses with a space or two (4 spaces is too much - deep nesting would go too much to the right). So there would be no need for the parentheses in most cases.	qwerty456127	15.085884	-4.007555	comment	7.0	21.0	1662631921	-10.32902
22094722	Femtolisp: A lightweight, robust, sc	Femtolisp: A lightweight, robust, scheme-like Lisp implementation	lelf	15.143596	-3.933836	story	7.0	146.0	1579474545	-10.4188795
22103363	Controversial opinion but I believe 	Controversial opinion but I believe that eventually these grammars and complex parsers will be found to have been a huge mistake for computer science. A mistake made for the sole reason of making programming languages resemble natural languages, even though they are not meant to be read fluently.Everyone who experienced the magic of lisp understands how beneficial it is to have the textual representation as close to the parsed abstract syntax tree. One can create new languages fit for the purpose of a given class of problems and thus reducing size of codebase 10 to 100 fold (or even million times in case of modern multi million LOC software projects).The biggest mistake lisp ever made was the unintuitive parenthesized prefix notation. Which can be thrown away by having all operations stric	snidane	15.102239	-3.9941297	comment	7.0	55.0	1579567954	-10.327718
23697753	LISP has an insidious parenthetical 	"LISP has an insidious parenthetical notation, and is well known to be a ""write only"" language, where nobody but the author can understand large programs written in LISP. It is avoided commercially for this reason."	magicmouse	15.109017	-3.9849076	comment	8.0	27.0	1593577772	-10.421621
20505378	I'm writing a book about algorithms 	I'm writing a book about algorithms and Lisp	ska80	15.126541	-3.9315822	story	8.0	407.0	1563872512	-10.397372
20503742	The best way to kill a good Lisp is 	"The best way to kill a good Lisp is to remove the parentheses.The people who complain about parens are still going to ignore your language even after you remove the parens, and then the Lispers will ignore you too. See Dylan.This debate is exasperating. It's like hearing people say ""I'm not interested in that Ferrari because it has a manual transmission."" The only response to which is a silent, cold stare."	dreamcompiler	15.14723	-3.943889	comment	8.0	46.0	1563845222	-10.479462
20505807	Common Lisp Style Guide	Common Lisp Style Guide	ska80	15.148878	-3.9368236	story	8.0	114.0	1563879988	-10.457433
20774358	It just breaks my heart to see Uncle	It just breaks my heart to see Uncle Bob seduced by a Java-family language right when C++ is getting increasingly fun. He suffered through the bad old days when C++ was only fast and powerful, and is now missing out on the good new days.I guess he's happy. At least he isn't touting Haskell. Bon Voyage, Bob!But somebody needs to break it to him that Lisp is not a functional language. Or, if it is, so is C++.	ncmncm	15.125686	-3.9608643	comment	8.0	25.0	1566531756	-10.427191
39466417	"Reading ""A Programmer's Guide to Com"	"Reading ""A Programmer's Guide to Common Lisp"""	Tomte	15.143751	-3.9375503	story	8.0	195.0	1708606822	-10.440033
36561897	A curated list of Emacs Lisp develop	A curated list of Emacs Lisp development resources	andsoitis	15.133421	-3.9449995	story	8.0	122.0	1688308892	-10.422816
37209654	Ask HN: Is Lisp Simple?	Ask HN: Is Lisp Simple?	erlich	15.113185	-3.9872475	story	8.0	7.0	1692626354	-10.403174
24642998	Lisp (Common Lisp) beats all the oth	"Lisp (Common Lisp) beats all the other dynamic languages by a considerable margin. This is why I am developing Clasp - a Common Lisp implementation based on LLVM that interoperates with C++/C (https://github.com/clasp-developers/clasp.git) for scientific programming.With Clasp, we get the best of multiple worlds. We get a dynamic language (Common Lisp) with automatic memory management and enormous expressive power that can directly use powerful C and C++ libraries.  All three of these languages are ""long-lived"" languages in that code that was written 10 and 20 years ago still works.Performance is really important to me and I have written a lot of code over the past four decades. I won't develop meaningful code in any language that falls below Racket in table 4 because these language implem"	drmeister	15.127972	-3.9607975	comment	8.0	53.0	1601495558	-10.379195
24867548	Show HN: My book, The Common Lisp Co	Show HN: My book, The Common Lisp Condition System	phoe-krk	15.130122	-3.933809	story	8.0	177.0	1603445507	-10.41878
24892881	I've never really bothered to learn 	I've never really bothered to learn lisp, but this is incredible. I get it now.That being said, I wonder how data types would work as opposed to lists. What would a language based around maps look like?	nynx	15.107477	-3.9912274	comment	8.0	30.0	1603687266	-10.40909
24893821	Can anybody recommend resources for 	"Can anybody recommend resources for the ""next level""? I get that ""code is data"", the ""unless"" example is nice, but what I don't get is: why would I want to do that?As a non-LISP developer I get by without macros and all the fancy things that are possible with LISP. I would like to see a strong case of daily tasks that are much easier with LISP macros. Anybody?"	blackbear_	15.13565	-3.9529815	comment	8.0	34.0	1603699695	-10.402318
32631578	> )))))You could stack them like thi	> )))))You could stack them like this in every language but only in Lisp do people actually do it. Lisps bad habbit of stacking all the parentheses like that is what makes it so hard to read. It is easier to write that way, but it is very hard to understand how many contexts up you just moved.	Jensson	15.085549	-4.011302	comment	8.0	49.0	1661717077	-10.359557
32630675	An Intuition for Lisp Syntax (2020)	An Intuition for Lisp Syntax (2020)	cercatrova	15.124509	-3.9697878	story	8.0	175.0	1661711088	-10.430007
32058142	Uhoh.  Author of the post here.  You	"Uhoh.  Author of the post here.  You know, when a post leaves its target audience, it can really make all the difference, huh?  Last week I had a post on HN's frontpage and it was aimed at a general audience, it was an introductory topic (an intro to Scheme, without assumptions of involvement in that community).  This time it's a post of mine I wrote off the cuff talking to a specific audience about a specific topic (specifically, me musing out loud about a project that would be interesting to the Guile community, to the Guile community).  And that's fairly reflective in the replies here.- Common Lisp is the only real lisp and anyone who's not using it reinvented it badly?  Check.- Questioning what is ""systems programming"" and yes I actually already did that in the post itself, it's a larg"	paroneayea	15.150043	-3.938007	comment	8.0	28.0	1657556332	-7.3735023
32227800	Programming languages! It is ironic 	Programming languages! It is ironic because I am a programmer and I write programs and develop software for a living. But proliferation of programming languages has made my life worse. Too many programming languages and every company has their own favorites!It may be an unpopular opinion on HN but I don't enjoy learning new syntaxes every year for relatively few benefits in new concepts or paradigms.In my ideal world everyone would be using Lisp (my username checks out!) but so much power. It has a simple syntax (some say it has no syntax but I think that is a little hyperbole). In my ideal world new concepts and paradigms are implemented in Lisp using Lisp. I'd much rather spend time solving real problems that real human beings care about. I'd much rather learning new ways of solving prob	commonlisper	15.135213	-3.9529974	comment	8.0	26.0	1658770027	-10.435901
22030649	Ask HN: Why Shouldn’t I Use Lisp?	Ask HN: Why Shouldn’t I Use Lisp?	nicholas-cc	15.143196	-3.9483235	story	8.0	11.0	1578873389	-10.479719
22141407	This is what drove me away from lisp	This is what drove me away from lisp.If everyone says you have to use a plugin to auto-insert parentheses, that means computers know where they go. So why are we writing them??	Swizec	15.100338	-3.9928708	comment	8.0	32.0	1579892959	-10.3193245
13886441	> The super advantage of Lisp (inclu	> The super advantage of Lisp (including Scheme): Its format for defining data is the same as for writing code, making macros a natural part of the syntax: You can change your source code just like you’d change any other list (or rather tree) data type.I've heard this repeatedly over the years, but the explanation unfortunately always stops right there. Could you please give an example of why you'd want to change your source code programatically? It's always assumed that the reader implicitly knows why this is a good and important thing. Perhaps a practical example showing(A) how this would work,(B) what the benefit is, and(C) how the added work in reasoning is worth that benefit.Note: I personally like the parentheses, as they group everything together so simply.	branchly2	15.11837	-3.9793398	comment	8.0	35.0	1489682407	-10.409187
14419407	I'm still left with the question of 	"I'm still left with the question of ""why all the parenthesis?""While it might sound silly and reductionist, it is ostensibly the single hurdle I could never overcome when it came to lisp languages. The majority resides with the fact that it could work without them, so I see it as an ancient artifact."	graphememes	15.096498	-3.9977431	comment	8.0	56.0	1495739869	-10.345882
14506108	D-Expressions: Lisp Power, Dylan Sty	D-Expressions: Lisp Power, Dylan Style (1999) [pdf]	mpweiher	15.141622	-3.9431322	story	8.0	82.0	1496841297	-10.466468
31582494	The First Lisp Compiler	The First Lisp Compiler	texdraft	15.123488	-3.957837	story	8.0	208.0	1654094620	-10.394534
31590819	Show HN: Common Lisp running nativel	Show HN: Common Lisp running natively over WebAssembly for the first time	metagame	15.133171	-3.9544258	story	8.0	97.0	1654138972	-10.418358
26051255	Mezzano: Operating system written in	Mezzano: Operating system written in Common Lisp	ingve	15.114735	-3.9417276	story	8.0	224.0	1612655187	-10.281217
35608877	Lisp Is the Linux of Languages	Lisp Is the Linux of Languages	jrberendt	15.135155	-3.952837	story	8.0	19.0	1681781319	-10.361078
35853809	> The developers of Lisp give you th	> The developers of Lisp give you the full powers that they had to develop the language.So someone joining the project doesn't just have to learn Lisp, they have to learn Inhouse Lisp? And the abstractions provided by modern languages are woefully incomplete?> Lisp code written some 30 years ago will most of the time, without issue, work on a modern Common Lisp implementationYou could say the same about Java and 20 years.	dehrmann	15.142638	-3.9457598	comment	8.0	27.0	1683481685	-10.445876
36178942	Reduce vs. Fold in Common Lisp	Reduce vs. Fold in Common Lisp	billiob	15.144586	-3.9389098	story	8.0	92.0	1685815404	-10.5010805
36195584	As someone who isn't a trained progr	"As someone who isn't a trained programmer (and has no background or understanding of lisp) that looks like you took something sensible and turned it into gibberish.Is there a recommended ""intro to understanding lisp"" resource out there for someone like myself to dive in to?"	digdugdirk	15.147842	-3.9355571	comment	8.0	36.0	1685970015	-10.436976
36498107	Emacs4CL: A DIY kit to set up vanill	Emacs4CL: A DIY kit to set up vanilla Emacs for Common Lisp programming	susam	15.109356	-3.9550104	story	8.0	112.0	1687897112	-10.372512
28722137	I found Common Lisp to be surprising	I found Common Lisp to be surprisingly ahead of its time in many regards (debugging, repl, compilation and execution speed, metaprogramming), but unfortunately it doesn't have a large community, and it's showing its age (no standard package management, threading not built into the language). It's also dynamically typed which disqualifies it for large collaborative projects.	kubb	15.122808	-3.955269	comment	8.0	78.0	1633114415	-10.416723
29153440	Modern, functional Common Lisp: myth	Modern, functional Common Lisp: myths and tips (2020)	dunefox	15.140084	-3.9436796	story	8.0	110.0	1636401156	-10.467975
29612209	Lisp in Vim with Slimv or Vlime (201	Lisp in Vim with Slimv or Vlime (2019)	Tomte	15.089355	-3.957085	story	8.0	89.0	1639900297	-10.425929
34328267	That is interesting. I am wondering 	That is interesting. I am wondering though, in what areas does Lisp get used these days?What would be a good project to showcase the strengths of Lisp, versus other well-known languages?How/why do people end up learning Lisp, what is the usual route to entry?Genuine questions, not trying to start a language battle here. I've never used Lisp before so am curious about all of this. To me it feels like one of those exotic old-school languages like Erlang or Perl.	dockleaves	15.141253	-3.9466062	comment	8.0	25.0	1673371528	-10.4503355
34609877	History of Lisp Parentheses (2019)	History of Lisp Parentheses (2019)	sph	15.1131	-3.9825532	story	8.0	80.0	1675256948	-10.365884
34622992	> A more conventional notation was p	> A more conventional notation was planned but never happened:This is evidence that S-expressions are objectively superior to other serializations.  They are objectively simpler (this is why they were chosen in the first place -- writing a parser for sexprs is vastly easier than writing a parser for just about anything else), and the fact that humans who become accustomed to them early on generally prefer not to move away from them is evidence that other representations offer no advantages, and considerable disadvantages in the form of added complexity for no objective benefit.  In other words, the main reason people don't like S-expressions is that they are indoctrinated from an early age (like grade school) into objectively inferior serializations, which trace their roots literally into 	lisper	15.093694	-4.001026	comment	8.0	62.0	1675319982	-10.339736
34862607	I still Lisp (2021)	I still Lisp (2021)	mgrayson	15.151393	-3.9302578	story	8.0	127.0	1676846360	-10.479614
19037283	Scripting in Common Lisp	Scripting in Common Lisp	mr_tyzic	15.13426	-3.9494512	story	8.0	130.0	1548870111	-10.349332
19407811	One persistent problem I see in the 	One persistent problem I see in the Common Lisp (love the language!) space is the wide availability of crapware that not only doesn't bring something new to the table but is actively damaging to the community since it's diluting the set of good libraries and making it harder for new users to tell the wheat from the chaff. Lem is crapware. The problem it's supposed to solve, writing CL without configuring Emacs, is not a problem since there exists Portacle [1]. Lem is inferior to Emacs/SLIME/Sly in every way especially for writing Lisp. Lem has no future. But it exists and may act like a strange attractor to those who don't know better.A question I'd really like to find the answer to: Why is there so much crapware for CL?. Why doesn't the community come together behind the few, really good,	insertcredit	15.124316	-3.9631803	comment	8.0	34.0	1552744253	-10.441868
15882908	What's the most popular Lisp in use 	What's the most popular Lisp in use today? Does it come with a static compile type checking?	xstartup	15.107037	-3.9787865	comment	8.0	38.0	1512774491	-10.264364
16419918	For a person who loves Scala, Haskel	For a person who loves Scala, Haskell and Python and have heard a lot about LISP (and even uses a DIY LISP notation to serialize some stuff in some projects) yet didnt't have time to actually study LISP yet... In what parts can LISP or Scheme be better than Haskell as a programming language from the practical point of view? I.e. why should I choose to code a program in LISP rather than in Haskell or some other functional language?	qwerty456127	15.120839	-3.987623	comment	8.0	31.0	1519131011	-10.471491
16448191	That said, it would be nice if lisp 	That said, it would be nice if lisp used square brackets for this instead. Easier to type on boring old US QWERTY.	VyseofArcadia	15.087802	-4.001711	comment	8.0	32.0	1519410416	-10.307673
16448438	I don't really mind the parens, but 	"I don't really mind the parens, but the whole attitude feels indicative of a problem. Like - it's 2018 and people are still using 'cdr' and 'cons' as terminology and happily expecting other people to learn those words and not even feeling bad about it.If the person justifying Lisp doesn't mind that the word 'cons' is terrible, why should I trust their aesthetic sense about anything? If I have to have ""miserable notations"" to get ""coding nirvana"", and coding nirvana is so great, why not fix the notations? do you just think everyone should have to struggle because you did?I guess it feels like trying to determine which of these statements are true:
(1) ""Lisp is coding nirvana""
(2) ""Lisp is weird regressive nostalgia for a simpler era where nothing was typed and everyone used Emacs and memori"	ajkjk	15.141031	-3.9521031	comment	8.0	47.0	1519412379	-10.439793
16584140	Ask HN: What is the best way to get 	Ask HN: What is the best way to get started with practical LISP?	wheresvic1	15.143197	-3.9403625	story	8.0	28.0	1521029451	-10.485361
17525877	Yep, that's where I stopped. What I 	Yep, that's where I stopped. What I think is going on... Some people think predominantly in abstraction and don't really care about syntax. As Paul Graham once said, LISP doesn't really have syntax - you write parse trees directly. That may be fine for people who have achieved that level/style of programming, but it's a tiny minority.Why should I write (+ p 2) when most people think (p+2)? This difference gets worse with more complex expressions. For the masses (and I mean a lot of very capable people) this is just garbage. For some it's wonderful. I can't say it's wrong, just not my thing. Perhaps it's the Blub paradox - I've never had the LISP epiphany so I can't say. I have had the python epiphany, and it's quite the opposite of this.	phkahler	15.1053705	-3.991188	comment	8.0	44.0	1531509640	-10.312785
17706589	Quick question: why did we stop prod	Quick question: why did we stop producing lisp machines, or any other machine more closely related to Lambda calculus model of computation than a Turing machine? Is it merely cultural, or are there technical reasons as to why we stopped producing them competitively?	gnulinux	15.139454	-3.9451542	comment	8.0	66.0	1533650178	-10.4340925
21643606	I'm amused by the fact that when you	I'm amused by the fact that when you criticize LISP's syntax, defenders always say the syntax doesn't matter and real Lisp programmers don't even see the parenthesis. But then you look at these implementations of Lisp-like variants of existing programming languages and the thing the developers are most enamored with is the repetitive, parenthesis-laden syntax of Lisp, while keeping the majority of the non-Lisp semantics in tact (adding just a few functional conveniences like first class functions).I'm not even criticizing, most of these are hobby projects and you can code how you like. I just think it's funny how hard Lisp clings onto the parenthesis thing while claiming the parenthesis thing doesn't matter.	c3534l	15.109126	-3.9891121	comment	8.0	55.0	1574809050	-10.3647785
21722104	As a lover of Lisp, I find these sor	"As a lover of Lisp, I find these sorts of initiatives really depressing and frustrating.  They seem to come up over and over again, where someone has the bright idea to make Lisp less Lisp-like, often by getting rid of all the parenthesis and making the language more Algol-like.But parenthesis are, for me, one of the greatest things about Lisp.  They make understanding, reasoning about, editing, and manipulating the code really easy, and add a consistency to the language which I really appreciate when compared to mismash of arbitrary, inconsistent delimiters in other languages.This leads me to adopt a ""you'll have to pry my parenthesis from my cold, dead fingers"" attitude when I see suggestions like these.  Please, just keep Lisp Lisp."	pmoriarty	15.103483	-3.9907057	comment	8.0	35.0	1575643185	-10.339179
39120734	Common Lisp has bad marketing (even 	"Common Lisp has bad marketing (even OCaml has Twitch streamers and ""influencers"" now), and bad support for general editors, both of which make it a non-starter for most curious people who have an afternoon to try something. But behind all that is magnificent activity for those who got over the initial potential energy barrier. Just to give some examples:1. SBCL, the most popular open source implementation of Lisp, is seeing potentially two new garbage collectors, one of which is merged and open to beta testing. One of them is a parallel collector written by a university student (!!) which blows my mind.2. SBCL has better and better support for deploying Lisp as a C-compatible shared library, using SBCL-LIBRARIAN. It makes it play nicer with other applications in C and Python, without the b"	reikonomusha	15.126329	-3.9626145	comment	8.0	112.0	1706120392	-10.454253
39216904	Compiling a Lisp (2020)	Compiling a Lisp (2020)	swatson741	15.133747	-3.9457695	story	8.0	114.0	1706801007	-10.419765
39347453	K Isn't Lisp (2004)	K Isn't Lisp (2004)	RodgerTheGreat	15.148426	-3.9386303	story	8.0	51.0	1707758012	-10.453879
18267285	Evolution of Emacs Lisp [pdf]	Evolution of Emacs Lisp [pdf]	tarsius	15.148275	-3.9339504	story	8.0	194.0	1540114063	-10.441261
18518807	Lisp Machine Inc. K-machine (2001)	Lisp Machine Inc. K-machine (2001)	mepian	15.146879	-3.9351153	story	8.0	114.0	1543005815	-10.438779
18530260	Compiler basics: Lisp to Assembly	Compiler basics: Lisp to Assembly	eatonphil	15.093483	-3.977609	story	8.0	242.0	1543194850	-10.359965
18882335	uLisp: Lisp for microcontrollers	uLisp: Lisp for microcontrollers	tosh	15.131677	-3.9419513	story	8.0	97.0	1547201806	-10.42836
29842271	"Not in Lisp! (""foo"" ""bar"") and (""foo"	"Not in Lisp! (""foo"" ""bar"") and (""foobar"") are lists of length 2 and 1, respectively.(Python copies some bad ideas from C. Another one is having to import everything you use. It seems that since Python is written in C, its designer took it for granted that there will be something analogous to #include for using libraries, even standard ones that come with the language.)Implicit string literal catenation is tempting to implement because it solves problems like:   printf(""long %s string""
          ""nicely breaks up""
          ""with indentation and all"",
          arg, arg, ...)

and if you're working in a language which has comma separation everywhere, you can get away with it easily.There are other ways to solve it. In TXR Lisp, I allow string literals to go across multiple lines with a back"	kazinator	15.107925	-3.9897661	comment	8.0	53.0	1641578081	-10.377837
30173580	you don't need to run lisp in a larg	you don't need to run lisp in a large team. if you adopt lisp you only need 10 programmers to do what 100 will do in another language :)	medo-bear	15.137401	-3.9507105	comment	8.0	145.0	1643774803	-10.473337
30174557	We've also been using Lisp in produc	We've also been using Lisp in production. It has gone wonderfully, and has allowed some of the most simultaneously maintainable, resilient, and efficient code I've seen in my career. It's also attractive differentiator to some programmers who don't want to drone away writing bulk-Java day-in and day-out.A key to running Lisp in production is to step away from thinking of it as a lone-wolf bionic-suit hacker language, and to invest in developing a style guide, code review guidelines, CI/CD, and a culture of training new programmers to write Lisp. I've found that you typically don't have to hire Lisp specialists. As long as you find good programmers, they pick up Lisp just fine in just a few short weeks.The sibling comments are right though: Lisp's reputation is unfortunately affected by so,	reikonomusha	15.134408	-3.953897	comment	8.0	47.0	1643784269	-10.468088
30543581	A Modern Lisp Machine from Scratch (	A Modern Lisp Machine from Scratch (2018)	hugo-abreu	15.138071	-3.9392781	story	8.0	64.0	1646327071	-10.4169235
12659167	I genuinely would love to see apps w	I genuinely would love to see apps written in lisp. It's all Javascript nowadays, with about 5-8 frameworks dominating this sad landscape.Imagine how refreshing it'd be to see Lisp driving webapps, front and back-end.Not even saying that should be the one size fits all, I'm saying, anything else...	keyle	15.11243	-3.9717965	comment	8.0	37.0	1475831156	-10.435223
13137393	Even today, Common Lisp is still one	Even today, Common Lisp is still one of the best choices for many applications.Then why don't people build amazing and popular things with it? I don't mean one or two people build one or two things, but lots of people building lots of things.Nobody uses it, but it's the best choice, can't both be true. And 'nobody uses it' is approximately true. It's not a mainstream JVM language or CLR language, it's not an AWS or Azure or Google Web Services language, it's not used for Linux Kernel, Windows, Oracle, *BSD, SQL databases, No-SQL databases, it's not used where Erlang is, it's not the research language Haskell is, it's not the fun esolang or the long-tail COBOL, it's not the new compiles-to-JavaScript, it's not the back of 3D games or VR engines, it's not behind Amazon's shop or used where G	jodrellblank	15.132342	-3.962	comment	8.0	52.0	1481270443	-10.483209
13193877	This great idea of Lisp (the simple 	This great idea of Lisp (the simple syntax of function calls in round brackets) isn't much different than a good macro assembler even back in the 1960's. The only major difference was that more than 1 function could be defined in 1 source code line. (I think that machine code is nothing but a sequence of function calls where the function is the logic encoded in the CPU itself for each opcode.) Is it fair to compare the complexity of expression evaluation etc (Fortran) with a macro assembler? Obviously any program can be coded in a macro assembler and therefore that would also be true from a syntax like Lisp.When I was in my 20's, I programmed at least 100,000 lines of Z80 assembler for the first micro computers. One project was at least 40,000 lines and so I know how difficult it is to pro	clarkd99	15.107985	-3.9776936	comment	8.0	53.0	1481902155	-10.386226
27805294	From the article: “My heart was brok	From the article: “My heart was broken because Common Lisp is such a fine fine language and it is a joy to work in and hardly anyone uses it in industry. The industry has a lot of code in Java even when it takes much less time to write code in Lisp. What happened to the programmer’s time is more important than the machine’s?”I think one issue that Common Lisp and many other programming languages face is that while a programmer’s time is more valuable than a machine’s, there are dynamics at play when maintaining commercial software projects that favor coding in more popular languages, such as the ability to easily hire developers knowledgeable in the language and/or paradigm.  For example, imagine being a manager of a project written in Haskell that liberally uses functional programming con	linguae	15.12502	-3.9742115	comment	8.0	90.0	1626045242	-10.429335
12465298	Tiny Lisp Computer	Tiny Lisp Computer	jabits	15.136475	-3.93879	story	8.0	153.0	1473448816	-10.405104
28363230	Ask HN: Why Should I Learn Lisp?	Ask HN: Why Should I Learn Lisp?	testing_1_2_3_4	15.150349	-3.9355838	story	8.0	8.0	1630375964	-10.4601755
22459871	Why don’t lisp fans use older lisp i	Why don’t lisp fans use older lisp implementations like Common Lisp or scheme? Is it just a lack of libraries and frameworks?	gentleman11	15.140459	-3.9489965	comment	8.0	57.0	1583102135	-10.396204
23038054	I'll admit I don't think I've really	I'll admit I don't think I've really noticed the presence of lisp online other than when people want to talk about lisp. Can someone share some practical examples of where lisp is being used?  Maybe a popular open source project I never realised was written in a lisp family language?	Waterluvian	15.144016	-3.9435892	comment	8.0	37.0	1588294477	-10.453478
23164938	Lisp languages should be great for e	Lisp languages should be great for embedding into games to implement game logic, instead of more straightforward solutions such as embedding Lua. I've always wanted to explore this for my iOS side-project game, which now uses an event-based system inspired by ReactiveX, implemented in Lua. This works pretty well but is very hard to debug.The main thing holding me back to try to replace it with something Lisp-like is that I have zero experience in Lisp programming. I know some FP theory (in fact the Lua-based event system lends some concepts from it), but when I try to reason about common subproblems I really have no idea how to map them to something like Lisp. For example how to efficiently implement a message bus with observers that can register themselves, using state-based functions to 	w0utert	15.127395	-3.9633517	comment	8.0	35.0	1589360402	-10.48952
23211273	Ronin – A Lisp-based image processin	Ronin – A Lisp-based image processing tool	Gormisdomai	15.132471	-3.9402604	story	8.0	366.0	1589715215	-10.432091
23233262	I think Reddit's decision to move fr	"I think Reddit's decision to move from Common Lisp to Python is interesting and their reasoning (ecosystem) is still valid 15 years later.The historical timeline is especially interesting because Reddit's cofounders Steve Huffman & Aaron Swartz were alumni of Paul Graham's first YC batch and PG is the author of the well-known Lisp essay ""Beating the Averages"":- 2001-04 Paul Graham : Lisp essay ""Beating the Averages"" [1]- 2005-07-26  Paul Graham :  https://groups.google.com/forum/#!topic/comp.lang.lisp/vJmLV...- 2005-12-05  Steve Huffman :  https://redditblog.com/2005/12/05/on-lisp/- 2005-12-06  Aaron Schwartz :  http://www.aaronsw.com/weblog/rewritingredditThe takeaway from the Reddit case study is this:  Yes Lisp"	jasode	15.134682	-3.9497364	comment	8.0	80.0	1589883666	-10.315621
23234145	C has macros. They are nothing like 	C has macros. They are nothing like lisp macros. Please cite a non-lisp language with macros a powerful as lisp's.	dreamcompiler	15.100859	-3.989574	comment	8.0	27.0	1589891766	-10.291732
33455274	TeX and Literate Programming (and Li	"TeX and Literate Programming (and Lisp) are my fundamental, day-to-day tools.Code it, explain it, generate a Literate PDF containing the code.The programming cycle is simple. Write the code in a latex block. Run make.
The makefile extracts the code from the latex, compiles it, runs the test cases (also in the latex), and regenerates the PDF. Code and explanations are always up to date and in sync.I have found no better toolset."	daly	15.109251	-3.9573665	comment	8.0	28.0	1667500077	5.44331
33575863	He's overlooking an incredibly impor	He's overlooking an incredibly important factor:Java and C++ had capable, even enterprise quality free compilers at a time when Common Lisp environments were typically either hideously expensive or poorly supported or both.You could grab Sun's JDK for free, or GCC, or (later) Visual Studio Express at a time when the best options for Common Lisp were thousands of dollars per seat, or barely working on x86 (CMUCL didn't have x86 support in any capacity until after 96, and by then Java was out).Personally, I loved lisp in the 90s, but it was just so much easier to get my hands on C and Java, and libraries to go with them. Java, C and C++ were actually available on DOS and Windows. Even today, Windows support among lisps is terrible!Edit: I miss Turbo C, but had there been a Turbo Lisp, priced	dleslie	15.118929	-3.9641094	comment	8.0	62.0	1668279190	-10.388916
34014909	Can someone explain me why is Lisp s	Can someone explain me why is Lisp still use today ?	ForcedPush	15.145097	-3.9411893	comment	8.0	34.0	1671201339	-10.469943
26632429	Lisp-stat: An environment for Statis	Lisp-stat: An environment for Statistical Computing	sieste	15.139772	-3.939479	story	8.0	101.0	1617094583	-10.465647
26710858	Why do so many HN'ers like lisp?It's	Why do so many HN'ers like lisp?It's just... archaic.	antiquark	15.148255	-3.9423554	comment	8.0	26.0	1617711261	-10.455201
38273510	Note to self: learn a lisp. Lisp peo	Note to self: learn a lisp. Lisp people appear to be having more fun than the rest of us.	__MatrixMan__	15.147605	-3.9412513	comment	8.0	49.0	1700024535	-10.4990015
38363110	Lisp is amazing. Interesting why Pyt	Lisp is amazing. Interesting why Python won the race to become the language of choice for the neural networks wave of AI.	borissk	15.142686	-3.9507315	comment	8.0	44.0	1700571826	-10.428638
15057773	The home page looks like a tombstone	"The home page looks like a tombstone of Common Lisp with a bunch of epitaphs on it.On the other hand, the spirit of Lisp has successfully taken over the world. The modern Lisp is called JavaScript.I am perfectly aware of all the differences between Lisp and JavaScript and of the other languages that have influenced JavaScript (Self, Perl, Lua), but think of this: what made Lisp so great in the past?    - automatic memory management (compared to Fortran/C);
    - very dynamic language and environment,
      hooks on everything, live systems;
      `eval`, available meta-interpreter;
    - exceptions and condition system instead of segfaults;
    - multi-paradigm, flexible programming language: 
      functional, OO and imperative programming when needed;
    - research roots and great minds"	dmytrish	15.100281	-3.9945095	comment	8.0	44.0	1503224122	-10.453802
15185827	Lisp Machine Manual (1984)	Lisp Machine Manual (1984)	sillysaurus3	15.147951	-3.9318972	story	8.0	142.0	1504721521	-10.430158
15231748	I am curious why is hackernews alway	I am curious why is hackernews always so happy and obsessed with lisp, there is almost daily a lisp post on the frontpage. I dont really care/mind but I am just curious as why people love lisp so much. The only thing that I notice about Lisp are the bracket jokes and memes.	Sjenk	15.149736	-3.9365845	comment	8.0	38.0	1505246368	-10.471845
23592596	Lisp is large, important, and also n	Lisp is large, important, and also not statically typed. It's worked out ok for Lisp programmers. JS itself isn't strongly typed and is the most successful and important language in the world (probably in the history of programming), so that's two game-changers that don't require static typing.	mimixco	15.055258	-4.0225563	comment	9.0	76.0	1592754089	-10.439256
19979545	Lisp in Web-Based Applications (2001	Lisp in Web-Based Applications (2001)	tosh	15.1225605	-3.9581935	story	9.0	92.0	1558519288	-10.441834
20210557	There are still people explaining to	There are still people explaining to me why you need a 'system programming language' like C or Rust for certain tasks.  Meanwhile, I'm playing a game of Quake on Mezzano, where everything from drivers to the actual videogame is written in pure Common Lisp.In case you wonder how froggey managed to obtain a Common Lisp version of Quake, have a look at https://github.com/froggey/Iota.	heisig	15.122582	-3.964162	comment	9.0	57.0	1560844628	-10.441586
20374467	My Lisp Experiences and the Developm	My Lisp Experiences and the Development of GNU Emacs (2002)	tosh	15.118625	-3.954877	story	9.0	177.0	1562495769	-10.40841
20513056	> The best we can do is to recover f	> The best we can do is to recover from a failure and maybe somehow retry what we were doing, but we can’t magically “go back” to where we were, and do something different. But with algebraic effects, we can.This is literally Common Lisp's condition system which a) decouples signaling conditions from handling conditions, b) allows you to execute arbitrary code in the place that signals, c) allows you to stack independent pieces of condition-handling code on one another so they run together, and d) allows you to unwind the stack or not unwind the stack at any moment, so your code may continue running even if it ends up signaling.ANSI Common Lisp was standardized in 1994. This post is from 2019. That's reinventing a 25+ year old wheel the author is likely unaware of.	phoe-krk	15.120574	-3.969505	comment	9.0	40.0	1563953807	-10.299726
20814511	Running Lisp in Production (2015)	Running Lisp in Production (2015)	wglb	15.136833	-3.9439125	story	9.0	167.0	1566941009	6.412396
14333157	Lisp, Smalltalk, and the Power of Sy	Lisp, Smalltalk, and the Power of Symmetry (2014)	saturnian	15.143429	-3.9416213	story	9.0	136.0	1494711516	-10.4229355
16078047	I don't understand, what are lisp/sc	I don't understand, what are lisp/scheme/racket/haskell being used for? I mean how are those languages good from a software engineering point of view? From a project management point of view?Is it possible to hear bad things about those languages? Why aren't they used? Is it because they are too hard to use, or to difficult to approach for a beginner?	jokoon	15.146527	-3.9428527	comment	9.0	44.0	1515152970	-10.490313
16584612	> a very large hammer for every prob	"> a very large hammer for every problem you might find, be it list comprehensions or generators or whatever OO voodoo you can come up with.List comprehensions, to me, are what makes Python a productive (or the most productive) prototyping language. It allows me to think and program in mathematical relations without much fuss. Add to that nice sets and dicts (needed for asymptotic efficiency), and I can easily forgive it that it is built on an everything-is-an-object paradigm (there are few things I detest more than OOP).I've never truly understood why you need the meta-capabilities of LISP. I much more need a syntax that does not hide what happens (procedure call, list indexing or at least ""indexing""). Macros amount to code generation. Code generation is mostly bad, it typically means the "	jstimpfle	15.110903	-3.986203	comment	9.0	36.0	1521034489	-10.388878
16861141	I like lisp as a programming languag	I like lisp as a programming language.But, this article gives one of the reasons for avoiding its use in a high performance production environment. Provisioning a VM with over 25GB RAM for an application which requires about 4GB of it is a huge waste of resources.While the common wisdom on HN is that for most applications, developer costs more than physical resources. Physical resources still cost money.Initially list might be a good option for development velocity. But, over time as the application matures, adding features becomes more complicated and the velocity goes down anyway. Shifting to something which reduces costs by upto 6x might be worth it.	sacheendra	15.145139	-3.9389331	comment	9.0	64.0	1523990876	-10.430187
17117046	Okay, I certainly don't want to star	Okay, I certainly don't want to start a language war, so let me be kind. There is one legitimate reason to switch from Lisp to Python: The number of packages and extensions. Python really has more than just batteries included, it's probably the language with the most available libraries after C++.Still, switching from Lisp to Python is bound to be painful...	jonathanstrange	15.122328	-3.9646764	comment	9.0	55.0	1526893069	-10.336455
17133557	Lisp in Jak and Daxter	Lisp in Jak and Daxter	tosh	15.131571	-3.9471946	story	9.0	120.0	1527078699	-10.378822
17653818	Maybe I came to SICP too late in lif	Maybe I came to SICP too late in life, but I've always struggled to get the hype. It seems so... Basic. Making a linked list is trivial in lisp. Lisp itself is trivial. Why does everyone care about this book so much?	3pt14159	15.148012	-3.9362378	comment	9.0	28.0	1533050141	-10.557752
21735148	Lisp Programming in Vim with Slimv o	Lisp Programming in Vim with Slimv or Vlime	gitrebase	15.0632515	-3.9574354	story	9.0	85.0	1575799022	-10.397121
18702178	Lessons Learned Implementing Common 	Lessons Learned Implementing Common Lisp with LLVM [video]	StreamBright	15.136508	-3.9430985	story	9.0	152.0	1545080441	-10.399011
18875475	Lisp Badge – Self-contained ATmega12	Lisp Badge – Self-contained ATmega1284 Lisp computer	lispm	15.14222	-3.9335334	story	9.0	129.0	1547139689	-10.531059
29947329	On Pitman's “Special forms in Lisp” 	On Pitman's “Special forms in Lisp” (2011)	HexDecOctBin	15.15201	-3.933603	story	9.0	56.0	1642262342	-10.416936
29987849	As far as I know, GOAL/GOOL remains 	As far as I know, GOAL/GOOL remains the only time Lisp has ever successfully been used in a video game. Given Lisp's near-mythic status of productivity, it at least piques my interest to see how ND might have used it creatively in the codebase.That and I've always wanted to check out the language after Andy Gavin (ND founder) talked it up on here [0][0]https://news.ycombinator.com/item?id=3152131	jimbob45	15.151471	-3.9348407	comment	9.0	36.0	1642549634	-1.7319385
30443949	(How to Write a (Lisp) Interpreter (	(How to Write a (Lisp) Interpreter (In Python)) (2010)	ivanvas	15.0977745	-3.990963	story	9.0	66.0	1645638497	-10.082639
12703498	Symbolics Lisp Machine Museum	Symbolics Lisp Machine Museum	rbc	15.131489	-3.9498742	story	9.0	126.0	1476388260	-10.317351
13194124	This article has many misstatements 	This article has many misstatements in its first half.> John McCarthy wrote 6 easy things in machine code, then combined them to make a programming language.John McCarthy didn't implement Lisp in machine code. Steve Russell did. Implementing Lisp properly in machine code is not easy; you have to write a garbage collector. To do that in the early 60s, you had to first invent garbage collection. Lisp was and is brilliant, but not as easily bootstrappable as this makes it out to be.> It's not obvious that these six things are computationally complete (AKA Turing Complete).`lambda` and function application alone are Turing-complete, as McCarthy would have known. The credit here belongs with Turing and Church, not McCarthy. `atom`, `cons`, `car` and all the rest are just icing on the cake of th	rntz	15.124128	-3.96969	comment	9.0	71.0	1481904039	-10.386949
28039094	No way. The ecosystem is just not th	No way. The ecosystem is just not there.All the libraries - both open source and commercial that do a million things - do not exist in the Lisp ecosystem.Even in 2000	eric4smith	15.133887	-3.9477196	comment	9.0	104.0	1627922724	-10.472196
28108806	Revisiting Prechelt’s paper comparin	Revisiting Prechelt’s paper comparing Java, Lisp, C/C++ and scripting languages	mahmoudimus	15.1207	-3.9663317	story	9.0	118.0	1628446748	-10.452472
33162318	They Called It LISP for a Reason: Li	They Called It LISP for a Reason: List Processing (2005)	susam	15.122267	-3.9604454	story	9.0	115.0	1665489763	-10.484679
33575225	Ok. What’s a good lisp like language	Ok. What’s a good lisp like language without the embedded parentheses? I know it’s subjective, but I just can’t get past them.	stevenally	15.125857	-3.961144	comment	9.0	29.0	1668274719	-10.360943
33739996	I want to get my head wrapped around	I want to get my head wrapped around lisp but I just see code like this and my head hurts	gigatexal	15.14597	-3.940228	comment	9.0	43.0	1669360018	-10.430249
26720403	Lisp as an alternative to Java (2000	Lisp as an alternative to Java (2000)	azhenley	15.121958	-3.9685314	story	9.0	156.0	1617767357	-10.493249
26830411	Lisp and the Web: Creating Web Apps 	Lisp and the Web: Creating Web Apps Through Lisp and GCE	abhinav22	15.124527	-3.9563434	story	9.0	162.0	1618555470	-10.464977
14795992	Back to the Future: Lisp as a Base f	Back to the Future: Lisp as a Base for a Statistical Computing System [pdf]	tosh	15.141089	-3.9389565	story	9.0	98.0	1500381184	-10.465967
14915425	I'm a Lisper (and Pythoner) and stro	"I'm a Lisper (and Pythoner) and strongly agree, the first one is not readable. I would say it's gross. It boggles my mind that Lispers haven't taken that problem seriously. I have taken it very seriously and have been working on it for years.I just started publishing my results.http://breckyunits.com/the-flaw-in-lisp.htmlWhat I've discovered is that the parentheses are completely unnecessary in Lisp, and in fact cause much harm by making Lisp harder to read and maintain in the long run. Drop the parentheses in Lisp by switching to whitespace/geometry for syntactic structure and you suddenly have the dream language.Your example above would be something like:  setv result
   -
    /
     + 1 3 88
     2
    8

You might think that looks a little strange too at first, but the neat thing about"	breck	15.095122	-4.000628	comment	9.0	62.0	1501714605	-10.381538
15070137	Answers from 2017 Common Lisp expert	Answers from 2017 Common Lisp experts	drdre2001	15.149016	-3.9370503	story	9.0	104.0	1503382207	-10.456298
15355979	A Brief History of Lisp Machines (20	A Brief History of Lisp Machines (2008)	type0	15.144419	-3.9364462	story	9.0	106.0	1506593364	8.285071
14662380	As someone currently learning CL, I 	"As someone currently learning CL, I think part of the reason it doesn't have widr adoption is that there is a huge number of features.Consider a language like Python. Aggressive duck typing means consistent syntax for different data structures and types. Stuff ""just works"" without a deep understanding of how it works.CL is the opposite. What is the difference between setp, setf, defvar, and defparameter? Why is the documentation so technical and dense? What is a ""form""? What are multiple return values and how do I get to them? Should I spend time learning the loop macro DSL?I find it similar to Haskell in this regard. The base level of knowledge to use the language is so high that you pretty much need a book, or a degree, to be able to get started. That's a huge barrier to entry."	nerdponx	15.129808	-3.9621806	comment	9.0	69.0	1498736410	-10.451272
30801856	If Lisp is do efficient for developm	If Lisp is do efficient for development, why are there essentially no commercial products that use it?	stevenally	15.147419	-3.9401634	comment	9.0	55.0	1648214737	-10.444671
31179701	I’ve never did anything serious with	I’ve never did anything serious with Common Lisp, but my light experience on it was that- the idea that almost all language constructs are user-implementable with macros is quite impressive (but I don’t buy the argument that “real” macros are only able in s-exprs)- and the REPL-driven development model was a really beautiful and seamless experience.But… every time I try to use it on some code, I find too many warts and inconsistencies that I just didn’t want to spend too much effort in making it work. It’s a beautiful language in it’s own ways, but the other parts are too ugly (to me, of course).I’m fine with it being a lisp or not; I just want a clean language with macros baked in (and becomes the basis of most language features), and with a REPL-driven development model as a first class 	pcr910303	15.126754	-3.9667096	comment	9.0	59.0	1651066605	-10.545873
31234338	Lisp in Space	Lisp in Space	todsacerdoti	15.153731	-3.9313715	story	9.0	190.0	1651495030	-10.434944
31554141	> There's something magically expres	"> There's something magically expressive about S-expressions and processing them.A downside I see with S-expressions – you often end up with something like (FOO BAR BAZ), where FOO identifies the type of thing, and BAR and BAZ are parameters/slots/etc – but you have to remember the (sometimes quite arbitrary) order that BAR and BAZ go in.Some Lisp family languages (such as Common Lisp, Clojure, Scheme with SRFI 88/89) support keywords (aka named parameters), so you can do something like (FOO :bar BAR :baz BAZ), which is considered equivalent to (FOO :baz BAZ :bar BAR). However, this is somewhat of a late development in the Lisp tradition, the status of its adoption is mixed, and (arguably) it is moving away (even if only by a little bit) from pure S-expressions. When people say ""S-expressi"	skissane	15.06014	-4.039456	comment	9.0	39.0	1653869176	-10.501807
25495997	Every now and then I see posts like 	"Every now and then I see posts like this and yet, the Lisp languages never took off after the 2000s. I understand that there might be some value to learning Lisp, but much of the things that made Lisp attractive before are already available in Python, Java, etc. and I see no ""enlightment"" in learning Lisp.This comment is going to get downvoted heavily here, but it's high time every one accepted the fact that the Lisp family is almost dead and move on."	behnamoh	15.139018	-3.949518	comment	9.0	33.0	1608566121	-10.460362
26024776	McCLIM – GUI toolkit for Common Lisp	McCLIM – GUI toolkit for Common Lisp	lelf	15.131097	-3.9424567	story	9.0	145.0	1612441648	-10.423725
26053567	What is the reason why Lisp allows y	What is the reason why Lisp allows you to use the hyphen for an identifier name?This overloads the subtraction operator. And it makes the code very confusing to read.And plus, Lisp also uses the hyphen as the subtraction operator.	blackrock	15.110647	-3.9809492	comment	9.0	40.0	1612686493	-10.37308
26298324	- I don't get lisp's (lisp-2) dynami	- I don't get lisp's (lisp-2) dynamic scoping (a big reason I haven't switched from vim to emacs). I'm much more comfortable with the lexical scoping of scheme (lisp-1).- I don't get big schemes (like R6RS). For a while, I thought of my own implementation of R5RS. But I've heard R7RS is pretty much R5RS with improvements. So R7RS it is.- But I'd like to have macros. I wonder if R7RS has macros.- Mainly interested in crazy metaprogramming and logic/relational experiments using Friedman/Byrd school of thought (reasoned schemer, minikanren, constraint kanren, that sort of stuff).- Finally instead of rolling my own from scratch, I've heard I could use something like chibi as a starting point (additional points since chibi is implemented in C).Comments?	yudlejoza	15.1169	-3.9794233	comment	9.0	36.0	1614557077	-10.658222
35630361	This post persuaded me to not take m	This post persuaded me to not take much of a look at Janet. This is also related to why I think that Lisps haven't become the most widely-used programming languages.Lisp enthusiasts like to point out the power of macros, and macros are the raison d'être for Lisp's homogeneous s-expression syntax. Most other features in Lisp (such as first-class closures and higher-order functions) can exist without s-expressions, but the powerful thing about s-expressions is that they enable Lisp macros.But with great power comes great responsibility. When I'm writing a program I want as little responsibility as possible while still being able to solve the problem at hand. I don't want to be responsible for memory management and bounds checking, and I don't want to be responsible for the hygiene of my macr	kerkeslager	15.108003	-3.9868011	comment	9.0	57.0	1681922755	-10.389236
29031580	Animated guide to Symex: Emacs struc	Animated guide to Symex: Emacs structural editing with Lisp	inetsee	15.116298	-3.9564168	story	9.0	145.0	1635453405	-10.365896
29234170	Ergonomics of the Symbolics Lisp Mac	Ergonomics of the Symbolics Lisp Machine (2014)	gjvc	15.135321	-3.942316	story	9.0	94.0	1637017812	-10.329249
34131310	What help is needed for Lisp communi	What help is needed for Lisp community in order to make Lisp more popular?	eimrine	15.132196	-3.953475	story	9.0	6.0	1672002658	-10.406401
34225742	Ask HN: If you were designing Common	Ask HN: If you were designing Common Lisp today, what would you change?	Decabytes	15.151868	-3.935204	story	9.0	18.0	1672705360	-10.465951
34909405	I always like seeing Common Lisp lin	I always like seeing Common Lisp links, but personally I was a bit put off by the very strong anti-commercial comments about LispWorks and Franz.I had a business idea requiring Common Lisp a few years ago and I purchased a LispWorks Professional license. Small standalone executables with a tree shaker [1] and I has received very good support without paying for the high priority support service. I also paid the maintenance fee last year for continued updates. Coincidentally, I am an advisor and chief architect for a small AI company and they use LispWorks also.Many years ago, I worked as a consultant on a medical AI project and my customer paid a fair amount of money to Franz for software licensing and tech support that included helping with development. Incredibly useful!I also love open s	mark_l_watson	15.123492	-3.930881	comment	9.0	97.0	1677154008	-5.7342577
35094037	To me, the most interesting aspect o	To me, the most interesting aspect of S-expression programming languages is that they are very well suited for other editors than the text editor. I know of a number of experiments in this regard but I have yet to see anything quite as ground breaking as what I can imagine is possible.How come we don't have Google Maps-like zooming with LOD mapping to abstractions at different levels?	kristiandupont	15.089639	-4.0063267	comment	9.0	48.0	1678454680	-10.389102
39666370	> The beauty of Scheme is that the f	"> The beauty of Scheme is that the full language only needs 5 keywords and 8 syntactic forms.Is there a learning resource that covers exactly this for those wanting to write software in lisp in 2024?As ""first principle thinkers"" in some ways all hackers crave for that ""fundamental building blocks approach"", a bit like wanting to know how we go from transistors to full computers and every step along the way. Most of us have made peace with accepting the many abstractions because we're slinging highly abstracted mostly python, and javascript code at startups.So learning Lisp seems like a nice digestible point to start from along the continuum if indeed there's some eloquent way to learn:
>only needs 5 keywords and 8 syntactic forms.and then be off to the races, so to speak."	kingkongjaffa	15.139478	-3.9462104	comment	9.0	29.0	1710152267	-10.479525
39670350	This might sound crazy or stupid but	This might sound crazy or stupid but I really want to know if there is some Lisp with manual memory management? I love Lisp syntax. People complain about the parentheses but for me they are a blessing. I like how extremely uniform and regular they look.But all Lisps I've seen have garbage collectors. If I could find a Lisp with manual memory management, I could ditch C++ in favor of that Lisp. Is there one?	mapreduce	15.110699	-3.980255	comment	9.0	28.0	1710175049	-10.38078
37031852	I've been circling around lisp for a	I've been circling around lisp for a couple of years. I'm starting in a month, I'll spend several hours a day. I still don't know what language I want to learn.I was drawn to Clojure because it looked like a lisp for getting stuff done. But a few things put me off. This article puts me off more. I want to get the semantics down before I have to think about what's going on under the hood.	psd1	15.147875	-4.0024014	comment	9.0	29.0	1691397056	-10.681036
37442649	Embeddable Common Lisp 23.9.9	Embeddable Common Lisp 23.9.9	jackdaniel	15.1469	-3.9373515	story	9.0	94.0	1694238963	-10.418747
24716635	Every once in a while, there's a pos	Every once in a while, there's a post on front page HN about Haskell and/or Lisp. Sometimes these posts get a lot of traction, but what confuses me is despite the apparent popularity of these languages among developers, still they are seldom used in serious software. I know there are exceptions (esp. with regards to Lisp), but still these languages never come close to other languages such as Java, JS, C, or even Scala.	behnamoh	15.124812	-3.9765	comment	9.0	32.0	1602140676	-10.467495
25322596	Sugar – a typed lispy language targe	Sugar – a typed lispy language targeting webasm/wat	marksmillibend	15.12674	-3.9542294	story	9.0	84.0	1607250986	-10.4387865
32700219	I just wish we could build and run i	I just wish we could build and run it on macOS 12.  The bootstrapping compiler required (sbcl-1.2.11) is nonfunctional there.	tempodox	15.125532	-3.9396238	comment	9.0	34.0	1662197725	-10.394274
32164102	Lisp.py	Lisp.py	memorable	15.110391	-3.984472	story	9.0	85.0	1658315822	-1.0086944
32458189	Can anyone recommend a source for se	Can anyone recommend a source for setting up an environment in Linux to run the code in this book?Do I need to learn eMacs to get close to a “modern lisp” programming environment?	wodenokoto	15.123791	-3.9515042	comment	9.0	40.0	1660474082	-10.37734
22085232	Why is lisp still so uncommon today 	Why is lisp still so uncommon today as a practical, business-needs language? Everyone I know who uses it loves it, but it’s virtually nonexistent in today’s enterprise.	3fe9a03ccd14ca5	15.139287	-3.9515584	comment	9.0	37.0	1579364585	-10.452992
22117241	uLisp – ARM Assembler in Lisp	uLisp – ARM Assembler in Lisp	eggy	15.080467	-3.9903271	story	9.0	172.0	1579698942	-10.355873
20012953	MakerLisp: Embedded Lisp Machine	MakerLisp: Embedded Lisp Machine	tosh	15.13563	-3.9436443	story	10.0	130.0	1558842329	-10.4104595
20732238	Getting Started with Lisp in 2019	Getting Started with Lisp in 2019	wheresvic3	15.145113	-3.9419336	story	10.0	125.0	1566156005	-10.46423
13906120	It is, I think, going to be very dif	It is, I think, going to be very difficult to enjoy writing code in a less powerful language when you are exposed to languages that hold awesome power.In fact, this has been the basis for much writing on Lisp too. Paul Graham has written entire essays along the same lines.If you work in a job that forces the use of a less powerful language than what you've been exposed to, you can, I think, go through a sort of depression. You simply long to use the tools that you know hold much more power yet must resign yourself to the tools you have.You can overcome the problem by being present in your work. The language might be ugly. It might be totally underpowered with limited means of abstraction and a type system that snmacks you and, sometimes, your client over the head. What you can do is, despi	jwdunne	15.13105	-3.9502814	comment	10.0	194.0	1489915928	-10.354132
14392519	Little Lisp interpreter	Little Lisp interpreter	astdb	15.127054	-3.9601269	story	10.0	117.0	1495451269	-10.348056
31248085	I encourage people to try out Common	I encourage people to try out Common Lisp because, unlike with Hy, you will get: speed, ability to build binaries, truly interactive image-based development (yes, more interactive than ipython), more static type checks, more language features (no closures in Hy last time I checked), language stability… To reach to Python libs, you have https://github.com/bendudson/py4cl My comparison of Python and CL: https://lisp-journey.gitlab.io/pythonvslisp/	vindarel	15.078169	-4.012661	comment	10.0	74.0	1651584790	-10.068695
31585480	> In LISP 1.5, function definitions 	"> In LISP 1.5, function definitions were stored on the property list of the function's name...The fact that this was once the norm but has since been done away with saddens me. I've always been fascinated with ""live environments"" but felt they only went half way if they didn't include the source code itself. If I'm going to be updating something in a running system, I want to know what source code was used to get the system to the state its currently in, and preferably be able to query that source code as data. Of course, that code could be kept within source control, but then it's a shadow of the running system -- a map of the territory and not the territory.As far as I know, the only languages/environments where this functionality is still available are Tcl, Smalltalk, and to some extent"	dmux	15.10124	-3.9760208	comment	10.0	40.0	1654105830	-10.377935
25559291	Wisp: A light Lisp written in C++	Wisp: A light Lisp written in C++	azhenley	15.124273	-3.9616482	story	10.0	140.0	1609164902	-10.368226
25886325	It warms my heart to know that astro	It warms my heart to know that astronauts are using LISP in space because they want to. On the other hand, I wonder how practical it is. I've more or less converted from LISPy langs to Python for real work because I was tired of re-inventing wheels and wanted to use libraries like Pandas that truly have no equals in the functional world.Edit: Question: How many LISPers truly use homoiconicity? Can you share any uses of it in real world software?	lopatin	15.132646	-3.972596	comment	10.0	54.0	1611437579	-10.428533
26059023	A Lisp REPL as my main shell	A Lisp REPL as my main shell	qazwse_	15.124623	-3.9565685	story	10.0	149.0	1612738762	-10.391048
36016649	Symbolics Lisp Machines Graphics Dem	Symbolics Lisp Machines Graphics Demo (1990) [video]	mepian	15.12881	-3.9502308	story	10.0	148.0	1684626526	-10.320498
34594675	Typed Lisp, A Primer (2019)	Typed Lisp, A Primer (2019)	tagfowufe	15.146348	-3.9389408	story	10.0	77.0	1675171240	-10.402775
36887555	This sounds so amazing, why is Commo	This sounds so amazing, why is Common Lisp not the most popular language out there? (asking as someone who almost never writes code)	peanutz454	15.135385	-3.9600742	comment	10.0	72.0	1690420306	-10.441684
37400398	Writing Small CLI Programs in Common	Writing Small CLI Programs in Common Lisp (2021)	mooreds	15.123139	-3.9544687	story	10.0	144.0	1693964412	-10.344421
37402539	Awesome, but there is kind of a deal	Awesome, but there is kind of a deal-breaker here:AFAIK, there isn't an official and hassle-free way to generate a statically-compiled binary with SBCL the way Go and Rust can. Like you develop on a debian 12 system, then move the binary to your debian 11 server only to be confronted with the notorious 'incompatible glibc version error'. It's super annoying.In ECL, I think it's possible to use musl and bundle libecl and mucl libc into the final binary, but I'm not sure.The caveat is ECL output startup time is around 500ms (as opposed to the much more performant SBCL output)	ducktective	15.125381	-3.9465253	comment	10.0	52.0	1693988231	-10.374928
24893416	This is maybe the best introductions	This is maybe the best introductions to Lisp i have seen, especially for a js dev like me it could hardly get more approachable and convincing.I could not help but thinking at the end, this is really awesome but s-expressions are kind of hard to read and reason about for my brain, it would be cool if we could generate them from more readable syntax, maybe something like javascript :D . Unfortunately the standard js AST seems to be not a great fit but i found a S-Expression encoder for js AST https://github.com/anko/eslispThis way instead of having to write s-expressions manually we took a whole circle and are back at js but with macros, not relying on eval and having a code is data representation...	jFriedensreich	15.091057	-3.9974852	comment	10.0	97.0	1603694808	-10.344161
38850961	A lightweight Lisp interpreter in Ma	A lightweight Lisp interpreter in Malbolge	noteness	15.120228	-3.952769	story	10.0	114.0	1704258482	-10.355834
22141580	> I have to admit, that at the begin	> I have to admit, that at the beginning using brackets was not easy for me. Once I’ve realized that the brackets are just on the other side of the function name, everything was simple and I could code very fast.A question to fellow Lispers: is there a good reason why LISPs do not put parenthesis they way we know from math? Why `(f foo bar)` and not `f(foo bar)`?	kotutku	15.091355	-4.0042667	comment	10.0	47.0	1579893979	-10.357298
19121443	LispOS: Specification of a Lisp oper	LispOS: Specification of a Lisp operating system (2013) [pdf]	molteanu	15.127978	-3.942785	story	10.0	140.0	1549703280	-10.385593
19270886	Let’s LISP like it’s 1959 [video]	Let’s LISP like it’s 1959 [video]	DyslexicAtheist	15.156069	-3.930836	story	10.0	183.0	1551357205	-10.472555
19407548	Lem: A Common Lisp editor/IDE with h	Lem: A Common Lisp editor/IDE with high expansibility	lelf	15.104029	-3.9620602	story	10.0	159.0	1552740553	-10.379829
17037083	Lisp is quite popular at my current 	Lisp is quite popular at my current workplace. A few popular open source projects published by our organization have been written in Clojure (a dialect of Lisp that runs on JVM and CLR). A few domain specific languages used internally in our organization are also inspired by Lisp.On a more personal front, I find Lisp to be simple, elegant, and expressive. I use Common Lisp (SBCL) for personal use. Working with Lisp induces a sense of wonder: how simple concepts can be composed elegantly to build complex functions and complex software. It's the same kind of sense of wonder one feels when one learns how the simple concepts of Euclid's postulates can be used to prove complex concepts in Geometry or how the Newton's laws of motion can be used to derive intricate and complex concepts in classic	susam	15.1313715	-3.9638631	comment	10.0	157.0	1525938763	-10.432974
17959441	Its not exactly equivalent, but havi	Its not exactly equivalent, but having spent the last month debugging a nightmare of C++ template meta programming mixed with a lot of C macros...  I think things like this can be nice if they’re applied tastefully but I wouldn’t trust 99% of programmers to be judicious with these things. As someone else said, it’s catnip to a certain type of coder. It also creates a really nasty implicit dependency — you can’t pull out individual components because they’re dependent on the DSL, and who knows what dependencies the DSL pulls in? I would actually argue that macros might be why Lisp didn’t become mainstream; it creates a lot of fragmentation. Most people don’t even want to learn the syntax of their build system, asking them to learn some weird language extensions they can’t take to their next	overgard	15.110862	-3.988906	comment	10.0	62.0	1536671859	-10.388635
18518988	I wonder if a kickstarter to create 	I wonder if a kickstarter to create a new Lisp Machine could work.I envision something like a Raspberry Pi, but with the hardware designed to run Lisp, and taking inspiration from the original Lisp Machines.	pmoriarty	15.141767	-3.9389007	comment	10.0	75.0	1543008285	6.4566193
29975334	Ask HN: How does Common Lisp deal wi	Ask HN: How does Common Lisp deal with side effects?	iamwil	15.125176	-3.9665377	story	10.0	10.0	1642482154	-10.415846
13096705	I've been working in JS full time fo	I've been working in JS full time for a couple of months now, except for a short break to build a JSX parser for Emacs. Switching to lisp was such a breath of fresh air. The code was denser, and every line took longer to write, so not sure about overall productivity, but man was it more enjoyable to write!I wish there were an update to this book. I seriously looked into giving up on JS and using Parenscript and Wookie or Hunchentoont but it seemed like I'd be taking on a lot of yak hair. Does anyone here use any lisp for Web Development? What's the modern lisp (CL or otherwise) stack?	fovc	15.090035	-3.995158	comment	10.0	49.0	1480788557	-10.407662
13193376	I wonder why lisp isn't as popular a	I wonder why lisp isn't as popular as say python for AI, ML, and stuff. I see these fields as having a strong academic tone, and it feels like racket or clojure could be bigger when it comes to that.	erik14th	15.152516	-3.9410963	comment	10.0	51.0	1481898154	-10.636086
13296991	Ask HN: Learning Lisp?	Ask HN: Learning Lisp?	jonaf	15.153614	-3.933581	story	10.0	21.0	1483300350	-10.451206
12354236	Apart from Clojure (which is not LIS	"Apart from Clojure (which is not LISP, really), I haven't seen end-user applications written in LISP dialects (I don't think emacs is end-user software). Scheme (and its PLT dialect Racket) was in academia for so long that it literally got ""friend-zoned"" and has little (read ""no"") use in the industry.Then again, I expected to see more Common LISP around. Paul Graham really put it right, but I guess any leverage/advantage LISP had on other languages, it waned in the 90's (maybe Viaweb was one of the last projects done in LISP, and even that was translated later to other langs...)I don't think s-expressions are _that_ problematic. The main issue with LISP's nowadays is lack of _momentum_. Java gained its momentum by Sun, after that it just keeps rolling in the industry and apparently, there'"	behnamoh	15.115726	-3.9823434	comment	10.0	90.0	1472063766	-10.431153
35301138	Common Lisp Quick Reference (2018)	Common Lisp Quick Reference (2018)	abudabi123	15.146225	-3.938732	story	10.0	148.0	1679738445	-10.445463
28036679	Lisp as an Alternative to Java (2000	Lisp as an Alternative to Java (2000)	susam	15.126411	-3.9638047	story	10.0	150.0	1627913220	-10.488924
22935650	Forth Lisp Python Continuum: A small	Forth Lisp Python Continuum: A small highly-dynamic self-bootstrapping language	kick	15.09848	-3.9875066	story	10.0	152.0	1587482229	-10.195903
33282865	Between Two Lisps (2020)	Between Two Lisps (2020)	podiki	15.14915	-3.935471	story	10.0	106.0	1666313901	-10.467479
33324106	Ask HN: Lisp and Artificial Intellig	Ask HN: Lisp and Artificial Intelligence	nyc111	15.137358	-3.9449685	story	10.0	15.0	1666654587	-10.46112
33572930	I still don't get Lisp. Why does the	I still don't get Lisp. Why does there need to be an endless amount of dialects? Doesn't this completely needlessly fracture the ecosystem into hundreds of pieces making it impossible to effectively support?Isn't the point of Lisps to be endlessly customizable, making the invention of a new dialect less necessary?The only Lisp I'd consider for a real project is probably Clojure and I'd even be hesitant about that. Sure, you can make a simple web project with Arc (HN), but it seems like you get 0 libraries, 0 interfaces with other systems and 0 tooling. Why would I bother with that?	solarkraft	15.137838	-3.9509072	comment	10.0	47.0	1668260316	-10.450835
33574311	A brief interview with Common Lisp c	A brief interview with Common Lisp co-creator Dr. Scott Fahlman	dorfsmay	15.152303	-3.9348114	story	10.0	169.0	1668269272	-10.451467
37660025	Spinneret: A modern Common Lisp HTML	Spinneret: A modern Common Lisp HTML generator	nanna	15.11991	-3.948552	story	10.0	116.0	1695738978	-10.427957
37830342	Common Lisp: An Interactive Approach	Common Lisp: An Interactive Approach (1992)	nanna	15.131547	-3.9422615	story	10.0	119.0	1696933418	-10.423276
20232435	I keep hearing about Common Lisp, bu	"I keep hearing about Common Lisp, but I just don't ""get it"". Is it really as mind-blowing as people say when you ""get it""?"	umvi	15.152495	-3.9366496	comment	11.0	44.0	1561035765	-10.476102
20590439	How to Write a Lisp Interpreter In P	How to Write a Lisp Interpreter In Python (2010)	KibbutzDalia	15.108626	-3.984292	story	11.0	132.0	1564715412	-10.224165
20845458	> homoiconicity, meaning code can be	> homoiconicity, meaning code can be represented as a data structure inside the same language> generating strings and passing them into eval like for example in PythonPython has become a pinata for language enthusiasts?  Python lets you pin a decorator on a function, get the AST (a data structure AFAIK), manipulate it in a sane fashion in Python,  compile it, return the result.  No string munching eval requireI'm all for Lisp but this just isn't convincing	marmaduke	15.097178	-3.9985209	comment	11.0	48.0	1567245369	-10.2814
13929355	Modern C++ and Lisp Programming Styl	Modern C++ and Lisp Programming Style	deepaksurti	15.123265	-3.9679182	story	11.0	145.0	1490171984	-10.408782
25554756	A Tiny Lispy Transpiler	A Tiny Lispy Transpiler	oumua_don17	15.112481	-3.9640105	story	11.0	110.0	1609107494	9.23253
26162522	Ask HN: Why should we learn Lisp?	Ask HN: Why should we learn Lisp?	smlckz	15.14188	-3.9377697	story	11.0	16.0	1613534571	-10.439307
35752221	That book is a little bit controvers	"That book is a little bit controversial. Here is the main criticism leveled at it:
https://gist.github.com/no-defun-allowed/7e3e238c959e27d4919...> The interpreter uses very dubious implementation decisions, and the language that is created as a side-effect makes reasoning about anything near impossible.Personally I really like the writing style of the book and had fun following it BUT you definitely shouldn't use it as your primary source to learn about these things.You need to do you own research and figure out why some ideas presented in the book are dead-ends that should be avoided.It is definitely NOT a useful for those who want to learn the proper way to implement a Lisp, especially a non-toy one.Alternatives are Crafting Interpreters by Robert Nystrom and MAL (Make your own Lisp). H"	cardanome	15.14577	-3.9360878	comment	11.0	60.0	1682770935	-10.441198
35936878	What value would learning Lisp provi	What value would learning Lisp provide, if you're not curious and learning for the love of learning, or you're not an emacs user?	jossclimb	15.142138	-3.9478636	comment	11.0	39.0	1684059426	-10.477743
36195276	Personally I find that LISP syntax r	"Personally I find that LISP syntax remove a layer of complexity by directly exposing the AST to my brain instead of adding a layer of internal parsing.    1 + x * 2 - 3 % x

is longer to decipher than    (% (- (+ (* x 2) 1) 3) x)

which is itself harder than    (-> x (* 2) (+ 1) (- 3) (% x))

But it takes a while to be used to it.
And yes, it really helps writing macros, but I wouldn't say this as always be a good thing. Macros are far from being the alpha and omega of programming, as they add an implicit layer of transformation to your code making it easier to write but very often harder to read and reason about."	yogsototh	15.107569	-3.9887843	comment	11.0	65.0	1685968025	-10.37188
28725958	Common Lisp	Common Lisp	astdb	15.149254	-3.935279	story	11.0	172.0	1633148825	-10.4602785
29403876	"I wonder how popularity of ""exotic"" "	"I wonder how popularity of ""exotic"" languages increases when AoC's aroundF#, Lisp and so on"	tester34	15.134617	-3.9419844	comment	11.0	59.0	1638368920	-10.429974
29507078	So... I want to like Lisp, and every	"So... I want to like Lisp, and every time I read stories like these I understand why people enjoy it.But then I see a code snippet, something like this manual datetime string parser. Apparently the programmer needed to roll their own, and I wonder: how on earth am I going to convince my corpo overlords that this language belongs anywhere near a production system?  (let ((year  (parse-integer string :start 0 :end 4))
        (month (parse-integer string :start 6 :end 7))
        (day   (parse-integer string :start 9 :end 10)))
    (- (+ (\* year   31556926) ;; no. of seconds in a year
          (\* month  2629743)  ;; no. of seconds in a month
          (\* day    86400))   ;; no. of seconds in a day
       (\* 1900 31556926))))   ;; lisp timestamps start at 1900"	isoprophlex	15.128259	-3.9623778	comment	11.0	45.0	1639118488	-10.387527
36548071	Whenever a post about Lisp graces th	Whenever a post about Lisp graces the front page of Hacker News, I typically observe two main categories of commenters. The first group is composed of devout Lisp enthusiasts who have either applied it to solve problems in the past or continue to utilize it in their personal and professional projects. They are well-versed in the numerous advantages of Lisp over many contemporary programming languages. Their familiarity with the language extends to its versatility in writing DSLs using its macro system, its adaptability in altering running programs, and its debugging prowess. They value the ability to scrutinize the internals, apply multiple programming paradigms, and appreciate various other benefits.The second group, conversely, is characterized by its perennial question whenever a Lisp-r	submeta	15.142746	-3.9496229	comment	11.0	75.0	1688200680	-10.508223
36635373	Owner of Symbolics Lisp machines IP 	Owner of Symbolics Lisp machines IP is interested in a non-commercial release	mepian	15.137008	-3.9386256	story	11.0	230.0	1688751580	-10.319554
36887744	Wow, wasn't expecting to see my post	Wow, wasn't expecting to see my post on here! Eventually, I want to write a follow-up, but I'm still a beginner.Here's what I've liked about Common Lisp so far:* The condition system is neat and I've never used anything like it -- you can easily control code from afar with restarts* REPL-driven programming is handy in situations where you don't quite know what will happen and don't want to lose context -- for example parsing data from a source you're unfamiliar with, you can just update your code and continue on instead of having to save, possibly compile, and restart from the very beginning* Common Lisp has a lot of implementations and there's a good deal of interoperability -- I was able to swap out implementations to trade speed (SBCL) for memory usage (CLISP) in one case (multiple comp	schemescape	15.121958	-3.9683187	comment	11.0	78.0	1690421803	-10.423579
37222669	HCSL: Hand coded stringy lisp	HCSL: Hand coded stringy lisp	0x3444ac53	15.119164	-3.964217	story	11.0	26.0	1692712111	-10.378004
32632382	Having played around with Clojure an	Having played around with Clojure and Scheme for a while (but never got too serious), I always thought homoiconicity and macros were extremely cool concepts, but I never actually ran into a need for them in my everyday work.>Now, if we agree that the ability to manipulate source code is important to us, what kind of languages are most conducive for supporting it?This is useful for compiler programmers, or maybe also those writing source code analyzers/optimizers, but is that it? On occasion I have had to write DSLs for the user input, but in these cases the (non-programmer) users didn't want to write Lisp so I used something like Haskell's parsec to parse the data.The remote code example given in the post is compelling, but again seems a bit niche. I don't doubt that it's sometimes useful 	reifyx	15.101129	-3.9995277	comment	11.0	45.0	1661723070	-10.505541
19272913	> The reason s-expressions are bette	> The reason s-expressions are better than text is that they are more expressiveThat has got to be a joke right? S-expressions are a subset of text it’s axiomatically impossible for them to be more expressive.	hjk05	15.086317	-4.0132437	comment	11.0	42.0	1551373896	-10.428417
16829278	Carp: A statically typed Lisp, witho	Carp: A statically typed Lisp, without a GC, for real-time applications	tosh	15.1111355	-3.9702332	story	11.0	202.0	1523622201	-10.332561
17633055	Parinfer – Simpler Lisp Editing	Parinfer – Simpler Lisp Editing	espeed	15.109843	-3.9765332	story	11.0	200.0	1532784494	-10.322104
17796518	Is Lisp Still Unique? Or at Least Di	Is Lisp Still Unique? Or at Least Different? (2002)	tosh	15.153941	-3.9322946	story	11.0	78.0	1534717518	-10.454682
21231362	Wish I could have Lisp without all t	Wish I could have Lisp without all the parentheses. Parentheses just sour the experience for me.	m0zg	15.094723	-4.002732	comment	11.0	60.0	1570866957	-10.343551
21535165	PAIP: Run Common Lisp in Browser?	PAIP: Run Common Lisp in Browser?	register	15.142676	-3.936389	story	11.0	68.0	1573738008	6.367231
18105948	> Why are programming environments s	> Why are programming environments still so primitive?Because we as an industry made a strategic decision in the late 20th century to value run-time efficiency over all other quality metrics, a decision which has manifested itself in the primacy of C and its derivatives.  Everything else has been sacrificed in the name of run time efficiency, including, notably, security.  Development convenience was also among the collateral damage.> Why can't I debug a function without restarting my program?Because you use C or one of its derivatives instead of Lisp or one of its derivatives.  In Common Lisp you can not only debug a function without restarting your program, you can redefine classes without restarting your program.  It is truly awesome.  You should try it some time.	lisper	15.098012	-3.9879506	comment	11.0	76.0	1538311658	-10.3427305
18254243	I know I am going to write an unpopu	"I know I am going to write an unpopular opinion and get downvoted for it, but here it goes...I am still not convinced by the general ""we don't need to upgrade the Common Lisp specification"" attitude.It surely is remarkable as a specification, encompassing so many aspects of the language, yet it leaves so many other aspects to the particular implementation. Multi-threading for example is supported by most major implementations yet their syntax (and often, semantics) are very different from each other. Same goes for cooperative multitasking (corutines etc). Someone else could come up with other examples.In my opinion a new committee should be formed, to standardize the syntax and semantics of these so common functionalities.In this sense, the various C++ language working groups are doing a r"	znpy	15.132074	-3.9602995	comment	11.0	91.0	1539923385	-10.491801
18900887	Halo was written with a Lisp dialect	Halo was written with a Lisp dialect called blamscript (2014)	kuwze	15.136157	-3.9504347	story	11.0	119.0	1547443770	-10.494156
18911940	Some Lisp books (2012)	Some Lisp books (2012)	deepaksurti	15.15231	-3.9328778	story	11.0	192.0	1547567177	-10.450898
29771957	Understanding the Power of Lisp (202	Understanding the Power of Lisp (2020)	susam	15.149171	-3.9357626	story	11.0	123.0	1641148593	-10.444602
30631590	Paredit mnemonics for slurping and b	Paredit mnemonics for slurping and barfing Lisp symbolic expressions	susam	15.108387	-3.9729064	story	11.0	70.0	1646941912	-10.273949
12777852	How to Write a Lisp Interpreter in P	How to Write a Lisp Interpreter in Python (2010)	xorbox	15.107698	-3.9838538	story	11.0	130.0	1477306927	-10.233593
13471401	excuse my ignorance, but other than 	excuse my ignorance, but other than emacs, what are the uses of LISP?	0wl3x	15.137783	-3.9463387	comment	11.0	43.0	1485267243	-10.493861
12358177	Mezzano – An operating system writte	Mezzano – An operating system written in Common Lisp	arm	15.099778	-3.9345274	story	11.0	213.0	1472124180	-10.23116
28040351	The philosophy of Lisp encourages wr	"The philosophy of Lisp encourages writing your own libraries because it's so easy to do. You're expected to know how to program if you use Lisp; not to depend on tiny prewritten functions in the npm universe that may or may not solve your problem, that may or may not be written in a secure or efficient fashion, and that possibly pull in a million transitive dependencies you don't need.That said, Common Lisp itself includes many of the more useful but difficult-to-write features like hash tables, sort/merge, bignums, complex numbers, etc.The most-used stuff that's not in Common Lisp itself like multithreading and sockets are well-covered by external libraries. The lesser-needed stuff is also quite well covered by the quicklisp library infrastructure [0] as well.So the statement ""libraries.."	dreamcompiler	15.130209	-3.955915	comment	11.0	71.0	1627927435	-10.423756
26493588	Writing Small CLI Programs in Common	Writing Small CLI Programs in Common Lisp	reikonomusha	15.116836	-3.960751	story	11.0	174.0	1615999320	-10.377632
38180062	Ask HN: Does anyone Lisp without Ema	Ask HN: Does anyone Lisp without Emacs?	potta_coffee	15.116332	-3.9567819	story	11.0	17.0	1699378932	9.1157875
15467373	No.I expect this will be a fairly co	No.I expect this will be a fairly controversial comment, so I want to preface this by saying that I'm a big Lisp fan (just look at my handle).  Lisp is my favorite programming language.  I've been using it for nearly forty years.  My first Lisp was P-Lisp on an Apple II in 1980.  And I worked on Symbolics Lisp machines in the 1990s.  They were very cool, but there's a reason they failed: general-purpose computing is infrastructure, and the economics of infrastructure are such that having a single standard is the most economical solution, even if that standard is sub-optimal.  For better or worse, the standard for general-purpose computing is the C machine.Because it's general-purpose you certainly can run Lisp on a C machine (just as you could run C on a Lisp machine).  You can even do thi	lisper	15.132263	-3.9557061	comment	11.0	59.0	1507913858	-10.407314
23761346	Google Common Lisp style guide	Google Common Lisp style guide	fanf2	15.142612	-3.944591	story	12.0	196.0	1594141655	-10.443552
23843533	Author here. The book has just gone 	Author here. The book has just gone to production and will be available at the end of the year in dead-tree and electronic formats.The book happened because I got annoyed at the fact that there is no good reference that shows how the condition system works, what are the foundations required for it to work, what are the basic building blocks that it is composed of, and what are its uses, both in the domain of  handling exceptional situations and, more importantly and less obviously, outside that domain.The book also contains a description of a full implementation of a condition system that can (and hopefully will!) be used outside Common Lisp. There's hope that some languages will pick up these parts of Common Lisp that fully decouple the acts and means of signaling conditions from the acts	phoe-krk	15.126313	-3.9652355	comment	12.0	112.0	1594810626	-10.364818
20376377	Readable Lisp S-expressions Project 	Readable Lisp S-expressions Project (2013)	singularity2001	15.09225	-4.001172	story	12.0	86.0	1562521044	-10.339427
20659557	Ask HN: How do you “get” Lisp?	Ask HN: How do you “get” Lisp?	khaledh	15.133275	-3.9612358	story	12.0	18.0	1565399964	-10.437771
14641658	History of Lisp Editing	History of Lisp Editing	lemming	15.147413	-3.9356413	story	12.0	157.0	1498524101	-10.438843
31199992	Why Lisp macros are cool, a Perl per	Why Lisp macros are cool, a Perl perspective (2005)	pcr910303	15.123166	-3.9766033	story	12.0	132.0	1651192709	-10.365569
31593786	...god, my eyes ...why is everything	"...god, my eyes ...why is everything CL plagued by such horrible design choices (hyperspec, Lisp-IDEs... all!) - why such ugly colors, ugly typography, bad contrasts, ugly logos, ugly diagrams, ugly supporting graphics?!I know that even the language itself is kind of the opposite of ""beautiful"", but the way all docs, blogs, websites etc. look ...seriously, is this intended to scare away any aesthetically sensitive people? Programming languages are about aesthetics too, and Lisp at its core (not CL ofc) is absolutely beautiful!"	catchclose8919	15.138697	-3.9307137	comment	12.0	59.0	1654171251	-10.433289
26065511	State of the Common Lisp ecosystem, 	State of the Common Lisp ecosystem, 2020	lelf	15.155252	-3.9345334	story	12.0	311.0	1612797053	-10.450103
36030937	Lem v2.0.0 – Common Lisp IDE with hi	Lem v2.0.0 – Common Lisp IDE with high expansibility	mepian	15.110613	-3.9562025	story	12.0	129.0	1684760721	-10.411266
36195008	In my long journey to make computers	In my long journey to make computers do what I want spanning several decades, systems, languages and trends, I've come across a certain class of geeks.This group would swear by Lisp. And by that I mean, they would treat Lisp as the gold standard. Sometimes, the only standard that matters. They would go to unimaginable lengths to explain why Lisp is really the purest form of computer science expression; how it sharpens your mind and elevates your skill; how it is akin to poetry, only better, because it's poetry in code.And after all this was done, and repeated several times over, I would gently nod at this exalted madman who had been blessed by the touch of the Lisp God. And then we'd both go back to whatever language we were actually using at the time.	magic_hamster	15.144159	-3.941775	comment	12.0	138.0	1685965744	-10.457362
29007537	What's a good Lisp dialect to write 	What's a good Lisp dialect to write small programs in? I have some Emacs Lisp experience but I wouldn't use it to automate small tasks. For that, I typically use Python.	hesk	15.064725	-4.002182	comment	12.0	38.0	1635289685	-10.361998
29064942	Differences with other Lisps	Differences with other Lisps	susam	15.142266	-3.9465303	story	12.0	159.0	1635762648	-10.47904
29633566	Serious question: who uses Lisp thes	"Serious question: who uses Lisp these days?
Been in software dev industry for over 20 years. Never encountered a single project employing the language.There must be some reason Lisp is so popular on HN."	bitcharmer	15.144808	-3.9443438	comment	12.0	37.0	1640058075	-10.525213
37086335	I quite enjoyed this article, but I 	"I quite enjoyed this article, but I reckon they're talking about ADHD rather than ""bipolar"" mind. Seen under that lens, I resonate with his caricature.Focus is a precious, rare resource outside my control. Mainstream languages, made for collaboration in big teams rather than maximum personal freedom, soon impose restrictions that kill hyperfocus. The ""unused variable is an error"" is the most egregious of them that I hate with a passion. The separation between compilation and running is another that seemingly inescapable today. With languages like Lisp, I can code at the speed of thought from prototype to production.These days tech is advanced by FAANGs, so no one cares about removing the safeties from our languages; this is the reason the focus-challenged among us still go back to Lisp and"	sph	15.101073	-3.984833	comment	12.0	80.0	1691742137	-10.366687
33058450	I Just Can't Kick Lisp	I Just Can't Kick Lisp	djha-skin	15.157165	-3.9304457	story	12.0	63.0	1664733398	-10.47521
22088311	I've read this story a couple times 	"I've read this story a couple times as it's popped up on the internet in different places. I've enjoyed it each time because it promises that lisp is an uber-powerful and easy (?) language.I'm always curious though: what's the other side of the story? Why is lisp always rejected?I started programming seriously (for money) in 2009, and when we needed a language we went with python because it had better math/science libraries than Java and much more libraries in general than clojure/lisp/ocaml. I confess I like the functional languages and like using some of their features in python.Was the no-libraries dealbreaker for the ""pure"" functional languages also true in 1999, which led google to java? Or maybe there are complex meta-programming bugs you can generate in the functional languages (and"	maliker	15.1261425	-3.974882	comment	12.0	81.0	1579392008	-10.481528
19415735	Kilo LISP	Kilo LISP	geocar	15.149462	-3.9330606	story	12.0	221.0	1552849423	-10.499217
19746122	Lisp Operating System (2015)	Lisp Operating System (2015)	antipropaganda	15.136964	-3.9394546	story	12.0	173.0	1556180882	-10.43555
17480435	Honest question: why do people like 	Honest question: why do people like lisp so much? Everything I've been able to learn about the language is that it was designed for a non-register based hardware that never caught on, so now it's just a less effective language that doesn't run as fast as anything else and has a steep learning curve since you need to learn a new programming paradigm. The only good thing I've heard about it is it's simple to implement since it doesn't have a ton of functions, but that doesn't seem like a very good reason to do something just because it's easy to write the code.	guywithahat	15.13948	-3.9540434	comment	12.0	51.0	1530995812	-10.43583
21625848	Lisp-Flavored Programming Languages	Lisp-Flavored Programming Languages	goranmoomin	15.124376	-3.9621153	story	12.0	98.0	1574661829	-10.39867
12197131	Lisp as an Alternative to Java (1999	Lisp as an Alternative to Java (1999)	nwhitfield1	15.123511	-3.9659646	story	12.0	77.0	1469975862	-10.471381
12231137	I am fairly deep into learning Haske	I am fairly deep into learning Haskell. After I am done, should I learn Lisp (SICP)? Smalltalk? Prolog?I am learning these languages for mind-expansion.I am also studying AI, will learning Lisp be relevant? (e.g. Help me reason about and write AI systems)	avindroth	15.129372	-3.9703975	comment	12.0	73.0	1470392242	-10.470526
28114356	A Lisp interpreter written in Lisp (	A Lisp interpreter written in Lisp (2017)	capableweb	15.118256	-3.9614944	story	12.0	160.0	1628501238	-10.401931
33162283	Eliminating FORMAT from Lisp (2003)	Eliminating FORMAT from Lisp (2003)	susam	15.137084	-3.9477699	story	12.0	70.0	1665489590	-10.461508
33463517	I really wanted to get Lisp. I thoug	I really wanted to get Lisp. I thought, I can't get onto the pedantic train of Haskell, but maybe I can do for Lisp. Had a play with Common Lisp and Scheme and... Nothing.It's not that I found either to be bad. I quite like the syntax actually. There were some nice things too, I get how macros are neat.But I didn't get that cathartic realignment of magnetic domains. I saw a neat programming language. In fact (gasp) I couldn't see many massive wins over my go-to Python.- yes, lisps are compiled and to some extent statically typed, so that's one- I get the REPL programming experience is better, though somehow it didn't hook me.- Macros... Yes Python doesn't have them, but there's so much introspection that in practice, whenever I saw a macro example, it was clear how to achieve the same thin	rich_sasha	15.110362	-3.9804375	comment	12.0	46.0	1667550688	-10.408076
33718011	Common Lisp Object System (CLOS)	Common Lisp Object System (CLOS)	memorable	15.122141	-3.9607377	story	12.0	113.0	1669204035	-10.448062
26957792	Symbolics Lisp Machine demo (2013) [	Symbolics Lisp Machine demo (2013) [video]	lelf	15.128357	-3.9489052	story	12.0	139.0	1619539492	-10.338507
27036566	Processing parentheses is still pars	"Processing parentheses is still parsing. It's kindergarten-level parsing, but it's still parsing.I've written thousands of lines of scheme code preprocessed to  eliminate most parenthesis. I'm convinced Lisp self-asphyxiated by fighting a last stand on parentheses, which is so far from the point of Lisp. With modern editor ""language server"" support and syntax coloring, languages can shape-shift to any appearance they want, separate from meaning.While I love the poetic look of parenthesis-spare Lisp, Bill Joy got it right when he said that code density on a screen affects programmer productivity. I love Haskell, both for this and because one reasons about the activity of programming as if one is doing algebra.While Lisp more easily modifies itself than any other language, macros are bolted "	Syzygies	15.098971	-3.9961302	comment	12.0	61.0	1620129030	-10.373142
38511519	Can someone explain these scheme and	"Can someone explain these scheme and lisp languages to me?
Every time I look at these languages, I can't grasp what you can use them for.
And why one would use them.I always feel like I'm missing something.
In the example scripts and code snippets, I can see that you can define functions, that you can use lists, mathematical operations, you can build some algorithms, you can print text, but it never goes further than that.I've only used languages like Python, Rust, C, Java, JavaScript, and they all have a very similar vibe, you have a std lib, which can interact with many things, you can build UIs, networking libraries and all that. And I could probably start using any language that is ""similar"" to these.But I could never use one of these scheme/lisp languages, as I can't really grasp them"	SushiHippie	15.122944	-3.9689949	comment	12.0	44.0	1701643350	-10.453556
15359391	I still fantasize about having lisp 	"I still fantasize about having lisp ""all the way down"", but I'm not sure what I mean or ought to mean when I am fantasizing. On the one hand, I mean implementing lisp in hardware as fundamentally as possible (don't really know why this would be valuable, but I'm still drawn to it). On the other hand, I mean having lisp be the foundation at the software level (ie., the kernel and the rest of the OS; I can more easily see how this would be valuable).Can someone here speak to the notion of a lisp machine in the future? Is there any chance this could happen? Would it be valuable? Does anybody else here have this same dream/fantasy/whatever-you-want-to-call-it?(edited slightly for wording and clarity)"	ra88it	15.142114	-3.9428608	comment	12.0	89.0	1506621598	-10.447823
30800520	The Lisp Curse (2017)	The Lisp Curse (2017)	gphilip	15.151607	-3.9305634	story	13.0	64.0	1648205060	-10.464954
31302086	(Yet Another) Lisp in Go	(Yet Another) Lisp in Go	tosh	15.137124	-3.94804	story	13.0	80.0	1651996013	-10.370094
31552349	Lisp, Smalltalk, and the power of sy	Lisp, Smalltalk, and the power of symmetry (2014)	behnamoh	15.142651	-3.943005	story	13.0	166.0	1653854317	-10.418739
31645558	A Road to Common Lisp (2018)	A Road to Common Lisp (2018)	jsfcoding	15.146563	-3.9372373	story	13.0	182.0	1654546401	-10.455971
26053467	Does anyone find Lisp readable?I hav	Does anyone find Lisp readable?I haven't used Lisp professionally, but find the code terribly confusing to read (mostly due to the look of it, I assume), while I can usually follow code of an unknown language reasonably well.	enw	15.129648	-3.9541924	comment	13.0	79.0	1612685205	-10.440815
34321090	Common Lisp: 2022 in review	Common Lisp: 2022 in review	Tomte	15.14839	-3.9341457	story	13.0	195.0	1673330557	-10.451345
34327306	A question I have that's not answere	A question I have that's not answered by the link is why would I want to learn lisp? If you were starting a project today, what are some of the features Lisp offers that make it a better choice than any other (more popular) language? And do those features outweigh the lack of community the larger languages have?	JLCarveth	15.146271	-3.9400277	comment	13.0	55.0	1673368079	-10.474438
39376417	It's the lists.No, not the prefix no	"It's the lists.No, not the prefix notation, parenthesis, what have you, although that doesn't help. The lists themselves. In Lisp, code is data, and data is lists.Yes, of course, there are hashmaps, arrays, strings. But idiomatic Lisp code really does use linked lists extensively, it's an entire style of programming. Even if you'd prefer to use different data structures (and again, Common Lisp does support this), you still have to be able to read and reason about the many parts of the language designed for, as the old quip had it, prothething lithts.The ""weird looking syntax"" does not help, but Lisp hackers are right that you get used to that part, might even appreciate it if macros are something you really care about. Structural editing a la paredit and parinfer are pretty nice too.But wh"	samatman	15.110583	-3.9908319	comment	13.0	159.0	1707949444	-10.445654
39570679	KamilaLisp – A functional, flexible 	KamilaLisp – A functional, flexible and concise Lisp	tluyben2	15.143709	-3.9445498	story	13.0	123.0	1709364570	-10.467967
15880172	Lisp at the Frontier of Computation 	Lisp at the Frontier of Computation [video]	reikonomusha	15.147909	-3.9303687	story	13.0	202.0	1512753176	-10.42601
16308844	So this is literally Lisp, just with	"So this is literally Lisp, just with curly braces instead of parenthesis :).I don't understand this part of the readme:> The advantage of Mark over S-expressions is that it is more modern, and can directly run in browser and node.js environments.Does this mean I'm so out of date with JS that this syntax is actually legit JS? Or does Mark run its own parsers, at which point it's just like sexps, except it uses the ""more modern"" curly brace instead of ""less modern"" parenthesis?"	TeMPOraL	15.072945	-4.025149	comment	13.0	71.0	1517840378	-10.407826
16407914	Lisps are like tiling window manager	Lisps are like tiling window managers... Some have a taste for them. Most, don't.Unfortunately some of the Lisp cool features are hard to implement without its simple syntax. Maybe the lesson is that we should find a f way to have syntax-independent programming languages! Just as we expect any successful language to have at least a couple implementations before being taken seriously, maybe we should expect a language to have at least a couple different alternative syntaxes and instant perfect translation between them (with comments and code style preserved), so I can use syntaxA and work on same codebase with my colleague using syntaxB. Than we'll be sure any metaprogramming or code intelligence tools don't suck because they'll be damn forced to not use the program text but the AST (that w	nnq	15.11273	-3.9838738	comment	13.0	80.0	1518983309	-10.391411
16419181	Overview and Introduction to Lisp (1	Overview and Introduction to Lisp (1986) [video]	tosh	15.135139	-3.9443948	story	13.0	156.0	1519121842	-10.457002
17852194	A Road to Common Lisp	A Road to Common Lisp	stevelosh	15.150571	-3.9364552	story	13.0	343.0	1535385265	-10.464295
29850703	Practical Common Lisp (2005)	Practical Common Lisp (2005)	bikramgig	15.144064	-3.930288	story	13.0	144.0	1641641697	-10.447944
13354035	How Lisp-family languages facilitate	How Lisp-family languages facilitate building bioinformatics applications	abrax3141	15.130262	-3.9638155	story	13.0	118.0	1483936474	-10.430296
12111811	Lisp: it's not about macros, it's ab	Lisp: it's not about macros, it's about READ (2012)	lisper	15.115226	-3.9760115	story	13.0	154.0	1468789466	-10.270671
23292805	Running Lisp in Production (2015)	Running Lisp in Production (2015)	lisper	15.137885	-3.94291	story	13.0	139.0	1590339324	6.425473
23293736	I seriously don’t get why lisp is so	I seriously don’t get why lisp is so popular on HN, it’s basically unreadable to very most of developers. It’s an ivory tower.	dirtnugget	15.149207	-3.9383523	comment	13.0	98.0	1590346745	-10.459097
34026414	Carp – a statically typed, non-GC Li	Carp – a statically typed, non-GC Lisp language	sph	15.102932	-3.976652	story	13.0	135.0	1671270809	-10.278051
27032277	Casio AI-1000 Pocket Lisp Computer f	Casio AI-1000 Pocket Lisp Computer from 1989 [video]	akuzi	15.129885	-3.9334624	story	13.0	178.0	1620084850	-10.338359
27277575	Second Climacs – Emacs Implementatio	Second Climacs – Emacs Implementation in Common Lisp	xvilka	15.12823	-3.9536252	story	13.0	131.0	1621954392	-10.402451
14754535	Lisp's mysterious tuple problem	Lisp's mysterious tuple problem	AndrewBissell	15.143454	-3.9385402	story	13.0	17.0	1499880682	-10.445788
15226110	Mal – Make a Lisp, in 68 languages	Mal – Make a Lisp, in 68 languages	ingve	15.142089	-3.9364722	story	13.0	236.0	1505211399	-10.40712
25287034	State of Common Lisp Survey 2020	State of Common Lisp Survey 2020	michaelanckaert	15.151022	-3.9328697	story	13.0	117.0	1606986243	-10.45729
32175820	New Lisp-Stat Release	New Lisp-Stat Release	Lisp-Stat	15.142848	-3.9404771	story	13.0	105.0	1658378149	-10.477274
13948966	Lisp Quickstart	Lisp Quickstart	macco	15.14876	-3.934351	story	14.0	327.0	1490364466	-10.382505
26067697	I think this article (of sorts) is d	"I think this article (of sorts) is definitely helpful for onlookers to Common Lisp, but doesn't provide the full ""story"" or ""feel"" of Common Lisp, and I want to offer to HN my own perspective.Disclaimer #1: I've been working professionally as a Common Lisp programmer---not as a contractor!---for the past decade. I have a vested interest in the language and hiring for it.Disclaimer #2: I am going to ignore commercial implementations of Lisp here, which provide very useful and advanced features, like GUI development, a user-friendly IDE, paid support, etc. [1,2]So let's get started. Common Lisp's best feature is that it allows you to be insanely productive at the ""raw programmer"" level. You can write, edit, and debug code very quickly and incrementally, and end up with safe & performant code"	reikonomusha	15.135651	-3.9554646	comment	14.0	69.0	1612806468	-10.437273
36154069	Cakelisp: A performance-oriented Lis	Cakelisp: A performance-oriented Lisp-like language	ducktective	15.130449	-3.957273	story	14.0	112.0	1685638973	-10.38133
29181404	Clog – The Common Lisp Omnificent GU	Clog – The Common Lisp Omnificent GUI	podiki	15.134396	-3.937885	story	14.0	163.0	1636581016	-10.389316
34557347	Lisping at JPL Revisited	Lisping at JPL Revisited	lisper	15.14939	-3.9326975	story	14.0	219.0	1674911934	-10.511238
39397942	The Emacsen family, the design of an	The Emacsen family, the design of an Emacs and the importance of Lisp (2023)	oumua_don17	15.127939	-3.9494872	story	14.0	140.0	1708095735	-10.400693
25313311	Between two Lisps	Between two Lisps	galfarragem	15.152242	-3.9349365	story	14.0	142.0	1607163368	-10.478448
32802308	Common Lisp names all sixteen binary	Common Lisp names all sixteen binary logic gates	optimalsolver	15.12445	-3.9541314	story	14.0	158.0	1662923007	-10.240545
33055150	I'm really curious: do people consid	I'm really curious: do people consider common lisp to be the go-to lisp today?if yes, that's awesome, I'll look into it.if no, what is the go-to? and is there an emacs-like using that lisp?	pvinis	15.143471	-3.941995	comment	14.0	73.0	1664711958	10.244568
21559737	Beating C with Common Lisp	Beating C with Common Lisp	verisimilitudes	15.1377325	-3.9439914	story	14.0	95.0	1574020834	-10.368101
13467473	The Bipolar Lisp Programmer (2007)	The Bipolar Lisp Programmer (2007)	olieidel	15.136875	-3.9471607	story	14.0	102.0	1485215657	-10.452482
33736005	A few examples of Lisp code typograp	A few examples of Lisp code typography (2013)	reikonomusha	15.12387	-3.9505491	story	14.0	121.0	1669322557	-10.390097
38126052	A standalone zero-dependency Lisp fo	A standalone zero-dependency Lisp for Linux	keepamovin	15.124679	-3.9483054	story	14.0	191.0	1699001091	12.533584
20919819	The Lisp Curse (2011)	The Lisp Curse (2011)	felipelalli	15.153878	-3.931786	story	15.0	59.0	1568047653	-10.467391
14480157	The Lisp Curse (2011)	The Lisp Curse (2011)	mpweiher	15.154483	-3.9327848	story	15.0	86.0	1496558014	-10.459938
14581228	Goism – Use Go instead of Emacs Lisp	Goism – Use Go instead of Emacs Lisp inside Emacs	demiol	15.114532	-3.9921253	story	15.0	164.0	1497801648	10.221479
25583506	Anyone here use SBCL or Common Lisp?	Anyone here use SBCL or Common Lisp? Curious what you guys think of it.	gautamcgoel	15.127712	-3.9484046	comment	15.0	82.0	1609348480	-10.431202
26297040	Not Lisp again (2009)	Not Lisp again (2009)	caslon	15.150342	-3.9335477	story	15.0	246.0	1614546237	-10.475844
35826104	Paradigms of A.I. Programming: Case 	Paradigms of A.I. Programming: Case Studies in Common Lisp (1991)	abudabi123	15.134011	-3.9531252	story	15.0	237.0	1683269809	-10.461897
35936463	Successful Lisp: How to Understand a	Successful Lisp: How to Understand and Use Common Lisp (1999)	medo-bear	15.147717	-3.9435003	story	15.0	172.0	1684054313	-10.4859495
36544573	Steel Bank Common Lisp	Steel Bank Common Lisp	swatson741	15.144313	-3.9321125	story	15.0	262.0	1688170717	-10.492716
28850861	Janet – a Lisp-like functional, impe	Janet – a Lisp-like functional, imperative programming language	tsujp	15.089377	-3.998844	story	15.0	224.0	1634124372	-10.520799
28880888	Mezzano on Librebooted ThinkPads	Mezzano on Librebooted ThinkPads	lispm	15.091366	-3.9312873	story	15.0	226.0	1634320941	-8.004456
34863017	I have a suspicion that outside of t	I have a suspicion that outside of the 10 people writing lisp seriously—shirakumo, stylewarning, lispm, and some others— there’s more characters of prose praising lisp being written than lisp being written. It’s a great language. I really like it and am using it for some projects. I just want people to actually use it rather than talking about using it.Edit: I’m wrong in the present case! Author has some cool projects on GitHub under themetaschemer. Still though I’m struck by the ratio of lisp project articles vs lisp praising articles hitting HN’s front page.	gaze	15.147726	-3.9369144	comment	15.0	112.0	1676849625	-10.436388
35092027	Carp lang: statically typed Lisp, no	Carp lang: statically typed Lisp, no GC	fbn79	15.110499	-3.9672017	story	15.0	237.0	1678437472	-10.283088
32761113	Kamby – A programming language based	Kamby – A programming language based on Lisp that doesn't seem like Lisp	henriquegogo	15.138196	-3.95088	story	15.0	155.0	1662610445	-10.473519
19121828	Build me a Lisp	Build me a Lisp	KayEss	15.140883	-3.939781	story	15.0	127.0	1549712305	-10.455365
16395810	Yes, code is data, but that's not wh	Yes, code is data, but that's not what makes Lisp cool	lisper	15.1152115	-3.9772294	story	15.0	154.0	1518812981	-10.441461
16583973	Honestly curious why Lisp has so muc	Honestly curious why Lisp has so much admiration and praise on HN. I played around with Scheme some long time ago, read SICP, learned a lot. And I know Lisp inspired many programmers like the founder of Ruby. But I would not think of Lisp when it comes to solving day to day problems. I rather pick Python because it helps me solve all kinds of problems. There are many more solutions I can think of (Ruby, Node, Go, even Perl).	submeta	15.15043	-3.9312506	comment	15.0	118.0	1521027550	-10.446709
17116780	Python for Lisp Programmers (2000)	Python for Lisp Programmers (2000)	bshanks	15.096129	-3.9947627	story	15.0	133.0	1526888263	-10.1357155
17439916	Lisp is part of the family of langua	Lisp is part of the family of languages that J. Backus referred to as 'transformational languages'. Its ability to self-modify creates programs that are almost impossible for people other than the author to understand. This is why after 50 years it is still a niche language, and will remain so. There is little demand for programming languages that are hard to maintain. A working program lasts decades, and passes through many hands, and LISP is dead-end technology that will forever keep being brought up as its temptations are irresistible to some.	magicmouse	15.135473	-3.955701	comment	15.0	121.0	1530517381	-10.451334
39118438	Embracing Common Lisp in the modern 	Embracing Common Lisp in the modern world	joaogui1	15.147442	-3.9389787	story	15.0	183.0	1706110063	-10.484192
18309383	Serious question: what is it about t	"Serious question: what is it about the ""beauty"" of Lisp that the HN community seems to like so much? To me, how Lisp looks is its worst quality--the number of parentheses is just mind boggling. I want to understand why it is so loved."	wycy	15.150214	-3.9324589	comment	15.0	97.0	1540563318	-10.419037
12920700	Honest question: why do tutorials in	Honest question: why do tutorials in this topic seem to always use functional languages/syntax as examples? Our compilers class at MST had us re-implement a lisp compiler, but didn't touch on why we used lisp specifically (other than the professor liking it; we were a largely C++ school). Do they think functional languages are simpler / less complex / easier to understand? Is there something inherently easier to implementing a functional language instead of something more imperative?	drusepth	15.113306	-3.9934032	comment	15.0	85.0	1478788890	-10.464478
27569839	Common Lisp Books	Common Lisp Books	katzeilla	15.1505	-3.9332395	story	15.0	125.0	1624196358	-10.448522
12039268	Carp: a statically typed lisp, witho	Carp: a statically typed lisp, without a GC, for high performance applications	adamnemecek	15.107161	-3.9730713	story	15.0	196.0	1467750053	-10.318509
28180204	> I have met a lot of people who sai	> I have met a lot of people who said that they could do things with Lisp 20, 30 years ago that languages either cannot do today, or could only do recently.> It looks to me like the Lisp community knows something the rest of the world does not. They are not searching for the next hot thing. They seem to understand things on a deeper level than other communities. Perhaps “enlightenment” is not an overwrought term to use.For those that haven't read this before.  For me, any article making claims like this simply brings to mind the Lisp Curse:http://web.archive.org/web/20210617140457/http://www.winesto...(Not currently available...  Last snapshot is from June, so unsure whether this is permanent or just temporary.)Lisp is extremely flexible as a language.  The core is very small, especially i	jdmichal	15.143055	-3.9489698	comment	15.0	81.0	1628945261	-10.453849
22412148	Modern, functional Common Lisp: myth	Modern, functional Common Lisp: myths and best practices	Ambrevar	15.137743	-3.945169	story	15.0	226.0	1582626844	-10.450535
22747932	Restarts in Common Lisp	Restarts in Common Lisp	sulami	15.1222515	-3.961086	story	15.0	139.0	1585744398	-10.403829
14247269	Not Lisp again (2009)	Not Lisp again (2009)	solidsalvia	15.150527	-3.933063	story	16.0	266.0	1493739633	-10.480466
29006172	Why Lisp? (2015)	Why Lisp? (2015)	oumua_don17	15.148375	-3.9417143	story	16.0	157.0	1635281911	-10.468645
29157859	My Emacs Lisp book is finished	My Emacs Lisp book is finished	greenSunglass	15.145816	-3.9346895	story	16.0	410.0	1636433349	-10.41236
34380373	Project Mage is an effort to build a	Project Mage is an effort to build a power-user environment in Common Lisp	zdw	15.139955	-3.9403067	story	16.0	190.0	1673704952	-10.437708
19508616	I Built a Lisp Compiler	I Built a Lisp Compiler	kristianp	15.1248665	-3.9597957	story	16.0	354.0	1553740040	-10.355359
16406761	What Made Lisp Different (2002)	What Made Lisp Different (2002)	montrose	15.152563	-3.936121	story	16.0	184.0	1518971427	-10.461368
16714225	Never played around with Lisp, so ex	"Never played around with Lisp, so excuse the ignorance. Is this typical to construct HTML in Lisp? This feels incredibly verbose and error prone, not to mention confusing and hard to grok. Good luck having a designer mockup/write HTML.    (defun login-panel ()
       (pbox ""login/register""
         (:form :id ""logform"" :class ""nomargin""
           (:table :style ""border-collapse: collapse""
                   (:tr (:td :colspan ""2""  ""username:""))
                   (:tr (:td :colspan ""2"" (:input :id ""loguser"" :class ""txt"" :name ""user"" :type ""text"" :size 15)))
                   (:tr (:td :colspan ""2"" ""password:""))
                   (:tr (:td :colspan ""2"" (:input :id ""logpass"" :class ""txt"" :name ""pass"" :type ""password"" :size 15)))
                   (:tr (:td :colspan ""2"" (:input :id ""logme"	nodesocket	15.134888	-3.9465373	comment	16.0	66.0	1522392495	-10.4527
21735257	Two questions:With the advent of cap	Two questions:With the advent of capable editors like Visual Studio Code, is Vim still a relevant skill to have?Is SLIME still the state of the art for Lisp development environment? Is there no way to get started with Lisp programming without having to learn Emacs or Vim?	travislane	15.083375	-3.9634945	comment	16.0	57.0	1575801522	-10.40735
27598424	Learn C and build your own Lisp (201	Learn C and build your own Lisp (2014)	katzeilla	15.13559	-3.952746	story	16.0	231.0	1624402883	-10.391151
12112665	Okay, I'll put something heretical o	"Okay, I'll put something heretical out there:Lisp just isn't that much better than our current languages.  Sorry.Sure, when Lisp came out it was ""advanced"".  Garbage collection, AST parsing and manipulation, macros, packages, a standard library, modules, homoiconic data structures, etc.However, the good features of Lisp are now normal features of any modern language.  And some of those features have gone into the dustbin for good reasons.  And some of them (static vs dynamic typing) are personal taste.I remember using Lisp in 1984.  It was completely eye-opening relative to the BASIC, assembly, and C I was using up to that point.  However, it didn't run well on small machines that we plebians were using back then.  So, we plebians moved back to assembly, C and possibly Pascal.Lisp STILL ha"	bsder	15.1184025	-3.9672172	comment	16.0	88.0	1468803076	-10.41906
12199748	Ooh Ooh My Turn Why Lisp? (2008)	Ooh Ooh My Turn Why Lisp? (2008)	bootload	15.152825	-3.9341478	story	16.0	99.0	1470015176	-10.479741
35387255	My question for why Janet was answer	My question for why Janet was answered:> My favorite feature of Janet, though, is something that sounds really dumb when I say it out loud: you can actually distribute Janet programs to other people. You can compile Janet programs into statically-linked native binaries and give them to people who have never even heard of Janet before. And they can run them without having to install any gems or set up any virtual environments or download any runtimes or anything else like that.The space is ripe for a lisp that is easily distributable. Yes, common lisp can be statically compiled, but their binaries (at least with sbcl) can get pretty big [1], even with compression. Making a lisp specifically good at using to make CLI or desktop tools with good c ffi support is compelling.1: https://blog.djha	djha-skin	15.136243	-3.9489877	comment	16.0	105.0	1680271087	-10.45049
33600941	Lisp-stick on a Python	Lisp-stick on a Python	tosh	15.106168	-3.981341	story	16.0	198.0	1668459535	-10.2805195
14726108	Can somebody comment on the status o	Can somebody comment on the status of Lisp in 2017?If one were to learn a functional language, is Lisp a good choice today? Or is Haskell more appropiate?	21	15.132933	-3.9696028	comment	16.0	148.0	1499532961	-10.486001
15186598	Asbestos suit on.There are many posi	"Asbestos suit on.There are many positive things you can say about Lisp.However, many day-to-day developers, and their managers, believe that Lisp's syntax creates nigh-unreadable programs. For example, there's no built-in infix syntax, as opposed to practically all other programming languages, and many modern programmers today expect infix as minimum table stakes for a language.  Lisp syntax is extremely simple, but that doesn't mean the resulting code is easily read.  Very smart people will disagree with that opinion - especially a number of people on Hacker News!! However, just look up phrases like ""lots of irritating silly parentheses"" and you'll see that this opinion is extremely widespread.  Many people here will disagree with the sentiment, and that's fine, but it's a fact many peopl"	dwheeler	15.127044	-3.9654965	comment	16.0	82.0	1504727486	-10.399266
15466124	ChrysaLisp – A 64-bit Lisp OS with G	ChrysaLisp – A 64-bit Lisp OS with GUI	bespoke_engnr	15.11226	-3.9457223	story	16.0	306.0	1507905917	-10.317839
23600277	I'm studying CS but haven't heard an	I'm studying CS but haven't heard any concrete examples of why I should learn a lisp (scheme, Clojure). Every time I ask i get pseudo-intellectual answers of how it will expand my mind, make it easier to express complex human problems/domains into code or even make me re-evaluate things in life on a philosophical level. What? On the one hand, i'm sooo curious to study all of this and see for myself, but on the other hand, life's too short and I'm already spending so much time in front of a PC to get my degree, learn a couple of more languages, make side projects on github, personal blogs etc to make myself more employable.Anyway, i know this is HN i'm asking, but can you give me at least one compelling reason why I should study lisp,scheme or clojure ?	yagodragon	15.144195	-3.958421	comment	17.0	67.0	1592834540	-10.704596
31494932	This part was counterintuitive for m	"This part was counterintuitive for me:> We found the age-old belief that ""lisp syntax is just too hard"" is simply false; the main thing that most people lack is decent lisp-friendly tooling with a low barrier to entry, and DrRacket provides that.If the syntax requires special tooling to make it usable, isn't that a sign that the syntax is hard?Are there many people who believe Lisp syntax is as easy as Python or other non-Lisp languages?  If that's true for you, I'd be interested in hearing more about your experience."	zestyping	15.143053	-3.9533134	comment	17.0	84.0	1653412882	-10.387041
36367241	Reddit 1.0 was written in Lisp	Reddit 1.0 was written in Lisp	newsoul	15.138427	-3.934414	story	17.0	218.0	1686975563	-10.406932
28830677	Companies that use Lisp extensively	Companies that use Lisp extensively	tosh	15.141902	-3.9430413	story	17.0	215.0	1633973044	-10.45144
32053083	Guile Steel: a proposal for a system	Guile Steel: a proposal for a systems Lisp	pabs3	15.143658	-3.930276	story	17.0	104.0	1657522491	-10.400427
17439171	The Machine That Builds Itself: The 	The Machine That Builds Itself: The Strengths of the Lisp Languages (2016)	kuwze	15.135725	-3.9517884	story	17.0	239.0	1530502297	-10.43527
18373159	Why I love Common Lisp and hate Java	Why I love Common Lisp and hate Java (2012)	pmoriarty	15.137749	-3.955697	story	17.0	121.0	1541289190	-10.490697
13598123	Lisp is not functional (2010)	Lisp is not functional (2010)	saint-loup	15.143574	-3.9444299	story	17.0	67.0	1486561774	-10.458075
28532442	The Tragedy of the Common Lisp: Why 	The Tragedy of the Common Lisp: Why Large Languages Explode (2019)	abecedarius	15.135291	-3.949917	story	17.0	77.0	1631658890	-10.425615
15575505	Ask HN: Learning Lisp, and I have so	Ask HN: Learning Lisp, and I have some questions	maxpert	15.12512	-3.9535694	story	17.0	94.0	1509205799	-10.431313
20433368	Why is HN this interested in Lisp an	Why is HN this interested in Lisp anyway? Not saying it's a good or bad language, just don't quite get why it receives as much attention as it does.	s_Hogg	15.148931	-3.9399946	comment	18.0	122.0	1563112418	-10.449488
14247959	The objections the author had way ba	The objections the author had way back in the day are no longer the objections programmers of mainstream languages have to Lisp today.Today the objections I hear are more along the lines of:1 - All those parenthesis.  (Still a top objection)2 - Lisp doesn't look like or work like what I'm used to.3 - Lisp doesn't have as many libraries as the most popular mainstream programming languages.4 - There aren't nearly as many Lisp programmers, so it'll be hard to find more to join your project/company if you use Lisp.5 - There aren't nearly as many Lisp jobs, so why bother learning Lisp if you're going to have a hard time finding work using it?6 - Lisp is ancient, and anything that old is useless and primitive compared to new and shiny languages.	pmoriarty	15.154494	-3.9375274	comment	18.0	181.0	1493743303	-10.452818
25152882	Vodka is a creative coding environme	Vodka is a creative coding environment for creative writers (LISP)	tartoran	15.144546	-3.9397929	story	18.0	104.0	1605811624	-10.460785
32382977	Wisp: Whitespace to Lisp	Wisp: Whitespace to Lisp	signa11	15.135556	-3.948756	story	18.0	82.0	1659941509	-10.402258
22087419	Lisping at JPL (2002)	Lisping at JPL (2002)	sandinmyjoints	15.152559	-3.9306145	story	18.0	307.0	1579383267	-10.481827
16591592	Portacle – A Portable Common Lisp De	Portacle – A Portable Common Lisp Development Environment	wheresvic1	15.119627	-3.9468749	story	18.0	254.0	1521109405	-10.375597
39213261	Ask HN: Guide for Implementing Commo	Ask HN: Guide for Implementing Common Lisp	HexDecOctBin	15.128719	-3.9601195	story	18.0	82.0	1706769017	-10.418164
28048072	Lisp in an “impossible” language, th	Lisp in an “impossible” language, the most complex Malbolge program to date	palaiologos	15.128809	-3.9502625	story	18.0	263.0	1627991058	-10.392457
33464007	I see a lot of posts justifying why 	I see a lot of posts justifying why Lisp is nice and should be used. These are good. I agree with them. But I would also like to see posts about actual projects written in Lisp.Compare with Rust and Go. Rust and Go devs write articles evangelizing Rust but that's not all we see. We also see posts about so many useful Rust and Go projects too.How can we see a similar trend for Lisp? And no, it cannot be writing a Lisp in a Lisp or writing a Lisp in your favorite language or writing your favorite language in a Lisp. I am looking for useful projects that do something useful for users who can't give a damn what language the project is written in.I searched https://github.com/topics/lisp but a vast majority of the projects there are not software used by actual users in the wild. Most of them ar	ctrlmeta	15.141692	-3.9441447	comment	18.0	129.0	1667555334	-10.438152
23502964	I don't see why people won't just ta	"I don't see why people won't just take the step D and Lisp do-- allowing full use of the programming language at compile time.You can execute an ordinary functions at compile-time to read a DSL from a string or read attributes (reflective metaprogramming) on your program's classes. Take the string it outputs, use mixin(), and you have code. For example:    // Sort a constant declaration at Compile-Time
    enum a = [ 3, 1, 2, 4, 0 ];
    static immutable b = sort(a);

""a"" only appears in the compiler's memory. ""sort"" is a normal function that runs at compile-time. ""allowing accessto the full language at compile-time"" is similar to what dynamic languages such as Python and JavaScript give you, except D is a static language with GCC and LLVM backends."	crazypython	15.107586	-3.98008	comment	19.0	95.0	1591991050	-10.232569
20233220	The Tragedy of the Common Lisp: Why 	The Tragedy of the Common Lisp: Why Large Languages Explode	mpweiher	15.155146	-3.9306238	story	19.0	113.0	1561040783	-10.43004
20375596	I think Lisp failed because it had n	I think Lisp failed because it had no killer app. Most developers don't pick a language, they pick a project and the select the most appropriate language.Web frontend -> JavascriptUnix / Linux -> CWordpress plugins -> PHPWindows apps -> .NetiOS -> Objective C / SwiftAndroid -> JavaIn my entire career (25 years), I've never had a project that directed me towards learning Lisp. This pretty much leaves Lisp to the type of developer that seeks out new languages and is willing to spend the extra effort integrating, and that's a pretty small number of developers.If Lisp was in the browser instead of Javascript, it would be popular no matter the complaints about the language.	FigBug	15.113644	-3.9803243	comment	19.0	136.0	1562513684	-10.453734
14079573	Dale – A Lisp-flavoured C	Dale – A Lisp-flavoured C	macco	15.140657	-3.9430501	story	19.0	192.0	1491839848	-10.4514065
31654257	Joy: A maximalist web framework for 	Joy: A maximalist web framework for Lisp aficionados	memorable	15.134235	-3.9477253	story	19.0	209.0	1654609706	-10.430326
34524552	The rise and fall of Lisp at the Jet	The rise and fall of Lisp at the Jet Propulsion Lab (2002)	todsacerdoti	15.151609	-3.9341624	story	19.0	236.0	1674682895	-10.472404
32100035	Lisp in 99 lines of C and how to wri	Lisp in 99 lines of C and how to write one yourself [pdf]	jstanley	15.130155	-3.9523733	story	19.0	289.0	1657824776	-10.363185
30172641	Running Lisp in Production (2020)	Running Lisp in Production (2020)	myth_drannon	15.142201	-3.9371622	story	19.0	268.0	1643767634	6.4940386
13192738	The Idea of Lisp	The Idea of Lisp	rbanffy	15.148819	-3.936705	story	19.0	488.0	1481890743	-10.456438
12230869	The truth about Lisp (2006)	The truth about Lisp (2006)	0xmohit	15.148392	-3.9325566	story	19.0	120.0	1470387266	-10.474688
37682273	Lisp Badge LE	Lisp Badge LE	rcarmo	15.147448	-3.9330866	story	19.0	271.0	1695853631	-10.493865
15186053	There seems to be plenty of people w	"There seems to be plenty of people who think Lisp is awesome.If so, then why hasn't it become ""mainstream""?"	hoodoof	15.145885	-3.9424741	comment	19.0	182.0	1504723245	-10.466928
29202021	Why Lisp?	Why Lisp?	susam	15.1548815	-3.9303758	story	20.0	271.0	1636738176	-10.463857
39665939	(How to Write a (Lisp) Interpreter (	(How to Write a (Lisp) Interpreter (In Python)) (2010)	selvan	15.099836	-3.9923563	story	20.0	96.0	1710146875	-10.139274
33605019	I've been hearing claims my entire p	"I've been hearing claims my entire programming career about how Lisp is supposedly ""superior"" to mainstream programming languages, but I've never seen a concise code example that actually demonstrates this.For instance, it's easy to demonstrate how Rust is superior to C: Just show a short piece of code where an array is returned from a function. In C, this will involve raw pointers and manual memory management with all associated safety and security pitfalls, whereas in Rust you just return a `Vec` and everything is taken care of. Simple, obvious, real-world superiority.How does such an example for Lisp look like? I'd love to see 10 lines of Lisp that show me something that:1. I can't easily do in, say, Rust.2. Actually matters in practice."	p-e-w	15.111446	-3.9824724	comment	20.0	134.0	1668483990	-10.456918
31029478	Fennel: A Practical Lisp	Fennel: A Practical Lisp	mattroelle	15.089606	-3.9898992	story	21.0	261.0	1649954722	-10.237688
28875051	Carp – A statically typed Lisp, with	Carp – A statically typed Lisp, without a GC, for real-time applications	fuzzythinker	15.106129	-3.9675124	story	21.0	259.0	1634280559	-10.308862
39142295	If Lisp is so great	If Lisp is so great	molteanu	15.145389	-3.941823	story	21.0	33.0	1706275132	-10.459396
22770023	I see a lot of Lisp stuff on HN : do	I see a lot of Lisp stuff on HN : do a lot of people use it ?	_threads	15.149159	-3.938339	comment	21.0	87.0	1585926774	-10.4994135
23163596	How Lisp Became God's Own Programmin	How Lisp Became God's Own Programming Language (2018)	Qaphqa	15.133907	-3.9523706	story	21.0	151.0	1589345642	-10.435176
33462454	Why Lisp?	Why Lisp?	signa11	15.15377	-3.9302504	story	21.0	152.0	1667538552	-10.468134
27307388	An Intuition for Lisp Syntax	An Intuition for Lisp Syntax	codetrotter	15.12145	-3.9751122	story	21.0	130.0	1622145033	-10.424234
20210227	Mezzano – An operating system writte	Mezzano – An operating system written in Common Lisp	pjmlp	15.107923	-3.9372058	story	22.0	396.0	1560839506	-10.242138
31178737	Tutorial Series to learn Common Lisp	Tutorial Series to learn Common Lisp quickly	oumua_don17	15.15199	-3.932552	story	22.0	279.0	1651060112	-10.452234
27045375	Hy: A dialect of Lisp that's embedde	Hy: A dialect of Lisp that's embedded in Python	lnyan	15.096252	-3.99259	story	22.0	166.0	1620180659	-10.1199
31547765	Ask HN: What does a developer need t	Ask HN: What does a developer need to know to build their own Lisp from scratch?	stolen_biscuit	15.138019	-3.9526968	story	23.0	81.0	1653816500	-10.4124565
36154531	What are the enduring innovations of	What are the enduring innovations of Lisp? (2022)	eslaught	15.15088	-3.9354658	story	23.0	180.0	1685640799	-10.489882
22087742	You don't understand why kids would 	"You don't understand why kids would want to learn programming. At least those who do, want to learn because they can build cool things they can show off to friends.It's not about whether a programming language is simple or not. (I actually think LISP is not as simple to understand as imperative languages, unlike most nerds think) It's about what you can build with it.For example, my first experience with programming was to build a game. If someone had tried to force-teach me LISP, it would have actually had opposite effect on me because then it would be no different from someone trying to force teach me some boring subject I have no interest in. The best way to teach something is to provide gratification. LISP is only gratifying to nerds who marvel at its ""elegance"", but it has no ecosyste"	cocktailpeanuts	15.147795	-3.9375901	comment	23.0	125.0	1579386222	10.891786
17478489	Learn C and Build Your Own Lisp (201	Learn C and Build Your Own Lisp (2014)	AlexeyBrin	15.134873	-3.9543595	story	23.0	603.0	1530971483	-10.38793
37022525	Are there any popular lisps without 	Are there any popular lisps without parentheses or at least with minimal parentheses?	leke	15.106113	-3.98655	comment	24.0	93.0	1691333248	-10.372238
28366292	Some thoughts about raising the prof	Some thoughts about raising the profile of Lisp	AndrewDucker	15.152466	-3.9336195	story	24.0	93.0	1630407783	-10.45978
18308721	Not Lisp again (2009)	Not Lisp again (2009)	kamaal	15.150627	-3.9337633	story	25.0	403.0	1540558425	-10.467163
29987501	OpenGOAL: Port of Jak and Daxter, wr	OpenGOAL: Port of Jak and Daxter, written in GOAL, a custom Lisp by Naughty Dog	msk-lywenn	15.137198	-3.9384177	story	25.0	381.0	1642547628	-10.372067
36887091	It's 2023, so of course I'm learning	It's 2023, so of course I'm learning Common Lisp	behnamoh	15.151268	-3.9306986	story	26.0	373.0	1690417306	-10.467088
37086301	The Bipolar Lisp Programmer (2007)	The Bipolar Lisp Programmer (2007)	sph	15.135524	-3.9470391	story	26.0	163.0	1691741633	-10.472671
32383525	Ask HN: What Is the Lisp “Enlightmen	Ask HN: What Is the Lisp “Enlightment”?	armchairguy	15.139438	-3.9528239	story	27.0	43.0	1659948831	-10.46417
15781883	Lisp in fewer than 200 lines of C	Lisp in fewer than 200 lines of C	jfo	15.12698	-3.9547343	story	27.0	443.0	1511716989	-10.316338
24892297	An Intuition for Lisp Syntax	An Intuition for Lisp Syntax	simonpure	15.120746	-3.9754584	story	28.0	551.0	1603679214	-10.380175
13979002	How to write Common Lisp in 2017 – a	How to write Common Lisp in 2017 – an initiation manual	macco	15.150561	-3.9345777	story	29.0	476.0	1490724334	-10.422214
39182721	A Tour of the Lisps	A Tour of the Lisps	medo-bear	15.152639	-3.9338667	story	29.0	358.0	1706562936	-10.46138
23164614	Janet: a lightweight, expressive and	Janet: a lightweight, expressive and modern Lisp	galfarragem	15.14201	-3.9371696	story	29.0	408.0	1589356930	-10.495962
14909786	Hy – A Lisp-flavored Python	Hy – A Lisp-flavored Python	tosh	15.055864	-4.0309815	story	29.0	625.0	1501675280	-10.034568
