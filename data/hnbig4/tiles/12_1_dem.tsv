id	label	hovertext	author	x	y	type	relevance	size	year	umap1d
33071614	--update-refs is great, resetting de	--update-refs is great, resetting dependent branches after rebasing has been a constant source of annoyance	jhrmnn	8.584564	-6.566194	comment	3.0	11.0	1664821568	-11.92638
33072369	It seems odd that `scalar` is not a 	It seems odd that `scalar` is not a sub-command of `git`. Does anybody know the reason behind this?	zimbatm	8.541286	-6.4608684	comment	3.0	13.0	1664824995	-11.85697
33074536	Anyone have experience with using Sc	Anyone have experience with using Scalar? How is it? How far can it scale?I'm also curious how they managed to drive it into the Git project. Presumably there can't be that many orgs out there for whom git repo size is a bottleneck. My rationale there is that the Linux kernel has thousands of contributors and vanilla Git scales ok there. Maybe I'm being naïve about something?	bjackman	8.584278	-6.470479	comment	3.0	10.0	1664835956	-11.844438
33084465	Well, and while they don't use git, 	Well, and while they don't use git, they do use Fossil. Their explanation for why doesn't make Fossil seem less modern.https://sqlite.org/whynotgit.html	tyingq	8.455588	-6.6008396	comment	3.0	17.0	1664907380	-11.967088
33108466	This might be obvious, but it's wort	This might be obvious, but it's worth checking out git commit --amend. Then you can be regularly committing, but to the same commit.	robertlagrant	8.593684	-6.5086393	comment	3.0	14.0	1665065918	-11.903888
33108812	I think it really depends on whose d	I think it really depends on whose doing the commits, I've mostly worked with people who wont commit things that don't work so you see a lot less commits than you would expect. I prefer commits to be iterative and I prefer to see that if possible. I rather see 100 commits across dozens of files per commit vs 1 commit for 500 files.	giancarlostoro	8.573021	-6.50548	comment	3.0	17.0	1665067324	-11.923847
33109270	Never understood the appeal of squas	Never understood the appeal of squash commits at merge time, assuming the PR contains atomic, logical commits (all bets are off if your team's PR process accepts ad hoc commits..). You lose the utility of git bisect, conventional commits, etc, and also have larger, noisier commits forming your history/documentation. Is there a benefit to squash commits other than allowing developers to forget about that as they work? I may be biased against squash commits as I have spent enough time diving through garbage commit history to figure out bugs/Chesterton's fence that good commits as documentation appeals to me.	throwaway_au_1	8.550894	-6.58715	comment	3.0	22.0	1665069236	-11.947102
33192547	Could someone give some examples on 	Could someone give some examples on their own domains where the MERGE command is a huge QOL improvement over what's currently available?I see a lot of people being so very happy in the comments, and, well, I've tried to think long and hard about how to apply it to my current domain but was a bit at a loss... Maybe some practical examples can help?	brunooliv	8.70582	-6.493531	comment	3.0	13.0	1665675790	-11.582132
33235227	Git as backend	Git as backend	samuelstros	8.557073	-6.4572163	story	3.0	11.0	1666021743	-11.860262
33244710	Ask HN: In trunk based development, 	Ask HN: In trunk based development, you do not use branches at all?	WolfOliver	8.622087	-6.52864	story	3.0	2.0	1666083767	-11.848318
33388180	Commit basically doesn't matter to m	Commit basically doesn't matter to me, I think in the terms of PR. I can make 100 commits or 1, it doesn't matter because when I merge I squash them into a single commit that encompasses everything. There are some exceptions, as splitting a large merge into several smaller merges can help a lot, for example adding a database column in a pr, then adding in a separate merge usage of that column.In terms of commits, the commit message should be a good summary of what is there. In terms of a PR there should be several things. One is obviously tests present. The next is a what, why and a how, which should be explanations of why you are doing it, what the purpose is, how you are doing. Finally I think there should be a descsription of how this should be tested manually.	ecshafer	8.596088	-6.5335603	comment	3.0	38.0	1667079433	-11.921057
33388614	This is why I follow a rebase-then-m	"This is why I follow a rebase-then-merge approach. The commit graph looks like this:   |
   *
   |\
   | *
   | |
   | *
   |/
   *
   |\
   | *
   |/
   |

Each PR is neatly delineated, and I can quickly follow things at coarse-grained level (follow only the left parents; there's even a `git log` flag for this) or at a fine-grained level.This isn't just pretty -- this has been actively helpful to me many, many times. I can `git bisect` into a merged PR to more precisely identify where an issue arose, and `git rebase` onto intermediate commits instead of jumping all the way to the end if I find a whole PR to be problematic to rebase past in one go."	Twisol	8.5833845	-6.5597196	comment	3.0	11.0	1667082702	-11.918824
33389203	This is really weird to me -- the me	This is really weird to me -- the merge commits are the only ones without any information, because they are all autogenerated. The only time I ever look at a merge commit is when someone screwed up a merge conflict. I have written commands to filter out merge commits before.	Noumenon72	8.597437	-6.5653453	comment	3.0	11.0	1667087894	-11.926951
33421387	Git commit messages are useless	Git commit messages are useless	troutster	8.580073	-6.5207677	story	3.0	26.0	1667311426	-11.896779
26479461	My understanding is that neither Git	My understanding is that neither Git nor Mercurial can do this well out of the box, and FB and Google both have their own extensions to Mercurial to make this possible (because even though Mercurial is often slower than Git, it’s extensible)e.g. https://facebook.github.io/watchman/ - used as part of Facebook’s Mercurial solution, I think.	klodolph	8.521008	-6.5014944	comment	3.0	12.0	1615913799	-11.9188385
26488039	it should be noted that git (the bin	"it should be noted that git (the binary) is also in the process of deprecating `master`.This is the message I get on my machine when running git init:  hint: Using 'master' as the name for the initial branch. This default branch name
  hint: is subject to change. To configure the initial branch name to use in all
  hint: of your new repositories, which will suppress this warning, call:
  hint: 
  hint:  git config --global init.defaultBranch <name>
  hint: 
  hint: Names commonly chosen instead of 'master' are 'main', 'trunk' and
  hint: 'development'. The just-created branch can be renamed via this command:
  hint: 
  hint:  git branch -m <name>
  Initialized empty Git repository in /tmp/test"	dijit	8.5090475	-6.53224	comment	3.0	16.0	1615970449	-11.746863
26490987	How exactly did it break your workfl	How exactly did it break your workflow? The change only affects new repositories and doesn't prevent you from creating a master branch on those new repositories. You're even able to set any branch name as default on a user, org, or enterprise level.	ratamattat	8.506509	-6.5333586	comment	3.0	14.0	1615988095	-11.755096
26494968	"Git's usage is clearly more like ""go"	"Git's usage is clearly more like ""golden master"" in the recording sense -- the original from which other copies are made.Compare to other uses in technology that are far more directly related to control, and far less likely to change, e.g. https://en.wikipedia.org/wiki/Serial_Peripheral_Interface"	nitrogen	8.550476	-6.4655995	comment	3.0	14.0	1616005308	-11.844066
26502184	For this issue and so many others, e	For this issue and so many others, everyone should just get comfortable with interactive rebase. Crutches like this trap you in this space of never really learning git.  And that's a tragedy. All because you're impatient?  Afraid?	hashkb	8.567965	-6.567131	comment	3.0	26.0	1616072338	-11.870346
26502462	It's possible the other reason is tr	It's possible the other reason is trying to manipulate git history too frequently. Keep in mind this comes from a prolific git history abuser and rebaser... if hacking on a branch, a trail of messy commits is fine, it's your work in progress, it's also useful if you messed up otherwise you are forced to use reflog. Rebase when you are at the final stage of tidying things up and squashing commits down into a legible history, not on every single amendment... for this style of history rewriting rebase is perfect because you have the full power to rearrange rewrite and squash commits.	tomxor	8.574994	-6.551799	comment	3.0	10.0	1616074237	-11.891707
26502487	Could you share what your workflow w	Could you share what your workflow would be? I’m assuming you put the point on the line you want to fix, then use Magit to start a rebase at the last commit that changed that line, then apply your changes, then continue?I’m a casual Magit user, so learning from other users would be very beneficial.	shepmaster	8.582187	-6.546068	comment	3.0	17.0	1616074406	-11.931494
26567969	An overlooked vector is old commits.	An overlooked vector is old commits. It’s often times better to squash all commits before taking a project open source, which is a real shame for obvious reasons.Commit histories can spill a lot of secrets that are easy to overlook.	ed25519FUUU	8.586468	-6.455429	comment	3.0	12.0	1616597610	-11.875653
26579922	I avoid it because of complete lack 	"I avoid it because of complete lack of commit amendment tools.It seems like quarter of the time I make a commit I mess up either a commit message or a file list, and have to ""git amend"". I have no idea how the sqlite devs live without the feature, they must be much more careful programmers than I am."	theamk	8.635331	-6.5028815	comment	3.0	11.0	1616678585	9.879106
26609025	The final example `yank -- xsel -b` 	"The final example `yank -- xsel -b` is probably the most directly useful for me, but it still doesn't solve the following problem which irritates me to all hell:  $ git push
   fatal: The current branch new has no upstream branch.
   To push the current branch and set the remote as upstream, use

    git push --set-upstream origin new


Is there any sane way to copy the perfectly formatted `git push -u` command shown above without resorting to the following eval, which doesn't alias nicely?  $(git push 2>&1 | grep git)"	michelledepeil	8.545043	-6.487168	comment	3.0	10.0	1616923869	-11.846791
26622903	This article talks about doing fixup	"This article talks about doing fixup changes while working on the ""plan"".The utility offered though doesn't address the fact that now non-related changes are still bundled together.We've just managed to write the git commit message earlier?...."	setheron	8.58784	-6.5183	comment	3.0	11.0	1617030661	-11.860421
26623187	> you're liberally using branches, r	> you're liberally using branches, right? Branches are cheap in GitBranches may be cheap in Git, but they're expensive in typical modern software eng. process. For every branch, a PR must be opened, code must be reviewed, full test suite must be ran, the testers must ok that the change does not require extending the test suite, and only finally after the whole ordeal we're ok to merge. That's why I prefer my branches big and meaty.	burntoutfire	8.606024	-6.514143	comment	3.0	10.0	1617031665	-11.907432
26630340	Understand where author is coming fr	Understand where author is coming from - but doesn't squash-n-merge (newish github feature) solve the issue of needing to rebase and the issue of having too many merge commits?Squash-n-merge has nice property of removing unnecessary local information that probably doesn't matter at a meta level (commits are nice when reviewing PR, doesn't matter much later)	properdine	8.556048	-6.5878944	comment	3.0	48.0	1617067223	-11.9415455
26630358	Squashing commits into one mega-comm	Squashing commits into one mega-commit isn't great for future investigations of the commit history (code review, bisects etc). It is much better to create separate logical commits, rebase them and pull in the result, either as a branch fast-forward merge, or with a merge commit where appropriate.	pabs3	8.578913	-6.562169	comment	3.0	37.0	1617067497	-11.9451
26642120	So the big problem with Git and SHA1	So the big problem with Git and SHA1 is that in many cases you are giving full control to an untrusted third party over the sha1 hash of something. For example, if you merge a binary file, it'd be quite easy for them to generate two different versions of the same file, with the same SHA1 digest, and then use the second version to cause problems in the future. You may also be able to modify a text file in the same way without getting noticed in review (I'm not up to speed on how advanced sha1 collision techniques are now).Similarly, the git commits you merge themselves could have that done - the actual git commit serialization gives you a fair bit of ability to append stuff to it that isn't shown in the UI. That wouldn't affect the signed git commits. But it's still dubious to have the abil	petertodd	8.647317	-6.514559	comment	3.0	26.0	1617149811	7.1749334
26742101	Git has over-complicated source cont	Git has over-complicated source control for the majority of developers. Things were much simpler with svn.	bluedino	8.576737	-6.4684224	comment	3.0	10.0	1617906609	-11.879858
26742113	Agreed. Git should be treated as a d	Agreed. Git should be treated as a deep skill, as important to practice and train with as unit testing and regular expressions.Think of your git history as a product and art form in itself. If you don’t enjoy writing your commit history, readers will not enjoy reading it.On a tactical level, I highly recommend buying Sublime Merge 2.	breck	8.572826	-6.53718	comment	3.0	13.0	1617906663	-11.901932
26742295	You can still think of them as snaps	"You can still think of them as snapshots. Git just does compression on the entire folder of snapshots, including de-duplication of data that doesn't change between snapshots.In fact, when I teach git to students, I don't even bother with the trees/blobs, which in my view are just an implementation detail. I just tell them to think of git zipping up their working directory together with some metadata (commit message, reference to parents), and putting that zip file into its own ""compressed"" storage inside the .git directory. That seems to be sufficient for a good mental model of how to work with git (independently of the git's somewhat baroque command line interface, which just takes getting used to)"	goerz	8.574651	-6.501448	comment	3.0	23.0	1617907646	-11.8509
26742505	In practice, rebasing increases conf	In practice, rebasing increases conflicts, requires teams to time their merges, and obfuscates the history of the project.I never understood why people think this is a good pattern.	Solvitieg	8.577291	-6.5676126	comment	3.0	26.0	1617908876	9.454976
26749055	The merges-straight-to-master give m	The merges-straight-to-master give me the willies.https://botsin.space/@complainingaboutmastercommits	alrs	8.674904	-6.484106	comment	3.0	11.0	1617967105	9.224766
26787781	In the 'real' Git, one of the functi	In the 'real' Git, one of the functions I use frequently is `git checkout -- .`, which discards any unstaged changes. Looking at Gitlet's implementation, it wouldn't handle that well as `checkout` can only take a ref.So I guess I'm wondering what the real `git checkout -- .` actually does behind the scenes?	momothereal	8.570004	-6.530449	comment	3.0	21.0	1618283911	-11.895532
26788059	This is correct, ‘git restore’ is th	This is correct, ‘git restore’ is the way to do this in the current version of git. ‘checkout —-‘ still works, but the ‘help’ text in ‘git status’ now recommends using ‘restore’.Not only is it more semantic, it reduces the complexity of ‘git checkout’ which is a common complaint.Really, It doesn’t make much sense to tack on some random ’--‘ flag on ‘checkout’ for that functionality. ‘restore’ is clear and describes what it does.	40four	8.523231	-6.5867	comment	3.0	16.0	1618287210	-11.907851
26803266	It's got a big impact, but mercurial	It's got a big impact, but mercurial was released pretty much the same month as git. Git got more popular, likely helped by Linus already being known. If we didn't get git, we'd use something else without issues. And you can use something else right now. Linux on the other hand just doesn't have an alternative equal in features.	viraptor	8.526768	-6.527201	comment	3.0	13.0	1618378254	-11.952849
37619622	"you could always do git commit -m """""	"you could always do git commit -m """" --allow-empty"	no_wizard	8.58225	-6.504862	comment	3.0	10.0	1695430029	10.689421
37622653	Wouldn’t it be great if my car also 	Wouldn’t it be great if my car also brewed coffee?I drink coffee every day on the way to work.I’m always in a hurry. It would be convenient to just build that in.I always drink coffee while driving, I may as well just build it in.Cut to a month later because my car won’t start because I’m out of coffee grounds.This is how fossil seems to me.I probably have hundreds of repos with just versioned files. That’s it. I don’t want an issue tracker and chat and everything else in my git.And when I do, I can trivially push my repo to GitHub or gitlab or sr.ht or whatever.Comically, I’d probably use the fossil service if it supported git.Anyone else remember when Google Code only supported mercurial? And they talked about how much better mercurial was than git. And they were right. And no one cared.	prepend	8.505889	-6.49763	comment	3.0	26.0	1695471866	8.795706
37680769	There are projects that automaticall	There are projects that automatically merge dependabot PRs...	sdflhasjd	8.651798	-6.4481983	comment	3.0	11.0	1695846366	-11.802558
37799726	From my teaching experience it could	From my teaching experience it could be a fear to do something wrong. I've come from SVN and ClearCase where doing wrong was quite a trivial thing. And Git relaxed me a lot. Knowing only push/pull makes actual changes and you have reflog to revert any possible mess is a big relief.	bvrmn	8.563405	-6.507208	comment	3.0	10.0	1696663398	-11.889521
37799952	"I've shown coworkers ""git log --grap"	"I've shown coworkers ""git log --graph --oneline --decorate --all -50"" many times and always have them start with it (and even use it throughout stepping them through something) to try and show that structure as we go.  I think it helps a bit, but their IDEs go to great lengths to keep them out of the command line, so they're never completely sure what happened when it does something odd to their repo."	Izkata	8.574301	-6.488403	comment	3.0	11.0	1696666050	8.617347
37799826	My big issue with Git is the way it 	"My big issue with Git is the way it handles Merges.It throws up this dialog saying ""there are conflicts"", and by the time you see this, it has already monched a bunch of files in your local version and now the only way out is through.  You need to drop everything and fix all this stuff right now before you can proceed.  Even if it's last thing on Friday night and you'd rather just go home and try again on Monday.If there was just an ""Abort"" button that stopped trying to push or commit or whatever and just put things back the way they were before, that would take all the worry out of it.Because usually it would have been easy to avoid the conflict if only you knew it was coming before Git f'd your whole project."	jasonkester	8.589749	-6.5324464	comment	3.0	18.0	1696664486	-11.871192
37809756	Why on earth is your state in git? T	Why on earth is your state in git? The tool has built-in functionality to handle just these kinds of workflows. This reads a lot like hitting your thumb with the hammer and blaming hammers.	chrisfowles	8.575225	-6.4612107	comment	3.0	15.0	1696766835	-11.867082
37812018	I wish git would stash changes when 	I wish git would stash changes when I checkout uncommitted code	danhab99	8.57223	-6.5276976	comment	3.0	11.0	1696783261	9.43685
37812156	Scrap the thing entirely and replace	"Scrap the thing entirely and replace it with something that uses intuitive metaphors like ""save"", ""load"", ""undo"", ""go back to old version"", ""update my work with work from colleague"", ""update the official state with my work"" and others. Folders instead of branches. Be 100% language-aware; any merge result has to build obviously.If this rejects actions and limits possibilities that Git provides, so be it."	UweSchmidt	8.576419	-6.521865	comment	3.0	15.0	1696783945	-11.901673
37828733	Wow, if you exclude lines changed in	Wow, if you exclude lines changed in the commit due to indenting changing, there are only five new lines of code for this change!	jh00ker	8.592943	-6.5166736	comment	3.0	11.0	1696914914	-11.889102
37847399	Ask HN: Git Training Course Recommen	Ask HN: Git Training Course Recommendations?	dmonitor	8.537769	-6.4810643	story	3.0	4.0	1697044933	-11.911212
37855751	sr.ht does thatI don’t find it very 	sr.ht does thatI don’t find it very user friendly (well, at all), but if you want a git forge that does that, you can use it.	yankput	8.553751	-6.445301	comment	3.0	15.0	1697109727	-11.890602
37888915	> git reset --hard HEAD~2Stupid comp	> git reset --hard HEAD~2Stupid computer.  That does 2 commits.> git reflog expire --expire-unreachable=nowFor the love of god why?  The reflog is there to save your bacon.  I guess because they are still reachable from the remote's reference so they won't completely vanish just yet.> git push -fNow they're gone unless you can find the hashes somewhere else.  The objects might still be present.> I apologize that two of your commits are now goneIs that you or still GPT?	Am4TIfIsER0ppos	8.566449	-6.531231	comment	3.0	13.0	1697369864	-11.900878
14712542	Git wrappers are interesting things.	Git wrappers are interesting things. I know a lot of people dislike them in concept.. but strangely enough, I like them in concept. I'm far from a git expert, frankly I'm just barely literate, but I firmly believe there must be a more simplified UX for Git.Again, never to prevent normal usage, but to focus on educating the various states of git, and really trying to make the commands very obvious for normal use cases.I see so many of these.. I'm wondering if it's sort of a rite of passage. Maybe I should write my own? I'm sure I'd become more proficient at Git if I did.edit: Since writing this, I think I decided on writing my own wrapper. Specifically, focused on a very small subset of straight forward commands with exceptionally obvious wording and step by step education.I really like the	notheguyouthink	8.547304	-6.5029225	comment	3.0	13.0	1499364913	-11.916165
14733610	Decided to google about this...Found	Decided to google about this...Found this article: https://www.pcworld.idg.com.au/article/129776/after_controve...I wonder, how many people reading that article would predict the rise of stuff like GitHub and GitLab and the success of Git to the point of crushing CVS and making SVN decline in popularity?	speeder	8.591857	-6.458814	comment	3.0	15.0	1499664693	-11.871906
14733668	It's quite frustrating seeing people	It's quite frustrating seeing people complain about Git usability like it's some broadly accepted and objectively bad thing. As frivolous as anecdotes are, I took to Git very smoothly and I found it to operate in a very obvious and explicit fashion, particularly once I'd shifted my mental model from what I was using at the time (primarily SVN.)Git is a very powerful, flexible, reliable and efficient tool. I'd be over the moon if someone wrote an init system holding similar values.	beefsack	8.545184	-6.485246	comment	3.0	22.0	1499665804	-11.887748
14740557	> The thing we do differently from m	> The thing we do differently from most is that we run the full test suite against every patch, as if it were merged to master, before committing it into the master branch, whereas most CI setups test after committing, or if they do run tests against every PR, they do so before merging, leaving open the possibility of regressions introduced during the merge.Hm, Travis CI on GitHub runs tests on a pull request before the merge. Is what they're doing really that unusual?	wfunction	8.70924	-6.5317383	comment	3.0	14.0	1499730380	0.2227918
14820738	I gave Magit a try on Windows, and i	I gave Magit a try on Windows, and it failed miserably at finding git automagically. With no configurable option and no documented or at least easily hackable entry point, Magit was my quickest Emacs package removal.	HelloNurse	8.581527	-6.4716806	comment	3.0	12.0	1500646946	-11.7760315
14837627	I love git, but the learning curve s	I love git, but the learning curve seems very high for the unititiated. Git seems to work best as the assembly language of source control for a lot of people. It's okay as long as you put a nice GUI on top of it.Even though I'm pretty comfortable with git thanks to attending  a two day workshop conducted by a guy from Github, I still like using tortoise git.	scarface74	8.55534	-6.4874887	comment	3.0	37.0	1500896790	-11.851442
14924532	The feature I'd be most interested i	The feature I'd be most interested in here is the integration with git, but I don't see an example on the site that demonstrates that. If the author is reading this, could you please add one? (Or maybe point it out, if I'm just missing it?)	swift	8.566642	-6.47322	comment	3.0	10.0	1501799246	-11.858685
14967546	I think a lot of people don't bother	I think a lot of people don't bother with rebasing because they either don't know how to do it, or they are scared of the idea of a version control system not explicitly saying what they've done to accomplish the latest version of their code.Once you get even a small understanding of it, there are plenty of places you can use it. For example, in the past month I've used it to:1. Rewrite the history on a coding test I was given for an interview. The recruiter was oddly specific about how long to spend on it, and when it had to be in by, even though they said no one would look at it for another week. I worked on it throughout the extra week, and modified the history to make it look like I had done it in the allotted time-slot.2. Rewrite history in feature branches where it doesn't accurately	EnderMB	8.590307	-6.557133	comment	3.0	11.0	1502278704	-11.903431
14967414	I think there are two perfectly acce	I think there are two perfectly acceptable schools of thought.One says that the history should be preserved exactly, because its important we keep a record of exactly what happened.The second says that its ok to rewrite history a little if that makes it more understandable.I think you would put yourself in the first, and that's ok. I would put myself in the second because at the end of the day I value understanding over precision in git histories. I'm of the opinion that one cares about the commit I made to correct a missing semicolon.	splike	8.573326	-6.543483	comment	3.0	10.0	1502276940	-11.897735
15044431	I never trust anything but the comma	I never trust anything but the commandline when it comes to git. Then I know full and well what I'm doing regardless of the editor. When there are too many icons and buttons to click I don't like to have to remember what they all mean, or how well they map to the underlying core git concepts.	ogrim	8.562786	-6.50785	comment	3.0	10.0	1503043973	-11.882234
15050173	> but he hadn't committed for 3 mont	> but he hadn't committed for 3 monthsI get nervous when I haven't commited for 2-3 days. Since I don't want to commit broken code, I make a patch and send it somewhere for peace of mind. In addition to that I have an editor add-on that saves a copy every single time I save a file. One time it allowed me to recover the work of several days.You don't need backups until you do. Some people learn the hard way.	DiThi	8.590746	-6.4830256	comment	3.0	15.0	1503094438	-11.927709
12553536	Actually the only thing that keeps m	Actually the only thing that keeps me from switching back to ST3 is Atoms first class support for `.gitignore` and excluding files from the quick open menu.I know there's a package that claims to update the file ignore pattern to match the open project, but it really doesn't work well at all.	wkirby	8.6322	-6.4740148	comment	3.0	12.0	1474505981	-11.819456
12553657	My complaint is actually not with ST	My complaint is actually not with ST3, but with Package Control. I have to maintain my user preferences in git because PC rewrites them and resets the theme every time it updates. (I run the Material Design theme)	slowmovintarget	8.573911	-6.472173	comment	3.0	12.0	1474507702	-11.875479
12582312	Yay now it's only missing rebase the	Yay now it's only missing rebase then merge with --no-ff to be useful to me!	mfontani	8.595571	-6.5616226	comment	3.0	26.0	1474901680	9.296937
12582493	After being initially skeptical I wa	"After being initially skeptical I was convinced by a colleague that this is a good model.The merge commit acts as a kind of ""pushlog""; it tells you what actually landed together as a single unit. It probably also tells you what passed CI; although many projects state that you shouldn't have individual commits that don't pass CI it's rare that this is enforced below the level of the PR. That should be good for bisection. Because the commits are always rebased onto master (and of course you never allow merge commits other than from code being integrated into master) your history is relatively clean, you don't get multiple overlapping branches, but something like  M1 ------- M2 -------- M3
   \ B1 - B2 / \ C1 - C2 /

Because the merges are --ff-only you don't get the confusing situation where"	jgraham	8.587419	-6.557402	comment	3.0	12.0	1474902879	-11.945928
12582558	> so I don't have to keep going back	> so I don't have to keep going back to my own terminal after my PR is approved.Why would you have to go back to your terminal after the PR is approved? In either case, the merges are done by the admin..	mkagenius	8.605321	-6.5272083	comment	3.0	10.0	1474903305	-11.864588
12582575	I, too used to wonder about this. Bu	I, too used to wonder about this. But in git merge commits basically break bisect and revert. You can't tell git to only consider feature merges for it's bisection (which is normally what you want), nor will revert on a merge commit behave the way people expect. And not everyone enjoys reading long essays about to work around these problems.	patrec	8.629475	-6.554901	comment	3.0	18.0	1474903419	-11.868431
12615358	Mercurial gets around this issue (wi	"Mercurial gets around this issue (without having a staging area) by providing an interface for interactively committing files or subsets of files via ""hg commit --interactive"""	ngoldbaum	8.580053	-6.5494175	comment	3.0	16.0	1475270630	-11.919912
12615529	Someone is from an industrial enviro	"Someone is from an industrial environment. Work in process, in the form of partially complete goods, is a curse of badly organized factories.  It's more visible in a factory environment; you have to walk around the stuff on the shop floor. It also costs real money - you've bought the parts, but can't sell the product yet.One form of limiting work in progress is this: if you want reliable software, insist that no new features go in until all the reported bugs have been fixed.  A weaker form of this is to have a master branch, which gets bug fixes only, and a development branch, into which new features go.  Merging can happen only when there are no open issues in the master branch.This is the opposite of ""shit early, shit often"" development."	Animats	8.629651	-6.5217156	comment	3.0	13.0	1475272846	-11.874887
12615945	You find it hard to create a list?  	"You find it hard to create a list?  Here's an example of making a staging file:    echo file1 > staging                       # e.g. git add file1
    echo dir2/file2 >> staging                 # e.g. git add dir2/file2
    echo dir3/file1 >> staging
    echo dir3/file5 >> staging
    echo dir4/dir9/dir394/file384 >> staging

And committing the file:    eval ""$(echo gl commit -o `cat staging`)""  # e.g. git commit"	toomim	8.656451	-6.5804505	comment	3.0	12.0	1475280258	-11.918411
12621940	The approach of this experiment is i	"The approach of this experiment is interesting. But, as an experienced git user, I think it does not include easy access to very powerful and easy-to-learn features of git like ""git * -p"" which bring some interactivity in git commands."	alexduros	8.555104	-6.488635	comment	3.0	10.0	1475408868	-11.882433
12622292	I use git all the time and prefer it	I use git all the time and prefer it for all types of workflow as a VCS, but this idea that git is perfect and it's your own fault for not learning it properly is ridiculous.UX/UI in programs is important. I believe that git has one of the worst, most inconsistent UX's of all time. You can see this by the fractured commands.Quick examples:'git reset' vs. 'git revert' and sometime 'git checkout''git checkout' vs. 'git clone' vs. 'git pull' vs. 'git fetch' vs. 'git cherrypick''git rebase' vs. 'git merge' vs. 'git merge --squash'Each one of these performs actions on a repo giving you immense power and control to do specific actions, but it's horrible UX. It's very easy to end up in a detached HEAD state, or have accidentally rebased a repo so it's out of alignment with a remote, leaving you w	bluejekyll	8.567008	-6.52787	comment	3.0	19.0	1475416041	-11.8938265
12622705	Git needs the parent pointer equival	"Git needs the parent pointer equivalent of NIL.Whenever I start a blank new repo nowadays, I do a  git commit --allow-empty -m ""NIL""

See, many git operations require a parent reference! For instance if you want to interactively rebase the top commit, it's actually ""git rebase -i HEAD^"": rebase back to (but excluding) HEAD's parent. The equivalent ""git rebase -i HEAD~1"" means the same thing: that ~1 actually spans two commits: it refers to the parent, but since the parent is the excluded delimiting endpoint you can think of that 1 as being the number of commits being rewritten.If all you have is a single commit with no parent, you cannot rebase it.If you have NIL there, it takes the HEAD^ reference; no problem.Essentially, git is a list manipulation system whose use cases fail when operati"	kazinator	8.561638	-6.5622673	comment	3.0	15.0	1475421160	-11.915693
12622706	> With git, I'm forced to either mak	"> With git, I'm forced to either make an extraneous commit...You only need to commit or stash if there are conflicts, and many time there aren't, so you can first try to switch branches without stashing.> The only feature I noticed missing, is the ability to stash changes. I use this most often to move changes from one branch to another branchI started a big ol thread on stash yesterday, but there are a bunch of safer alternatives to stash. You never have to clutter history, you can always move things around and still keep it clean. Problem with stash is it circumvents git's normal systems, so it's a little dangerous (which the stash man page mentions.)https://news.ycombinator.com/item?id=12612630If there are conflicts, you could do this instead:  $ git checkout -b work
  $ git commit -am "	dahart	8.568003	-6.549251	comment	3.0	24.0	1475421163	9.507144
12623237	I don't understand this rationale. A	"I don't understand this rationale. Are you saying that Git's UI is perfect, and there's no improving it? It's not, and gitless does, indeed, improve on it.We should be celebrating better UIs over important tools, not saying ""I made great effort to learn it, therefore learning it with less effort is inferior"". No. If it does everything Git does, but more easily, it is strictly superior."	StavrosK	8.545103	-6.494809	comment	3.0	16.0	1475427754	-11.964466
12623473	> Git is, like many professional too	"> Git is, like many professional tools, something you simply got to learn.No. Why do people think ""professional"" has to mean ""poorly designed""?But then, the rest of your post seems to miss the point of this thing entirely. You go on to say that you basically only need 10 commands...which is pretty much the insight that lead to Gitless in the first place."	tree_of_item	8.54353	-6.4967747	comment	3.0	31.0	1475431119	-11.976525
12623823	"""Professional"" doesn't mean ""Poorly "	"""Professional"" doesn't mean ""Poorly designed"".  It means ""designed so that people with lots of domain knowledge and experience with the tool find that it never gets in their way.""In that sense, git is a professional tool.  If you know everything about it, it doesn't get in your way.  The problem is when you don't know everything about it.."	chowells	8.536571	-6.486504	comment	3.0	12.0	1475436543	-11.888993
12648440	Just wildly speculating here (with s	Just wildly speculating here (with some wishful thinking thrown in): maybe the intent is to indirectly encourage non-technical audiences to use git-based, public version control for authoring public and frequently revised documents.For instance: imagine if federal legislation, and amendments to federal legislation, were published in this manner. You could examine diffs to see how passed (or proposed) amendments altered (or will alter) the law. You could even have a 'git blame' sort of feature that let you to see which members of congress voted for or against particular amendments. It would definitely aid political transparency, and make it easier for the public to participate in the legislative process.Eh, I guess that's mostly my wishful thinking...	spangry	8.564959	-6.4440885	comment	3.0	10.0	1475705748	-11.875319
12657269	Git was made in, what, 2005. We knew	"Git was made in, what, 2005. We knew about discoverability then. We knew about accessibility then. We knew about user testing, about UX. Git makes use of zero of those concepts. In fact, it seems to be actively hostile towards its users^.We also had source control packages that were not only easier to use, but had more features: TFS let you put a lock on files that don't merge well, for example. Both TFS and Subversion allowed you to check-out only small portions of the repository.Git has some nice things. It's generally fast, for example. It allows developers to work offline. But when the developer community apparently unilaterally chose to adopt it, we threw away a lot of good stuff, let's not forget that.I'd also question that Git is ""universally respected"". I've worked with a great man"	blakeyrat	8.543011	-6.4658265	comment	3.0	17.0	1475799983	-11.895069
12673745	> with ungodly marketingWas the the 	> with ungodly marketingWas the the marketing of git basically due to the fact that Linus created it?	yitchelle	8.588255	-6.451216	comment	3.0	11.0	1476050323	-11.90722
12673644	Fossil is really cool. It never real	Fossil is really cool. It never really caught on, which is kind of a shame.OTOH, it's competing with git, a very well-designed piece of software with ungodly marketing (and a terrible UI, and it was so well designed because McVoy's various projects had already made many of the mistakes that Git didn't, although it avoided some of Git's mistakes, so Linus had something to work off of. But that's not the point).	qwertyuiop924	8.496492	-6.5307746	comment	3.0	34.0	1476049175	-11.951954
12674056	I like a lot about Fossil and moved 	I like a lot about Fossil and moved many projects into it for a while. What I eventually couldn't tolerate was the lack of rebase (and history rewriting in general). There are extensive debates going back years on the Fossil mailing list about the topic, but ultimately the authors were pretty firm that rebase/rewriting history is bad and they didn't want to support it.My local workflow uses commit rewriting a lot in order to keep a useful history. I commit like crazy and then squash/reorder/rebase to make a nice logical history (http://gitup.co is awesome for this on OSX, BTW). I couldn't do this, at least at the time, with Fossil, and ended up with piles of not-very-useful commits.	LVB	8.512344	-6.562708	comment	3.0	13.0	1476054393	9.509697
12716309	"If by ""Git for data"" you mean accumu"	"If by ""Git for data"" you mean accumulate-only (or append-only), immutable data stores... There are already many existing solutions. It's always good to see alternatives, though!"	aeharding	8.581537	-6.465045	comment	3.0	17.0	1476578922	-11.891618
12736061	The biggest technical difference is 	The biggest technical difference is the mostly immutable history, which is a feature or a drawback depending on who you talk to.More subjectively, most people I've chatted to about it seem to find Mercurial's interface much easier to grok / pick up as a new user than Git's (which is somewhat notorious for its quirks).There are other differences, but these stand out to me. That said, I use Git because adoption + community (and my experience with hg-git has been less successful than some... though it's been a while since I gave it a spin)	lucideer	8.518047	-6.535939	comment	3.0	23.0	1476808068	-11.936609
12736367	1) The .git directory doesn't play n	1) The .git directory doesn't play nicely with mono-repos. Since all files are just hashed files that live in the .git dir, knowing which files in there are part of a subtree is hard.  On the other side, Mercurial .hg dir uses a tree structure to track files, so you can do things like NarrowHG[0].2) As well, Git has multiple client implementation (like git, egit, jgit, etc...). Adding new features is a bit more complicated as all the implementations need to add them before they can be more widely used. Mercurial has one implementation that everyone uses. So new features are easier to add.3) The .git structure is simple, which is great, but it's become the API for git in a way.  While mercurial explicitly says you should never rely on the structure of the .hg directory. If you want to inter	kyrra	8.506777	-6.5456905	comment	3.0	11.0	1476809606	-11.932463
12738086	That was a busy meeting and the deve	That was a busy meeting and the developer mailing list is very busy. It's great to see continued investment from so many interested parties.Judging by the notes in the wiki [1], however, the purveyors of my preferred server, Kiln, are not so engaged lately:> Available hosting solutions: Bitbucket, Kallithea (self-hosted), Kiln (still exists?)I believe it is maintained and even if not maintained would continue to work for ages, but I suspect we will be held to 3.x for a while.[1]: https://www.mercurial-scm.org/wiki/4.0sprint	shoover	8.550729	-6.4607654	comment	3.0	15.0	1476820590	-11.933998
12772678	> npm's default git branch is no lon	> npm's default git branch is no longer `master`. We'll be using `latest` from now on.Is there any reason to do this?	Etheryte	8.510306	-6.5287485	comment	3.0	14.0	1477213702	-11.754298
12786742	Why would I commit my breaking, work	Why would I commit my breaking, work in progress experiments to a branch? Isn't that what stashes are for?	petre	8.570709	-6.551414	comment	3.0	10.0	1477392150	-11.904221
12804096	If git exposed a consistent, underst	If git exposed a consistent, understandable interface to its data model you'd have a point.Mercurial exposes a much more consistent, much more understandable interface to a very-similar-to-git data model, so it's not like this is impossible.So it'd be really nice if people could be allowed to point out the shortcomings of git's command-line interface without other people implying their complaints must be rooted in being too dumb and/or too lazy to understand git.	ubernostrum	8.520795	-6.565031	comment	3.0	14.0	1477566197	-11.93886
12804309	OT (or not) -Of 20 most popular Qs o	OT (or not) -Of 20 most popular Qs on SO, 7 now ask how to do trivial operations in git.http://data.stackexchange.com/stackoverflow/query/36656/most...Take it or live it, git has facts-based proven track record of ui wtfness.	avip	8.554166	-6.46974	comment	3.0	11.0	1477568948	-11.871006
12829528	I love that they try to make it asse	I love that they try to make it assessible. But I disagree with that it would be an acceptable goal in git just to understand a subset of it. You need to understand nearly everything, even the internals. Only then it can really become useful to you.The mistake the community made is putting git on the throne of version control. It's not. It's a tool for experts that can do a lot for you if you know how to use it. But to achieve that it pays the price of not really being assessible.Now that it's in its position, the best thing you can do is to learn it. There is the git book. Read it. Annoying, I know. But that's the gameplan. Not doing it is just dragging out the inevitable.	erikb	8.546623	-6.496472	comment	3.0	13.0	1477832170	-11.901894
27494971	The git plumbing and plumbing comman	The git plumbing and plumbing commands are straightforward and easy enough to understand once you read about them a bit (I recommend the free Pro Git book online).The original git porcelain commands - git branch, git reset, git pull - are execrable. They’re filled with implementation details (index/cache vs staging), weird and suggestive syntax that seems like it should be extensible and widely applicable but isn’t (localbranch:remotebranch), and nuclear-powered self-destruct functionality hidden amongst playthings (git reset vs git reset —hard).	CountSessine	8.557509	-6.518778	comment	3.0	13.0	1623608730	-11.984248
27532752	The reordering feature looks exactly	The reordering feature looks exactly like how I'd want it. It's a feature I haven't found in any other client. I've stuck with gitk until now, but this might just make me take a look at GitHub Desktop.	satya71	8.633181	-6.462575	comment	3.0	11.0	1623873274	7.7983785
27539793	Even with git, that is not the way i	Even with git, that is not the way it would happen. The people working on the bills are smarter than that.It is trivial to commit someone else’s patch as your own and without any history if you want to write the script.  Just not that hard.	compiler-guy	8.591262	-6.445075	comment	3.0	13.0	1623939289	-11.870588
27578219	Because a message is mandatory to be	Because a message is mandatory to be able to make a commit.	lorlou	8.5887375	-6.5196347	comment	3.0	12.0	1624275526	-11.901987
27580314	For some reason people love to defen	For some reason people love to defend the obscure and strange and oftentimes objectively terrible Git CLI. I’ve found Mercurial much more straightforward for my (mundane and boring but prevalent) use cases, and I lament that it isn’t more widely used.	sebmellen	8.512173	-6.540168	comment	3.0	31.0	1624290408	-11.927402
27580502	> git is already the easiest to unde	"> git is already the easiest to understand of any VCS that I've usedBreaks down in uproarious laughter.One of the worst offenses git is its use of multiple different jargon terms for the same concept; indeed, it's the only VCS I've used where reading help leaves me less sure than when I started if it does what I want it to do.If I accidentally leave my system in a weird state (say, I'm in the middle of a git rebase and I forgot to git rebase --continue), and I start doing some regular git commits, the resulting mistakes are, while possible to recover from, difficult to do so unless you know git's internals. I have to use the ""what's that git command to list the commits I just dropped on the floor by accident?"" with surprising frequency."	jcranmer	8.558581	-6.513359	comment	3.0	10.0	1624291528	-11.930805
27580588	> And if I push without first pullin	"> And if I push without first pulling, must it always punish me with a merge commit? Can't I say ""oh shit I don't want to do this, go back and git pull""?This is a source of probably 50% of my ""ah, fuck, time to undo..."" moments with git, these days. I hate that shit. Muscle-memory gets ahead of me and I commit on a shared remote branch, which would be fine given our workflow except that I didn't pull first. What a pain in the ass."	handrous	8.580649	-6.541742	comment	3.0	15.0	1624291883	-11.871079
27580711	That's a failing of Git. TortoiseSVN	That's a failing of Git. TortoiseSVN brought source control to millions of people. A good tool should be fully embeddable in a UI, 15 years after its launch.	oblio	8.565262	-6.444299	comment	3.0	18.0	1624292605	-11.895913
27581665	And if I create a new branch locally	And if I create a new branch locally, why must I specify what name I'd use for it on the remote? Why would I like an other name I wonder? It's fantastic that it can do this, but the default should be the branch name I'm using and that's that.	npteljes	8.530184	-6.5278573	comment	3.0	13.0	1624297835	9.10734
27581766	There's a limitation to the DAG mode	There's a limitation to the DAG model that has bothered me for a long time.I don't always want a branch to descend from a commit - sometimes I want it to descend from another (less featureful) branch.I want the ability to say that branch 1.1 is equivalent to branch 1.0 + {some set of changes} is something that would be exceptionally useful in a lot of circumstances.(And I know this would create some new fun and games from a conflicts perspective, but I think it'd be worth it for any use case that involves long term maintenance of different releases of the same piece of software.)	yarg	8.577234	-6.549667	comment	3.0	12.0	1624298333	8.884309
27580659	While GitUp is a GUI app, and only a	While GitUp is a GUI app, and only available for macOS, I think it's worth noting that it has some great undo/redo capabilities built in.From what I understand, some of them were more feasible to develop because they implemented their own plumbing (GitUpKit), instead of relying on the official git plumbing.https://gitup.co/	gldnspud	8.567379	-6.4896693	comment	3.0	13.0	1624292282	-11.90087
27580719	Yeah, this barely scratches the surf	"Yeah, this barely scratches the surface though.Take branching, which is something you're supposed to be doing all the time.  So abstractly, I want to be able to get a list of my current branches, create a new branch, check out an existing branch, delete an existing branch, and maybe rename a branch.  I would expect the commands for these operations to be something like:    git branch list
    git branch create [name]
    git branch delete [name]
    git branch rename [old-name] [new-name]

We can argue over whether checking out a branch should be ""git branch checkout [name]"" or just ""git checkout [name]"", but in either case, if I have unsaved changes in my working directory, I would expect to at least get a warning about this before that work got clobbered.None of these things are actually"	lisper	8.54536	-6.545294	comment	3.0	12.0	1624292649	-11.891833
27581206	I don't understand. You can always r	I don't understand. You can always restore any previous state using git, I used to do it from the command line.If I use github desktop I can roll back a commit whenever I like with a simple menu command.What am I missing here. I feel like I don't understand what the tool is doing.	whiddershins	8.584373	-6.5343275	comment	3.0	10.0	1624295585	-11.91501
27583971	What's wrong with `git push -f`? Whe	What's wrong with `git push -f`? When I'm working on a branch that's been previously pushed with `-u`, it's pretty normal to force push it, particularly if you're amending or reordering commits in response to review feedback, or rebasing due to conflicts in preparation to merge.	mikepurvis	8.568035	-6.5300174	comment	3.0	10.0	1624307169	-11.889156
27643483	On one hand, I agree that these are 	On one hand, I agree that these are all good points. I haven’t ever played with kernel code, but I have tried to backport years-old Glibc commits and it’s an absolutely miserable experience because “minor” things like small-scale reformatting would frequently be bunched together with unrelated changes. They also maintained their configure script in version control and apparently even merged it manually, because I’ve found that at many points in its history it would be composed of pieces generated by different versions of autoconf.On the other hand, I don’t think that the conclusions of this story are as inevitable as it makes them seem. Much of the pain it describes is due to the fact that Git is, as it proudly  itself, stupid: it doesn’t understand that your spacing or line breaking or br	mananaysiempre	8.63425	-6.451021	comment	3.0	14.0	1624726232	-11.901909
27643727	> The commit was about 10 years old,	> The commit was about 10 years old, and it replaced every tab with 4 spaces.Reminds me of a project I worked on a while back - whenever you looked at the git history of a file, if you went back far enough you’d hit a dead end at the point where every source file was renamed from *.c to *.cpp.	pansa2	8.584186	-6.5248427	comment	3.0	17.0	1624727635	-11.912057
27645409	Git tracks changes across renames th	Git tracks changes across renames though right?	alkonaut	8.60474	-6.5591474	comment	3.0	14.0	1624738428	-11.87938
27710927	Side note but what is going on with 	Side note but what is going on with this projects commits?	exdsq	8.586281	-6.4593387	comment	3.0	23.0	1625230833	-11.8812275
27712154	Interesting to see someone doing thi	Interesting to see someone doing this, it often comes up that we should actually have more levels of version control granularity than merges and commits. Just need an application of AI to generate good commit messages here :)	fulafel	8.624064	-6.5287476	comment	3.0	13.0	1625237054	10.824079
27723578	The author identifies the problem wh	"The author identifies the problem which I think is a  fundamental failure of the git model which is that commits aren't associated with branches.  But proposes a different solution.  I wonder why they didn't decide to attach a branch identifier to each commit.  This would solve the problem as I see it as you could truly view a branch history; typically for example you'd be asking for logs of the ""master"" branch history.  The topological view can help but the lack of notion of a branch as anything but a pointer to one commit means you effectively do loose history unless you go for a burdensome tagging scheme."	derriz	8.564955	-6.544972	comment	3.0	17.0	1625335868	-11.903869
27724310	But that problem is easy to fix with	But that problem is easy to fix with 0 disadvantages: Don’t do that.Don’t do it for the same reason that you have a convention of useful commit messages.	thrashh	8.587942	-6.5249224	comment	3.0	12.0	1625341964	-11.937659
27724495	The ugly truth though, is that the p	"The ugly truth though, is that the process of programming can be shamefully bad. Often times the in-progress branch commits are the opposite of the platonic ideal commit message, for common human reasons. By 'common human reasons' I mean programming is messy, and it's often unclear why something does or does not work until after something functional is arrived at.The important thing is that your tools, specifically git, works for you, and not the other way around, so 'bad' commit messages like 'before', followed by 'after' are totally fine while working in the branch as long as it gets cleaned up during merge. However, they are the antithesis of useful months or years down the line while playing code historian. (Hilariously, the answer to the question ""what idiot wrote this code"", is somet"	fragmede	8.59004	-6.5368204	comment	3.0	23.0	1625343101	-11.910725
27724975	This. There is no need to introduce 	"This. There is no need to introduce a new concept like ""commit groups"" to permeate through everything. Just use merges and display them nicely.The problem is getting all the visualization tools on the same page.Bazaar got this right. Their official UI displays a linear history with the ability to expand any merge commit to show the side branch.https://commons.wikimedia.org/wiki/File:Bazaar_Explorer_-_Lo..."	exclipy	8.572645	-6.553919	comment	3.0	11.0	1625346806	-11.924842
27725649	It's pretty easy though. Leave all t	It's pretty easy though. Leave all the commits. Put meaningful messages in your merge commits, and your clean macro history is just merge commits and the messy one is the rest.	dec0dedab0de	8.582032	-6.5574503	comment	3.0	17.0	1625352719	-11.925653
27728299	It really depends on the timescale o	"It really depends on the timescale of your changes.  Change a few lines in an afternoon?  Nobody cares about the history.  But if you ever have a long-running branch, you will care about your local history.  You'll merge in the main branch, and it will conflict.  Someone already renamed the thing that you're renaming in your branch.  An auto-formatted changed its mind.  The API changed.  Some stuff was refactored.  The difference between ""hmm, annoying"" and ""I'll just delete this work and start over"" after struggling for a week pretty much comes down to the history -- remembering what you did and why, and being able to apply pieces of that relative to the new state of the main branch.This is one of those insidious things that will only affect you.  Nobody else has your working copy, and no"	jrockway	8.5709915	-6.5517235	comment	3.0	12.0	1625390254	-11.911895
27731182	> Once you git push (or in theory so	"> Once you git push (or in theory someone pulls from your repo, but people who pull from a working repo often deserve what they get) your changes to the authoritative upstream repository or otherwise make the commits or tags publicly visible, you should ideally consider those commits etched in diamond for all eternity.I've broken this rule multiple times per day for the past 10 years.On your own feature branches, rebase your fucking shit and force push.  I see so many people creating ungodly messes because they never want to erase the history of PRs that they've submitted and its just a nightmare of merge commits pulled back into their branch from master.I've watched a decade of git n00bs practice this ""never under any circumstances rewrite history"" advice and it fucks them up over and ove"	lamontcg	8.571907	-6.531151	comment	3.0	14.0	1625419379	-11.916408
27731579	I personally spend significantly mor	I personally spend significantly more time writing git commit messages than reading them.  Spending lots of time looking at old commits is IMO a sign of poor code quality.  Similarly, summarizing each change deserves some real thought so when you are reading these messages their actually helpful.	Retric	8.578444	-6.523216	comment	3.0	15.0	1625422882	-11.910812
27738126	> We don't look at this difference a	> We don't look at this difference as a workaround in Fossil for autosync, but instead as a test-first philosophical difference: fossil commit is a commitment. When every commit is pushed to the parent repo by default, it encourages a working style in which every commit is tested first. It encourages thinking before acting. We believe this is an inherently good thing.I wonder how this works with tests that cannot be run locally (or ones that I'm not willing to sit through for the whole 1 hour the test suite runs for?)?Eager to hear from Fossil practicioners on this.The ideals do sound very good - but they remind me of the difference between an academic and a practicioner. One gets things done while the other advances the state of the field. Depends on what you like.	hashhar	8.522505	-6.5589895	comment	3.0	12.0	1625493905	9.468138
27738331	Why? It would be better, I frequentl	Why? It would be better, I frequently commit in.This way it is even easier to find the offending commit, because changes are smaller (yes, sometimes not working at all).	krzyk	8.596355	-6.5184383	comment	3.0	19.0	1625495152	-11.932352
27756876	I took the opportunity to rename all	I took the opportunity to rename all my master branches to `trunk`:https://en.wikipedia.org/wiki/Trunk_(software)Because y'know, branches? Trunk and branches? It's the older term. I ran into it using Fossil and liked it, now all my git repos have trunks as well.Of course there's nothing wrong with master, that was just histrionic bullying. At best it was people doing something they can do (change variable names) as a substitute for something they can't (meaningfully affect racial injustice).But like I said. I took the opportunity. Way better name than main... or master for that matter.	samatman	8.526872	-6.520639	comment	3.0	12.0	1625626666	-11.579355
35335958	>  what prevents a intern to not hav	>  what prevents a intern to not have a correct exclusion there, and happily push a .ds file ?Our CI.And code review is what prevents .DS_Store to be added to .gitignore.And, again, I'm saying this as a purist with a developer team of 99% Mac users.	pilif	8.649212	-6.4492846	comment	3.0	20.0	1679978033	-11.7027025
35365650	> A friend of mine felt it was finge	"> A friend of mine felt it was finger pointing when her coworker said ""could you take a look at your commit `abc0123`? because it broke the test `Xyz`"". I thought it was direct but professional.IMO, it was appropriately finger pointing. The person who breaks the build should be the one to fix it - they're the one with the most context.But also - require tests to pass before a commit is allowed. It makes development so much better."	nordsieck	8.608331	-6.519236	comment	3.0	10.0	1680133761	-11.884103
35372394	I agree with the just learn git part	I agree with the just learn git part. We are all students when it comes to learning something new to you and this career is a constant stream of learning things. So my advice would be to deeply learn what your tools are doing and do that by trying out different things in a zero risk sandbox.  Git is decentralized, you can setup a local repository that you can use for practice and to learn what is going on.	matt_s	8.529358	-6.4726267	comment	3.0	14.0	1680183039	-11.908955
35374922	Got requires a mental model. I've tr	Got requires a mental model. I've tried to teach git without the mental model and it just doesn't work. There's a whole pack of people on the internet who refuse to learn the internals and complain incessantly about it. I don't think there's anything wrong with them, but it's a signal that for some folks conceptualizing what's in the docs is difficult for them. The explain command I think could go a long way in doing that, similar to how I used explain to learn SQL.	kodah	8.540786	-6.4917374	comment	3.0	12.0	1680192436	-11.912424
35380587	I thoroughly resent that I'm being f	I thoroughly resent that I'm being forced into that workflow. I'm trying to get enough distance to tell if it's actually overkill or just being a curmodgeonly old git.	pdpi	8.546571	-6.5130105	comment	3.0	12.0	1680221140	-11.888448
35392431	Squashing the commit history before 	Squashing the commit history before releasing it was an interesting (and completely predictable) decision.	Me1000	8.579755	-6.529703	comment	3.0	10.0	1680291878	-11.908431
35401172	If you break a branch, the sound of 	If you break a branch, the sound of it breaking informs you that you have broken a branch.	philipov	8.608087	-6.5417404	comment	3.0	12.0	1680363954	-11.837159
35414285	> This branch is 1140 commits ahead,	> This branch is 1140 commits ahead, 125677 commits behind torvalds:master.Could this board ever get mainline support?	slaw	8.66836	-6.459519	comment	3.0	10.0	1680464391	-11.78786
35440187	Consider an alternative approach: ch	Consider an alternative approach: chunk up and embed your entire codebase (dramatically cheaper) and insert it into a vector store. when you go to send a query, search the store and retrieve the most relevant chunks, and those are what you send with your query.Optionally send other specific code alongside it.This should be similar in quality and dramatically cheaper. It's quite doable with langchain, and you can use Chroma + DuckDB to avoid having to pay for Pinecone.You could even maintain there vector store using git diffs to only update chunks that have changed.	jasonjmcghee	8.65514	-6.472774	comment	3.0	12.0	1680618404	9.549968
22304678	> the supposedly obtuse interface ma	"> the supposedly obtuse interface makes a lot more sense when you approach it with an understanding of the fundamentals in hand.Agreed. I always said the best git tutorial is https://www.sbf5.com/~cduan/technical/git/> 
The conclusion I draw from this is that you can only really use Git if you understand how Git works. Merely memorizing which commands you should run at what times will work in the short run, but it’s only a matter of time before you get stuck or, worse, break something."	chx	8.544382	-6.4943295	comment	3.0	27.0	1581468809	-11.901271
22304841	> instead of the inside outNow the n	> instead of the inside outNow the name makes even more sense. I first read it as sh/git, but reading it as something that starts inside and slowly works its way out is now my preferred explanation of the name.	wkjagt	8.5598135	-6.4876804	comment	3.0	16.0	1581470725	-11.857864
22305181	What I never fully understood is why	"What I never fully understood is why the staging area isn't simply a commit that gets amended repeatedly as files are staged into it. Maybe just a tree pointer, since the rest of the commit data isn't available until commit, but you could fill in some placeholders. (""(staging)"" for the message, current times for the timestamps, etc.)(Note that index doubles for other functions like merging/conflict resolution, but I never thought that was a good thing, and could be separated out.)"	deathanatos	8.655908	-6.5822053	comment	3.0	11.0	1581474381	-11.926018
22305318	I never really understood Git until 	"I never really understood Git until I read this tutorial: https://github.com/susam/gitprThings began to click for me as soon as I read this in its intro section:> Beginners to this workflow should always remember that a Git branch is not a container of commits, but rather a lightweight moving pointer that points to a commit in the commit history.    A---B---C
            ↑
         (master)

> When a new commit is made in a branch, its branch pointer simply moves to point to the last commit in the branch.    A---B---C---D
                ↑
             (master)

> A branch is merely a pointer to the tip of a series of commits. With this little thing in mind, seemingly complex operations like rebase and fast-forward merges become easy to understand and use.This ""moving pointer"" model of Git"	chenhan	8.565558	-6.546783	comment	3.0	15.0	1581476260	-11.901621
22306762	If it's so hard to learn about this 	If it's so hard to learn about this tool and so easy to learn about it the wrong way, that's a pretty obvious hint that there's something wrong with the tool.Having to learn about the internals is a giveaway that the tool suffers from poor encapsulation.To me git is definitely one of those tools where one should satisfice and not learn it deeply, because it's not worth the effort. One can successfully stick to a simple workflow and ignore anything git astronauts come up with, like git flow if they want to keep their sanity and focus on what matters - creating quality software. And almost any team has some git fetishist which will be thrilled to help when things go south. And if they don't, it's probably for the better.	blub	8.546714	-6.506884	comment	3.0	24.0	1581493557	-11.934011
22337278	Still salty about them dropping merc	Still salty about them dropping mercurial support without providing any migration tools, and planning to just delete data without any archiving.	doubleunplussed	8.500041	-6.5501795	comment	3.0	13.0	1581794298	-11.974733
22362998	If you share a development branch wi	If you share a development branch with someone, then you should prefer merging over rebasing because rebasing changes rewrites the commit history, causing the locally checked out branches among collaborators to disagree. You never know when someone will need to take your branch to develop on, so generally it’s a good idea to merge over rebase. When master is merged into your PR branch, the fork point is forwarded to the last master commit, so you shouldn’t have any trouble merging back into master.	dimes	8.594286	-6.5547433	comment	3.0	12.0	1582085810	-11.887577
22369187	Once upon a time, we had version con	Once upon a time, we had version control systems that provided keyword expansion for something like %G% (SCCS, BitKeeper) or $Id$ (RCS, CVS come to mind). With git, this has fallen out of fashion, however, but I'm not sure why.	beefhash	8.702759	-6.4455185	comment	3.0	10.0	1582141113	-3.7501116
22489249	In my opinion the problem with GitFl	In my opinion the problem with GitFlow and a lot of other git workflows is you end up holding a bunch of state inside of your git branches which is hard to decipher, complicated to manage, creates work for people ( with merge conflicts, and managing feature branches that need to be merged ), and is capable of losing progress.My solution: USE FEATURE FLAGS. Keep the list of features and refactors you want deployed in a format that is easy to audit and reason about.I like the Microsoft branching strategy: https://docs.microsoft.com/en-us/azure/devops/repos/git/git-...Basically:* Create feature branches.* Merge into master when the feature is done. For long lived branches: Don't keep them around. Merge them into master and put them behind a feature flag.* Deploy to environments using release 	honkycat	8.603888	-6.52884	comment	3.0	11.0	1583364217	-11.948723
22489313	I've yet ever to see a rebase workfl	I've yet ever to see a rebase workflow fail, and I've been using a rebase workflow since at least 2002.I do sometimes have to rebase across thousands of commits because I let a branch rot, and that can be hard to rebase, but it can be equally difficult to merge.  Instead I use a bisecting rebase approach where I try to rebase straight to the new upstream, and if there's conflicts, abort the rebase and try rebasing to halfway to the new upstream, continuing the process until the rebase was across just one commit, thus I can resolve conflicts directly with the upstream commit that caused them, then restart the process until done.	cryptonector	8.579872	-6.5695257	comment	3.0	25.0	1583364734	-11.907986
22489378	Hmm, that doesn't match my experienc	Hmm, that doesn't match my experience. If I remember correctly, I've mostly seen long-running branches where the conflicting code was moved/taken care of still having rebase conflicts because git is running the commits one by one, and is conflicting with the old commits (before they were fixed), requiring me to fix them yet again.Merging doesn't have that problem, it usually just merges fine unless there are conficts in the latest commit (not all previous ones).	StavrosK	8.605258	-6.5494795	comment	3.0	17.0	1583365181	9.050632
22489405	Exactly, that something as trivial a	"Exactly, that something as trivial and obvious as version control costs so much mental overhead is completely bizarre.Sure, SVN doesn't have as many features as git, and merging sucks, but it offers the most important features of version control (recording ""who has done what, when"", and undoing changes). Teaching SVN usage to a non-techie takes literally a few minutes (especially with an intuitive UI like TortoiseSVN), and it's very hard to break something."	flohofwoe	8.585535	-6.469336	comment	3.0	13.0	1583365485	-11.87638
22489744	That is the scariest script I have e	That is the scariest script I have ever seen in my life.It makes me believe there is a real existential problem with git as a product.	jariel	8.560523	-6.4461365	comment	3.0	13.0	1583368056	-11.870572
22490603	> * major features are done in featu	"> * major features are done in feature branches, w/rebasing prior to mergeRebase in a feature branch, that can be long-lived and have many commits, seems like a painful experience to me.You can end up solving the same conflict more than once, or even solving conflicts that don't exist in the final result.
no-ff merge commits are usually easier to solve.Am I missing something? Is there an easier rebase strategy?"	pmoleri	8.599224	-6.560513	comment	3.0	10.0	1583377734	-11.936222
22490824	> these folks have trouble with even	"> these folks have trouble with even basic questions, like, ""is this the change you intended to make on this branch?"" when shown a diff.I've seen people like this too, when reviewing PRs, I often see unwanted code being committed, and I just don't understand why this keeps happening. One of my defaults when committing code is to run ""git status"", then run ""git diff"" on each file I'm committing. I thought this was a pretty well used flow, but apparently it's not."	woutr_be	8.5806	-6.5027895	comment	3.0	10.0	1583380622	-11.885047
22489859	"I'm one of the git ""experts"" that oc"	"I'm one of the git ""experts"" that occasionally helps unwedge people who are ""wedged"" with git.Every time, they are mentally unwilling to learn git.And before anyone mistakes that for complexity on git's side… often, these folks have trouble with even basic questions, like, ""is this the change you intended to make on this branch?"" when shown a diff."	deathanatos	8.559648	-6.498111	comment	3.0	15.0	1583369315	-11.906513
22498039	the risk of this workflow is that PR	the risk of this workflow is that PRs will languish for too long, and the work required to rebase them when they're actually needed will cause friction and mistakes. this will often manifest when your software reaches a certain level of maturity and you have established a release model that distinguishes between a release that includes only bugfixes and a release that introduces new features.you definitely want to get your PRs merged in to _something_ as soon as they are complete, to avoid bitrot. but just because they're complete doesn't mean you want them included in the next release.	woodrowbarlow	8.649715	-6.514593	comment	3.0	10.0	1583441321	-11.885727
22498211	Same here. Trunk based is easy to ex	Same here. Trunk based is easy to explain and enforce.The only challenge we faced was maintaining patch releases. Folding in fixes for common issues which were found in newer releases sometimes involved more than just cherrypicking the fix into a patch release for an older version.This inevitably led to asking users to update to more up-to-date versions. This further enforced the linear development paradigm.	zoomablemind	8.609197	-6.5330744	comment	3.0	10.0	1583442159	3.1933517
22498553	There is a small trade secret, that'	"There is a small trade secret, that's hard to visualize. If you merge two changes into master you can break it.The fact that a change passed a CI and another change passed a CI doesn't mean they can merge and the result is guaranteed to pass CI. It will often break and if you think for a minute you will come up with really rudimentary examples of this.The really primitive solution is to call the merge-recipient branch the ""develop"" and only merge to ""master"" when you are sure what you are merging is good. You'll be ok if you do it sequentially (no parallel merges to master).A more complicated solution is to actually test (in CI) ""what happens when I merge this"" but in hiding, without showing it to others. Even more complicated is to do it in parallel. Gitlab calls it Merge Trains (Premium "	kubanczyk	8.492133	-6.464706	comment	3.0	11.0	1583443915	8.728713
22516946	We just switched from Perforce to gi	"We just switched from Perforce to git at work, and about the first 2/3 of a project I work on got squashed together.  It took me less than a week to bump in to that ""initial commit"" when trying to figure out why a bit of code is the way it is.""git blame"" (or the p4 equivalent) is my usual archaeologic tool in this context, but ""git bisect"" has been very helpful in others.  For the first, it should be easy to look at your current codebase in SVN and see how far back the history goes in any particular area.  I've found that bisection is most useful for relatively recent history, because I usually have wanted to build or run the software to test for a bug or something - beyond some point in history that becomes impractical.Moving from SVN to git shouldn't require losing history though..."	bacon_waffle	8.579478	-6.537286	comment	3.0	13.0	1583655616	0.95309854
22517334	Maybe the old guys didn't think ther	Maybe the old guys didn't think there was a good reason to switch from SVN to git, if SVN had been working for them. It sounds like switching just because git became more popular.Of course if you're young, it's no big deal since you haven't been using SVN for decades, and what's the big deal with learning something new? But when you've been around the block a few times, sometimes there's needs to be a better reason than the new and shiny.	goatlover	8.563873	-6.485573	comment	3.0	10.0	1583662930	-11.833857
22519431	Yes, but maybe not in the way that y	"Yes, but maybe not in the way that you're thinking.The scenario isn't ""I'm gonna go browse the changes that were made in March of 1994"", instead it's trying to solve a specific mystery.You see some code that doesn't make much sense, so you look at git blame to find the commit where it was written. Look at the full change, read the commit message, and now you've got some more context. Often this is enough to understand, but if not, you can check out the code at that time and read the implementation of related systems. Soon things are starting to make sense! Certainly they make much more sense than they did when you started."	rictic	8.590547	-6.5110636	comment	3.0	17.0	1583690184	-11.883541
22519760	I love reading through revision hist	I love reading through revision history but it's so, so easy to mess up given people and time.We have a long history spread across several different (generations of) SCMs. I see each of the following quite often:Most recent revisions (version A, code comments date code to the 90s):- 2011-02-03: Migrate to git- 2008-01-12: Migrate to SVN- ~Fin~Most recent revisions (version B):- 2018-12-12: Split <X> out into own file- ~Fin~Most recent revisions (version C, sweet monorepo blogpost edition):- 2019-10-01: Create monorepo for <Team/Superteam/Division>- ~Fin~---It's hard to do transitions between SCMs (or between repos) right. For instance, when you follow the recommended steps for moving to a monorepo in git, the history is maintained but not shown in GitHub. It's so easy for well meaning peop	chucksmash	8.57753	-6.5747285	comment	3.0	14.0	1583693369	-11.915614
22519959	What's the latest on how long a comm	What's the latest on how long a commit message should be? Used to be everyone said a message should never be longer than two sentences and that they should be as short as possible so that people actually read them. This thing posted is an essay. Not the haikus I thought was considered best practice.	c3534l	8.597574	-6.5403132	comment	3.0	11.0	1583695511	-11.921393
22521114	I, too, use git commit messages to d	"I, too, use git commit messages to document the reasoning behind my changes. But I'm unsure if my colleagues even notice, since they regularly write bad commit messages like ""Fix bug"" and things like that. Also I regularly find my commit messages got lost, since the reviewer squashed several commits into one.Do you have any tips for establishing a culture of good commit messages?"	pvorb	8.579787	-6.5308084	comment	3.0	11.0	1583707025	-11.892865
22576116	> One reason projects with large bin	> One reason projects with large binary files don't use Git is because, when a Git repository is cloned, Git will download every version of every file in the repository.Wrong? There's a --depth option for the git fetch command which allows the user to specify how many commits they want to fetch from the repository	piliberto	8.566257	-6.4428053	comment	3.0	12.0	1584200918	-11.891383
22577943	I think this is a very p4 centric vi	I think this is a very p4 centric view of the world.Locking helps with preventing collisions, but honestly the issue is still always communication. Why are people even touching files they shouldn't be touching?Meanwhile perforce is a pain for code heavy projects and requiring a central perforce server. Git works great there.The issue is neither is a silver bullet for the others workflow and needs, and they both suck horribly for mixed code and binary asset workflows.That's not even considering cost.Meanwhile film studios generally prefer keeping the considerations separate and using symlinks or URI to their data store and that works really well. But that doesn't work great for remote workflows.So again, I think you're applying a very p4, game centric view to this. There are lots of differe	dagmx	8.598087	-6.4897637	comment	3.0	19.0	1584213962	13.832231
15112184	About 12 years ago, I worked for a c	"About 12 years ago, I worked for a company that scored a one. I and a number of other people on the team started working to improve things. Over a span of about six months, we had the team up to a 7. There was still plenty of room to improve but we all felt massive accomplishment.Then our Director (also a developer) told us ""this SVN thing isn't useful"" and demanded that we stop using version control. Then he saw Mantis (our bug tracker) and complained about how ugly it was. Instead of choosing a prettier one, we had to use his Excel spreadsheets on the local fileshare. It got worse and worse until our 7 went back to a 2 in about 60 days.Six months later, 8 of the 10 had left. Even the people who hadn't originally been on board with the changes but saw the benefits left."	caseysoftware	8.623317	-6.4483466	comment	3.0	10.0	1503861093	-11.8350725
15192905	I may be being stupid here, but shou	"I may be being stupid here, but shouldn't you really be using a comprehensive test suite and a code coverage tool like simplecov [0] to automatically show you your dead code? Or if you don't do test coverage (!) something like coverband [1] in production? That way you get to see straight away which code is genuinely dead rather than having to go spelunking with `git-bisect`?[0] https://github.com/colszowka/simplecov
[1] https://github.com/danmayer/coverband"	boffinism	8.626696	-6.512168	comment	3.0	13.0	1504799172	-11.961398
15215458	Bad commits are the absolute most di	Bad commits are the absolute most difficult thing to reverse when they get released and the userbase codes to them.  When I don't pay super close attention to what's being contributed, it creates three times as much work after I let it through.	zzzeek	8.593605	-6.5049276	comment	3.0	16.0	1505096423	-11.887425
15244505	I'm not sure what she is talking abo	I'm not sure what she is talking about because you definitely do not have to copy files across. I have a git checkout on my C: drive and interact with it via /mnt/c with no trouble. I'm editing in VS Code and running git and npm in Ubuntu shell with zero friction.	tootie	8.55585	-6.462879	comment	3.0	15.0	1505355109	-11.902433
15263801	I would think squash a poor default 	I would think squash a poor default policy; it destroys information in the granularity of commit, and in the commit messages.	rout39574	8.589694	-6.5283723	comment	3.0	10.0	1505554739	-11.9127
15263849	Ok, if your set of changes is too la	"Ok, if your set of changes is too large to review in one piece, and you put in the work of refactoring your changes into a speedrun-style best possible history so they are cognitively review-friendly, I grant that this is a valid use case for rebase.
Though erasing the real history is still a serious drawback, and the unit of code review is still too large. Not many projects work like this, however."	fulafel	8.577295	-6.5541897	comment	3.0	10.0	1505555596	-11.9120655
15292364	"    git log --pretty=format:""%H%x00%"	"    git log --pretty=format:""%H%x00%s"" | sed 's/&/\&/g; s/</\</g; s/>/\>/g; s/""/\""/g; s/'""'""'/\'/g; s@\(.*\)\x0\(.*\)@<tr><th>\1</th><td>\2</td></tr>@'

You could do the dumb html entifying in a real language. The article's solution is a straw man, since it's promoting their personal language.Why did they see \x01 & \x02 as possible sentinels but not nulls? python is fine with nulls…"	falsedan	8.616313	-6.498258	comment	3.0	12.0	1505905143	-11.833699
15315697	Gitlab is great when you self host i	Gitlab is great when you self host it, but not so much using their service, you can take a look at https://twitter.com/gitlabstatus see how often they have breaking problems. Not to say this cannot happen, but they have considerably higher compared to others. But, for feature wise they are also great, but I do not see how this deep integration with Kubernetes will work out, making the core product more complicated and focused on single target. Not that you cannot write your own CI, but marketing it Auto DevOps when it does only K8s does not seem right to me.	CSDude	8.671381	-6.6346674	comment	3.0	16.0	1506113600	-12.418047
15321547	How do you measure that, though?It s	How do you measure that, though?It seems like you have to ignore all value derived from networks in order to come to the conclusion that software is no more powerful than in the 90s.In the 90s I couldn't have met with my team, with members in Moscow, California, Pennsylvania, and Texas, in any reasonable way...today I can chat, including video and sound, on a whim!Managing source code today is massively more productive than in the 90s. CVS (or, heavens forbid, RCS) on a central server was how it was done back then, if you had revision control, at all. It's not merely a better revision control system (git), it's the web-based infrastructure around it (github/gitlab/web-based CI/whatever). That wouldn't be possible on any platform that's less connected and less widely available than the web.	SwellJoe	8.567689	-6.4708867	comment	3.0	14.0	1506198484	-11.82086
15375297	I think Tarsius already did this and	I think Tarsius already did this and called the result Magit. For bonus points he made it perfectly interoperable with gitEdit: Kickstarter campaign going on with 23h left https://www.kickstarter.com/projects/1681258897/its-magit-th...	fovc	8.621968	-6.4690614	comment	3.0	11.0	1506810338	-11.80591
15375999	So Git is what Linus thinks is good.	So Git is what Linus thinks is good.  What I think is good, and this was Git's inspiration, is at http://bitkeeper.orgIt's very different from Git.  Git versions the tree, BK versions the tree and versions files.  The difference is profound.  In BK, you debug by looking at the file history and then zooming out to the commit history.  Git can't do that.  Or it fakes it and gets it wrong.  Same with merges, renames, creates, deletes, Git gets all that wrong.I know it won and there is no hope that things can get better but if you want to see what better looks like, check out BK.	luckydude	8.595782	-6.484689	comment	3.0	11.0	1506823476	-11.897178
15379210	Do not use Git Flow for a web applic	"Do not use Git Flow for a web application deployed on your own infrastructure (SaaS, microservice, mobile backend, etc.). It will slow down development and make your software less reliable.The entire purpose of Git Flow is saving up changes to release later, e.g., saving up for a weekly release event. Don't do that! Deploy your changes as soon as they are ready, if they aren't ready don't merge them into a shared branch. If you do Continues Delivery you don't need ""hotfix"" branches because every changes goes out as soon as it is ready, so you don't need any of the complexity of Git Flow.By saving up changes for a release event it means more things are getting released at once. If there is a problem after deployment it will be harder to narrow down the cause. Git Flow fosters a harmful deve"	antoncohen	8.6078	-6.543348	comment	3.0	10.0	1506883751	-11.913109
15394860	Hey Michael! Congrats on the launch 	Hey Michael! Congrats on the launch :)Providing a one-size-fits-all solution here is probably impossible, but it seems like it would be nice to provide some mechanism to be notified that you're making edits based on stale information. If such a mechanism existed, it would be easy to add a bunch of canned merge strategies. In doing so you can probably teach people a little bit about the pitfalls they're likely to run into (these sorts of bugs are insanely difficult to track down), while not really making them do much work.The approach we've taken in Eve is that we can't solve all these problems for you, but we can at least let you know that things can go sideways and prompt you to make a deliberate decision about what should happen. It's amazing how helpful that ends up being.	ibdknox	8.734486	-6.461081	comment	3.0	10.0	1507055973	-11.699162
15402879	> Keybase team member here. Interest	"> Keybase team member here. Interesting fact: git doesn't check the validity of sha-1 hashes in your commit history.I heard this a couple of times and tried to confirm it a while ago, but was unable to. I wasn't able to forge a repository with faulty hashes in it.
I also heard plenty of people tell me that there exist public repositories with wrong hashes in them, but when I asked them they never could come up with concrete examples in the wild.I'm seriously curious about this, can you provide any clonable proof of concept repository with wrong hashes?"	hannob	8.654057	-6.519691	comment	3.0	12.0	1507141275	7.207325
15405110	Why the hell would you do that. That	Why the hell would you do that. That defeats the point of git.	mlindner	8.542145	-6.4616446	comment	3.0	11.0	1507154553	9.427346
15415526	Why do people need git support in an	Why do people need git support in an editor so much? Using git from the terminal is easy and you always know what is executed because you do it manually.	ssijak	8.563193	-6.477815	comment	3.0	13.0	1507283104	-11.868969
15449610	Saw the commit, its nice you improve	Saw the commit, its nice you improved the code quality too, wherever you touched by adding diamond brackets and making fields final.	mangatmodi	8.594235	-6.515295	comment	3.0	13.0	1507729103	-11.894811
15452008	I'm curious to know how usage of AWX	"I'm curious to know how usage of AWX affects your ability to maintain everything (inventory, roles, playbooks, etc.) in version control.I'm guessing AWX wants to be the central ""source of truth"" for all of that stuff instead of just keeping it all in a single git repo."	jlgaddis	8.58116	-6.497984	comment	3.0	10.0	1507746468	-11.873923
15482039	Read that again. We asked to commit 	"Read that again. We asked to commit without revealing details, he said yes, that's what happened. I guess he changed his mind about that after the fact, but nobody promised not to commit. We didn't ""defect"" from an embargo unilaterally."	tedunangst	8.58375	-6.5163536	comment	3.0	24.0	1508147737	-11.877243
15548424	> When I'm signing a commit, I'm vou	"> When I'm signing a commit, I'm vouching that I am responsible for applying this set of changes to a given state of a repo. It says nothing about my belief in the validity of changes to the repo made before it.Then you should be signing a diff not a commit. Signing a commit represents something different, because commit references both the current tree (all files) and parent commit you're basically vouching for all history and all files.For reference, git commit structure [0]:    $ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
    tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
    parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
    author Scott Chacon <schacon@gmail.com> 1205815931 -0700
    committer Scott Chacon <schacon@gmail.com> 1240030591 -0700

    changed the version num"	hdhzy	8.599218	-6.5235777	comment	3.0	11.0	1508920571	10.257323
15590587	https://i.redd.it/q0334spe5fny.png2 	https://i.redd.it/q0334spe5fny.png2 out of the top 10 committers work for Blockstream (matt works at Chaincode Labs now).Care to revisit your conspiracy? Or is something wrong with the data?	hudon	8.617761	-6.4722915	comment	3.0	28.0	1509414693	-11.849195
15593843	OP author here: the rivalries there 	"OP author here: the rivalries there are directional, ""if you liked X, you probably disliked Y"", but not vice versa. (One thing I find interesting is that most rivalries really are directional: you see git users disliking svn, but not svn users disliking git).Perhaps there's a way I could make that clearer in the post!"	var_explained	8.546847	-6.4608097	comment	3.0	10.0	1509463141	-0.8468216
15725497	Interesting to see them try to fix G	Interesting to see them try to fix Git when Facebook considered it (due to similar constraints) and decided to go with Hg instead: https://code.facebook.com/posts/218678814984400/scaling-merc...	rokob	8.510455	-6.510152	comment	3.0	11.0	1510948839	-11.925555
15725668	Those kinds of use cases are what Gi	Those kinds of use cases are what Git LFS [1] was created to help with. The  major Git vendors support it (Bitbucket, GitHub, GitLab). I'm not as certain about the open source implementations.[1] https://git-lfs.github.com/	mkobit	8.580858	-6.4489923	comment	3.0	12.0	1510950092	-11.915911
15751451	I wonder what the creators of git th	I wonder what the creators of git think about your opinion on how to use it properly...Jokes aside, what you see it usually just the squashed commit submitted for merge. With 6 million git objects, you reconsider twice having each change in a single commit.	blueflow	8.584385	-6.5419927	comment	3.0	12.0	1511297764	-11.910403
15753354	Before I started using mercurial and	Before I started using mercurial and git I tried fossil for a few days. It was really good. I think the only reason my company decided to go with mercurial and git was the lack of a service like bitbucket or github for fossil.I am really excited to see the new avatar of fossil.	developuh	8.518381	-6.52203	comment	3.0	13.0	1511313209	-11.957219
15753634	How's Fossil do with large binaries?	How's Fossil do with large binaries? We've got a 24GB git repo and it's...not the greatest. (Not terrible, either, but not great.)	dilap	8.54123	-6.4665766	comment	3.0	10.0	1511316593	-11.918969
37953041	Cause git ain’t user friendly enough	Cause git ain’t user friendly enough for lawyers and they use word not a plain text editor which doesnt make it easy to see the diffs. But yes ;)	manxman	8.606572	-6.4699054	comment	3.0	29.0	1697784207	-11.842697
37960651	Some Miscellaneous Git Facts	Some Miscellaneous Git Facts	qsantos	8.552547	-6.4570518	story	3.0	52.0	1697831156	-11.877027
37999298	Git doesn't store diffs on logical l	"Git doesn't store diffs on logical level. Git operates on snapshots of trees. Commit is not ""a collection of changes"", it's a snapshot of a tree with attached predecessor of it.Then the another layer (which can be git, but also can be any other tool, adding custom diff tool to git is very easy) uses that to generate diffs.There is zero stopping anyone from adding contextual diffs to Git. Just ask it for content of both commits and feed it to the algorithm.Yes, git underneath stores data as diffs but they are only vaguely related to logical structure of commits"	ilyt	8.622001	-6.5217733	comment	3.0	12.0	1698156071	-11.878099
38031453	Short answer: It was better than eve	Short answer: It was better than everything else, and the competition really sucked.Long answer: A big factor was that new devs already knew Git because it had taken off spectacularly in the open source world. In only a few years SVN was legacy and everyone switched to Git (and Github) for open source.Windows shops that had been using SVN had a very natural transition to Git, with lots of tooling and experience available.But there were indeed a lot of Windows shops that used other, mostly commercial and centralized version control systems before. While they might have had some advantages over CVS and SVN or when used for enterprise, those advantages disappeared when compared to the new distributed version control systems like Mercurial and Git.Even though Git is not exactly easy to learn, 	jval43	8.59649	-6.47447	comment	3.0	10.0	1698353072	-11.909187
38070836	Your 'senior' engineer is likely rig	Your 'senior' engineer is likely right: they are trying to get some kind of process going and you are actively sabotaging that. This could come back to haunt you later on when you by your lonesome decide to merge a 'small PR' with massive downtime as a result of not having your code reviewed. Ok, you say, I'm perfect. And I believe you. But now you have another problem: the other junior devs on your team who see vrosas commit and merge stuff by themselves will see you as their shining example. And as a result they by their lonesomes decide to merge 'small PR's with massive downtime as a result.If you got _reamed_ you got off lucky: in plenty of places you'd be out on the street.It may well be that you had it right but from context as given I hope this shows you some alternative perspective	jacquesm	8.630102	-6.513044	comment	3.0	27.0	1698680358	-11.892244
38094189	"Yeah, I'd say ""if you use merge you'"	"Yeah, I'd say ""if you use merge you're doing it wrong"". Rebase + squash everything is the only way to go unless you're merging a giant feature branch in... and even then, try to avoid that."	ajkjk	8.59962	-6.5572996	comment	3.0	18.0	1698808069	9.309735
38115229	See also:- The git staging area, the	See also:- The git staging area, the term literally everyone agrees with- https://news.ycombinator.com/item?id=28143078> “Your branch is up to date with ‘origin/main’”> ... But it’s actually a little misleading. You might think that this means that your main branch is up to date. It doesn’t.No need to well-actually this one. Isn’t the Two Generals problem applicable here? If you are being really pedantic, it is impossible to tell whether you are “up to date” right this split second. Even if you do a fetch before `status`. So what’s the reasonable expectation? That the ref in your object database—on your own computer—is up-to-date with some other way-over-there ref in an object database last time you checked.A simple `status` invocation can’t (1) do a network fetch (annoying) and (2) remind	civopsec	8.567415	-6.486544	comment	3.0	15.0	1698940158	-11.853134
38115090	I guess I've never really found the 	"I guess I've never really found the ""ours"" and ""theirs"" terminology too confusing -- it's called ""ours"" because that refers to the branch I have checked out right now (i.e. that's ""my"" branch), and ""theirs"" because that's the other branch, the foreign one which isn't currently ""mine"".But maybe that's because I almost never use rebase, where it apparently is switched?"	pickledish	8.552522	-6.545177	comment	3.0	11.0	1698939664	9.297948
38116300	> “can be fast-forwarded”I find this	"> “can be fast-forwarded”I find this one annoying because I generally don't want to run `git pull` -- I almost never `git pull`, I usually just `git fetch` and update my branches as necessary. I do wish there was a built-in shortcut for ""try to fast-forward this branch""; I often just do a rebase or a merge, which will do the right thing for a fast-forward, but won't fail if a fast-forward is impossible. I can do `git merge --ff-only`, but I would like it if `git fastforward` or `git ff` was available instead because for me it is such a common operation.To forestall the obvious -- I don't like to make custom aliases or commands (though I've done it in the past) because it makes it harder to migrate between environments."	andrewla	8.573704	-6.521564	comment	3.0	12.0	1698943510	-11.907266
38116446	Git terminology is a clinical exampl	Git terminology is a clinical example where many (most? definitely not all) terms make perfect sense once you already understand how it works, but make almost no sense in concert with other terminology or when you don't know the implementation details.Leaky terminology.	kbknapp	8.550231	-6.4875617	comment	3.0	11.0	1698944011	-11.891306
38116523	> whose only job is to save textI do	> whose only job is to save textI don't see git as a tool to save text, its for coordinating changes on the same 'text' by multiple people, and doing so quite precisely and reliably, without blocking anyone's path forward. Try that with word.It could be better, yes. But I'm always surprised by the hate git gets. Its an amazing tool and miles ahead of the tools we created for non-developers (word, google docs, etc).Maybe its because I'm old enough to remember when subversion was king.	Lutger	8.595513	-6.4647584	comment	3.0	26.0	1698944287	13.730612
38117015	"I think I have a case of ""Git Stockh"	"I think I have a case of ""Git Stockholm Syndrome""; I don't find any of these terms terribly confusing, but I think that's in no small part because I haven't really learned any other systems, and have been entrenched in Git since like 2011.Looking back, I suspect that I was extremely confused when starting out, but was pretending I wasn't to try and seem cool."	tombert	8.5454035	-6.4869165	comment	3.0	21.0	1698945966	-11.890445
38118475	> pointers to commitsOr to use the n	"> pointers to commitsOr to use the name git gives to that concept, ""refs."" Thus reflog :)Also, one thing that I've found hasn't occurred to most people using git, is that all the branch/tag/etc refs of your fetched remotes, are also refs, able to be referenced anywhere you can name a ref.For example, if you ever want to say ""I don't care what's on this branch, don't fast-forward or merge or rebase, just overwrite my local branch with what's on the remote!"" then that'd be:    git checkout foo
    git reset --hard origin/foo"	derefr	8.5660305	-6.5313387	comment	3.0	12.0	1698951952	-11.891514
38118523	Really great point and also really i	"Really great point and also really illustrates the tree structure underneath the hood for git and how it rules everything.The joke that isn't a joke is that you really need a CS degree to use git.  It's not wrong.The git default arguments makes for a very inconsistent experience, agreed.And then `git checkout .` vs `git reset --hard/soft` vs `git cleanup` are all super similar but very different.Still love it more than perforce/svn (I did like mercurial a little better back in the day but I doubt that might still be the case).-----
`git reflog` is king and shows you the truth."	virtue3	8.549064	-6.5201616	comment	3.0	11.0	1698952226	-11.906017
38131231	me either, so now anecdata of 2; but	"me either, so now anecdata of 2; but also, sounds insaneof all the things a human should be in the loop for,
merging to main seems like one of them"	veidr	8.737509	-6.4676595	comment	3.0	12.0	1699029624	9.221427
38134116	Fossil does this within the repo, ma	Fossil does this within the repo, maybe we need a way for Git to do so too.	miki123211	8.503929	-6.531007	comment	3.0	11.0	1699041163	-11.931695
38136437	I am no longer working on Mercurial 	I am no longer working on Mercurial (2005)	capableweb	8.503263	-6.5585675	story	3.0	34.0	1699054415	-11.974092
38161788	That's one diff between git and Hg. 	"That's one diff between git and Hg. Hg likes to consider the history ""sacred"" so there's no ""cleaning up your commit"" via squashing/cherry picking.This is actually superior in most cases. Being able to force rewrite history so easily in git was a design mistake imo."	btreecat	8.570301	-6.5524707	comment	3.0	11.0	1699274384	-11.886182
38163461	> I've never understood this impulse	"> I've never understood this impulse to do ""branch cleanup"". Why are you adding unnecessary work? Is the source repository for tracking a history of changes or is it an art exhibition?The history is an end product intended to help others (often future me) figure out when and why things changed, preferably in self-contained, well organized steps. Often my first attempt at a change does something in an illogical order, or I make related changes that later end up in a separate merge. In the short term that change in thinking is somewhat interesting. In the long term it only confuses whoever is looking through the history to figure out why something is the way it is.The stronger version of this completely discards any history when merging a feature, but I often find that to get rid of useful i"	jorams	8.565124	-6.563401	comment	3.0	13.0	1699282706	-11.931873
38165251	I might be lucky but in my whole dev	"I might be lucky but in my whole developer life I have only used like 3 commands git stash, git pull --rebase and git merge. 
I'm not even sure I used git rebase once."	h1fra	8.569841	-6.550639	comment	3.0	12.0	1699290341	-11.925294
38165281	>  I still greatly prefer it to the 	>  I still greatly prefer it to the alternative, which is to have merge commits cluttering up the commit history.GitHub recently added a feature that prompts people to update their branches via merge. It's frustrating because every PR now had dozens of merge commits polluting the history.	richbell	8.5878935	-6.546924	comment	3.0	13.0	1699290456	-11.942242
38165485	Git rebase is stupid, I’ve seen coun	Git rebase is stupid, I’ve seen countless f ups because someone needed the git history to look good	m3kw9	8.571708	-6.5634713	comment	3.0	17.0	1699291239	9.374308
38165534	The way I phrase and teach what I co	"The way I phrase and teach what I consider to be the important rule of git is:> Don't rewrite history on shared branches with proper communication.I don't teach ""never"", I don't teach that `main` is special, I don't teach that force pushing is forbidden, because I don't believe in those things.I highly prefer a rebase-heavy workflow. In addition to not ""cluttering"" the history, it's an invaluable tool to keep commits focused on ""the right level"" of atomic changes."	ohwellhere	8.566718	-6.5484333	comment	3.0	18.0	1699291362	8.706815
38165763	> I die a little bit each time I try	"> I die a little bit each time I try to understand what changes were related to a line when tracking down a bugA change/feature/bug is a branch, which is squashed into a commit on your main branch, right?
So your main branch should be a linear history of changes, one change per commit.How does that impact the ability to git blame?"	diek	8.559291	-6.4959016	comment	3.0	16.0	1699292231	-11.906974
38165773	git-rebase is stupid because somebod	git-rebase is stupid because somebody doesn't know how to use it?I use it all the time and I really like how I can make garbage commits (wip, test) and then squash them into atomic commits which are easy to review and later on easy to bisect when inevitably mistakes happen. Sure I've fucked up too when I was learning on how to use it and those were some painful mistakes but only through using it and making those mistakes have I learned to use the tool to great advantage (clean history).	jzm2k	8.566492	-6.566603	comment	3.0	14.0	1699292280	9.36864
38165976	"""Clean history"" is not a principal r"	"""Clean history"" is not a principal reason for VCS. ""Full history so you don't accidentally lose something and can revert to any point"" is the principal reason. When ""clean history"" conflicts with ""full history"", the choice should always defer to the latter. Rebase clearly breaks the full history principle."	naasking	8.576997	-6.5596704	comment	3.0	16.0	1699293088	-11.913476
38166116	"> * ""fixing whitespace"" * ""incorpora"	"> * ""fixing whitespace"" * ""incorporate review comments"" * ""fix broken test"" * ""fix other broken test""Things like this should not be standalone commits though, they should be incorporated into the previous branch by amending the original work.  It takes some effort to have a useful git history, it does not just happen on its own."	gray_-_wolf	8.583581	-6.5399637	comment	3.0	10.0	1699293611	-11.873535
38166144	Random thought: given you already ha	"Random thought: given you already have the gcaa alias, perhaps you could include a check that .git/REBASE_HEAD doesn't exist in that?Probably easiest as a little shell function like    gcca() {
      local GIT_DIR
      if ! GIT_DIR=$(git rev-parse --git-dir); then
        return 1
      elif test -f ""$GIT_DIR/REBASE_HEAD""; then
        printf 'Rebase in progress: commit --amend is disabled\n' >&2
        return 1
      fi
      git commit -a --amend ""$@""
    }

rather than an alias?[Edit] I forgot about rev-parse --verify, which simplifies this further:    gcca() {
      if git rev-parse --verify REBASE_HEAD >/dev/null 2>&1; then
        printf 'Rebase in progress: commit --amend is disabled\n' >&2
        return 1
      fi
      git commit -a --amend ""$@""
    }

This also leaves you stil"	qhwudbebd	8.594652	-6.53109	comment	3.0	11.0	1699293713	-11.859026
38166203	> What matters is that you end up wi	"> What matters is that you end up with working systems. That a lot of change happened is just, well, what happened. It doesn't need to be prettied up and made to look like your development occurred in a clockwork march of cleanliness. It literally does not matter unless you spend a lot of time doing git-bisect.And git blame. And git checkout to a past state. It ""doesn't matter"" only if ease of understanding your project history doesn't matter."	FeepingCreature	8.569641	-6.5361958	comment	3.0	19.0	1699293945	-11.881234
38166479	I think squash merges are a last res	I think squash merges are a last resort heavy-handed tool for dealing with developers who refuse to clean up their commit history before merging. Most developers can do better by hand.This is too much thought put into a VCS. I don’t want to have to think about my VCS at all beyond the commit message. For all of Git’s popularity, I’ve never seen benefits that justify the absurd amount of work and knowledge it takes to perform simple actions. It’s the VCS equivalent of Scheme or emacs.	jimbob45	8.577507	-6.561704	comment	3.0	13.0	1699294888	-11.9330635
38166491	"I believe that you are confusing ""fu"	"I believe that you are confusing ""full history"" and ""true history"".Every single point in the commit history represents an actual state of a repository at a specific point of time, along with the information of which point or points were next before it. This is all part of the true history.This is not a full history - you don't have every keystroke, abandoned commit, switch between branches and so on. But nothing that you're being told is wrong.As soon as you do a rebase, you're rewriting history. You're claiming that there were specific points of time with specific states that never actually existed. You're losing information about points of time and specific states that actually existed, which someone once considered important enough to do a git commit over.The difference becomes importan"	btilly	8.568221	-6.546801	comment	3.0	14.0	1699294922	-11.910699
38166561	Have you ever had to use git bisect?	Have you ever had to use git bisect? That's really where a 'clean' git history is important. Plenty of people never use git bisect, and that's fine too. That said it's a very useful tool when you do need it, and can drastically simplify finding when and where a regression was introduced.	ecnahc515	8.577032	-6.523014	comment	3.0	10.0	1699295142	0.96265805
38166707	The point of a clean git history is 	The point of a clean git history is not to have a clean git history. The point is to make it possible to debug later, via bisect, or show, or even just a diff. The point is to make the workspace clean for the next guy.Instead of letting it go, maybe we should have more discipline and organization in our lives and not less.	duped	8.568998	-6.5368285	comment	3.0	12.0	1699295665	-11.894571
38166803	There's also a third way called reso	There's also a third way called resource groups [1]. We use that to ensure that we only run the newest job if we have multiple deployment jobs waiting for execution. This way even if we have multiple pipelines racing each other, only the last deployment job wins.[1] https://docs.gitlab.com/ee/ci/resource_groups/index.html	tsak	8.384232	-6.4811716	comment	3.0	13.0	1699296025	9.019817
38167838	> * enables use of git bisect to loc	> * enables use of git bisect to locate bugsThis is really only viable if each intermediate commit on a development branch is intended to be bug free. If that's the standard you and your team work with, that's fine, but it's not usually my standard; in a development branch, I may commit things that don't even compile, let alone work, if it's a good point to commit.	toast0	8.58759	-6.5381317	comment	3.0	50.0	1699299897	0.5973662
38167895	The point of the parent comment is e	The point of the parent comment is exactly that you should clean up the history before merging to a public branch, so that you can use bisect, even if so far you had wip wip doh wip as the commit messages. The way to get there is to have a mix of proper and wip commits.	bonzini	8.58107	-6.5454926	comment	3.0	47.0	1699300142	-11.923039
38169426	I’m firmly in your camp on this one,	I’m firmly in your camp on this one, but I’ve noticed that advocating a tidy history gets a lot of push-back online. I think there is an element of self-fulfilling prophecy here. If a team habitually leaves a messy history behind, that history is rarely going to be useful, so naturally the team has low expectations and sees little value in doing anything to curate it. And if a team isn’t used to making an effort to curate its history, they may assume that doing so is expensive because `git rebase -i` is scary and not something they use on auto-pilot for a few seconds at a time.In other news, our developers also create several small PRs every day but each is for an incomplete change that doesn’t stand alone so we’re never quite sure which features are finished in any given build, everyone k	Chris_Newton	8.542989	-6.506537	comment	3.0	18.0	1699306901	-11.8708
38172577	I prefer to have clear commits that 	I prefer to have clear commits that tell a tidy story. For example:* Refactor function `foo` to accept a second parameter* Add function `bar`* Use `bar` and `foo` in component `Baz` to implement feature #XIf you give me a commit history like this, I can easily validate that each step in your claimed process does what you describe.If you instead give me a messy history and ask me to read the diff, you might know that the change to file `Something.ts` on line 125 was conceptually part of the refactor to `foo`, but I'll have to piece that together myself. It's not obvious to the person who didn't write the code what the purpose of any given change was supposed to be.This isn't a huge deal if your team's process is such that each step above is a PR on its own, but if your PRs are at the coarse	lolinder	8.574432	-6.5619116	comment	3.0	16.0	1699325381	-11.888556
38173100	Honest non-snarky question . . . wit	Honest non-snarky question . . . with Git becoming an industry standard, what is the case for using Mercurial?  I'm asking because I've never used it or heard of anyone other than Meta doing so.	psunavy03	8.503117	-6.555635	comment	3.0	11.0	1699329690	-11.958156
38223071	Funny enough. I only use merge becau	"Funny enough. I only use merge because rebase makes no sense to me.As an aside, I think git complexity can arise for two reasons. One is legitimate, if you have hundreds or thousands of devs committing to the same repo regularly you need to have some order to the chaos otherwise it just will grind to a halt.The other is bullshit. Where some dev / management people believe that the git process needs to be complex for small teams due to the need to justify their place by ""promoting safety"". In small team environments, simple branching off of main and then committing prs directly to main is more than enough in my opinion.But git gives you the tools to go as crazy as you want, so some people do."	twosdai	8.579779	-6.553643	comment	3.0	20.0	1699643214	-11.935516
38223334	Note that three-way merge is much ol	Note that three-way merge is much older than git. It's implemented by the diff3 program, which was part of Version 7 Unix from 1979 on, and the same algorithm is used by CVS, Perforce, and pretty much any other revision control system. The GNU version is part of diffutils, and of course there's also a BSD version.	not2b	8.638544	-6.548234	comment	3.0	11.0	1699644439	-11.946422
38223624	Not who you're responding to, but I 	"Not who you're responding to, but I also understand merge more readily than rebase.  Your explanation doesn't really help.Applying a commit ""on another branch"" isn't really well defined in my mind.  In my understanding, a commit consists of one or more parent commits, and the complete state of a tree, including the entire contents of all the files in it.Maybe there are other ways to be confused, but all of the uncertainty has been shoved into that simple phrase ""apply a commit on another branch"".  What does that actually mean?"	recursive	8.593194	-6.5789256	comment	3.0	11.0	1699645762	-11.875555
38281915	This is why I refused to go along wi	This is why I refused to go along with the git master->main rename. Beyond being incredibly dumb and zero people being actually offended by this ever, if you get hyperstitious slur cascades in system identifiers that are hard-coded into a bajillion places, the result is an endless series of bugs and timesinks that will still be blowing up in people's faces a decade later.The worst thing about these cascades is that they make people who jump on them early incorrectly feel virtuous and powerful, and that's seductive. Allow them to get away with it and before you know it there's yet another attempt at starting a cascade, and then another, and then another, and suddenly everyone is at each other's throats all the time over nothing. This is how we end up with people being attacked at work for u	nvm0n2	8.524324	-6.491485	comment	3.0	17.0	1700079726	-11.840463
38284680	This reminds me of something hilario	This reminds me of something hilarious I saw on Facebook a few years ago. My graphic designer friend was joking about how she has a ton of PSD files in a folder with funny numbers, names, and notes in the filename.Then, a programmer swooped into the comments section and tried to sell her on the merits of using git for version control. LOL. I nearly died laughing.	thequadehunter	8.571854	-6.4384894	comment	3.0	10.0	1700096866	-11.868196
38286682	It's been 10 years and I still need 	It's been 10 years and I still need to look up the most basic things in git. It's just not intuitive to me at all.Had fossil recommended to me. Also read their fossil vs git page, and I found myself agreeing with everything they said.https://fossil-scm.org/home/doc/trunk/www/fossil-v-git.wiki	LAC-Tech	8.500991	-6.5443845	comment	3.0	12.0	1700119875	-11.999268
38371588	Any comments about what it does bett	Any comments about what it does better than git and mercurial?	culi	8.5120945	-6.5464563	comment	3.0	13.0	1700606821	-11.9306135
38371894	You have a weird/selective perspecti	You have a weird/selective perspective.As someone who has used all of them in different companies since the 90s: RCS was ancient, even in the early 90s. Most widely found in things like UNIX source trees.CVS came along later (mid/late 90s), and was much more widely used.SVN came on the scene around the late 90s -- it was a massive improvement on CVS, and spread across open source and most professional shops like wildfire. Major sites like sourceforge were built on SVN, but also supported CVS.Git only became prevalent starting around 2006-2008, and adoption was actually really slow because of its inherent complexity. When Github appeared, that was really when the shift started in earnest.There were others along the way: MS SourceSafe, a moment when everyone was toying with Bitkeeper, etc., 	timr	8.597637	-6.4658585	comment	3.0	11.0	1700608205	-11.879416
38372073	> Originally, separate clones was th	"> Originally, separate clones was the recommended way to do ""topic branches"" in MercurialThis is still what the Guide on the Mercurial site mentions as the ""basic workflow"" for working on separate features. Named branches are considered ""advanced"", and bookmarks are an afterthought entirely.About 10 years ago, after reading a lot about how hg was more intuitive than git, I decided to give it a try. I was already using git branches a lot, so this was definitely not a good first impression."	jorams	8.513536	-6.55273	comment	3.0	12.0	1700609108	-11.939867
38372496	> Aside: I prefer Mercurial myself, 	"> Aside: I prefer Mercurial myself, and I hope to keep using it for personal projects until I die (:One of my favorite stories happened three or four jobs ago... at this job I kept a giant whiteboard that I had swiped from a conf room, behind my cubicle. And whenever anybody asked questions we put it up on the board. We were an SVN shop and someone had asked how Git worked and I was like ""do you want me to explain Git, which is harder to understand, or Mercurial, which is basically the same but a little easier if you're coming from SVN?"" and they said Mercurial. So that is how for a week or two a set of sketched diagrams sat around behind me describing Mercurial.So while that was happening, I was in the middle of some big commit, this guy Cal comes over. Cal is, we'd classify him as nontec"	crdrost	8.517738	-6.543379	comment	3.0	11.0	1700611463	-11.960874
38373125	Git functionality is great. But the 	"Git functionality is great. But the CLI just kind of grew in a nonsensical way. No serious effort seems to have been made on UX consistency and verb/noun names.People who've been using it for years don't notice, they don't even think about it. But when coming from scratch, it's anything but intuitive. The CLI is not discoverable in a reasonable way.That and there's so many ways to use it.Mercurial had the advantage of having a much more consistent UX. Though these days I'm sure I'd struggle with it, because I'm so used to git.Mercurial was never trying to ""replace"" git.  All of these guys came out at the same time. Git got headspace because Linux used it and GitHub was a ""cool"" Ruby on Rails site, run by cool web 2.0 kids, same era as the rise of Twitter, etc. (And also down all the time, "	cmrdporcupine	8.525635	-6.563202	comment	3.0	12.0	1700614856	-11.907504
38393511	protip: If you want to switch branch	"protip: If you want to switch branch you can now use ""git switch [-c] foo"". If you want to restore files you can do ""git restore ."".Basically you can stop using checkout.*edit*: fixed switch branch creation parameter."	sbergot	8.551837	-6.5328503	comment	3.0	12.0	1700752047	-11.903512
38393532	I'm still missing what part of the i	"I'm still missing what part of the intuition is incorrect? It seems like the only ""incorrectness"" is that there's no explicit hierarchy of branches. Except that's wrong the HEAD ref points to the default branch. Any other branches are of equal significance, though."	webstrand	8.596051	-6.5659766	comment	3.0	12.0	1700752199	-11.851192
38393597	"Git doesn't have the concept of ""mai"	"Git doesn't have the concept of ""main is special"", but at least tools like Gitlab have protected branches to stop you screwing up too much.Some concept of ""parent"" and ""child"" branches would actually be pretty interesting. You do have to support multiple ""parent"" branches though for long term support branches."	rkangel	8.520477	-6.5262284	comment	3.0	14.0	1700752505	-11.809872
38393718	I have found that git makes a lot mo	"I have found that git makes a lot more sense if you reverse the mental model of lineage. People think about a lineage going forward. But a more useful way to think is in terms of backward pointers.A commit points to it's parent(s). Since a branch is just a commit ID, you can follow the parent links backwards to find the whole history of that branch.So a ""branch point"" is just where two chains of parent links converge.The special part are merge commits. Those have multiple parents, indicating that two histories fused into one."	mtnygard	8.553098	-6.546822	comment	3.0	25.0	1700753133	-11.86677
38394101	Git stores snapshots and that’s it. 	Git stores snapshots and that’s it. The whole tree, not per-file.As to why Linus doesn’t like storing file moves: https://public-inbox.org/git/Pine.LNX.4.58.0504150753440.721...	keybored	8.6007595	-6.4926014	comment	3.0	11.0	1700754846	-11.81968
38396170	I have to serious ask. Of the people	I have to serious ask. Of the people who have issues with using or understanding git, how many of them have actually read the docs?Git is by no means perfect but the development community is great and there is a massive focus on improving the project and making things more approachable and intuitive.And because of that, git actually has really solid, coherent documentation with easily digestible tutorials and guides for all the things you need to do.So it always hurts me when I see people ranting and raving about how awful git is, how it can't do x, or how it doesn't make sense how it works but then you send them the guide or tutorial hosted on the git-scm website and suddenly it makes sense.Not to be beating the RTFM horse but RTFM guys.	jacoblambda	8.515883	-6.4996104	comment	3.0	14.0	1700765862	-11.904041
38400447	With all due respect, what a load of	"With all due respect, what a load of crap!SVN, branching that takes forever instead of a simple file with a commit hash in it? Are you serious?Mercurial, when I had to use it for almost 2 years? The single thing I missed the most is the fact that ""everything is just a label"" (or pointer if you will).Fossil I can't comment on with certainty, as I never really used it.This is probably gonna get voted into oblivion, but most devs just don't get VCS, period (yes I'm a dev, so this is an inside perspective). Git or not. They didn't get it in CVS days, they didn't get it in SVN days and they didn't get various commercial ones either. Somehow most devs just don't grok version control trees.But so far git is the single best VCS I have got to use. Everything that I actually need day to day follows "	tharkun__	8.558061	-6.4983606	comment	3.0	12.0	1700797039	-11.90578
38415970	> `bzr log` only shows commits direc	"> `bzr log` only shows commits directly on that branch. So if you are looking at the master branch that has commits A, B, and C, if someone goes off and works on D and makes commits D1, D2, D3, when D is merged into master, you now just see A -> B -> C -> D, where D is everything from D1+D2+D3.I think Git supports this with ""git log --first-parent"", to show only the merge commit, doesn't it? That's what I gathered from a discussion here some time ago on branching strategies."	ptx	8.5801935	-6.5484595	comment	3.0	19.0	1700940991	-11.911199
38417000	As a very satisfied long time Git us	As a very satisfied long time Git user who also ends up being its biggest advocate and trainer at any organization I end up at... no, it's not easy.It's easy from the perspective of someone who already understands its conceptual model, which is wonderfully elegant. It's not at all easy for beginners.The happy path is fine for the most part. There are several conceptual hurdles to developing basic competence with add, commit, push, and pull, but usually people are able to push past them and get to the point of using those commands even if their purpose and mechanism of action remain mysterious.But things immediately go to hell if something deviates from the happy path. Have you ever seen a beginner try to wrap their head around a merge conflict? Have you ever seen someone try to puzzle thro	nerdponx	8.558101	-6.517662	comment	3.0	10.0	1700948769	-11.907716
38426051	> Go learn vcpkg and come back to us	> Go learn vcpkg and come back to us when you learn why everyone does it this way.What reason do you have in mind?  Can you articulate it in a way that can be quantified/falsified?The last time I pressed someone on HN about this[1], it quickly devolved into vague handwaving[2] of the same sort—that we all already know why so we don't have to talk about it.(Asking because I thought I knew, and then one day I realized I couldn't actually explain it, at least not in a way that I could be confident that everyone else would actually agree with.  It feels a lot like the hand of Ra[3] is at play.)I'm curious to hear from anyone who thinks they know why or can perhaps point to where they've already explained it.  I'm particularly interested in responses from people who deal with NPM.  (What is the	cxr	8.585163	-6.507646	comment	3.0	24.0	1701039999	-11.894407
38528386	Magit has a really easy to use way t	"Magit has a really easy to use way to ""step"" through previous versions of files. It's usually bound to something like ""C-f p"". You get a read only buffer of the previous version open in the best text editor (emacs). You can then press n and p to step through next and previous versions of that file. Can be pretty useful!It's kind of funny, I think, how most git users don't seem to know how to access any version other than the current one. So many people think of it simply as the annoying tool you have to use to make code changes but don't really know what version control is."	globular-toast	8.593819	-6.4948115	comment	3.0	28.0	1701765881	-11.855661
38528981	That’s a pretty cool feature of Magi	"That’s a pretty cool feature of Magit.I was inspired to look for something similar for the next best text editor (vim) and came across this: https://salferrarello.com/using-vim-view-git-commits/    git log | vim -R -

Placing your cursor over a commit hash and entering K displays git show for that commit."	divbzero	8.585387	-6.5004206	comment	3.0	24.0	1701771192	-11.871075
38545354	How do you “git gud” at this sort of	How do you “git gud” at this sort of troubleshooting?I’ve built about a dozen synth modules over the last couple years and I’d say about half of them actually work 100% as intended.  I’ve stopped building new modules because my success rate is so abysmal and I’m pretty stuck on the basics for troubleshooting.I do flux and reflow any joints that look sus and I test with my meter to make sure that pins on chips don’t unexpectedly go to ground or +/-12v per the data sheet but that’s about the extent of my skills.Any resources or tools to get better at this sort of thing?	jnovek	8.597715	-6.483787	comment	3.0	13.0	1701877523	-11.871924
38590330	To be honest, I can’t even imagine w	To be honest, I can’t even imagine what you imagine “git save”  and “git update” would even do in an alternate universe.	zadokshi	8.545008	-6.448921	comment	3.0	12.0	1702200467	-11.871183
38590348	The inner workings of git are not ov	The inner workings of git are not overly complicated. The real problem is git only provides a thin layer on top of the inner workings. It’s not git that needs replacing, (it’s just saving blobs of data) it’s the user interface on top that is confusing.  The problem with simplifying the user interface is that abstracting away the complexity is super difficult.	zadokshi	8.550529	-6.5067573	comment	3.0	11.0	1702200702	-11.915846
38590414	Besides the frontend problems with g	Besides the frontend problems with git that everybody talks about, the backend could be improved. It's now line-oriented. It would be more useful if it knew about the semantics of the language you were writing so it could show you semantic differences. That might also provide a mode for binary files which git doesn't handle very well now.	dreamcompiler	8.560166	-6.4853	comment	3.0	15.0	1702201519	-11.878772
38590467	In my opinion the feature Git has al	"In my opinion the feature Git has always been missing is version control of branches. Of course the immediate consequence would be that you'd be able to roll back changes to branches but there'd be some more fundamental consequences as well. I'm pretty sure some of the problems with GUI's/wrappers around Git break down because there's no tracking of branches/tags.Besides that it's pretty much endgame in my opinion if you consider only the functionality it's meant to solve. If another ""better"" VCS would ever become popular I feel it would have to be a drastic change to the way of working with VCS, even more drastic than SVN to Git was. There's some cruft in Git that could probably be taken away, and that would make Git better in a theoretical sense, but in the real world that would never ha"	tinco	8.599719	-6.4386725	comment	3.0	11.0	1702202085	-11.847057
38592863	Does Git LFS help with this problem?	Does Git LFS help with this problem?	syndicatedjelly	8.5759945	-6.4513836	comment	3.0	12.0	1702227074	-11.944698
26920947	The article claims that GitHub doesn	The article claims that GitHub doesn't support this workflow, but it actually does a pretty good job natively. In particular, if PR2 targets PR1, merging PR1 into master will automatically change the base branch of PR2 to be master, and PR2 will then be able to merge cleanly. I suspect this might not work as cleanly if you rebase or squash as the merge method, since you're destroying the historical information that git would have used to figure out what's going on.	HALtheWise	8.590478	-6.530007	comment	3.0	13.0	1619224461	-11.904919
26920992	While working on PyTorch, I also wro	"While working on PyTorch, I also wrote an equivalent tool (funnily named nearly the same thing) for doing stack diffs (https://github.com/ezyang/ghstack/), which most of our team uses for more complicated PRs.  The UX for working on commits is a bit different than this tool though; instead of pushing branches individually, you just run ""ghstack"" on a stack of commits and it will create a PR per commit in the chain (amending each commit so that its commit message records what PR it corresponds to). To update the PRs, just amend or interactive rebase the original commits. Personally, I find this a lot easier to handle than finagling tons of branches."	ezyang	8.599793	-6.4718833	comment	3.0	14.0	1619224763	-11.918751
26921290	I highly suggest reading my article 	I highly suggest reading my article on How we should be using Git. It covers a Git Patch Stack workflow, where it originated from and the tooling we built around it.It has important ties to how the Linux Kernel and Git dev teams work as well as breaks down the benefits in relation to CI as a methodology.https://upte.ch/blog/how-we-should-be-using-git/	cyphactor	8.562768	-6.444561	comment	3.0	11.0	1619227115	-11.939436
26961314	All the examples[1] are about the in	"All the examples[1] are about the index.  And indeed, the index is probably a feature that should have been optional.  While it's supremely useful for maintainer-side operations (splitting patches, picking out parts of them, committing only the meat of a patch and not debug code, etc...) it's really not useful for a typical new user.  At all.  New users would be best served by a ""commit"" variant that simply updated the HEAD commit in place.[1] Actually not the last one.  I couldn't figure out what they were talking about.  ""Only committed versions of a file can be part of a branch"" -- I mean... duh?  Branches are a DAG of committed trees. I don't understand what they're asking for when they complain that the working version of a file can't be part of more than one branch.  It's not part of"	ajross	8.593438	-6.5625577	comment	3.0	44.0	1619556521	-11.907428
26961613	This is the workflow I follow, but m	"This is the workflow I follow, but my experience is it's pretty high-mental-overhead in practice - Git doesn't draw a distinction between commits that I created because I'm still working on something and want to switch branches, and are therefore reasonable to modify, and commits that came from some remote source and which you want to keep intact. They're both ""commits."" That means you, the user, have to keep track of which is which and think about which Git operations might disturb the wrong type of commits.I'd like Git to have a mode where, say, git rebase -i won't show me published commits by default, only work-in-progress ones. (This isn't necessarily the same as ""commits since the remote branch we're tracking,"" since it's possible to end up tracking a branch that's behind for some rea"	geofft	8.541117	-6.5658083	comment	3.0	11.0	1619557893	-11.881241
26961838	My biggest complaints with git is mo	"My biggest complaints with git is more around how it is difficult to throw away changes and how ignoring files is such a stateful process. I almost never need something nearly as specific as ""git checkout"" or ""git reset"". I generally either want to throw everything away up to the last local commit or I want to throw away everything and get my version to be the same as the branch on the server/another local branch. If I need something more fine grained, I will still do this, just on a per file basis. At no point have I ever wanted to just get rid of untracked files.That leads to my next point about ignores. I hate that I have to manually untrack a file even if it would be ignored according to a new ignore file. The best practice there in my opinion would be to explicitly exclude said file I"	slaymaker1907	8.607354	-6.4853115	comment	3.0	21.0	1619558969	-11.868554
26962888	I worked at a company that used Perf	I worked at a company that used Perforce. It took 2 weeks to get a branch created. No thank you.	icedchai	8.618023	-6.5141835	comment	3.0	14.0	1619563361	13.831043
26963205	"Really not defending perforce, but """	"Really not defending perforce, but ""branches"" are not how you usually work, a branch is basically a fork of the repo, it's almost impossible to reconcile.""Branches"", the way we use them in git are more like perforce Shelved CLs."	dijit	8.610105	-6.515346	comment	3.0	10.0	1619565155	13.83731
26963745	> Competing systems like MercurialTo	> Competing systems like MercurialTo clone Mozilla Firefox, Mercurial requires you have more than 2 Gigabytes of RAM. Not Firefox, Mercurial. Simply because the version history is so large, it requires over 2 Gigabytes of working memory to properly interact with enough to put a current clone of the repo on your computer.	fao_	8.531859	-6.4754157	comment	3.0	12.0	1619568191	-11.891717
26961979	I have a dedicated shell script for 	"I have a dedicated shell script for each thing I do in git, because it is impossible for me to memorize the original syntax and I'm terrified I'll gut the repo by getting a flag wrong. I have an ""undo"" script, that just gets rid of unstaged changes, a branch deletion script for removing local & remote branches, and so on. I just take my scripts with me everywhere I go. They're not ingenious, just a necessity. I advise doing this.People like to tell me, ""Oh see you just need to understand that git has something called a 'directed acyclic graph' blahblahblahblah"" and no, that has nothing to do with it. It's just incredibly arcane and bizarre syntax for the most obvious everyday operations. But since my scripts make life easy, I sort of don't care at this point.Also I don't rebase and thus I "	kerblang	8.556031	-6.515121	comment	3.0	24.0	1619559492	-11.898464
26963958	I'm not saying staging should go awa	"I'm not saying staging should go away. I'm saying it should work in reverse.Instead of having all the changes in your working directory and commit some temporary state not reflected in the working directory, I'd like to move my changes into a temporary area and then pick the lines into my working directory and commit that.That way I can compile and run tools etc on the code that will be committed before committing.If I'm not ready to commit everything, I could then stop the ""commit mode"" and my uncommitted changes would be brought back into the working directory.At least that's what I dream of."	magicalhippo	8.646888	-6.559344	comment	3.0	12.0	1619570135	-11.921384
26966409	This is a lot to address but please 	This is a lot to address but please consider all of the facts.There are hooks for pulling and whatnot. This is a vector for malicious code execution.Not everyone has a GUI system (window system).Git _has_ to be able to expose low level commands while still being usable.Decentralization is a _good thing_ when it comes to git. It is directly one of the goals of open source software, for which Git was built.You can configure all of these things for your team provided they run an init command at least once. Then set up your system however you like via hooks that automatically run to update their configs as necessary.Remember, your development process is not my development process. Also, not every system that clones a repository wants to run hooks. Git shouldn't force them to.You can 100% enfor	junon	8.552353	-6.4792624	comment	3.0	11.0	1619591963	-11.918279
26967703	I think what's often overlooked is t	I think what's often overlooked is that git wasn't created as a general solution to version control, but for the specific needs of Linux kernel development.Game development is pretty much on the opposite end of the spectrum, 99.9% of game project data isn't text (maybe not by number of files, but definitely by file size), and game development also traditionally isn't as extremely decentralized as Linux kernel development.The problem isn't git, but that it has become so popular that it's now the defacto standard version control system, and people expect it to work for scenarios it wasn't created for (at least people who don't know much about the specific workflow requirements of large-scale game development).	flohofwoe	8.577129	-6.4646506	comment	3.0	11.0	1619604862	-11.873781
26982932	One thing I've found nano useful for	One thing I've found nano useful for: git commit messages.If the commit file is empty, that cancels the commit. Nano will tell me how many lines it actually wrote, so if I have second thoughts I can cancel with certainty. Nano may well not be unique in that regard, but I tripped over another editor that saved what I thought was an empty file as a single line with just the EOL character.	jejones3141	8.599782	-6.5310183	comment	3.0	11.0	1619712364	-11.884682
26997970	I would agree with your points if no	"I would agree with your points if not for the fact that ""clean up commits"" or ""typo fix"" is a necessary result of PR's.Your teammate will request changes in your code, and the only way to cleanly communicate ""yes I made that change, and ONLY that change"" is through these clean-up commits.Otherwise, if you amend/force-push or open an entirely new PR, 99% of the diff are things that your team has already seen and reviewed.Squash merges let you clearly communicate how you addressed PR comments, while also keeping the master history clean."	scott0129	8.577341	-6.564242	comment	3.0	15.0	1619810065	-11.94175
26997974	I do agree that PRs should have a cl	I do agree that PRs should have a clean history. However:- Services like GitHub allow you to restore the original branch, so you never actually lose history. So I don't see any major drawbacks of squashing on merge.- If your PRs are several thousand lines long, they probably should've been broken up into multiple PRs (your reviewer will appreciate it)	ginja	8.57904	-6.552538	comment	3.0	14.0	1619810085	-11.909918
26998014	Generally, time spent twiddling with	Generally, time spent twiddling with the repo is time not spent delivering code. It's a distraction. Yes git has all these features that lets you do that and those feature matter when you're committing to the Linux repo which has thousands of eyes and your commit history has to help you communicate to a very wide audience. But the vast majority of us are not using git like this. I've used git bisect so rarely all this is overkill.	nickbauman	8.557658	-6.454548	comment	3.0	12.0	1619810315	-11.862868
26999261	Squash was the thing that convinced 	Squash was the thing that convinced me that the emperor has no clothes.  Realizing that I was going to either have to train every junior, every four-month community-college student brought in on co-op to modify their history in an awful UI with tons of gotchas, or I would have to accept the downsides of squash?It's so stupid.Git desperately needs a layer above the commit that groups related commits together into a semantically commit-like object that you can show in history and jump to its HEAD and  cherry-pick.  Because the squash is a dumb hack, and meticulously editing your history is not productive work.I want squash.  But I want squash without all the boneheaded implementation-detail downsides of squash.  I want squash where I can put up a PR and keep working and then not have to deal	Pxtl	8.570817	-6.573219	comment	3.0	11.0	1619816461	-11.948909
27000893	You have apparently never had the be	"You have apparently never had the benefit of a properly run git repository.Our master has straight history. We always rebase to merge a PR and we have build scripts that check this as well. You will not be able to merge a PR that tries to get more than one commit onto master, if the commits touch more than one of the modules (we have a monorepo with lots of individual services). Until the PR has been approved we leave individual commits on the branch though as that can be helpful.I have not had to ""mess"" with rebases ever. Most rebases apply cleanly and if they don't the conflict resolution is mostly very easy. The 'hardest' conflicts to solve were actually in the end the easiest to solve, because all you had to do was to `git rebase --skip` the appropriate commits. Of course some develope"	tharkun__	8.585107	-6.552536	comment	3.0	18.0	1619825169	-11.917736
27024316	My favorite one liner for a pretty a	"My favorite one liner for a pretty and compact graph-like git log:  git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n'' %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all

Add a global alias:  git config --global alias.lg ""log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n'' %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all""

Usage:  git lg"	lqet	8.603767	-6.518283	comment	3.0	10.0	1620045867	-11.863431
27042530	>  Complicating matters, programmers	">  Complicating matters, programmers can struggle to adapt standard version-control workflows to the fast, iterative nature of data exploration. As a result, crucial experimental details can be lost.>  ""Somebody will say, oh, did you try this in the model, or did you try this analysis?"" she says. Many times, the answer is yes, but because the analysis didn’t work, the code is deleted. ""What you want to do during the meeting is just pull it back up and be like, oh, yeah, I did, and here’s why it didn’t work. And our tool lets you actually do that.""Errrrr... Slightly confused as git tags help with this already?`git tag -a <tag-name> -m ""<full description of what this tag is all about>""`"	dijksterhuis	8.585727	-6.4750905	comment	3.0	10.0	1620160359	-11.869541
27135548	A side topic: is there a concrete re	A side topic: is there a concrete reason why github's LFS solution has to be so expensive?IIRC, it's $5 per 50GB per month? That's really a deal breaker to me and wondering whether people actually use LFS at volume will avoid LFS-over-GitHub.	goodcjw2	8.56374	-6.4495635	comment	3.0	29.0	1620856016	-11.923319
27135663	Is rewriting the history for large r	"Is rewriting the history for large repos really that difficult besides coordinating with other contributors? My understanding is that it shouldn't be that much worse than ""git gc --aggressive"". Yes it is expensive, but it is the sort of thing you can schedule to do overnight or on a weekend."	slaymaker1907	8.580483	-6.523591	comment	3.0	12.0	1620856761	-11.878257
27135968	git-annex is an interesting alternat	git-annex is an interesting alternative the HTTP-first nature of Git LFS and the one-way door bother you.You can remove it after the fact if you don't like it, it supports a ton of protocols, and it's distributed just like git is (you can share the files managed by git-annex among different repos or even among different non-git backends such as S3).The main issue that git-annex does not solve is that, like Git LFS, it's not a part of git proper and it shows in its occasionally clunky integration. By virtue of having more knobs and dials it also potentially has more to learn than Git LFS.	dwohnitmok	8.573057	-6.4610434	comment	3.0	16.0	1620858736	-11.905929
27136942	I despise LFS.I’m sure that if you k	I despise LFS.I’m sure that if you know how to use it... maybe... you can figure it out.That said; here’s my battle story:Estimate the time it’ll take to move all our repositories from a to b they said.Us: with all branches?Them: just main and develop.Us: you just clone and push to the new origin, it’s not zero but it’s trivial.Weeks later...Yeah. LFS is now banned.LFS is not a distributed version control system; once you use it, a clone is no longer “as good” as the original, because it refers to a LFS server that is independent of your clone....also, actually cloning all the LFS content from git lab is both slow and occasionally broken in a way that requires you to restart the clone.:(	wokwokwok	8.572866	-6.462463	comment	3.0	14.0	1620865643	-11.9029455
27142246	Show HN: Search 1M Linux kernel comm	Show HN: Search 1M Linux kernel commit messages	jabo	8.602091	-6.4977417	story	3.0	19.0	1620914865	-11.880067
27277269	Looking forward to using the new rel	"Looking forward to using the new release. ""git at the speed of thought"" describes magit quite well. Actually sometimes magit nudged me into the direction of looking up some more special git commands, to learn about them and then making use of magit's interface to them, often simply pressing one button more. Magit has not made me forget how command line git works, because it often shows me right there, what the arguments are I am specifying by a few key presses actually are. If it made me forget how to use actual git, I would be thinking: ""Meh, but I should know how to use git actually, for the times when I do not have magit around."" Fortunately this is not the case at all with magit."	zelphirkalt	8.590827	-6.4961877	comment	3.0	13.0	1621953116	-11.834731
27277809	I think most of what martin says is 	I think most of what martin says is rubbish, but this is not. I have never had `git blame` fail...ever.  I know what user is responsible for every line of code. Doing this is contemporaneous. Its right up there with commenting out blocks of code so you don't lose them.	SassyGrapefruit	8.5718565	-6.4974875	comment	3.0	24.0	1621955298	-11.8932295
27293489	most game studios don't use git to m	most game studios don't use git to manage their games. It's becoming more common but it is by no means a standard in games. The git integration in UE4 is very, very bad. It uses perforce terminology to describe git concepts, often to very confusing ends.	zemo	8.51535	-6.4542723	comment	3.0	12.0	1622050194	-11.852577
27307920	I’d say that highly depends on your 	"I’d say that highly depends on your habits and how your brain works.
Some people prefer to focus on one topic at a time, have their current branch open, and choose not to give in to opportunistic edits if unrelated to the task at hand.Others prefer to work their way through a piece of code for example from top to bottom, making opportunistic edits along the way, even if unrelated to the task. Not having to switch branches can be convenient in that case.I’m 100% in the latter team.
Near the end of a coding session, my `git diff` often shows three or four completely unrelated sets of changes. Some might call that a rather unproductive and annoying way to work. But I really love it that way. My brain just _craves_ to fix that typo or convert that tab to spaces right away, even when I’m suppos"	Hackbraten	8.603803	-6.569092	comment	3.0	10.0	1622147108	-11.891593
27345976	Sourceforge is one of the few left t	Sourceforge is one of the few left that support Mercurial, which I use.	geraldbrandt	8.500062	-6.543703	comment	3.0	11.0	1622480039	-11.962845
27349802	Just spitballing here: what if we se	Just spitballing here: what if we selectively notified users of updates when they'll be affected? So, when I'm using my spreadsheet program, and I go to sort the rows, a little note pops up informing me that there's a bug in sorting non-ascii characters that was fixed recently and would I like to update my word processor now or continue anyway?I'm imagining some automated tooling where changelogs are tied to specific git commits, and when you go down a code path that has a changelog entry tied to it in this way, it pops up the dialog. The program downloads the changelogs in the background (if the user chooses), but doesn't pop up a notification unless it's relevant to the user.	smichel17	8.608851	-6.4677253	comment	3.0	12.0	1622509921	-11.876751
27433876	This looks really interesting. I rea	This looks really interesting. I read through the docs on the site though, and it doesn't say anything about diffs and merges. Those are fundamental VCS operations so I hope it supports them. I recognize merging is complex for 2d/3d files but if it claims to be a VCS then I'd think it would have to support it, otherwise what use are branches?	darkstarsys	8.718653	-6.4747863	comment	3.0	11.0	1623153041	-11.787174
27493126	Definitely helped a bit. I just grad	Definitely helped a bit. I just graduated from university and am working full time as a developer now. I thought I knew how to use git because I knew how to do feature branching and merging. Boy was I wrong. Within a few weeks at my new job, I've realized that I'm missing so much useful git knowledge. When I learned about cherry-pick, my mind was blown.My goal right now is to develop a better mental model of git than what I have right now. If anyone has recommendations for resources, please let me know!	jjice	8.545262	-6.4954157	comment	3.0	12.0	1623595953	-11.876824
33488451	Again, he has a genius method:  git 	"Again, he has a genius method:  git log --author=""$EMPLOYEE"" -p | wc -l"	rhinoceraptor	8.570001	-6.4811897	comment	3.0	11.0	1667704062	-11.871032
33520227	Ask HN: Change Control for Non-Coder	Ask HN: Change Control for Non-Coders	SentinelLdnma	8.742096	-6.4824677	story	3.0	3.0	1667922356	-11.74159
33533621	Just learn Git. It's really not that	Just learn Git. It's really not that bad. Don't _ever_ make someone use Rebase without their understanding of what that really means.	krossitalk	8.568247	-6.5621223	comment	3.0	11.0	1668010127	9.380389
33533637	I don’t get why everybody wants to r	I don’t get why everybody wants to rebase their topic branches. Just use merge, come on. If you want a „clean“ commit history on main/master do a squashed merge into main at the end.This way we never had to force anything on the remote.	G3rn0ti	8.597705	-6.5720196	comment	3.0	18.0	1668010190	-11.933803
33534648	I mentally categorise `commit --amen	I mentally categorise `commit --amend` right there next to rebase personally. When people debate about rebasing and rewrite of history, I include `--amend`. Maybe I'm unique there though.	cnity	8.577242	-6.55743	comment	3.0	11.0	1668013950	-11.917025
33534489	I understand the sentiment, but sinc	I understand the sentiment, but since git is probably one of the longer-lasting constants in our industry (if not the longest-lasting constant), I personally think it's really worth to have a bit of a look into it.Something I wish someone suggested to me years ago: Instead of trying to understand the commands, try to understand the datamodel. A branch is just a pointer to a commit, a commit is just a pointer (with metadata) to a tree, a tree is just... and so on. Once you understood this (which really isn't any harder than, say, understanding how quick-sort works), going from the data-model to the commands is fairly easy, almost intuitive if it weren't for all the convoluted options that each command can take.Anyway, not trying to convince you or anything, just saying that I've been in you	Shacklz	8.542182	-6.4995337	comment	3.0	12.0	1668013325	-11.888941
33537732	This is an excellent explanation, th	"This is an excellent explanation, thank you.Still, I have questions. When I have topic checked out then run ""git rebase -i main"" does it first do fetch (or whatever) to make sure main's latest commit history is represented? Or is it up to me to do that first?The rebase concept is sound, but the semantics are a bit daunting.  git rebase -i main

This sounds like an operation is being performed on main. Terrifying! And ""rebase"" is a scary word choice regardless. Perhaps you remember when you were new to Git and can relate.I may give rebase a try at some point, to see if perhaps it might speed me up. The vast library of Git commands is a bit much for me though. It's like using an aircraft cockpit to control the television!"	MetaWhirledPeas	8.568387	-6.5744348	comment	3.0	10.0	1668027534	-11.955526
33538772	Git's interface is like the 'find' U	"Git's interface is like the 'find' UNIX command: it makes complex things possible, but does nothing to make common ones easy. 99% of times I want to find a file in the current directory or below:  find . -name foo -print

Can you spot the 3 obvious arguments that find shouldn't require me to type?Similarly, if so many users add -a to their git commands, why is this relegated to such an ugly flag?"	teo_zero	8.62569	-6.4805017	comment	3.0	10.0	1668032159	-11.812429
33542592	That's not a bad idea. Pushed wrong 	That's not a bad idea. Pushed wrong is pretty hard to recover from (since you often aren't allowed to rewrite history on the remote), so I don't think there could be an easy 'undo' action for that, but the other ones could potentially be done.	stephen_g	8.555678	-6.536123	comment	3.0	14.0	1668057904	-11.817484
33596480	For me, even though I had a superfic	For me, even though I had a superficial understanding of git, it was finally after going through the first few chapters of the Pro Git book that things finally clicked, and I literally sat there wondering how I managed to code anything at all without using git for years.> For programming it was How to Design Programs at www.htdp.orgI already have over 4 years of professional software engineering experience (mostly backend web development). And before that I've been coding as a hobby for like 8 years prior to that. I'm pretty good with C, python, and PHP, though I'm familiar with plenty of other languages. I also know a little bit of Haskell.For a person like me, is HTDP worth it? I had started with it previously but I found it a little boring. But I know the book is well regarded so I'm wo	2143	8.537691	-6.479029	comment	3.0	11.0	1668443284	-11.941077
33613974	Meh. If it has mercurial's revsets i	"Meh. If it has mercurial's revsets instead of gitrevisions(7) I'm game, I'll happily give up the staging if I don't need to open that manpage ever again.edit: yep, so long git   check if a given commit is included in a bookmarked release:
      sl log -r ""a21ccf and ancestor(release_1.9)"""	masklinn	8.572756	-6.5378475	comment	3.0	18.0	1668541386	-11.92433
33614071	It's simply not necessary to have th	It's simply not necessary to have that feature. Sapling encourages regularly committing and amending commits rather than staging changes.It's also easy to commit / amend part of your work by selecting the lines to include in nice curses interface (--interactive).	mitrandir77	8.632895	-6.524999	comment	3.0	18.0	1668541789	-11.862601
33614255	To use a similar featureset but in t	To use a similar featureset but in the same Git repository you normally use, you can try my https://github.com/arxanas/git-branchless. Then, you can use your usual staging workflows if desired, or use regular Git commands directly.Its design is inspired by Sapling, and, in fact, it uses some of the same code, such as the segmented changelog implementation. Possibly some of its ideas made their way back to Meta, such as interactive undo?Jujutsu also supports colocated Git repositories: https://github.com/martinvonz/jj. It also has the working-copy-as-a-commit idea and conflicts are stored in commits (so rebases always succeed). I think it's a step forward compared to git/hg/sl.	arxanas	8.581225	-6.5208235	comment	3.0	20.0	1668542644	-11.918437
33614427	Instead of `git add -p`, you would u	Instead of `git add -p`, you would use `sl commit -i` (whose interface I much prefer). To amend into a previous commit, I prefer to switch to it and then just use `sl amend` (+ `sl restack` if necessary), but you can also use `sl fold` IIRC. Instead of `git rebase -i`, you can use `sl histedit` (not a direct replacement for autosquashing, but worth mentioning).To split a single commit, you can use `sl split`, which is quite difficult in Git. (I miss that feature in Git quite a lot.) You can also use the `sl absorb` command to automagically merge local changes into the previous patches where they seem to belong (roughly speaking, commute changes backwards until they would cause a merge conflict, but it's a little smarter about avoiding certain merge conflicts).	arxanas	8.567604	-6.5607967	comment	3.0	13.0	1668543463	-11.895282
33614503	It's really just a matter of habit a	It's really just a matter of habit and getting used to no staging area takes short and has huge benefits.We develop HighFlux[1] which also gets rid of the staging area. It simplifies your mental model of what's going on a lot.Because everything you save is automatically committed, switching to a different task/branch is also always instant without needing stash.Because what you're testing locally is what you're committing, I also never have CI failures anymore (with the staging area I frequently had unexpected interactions with unstaged changes and sometimes even accidentally forgotten added files).1: https://highflux.io/	thijser	8.709297	-6.5719748	comment	3.0	20.0	1668543774	-11.920947
33614311	I agree it's not necessary, but i li	I agree it's not necessary, but i like having it because it lets me separate what's going to be added before i actually commit.I still commit small, frequent. But i like `git add -p` to skip debug lines, hardcoded conditions, etc. I don't want to mistakenly auto commit a whole pile of lines and then have to remove debugs/hacks/etc from things i've committed.Stage + Unstaged is my working area, and the two live together quite nicely to me personally. I could live without it, definitely.. but i'm not sure i'd want to.	lijogdfljk	8.588469	-6.5163865	comment	3.0	13.0	1668542938	-11.879302
33615265	"My brain immediately jumped to ""but "	"My brain immediately jumped to ""but you can just git reflog and then copy the state you want to revert to and then git reset --hard <commit>"", but not only is that not simple or obvious, it isn't even correct, since a commit or amend operation can be performed with only some of the changes staged, and a hard reset will wipe out anything unstaged. Ah sigh.So yes, in short I agree."	mikepurvis	8.574203	-6.5317464	comment	3.0	12.0	1668547675	-11.892048
33617971	I switched from git to Mercurial and	I switched from git to Mercurial and was absolutely gobsmacked by how much better it is. The only comparison was switching from a Blackberry to an iPhone - everything just works exactly the way I want it to.Yes, I read the manual for git, but I never needed to for Mercurial.	jkaptur	8.516094	-6.543311	comment	3.0	35.0	1668564838	-11.936972
33618413	I'm sort of amazed that git and merc	I'm sort of amazed that git and mercurial haven't built something like that yet. Makes me a little sad that Facebook created a new scm instead of expanding mercurial to include features like this.	kyrra	8.516164	-6.5265503	comment	3.0	11.0	1668568912	-11.946665
33618511	Mostly people who have this argument	Mostly people who have this argument don't have a code base large enough to run into actual limitations of git. They run CI with wonky java implementations of git and/or have giant amounts of binaries in their repos. Actually having Gigabytes of source code is pretty rare.	jupp0r	8.554681	-6.447894	comment	3.0	11.0	1668569803	-11.880984
33618589	This serves a very weird niche. Read	This serves a very weird niche. Reading through the docs, this seems just as complex to operate as git, but designed with less decentralized operations in mind. Why not just use mercurial if you want to use mercurial? Why invent this... monstrosity? Because GitHub pull requests are terrible?None of this makes any sense to me.> Local branch names are optional.As are they in git, just hang out with a detached HEAD.> There is no staging area.Practically the entire world sadly invokes `git commit -a` anyways and you still have to add untracked files.Neat project but I don't get what this is solving for.	xyzzy_plugh	8.554287	-6.5433345	comment	3.0	11.0	1668570433	-11.98286
33618630	> started to demand that the Mercuri	> started to demand that the Mercurial project work the way that Facebook wantedSeems to be a recurring pattern when people interact with open source communities. Why does it have to be like this? It's not just companies either...	matheusmoreira	8.506932	-6.55307	comment	3.0	15.0	1668570847	-11.942557
33618337	I'm kinda surprised by the excitemen	I'm kinda surprised by the excitement it gets. I'm still looking for a compelling explanation, why I (or anyone else) should even bother?I am a git hater myself. I mean, git just sucks. It always did, and it always was much worse than Mercurial. When they could have be seen as competition, I was forcing Mercurial as much, as I could, but then GitHub became a thing, and after a very short struggle it became just hopeless. There still are folks who use fossil or something, but ultimately git became THE SCM. So, yeah, I hate you, GitHub, I hate you, Linus, but I fully admit that you've won. So… now I can actually admit it isn't such a big deal.Sure, it would be somewhat better if git never existed at all and we'd all just use a better SCM from the very beginning. But given it's just not the c	krick	8.533805	-6.5168633	comment	3.0	10.0	1668568162	-11.941249
33626496	I find this message hard to get beca	"I find this message hard to get because git is dramatically easier to use and more tolerant of mistakes than previous version control packages.  It's certainly true that looking at the man pages could drive almost anybody insane but working from a cookbook it is very easy.  (Most of the time I think it is a mistake to ""Google"" for answers but rather you should learn to look things up in the official docs.  Git is a counterexample)Visual Source Safe would outright die when your repository overflowed a 32 bit file.Changing a wrong commit message was almost impossible with CVS.I push into the wrong branch and make other mistakes like that sometimes with git and I have no fear about it at all and little stress because I can always look in the cookbook and find the recipe to fix it.Git also is "	PaulHoule	8.564297	-6.4908013	comment	3.0	19.0	1668618205	-11.899049
33626975	I think git is hard because 99% of t	I think git is hard because 99% of the time it just works with little to no required understanding of what you are actually doing. That is to say that git is actually too easy... until it isn't. Once you hit a scenario where you get off the happy path, that is when git becomes hard.	athorax	8.522645	-6.52455	comment	3.0	11.0	1668619894	-11.893119
33704504	I love linear git!  Branches are ver	I love linear git!  Branches are very confusing for a nonempty set of people.  For us, it is always clearer to work with explicit files in the main branch.  You are implementing a new feature?  Nice: just create a new file on the main branch and keep updating it until you add it to the tests, and later you call it from the main program.  This system may break down on large teams, but when you are just a handful of grug-brained developers, it's perfectly appropriate.	enriquto	8.59079	-6.5194483	comment	3.0	22.0	1669115596	-11.89537
33704568	Extremely Linear Git History...also 	Extremely Linear Git History...also known as SVN. Guess reinventing the wheel does get you to top HN.	unnouinceput	8.573028	-6.4814124	comment	3.0	11.0	1669116217	-11.881391
33704649	See also Lucky Commit [0], which use	See also Lucky Commit [0], which uses various types of whitespace characters instead of a hash inside the commit, which makes it look more magical.I wonder about performance, though. Why is the author's method slower than the package I linked?[0]: https://github.com/not-an-aardvark/lucky-commit	kinduff	8.594061	-6.508004	comment	3.0	22.0	1669117048	-11.898547
33704941	> the reasonably common case very we	> the reasonably common case very well where someone is working on changes which are constantly breaking the branchBut isn't this bad practice?  My grug brain refuses to commit anything that does not pass tests.  Check tests, then commit.  Check tests, then commit.You can hide your as yet incomplete feature inside an undocumented option, and work from there, without breaking anything.	enriquto	8.58835	-6.5313964	comment	3.0	10.0	1669119387	-11.908412
33704947	Using whitespace is cool, but you kn	Using whitespace is cool, but you know what would be really cool? Using a thesaurus to reword the commit message until it matches the hash :)	oneeyedpigeon	8.591789	-6.530605	comment	3.0	12.0	1669119425	-11.887807
33705509	...so you are among the 1% who use t	...so you are among the 1% who use the functionality that causes 99% of what makes git's mental model so convoluted and hard to learn (for everyone, not just the one-percenters).	gyulai	8.541959	-6.4865413	comment	3.0	10.0	1669123696	-11.908233
33708156	> It seems like a very contrived exa	"> It seems like a very contrived example to me.I run in to this quite frequently, even on projects where I'm the only one working on it (I tend to have a lot of things going on in parallel). Once branches diverge and commits accumulate it can become a right pain. Usually my solution is to merge master into the branch just to keep up to date and then just undo everything, make one new commit in the master, and rebase that. But in some more difficult cases it was ""just merge and fuck it because life's too short"". I've also just manually ""copy/paste merged"" things to a new branch, because that seemed quicker than dealing with all the merges/conflicts.Maybe there are better ways of doing this, and arguably I shouldn't have all these long-lived branches in the first place (but it works well for"	Beltalowda	8.616816	-6.5580115	comment	3.0	28.0	1669137308	-11.920113
33708261	Can I asked how they converted you (	Can I asked how they converted you (or do you mean by dictate, as opposed to becoming convinced it was better)? I find myself loving merges and never using rebases. It's not that I cannot describe technically what's happening, but I just don't understand the love.	HWR_14	8.59992	-6.56329	comment	3.0	15.0	1669137739	9.296103
33709236	> arguably I shouldn't have all thes	> arguably I shouldn't have all these long-lived branches in the first placeThis is the problem here.  If you have multiple long-lived branches, there's no technical solution to preventing rot -- you must actively keep them in sync.Regularly merging in main is the opposite of the proper solution.  Constantly rebasing on top of main is the proper solution.	couchand	8.594732	-6.55859375	comment	3.0	23.0	1669142101	-11.910617
33711149	I wholeheartedly agree!With this, yo	I wholeheartedly agree!With this, you can also push people towards smaller PRs which are easier to review and integrate.The downside is that if you és o work on feature 2 based on feature 1,either you wait for the PR to be merged in main (easiest approach) or you fork from your feature branch directly and will need to rebase later (this can get messier, especially if you need to fix errors in feature 1).	pnt12	8.639967	-6.468208	comment	3.0	10.0	1669149483	1.8657964
33766852	Wow, I’m kind of the ‘go-to git pers	Wow, I’m kind of the ‘go-to git person’ in my team but have never heard of git notes. An obscure feature.	diarrhea	8.554732	-6.4500017	comment	3.0	24.0	1669582625	-11.871043
33767065	Is git bisect a power user feature? 	"Is git bisect a power user feature? I was taught git by a senior engineer early in my career and it was the first ""this will save your rear"" tool he showed me."	eropple	8.5365925	-6.4720674	comment	3.0	19.0	1669583834	-11.877425
33767062	I've tried to use git notes over the	"I've tried to use git notes over the years but unfortunately notes are tied to a specific commit hash. It's a blessing and a curse.Works great for some types of review system, or for ""tagging"" things related to deploy. Notes on commits on the master/main branch, which doesn't get rebased? Awesome thing, they work.But you can't as easily use them on branches: the moment a branch whose commits had notes is rebased, and SHAs change, good-bye notes associated with the ""previous"" SHAs :/"	mfontani	8.592186	-6.5034246	comment	3.0	22.0	1669583805	-11.976387
33803956	> git add -A .> Add everything I’m w	> git add -A .> Add everything I’m working on (new and edited files).Bad idea. Extraneous cruft that isn't caught by .gitignore will leak into the repo. Always run git diff and git status first to see what you are about to add.	dboreham	8.609246	-6.4939423	comment	3.0	17.0	1669828723	-11.885191
33945027	That would be really nice. I think t	That would be really nice. I think there is definitely room for version control for people who are less in the programming realm or who work on personal projects that have a more creative art flavour (writers, desingers, etc). The user interface of Git is too frustrating for these types. Even as a mathematician and somewhat-programmer I dislike Git a lot. Rebase, blame, stash...ugghhh. Although Git is nice I liked Subversion better.	vouaobrasil	8.604511	-6.47296	comment	3.0	11.0	1670778663	-11.918169
33947964	Came here to make the same comment.T	"Came here to make the same comment.There is a great blog post about it: https://dev.to/jacobherrington/how-to-write-useful-commit-me...It boils down to the following commit message template:  <what you changed>

  because <why it was needed>"	warpech	8.582419	-6.520395	comment	3.0	33.0	1670795586	-11.907306
34001845	If you need a shorter hash just trun	If you need a shorter hash just truncate a modern hash algorithm down to 160 or 128 bits. Obviously the standard lengths were chosen for a reason, but SHA2-256/160 or SHA2-256/128 are better hash functions than SHA1 or MD5, respectively. Blake2b/160 is even faster than SHA1!(I suspect this would be a good compromise for git, since so much tooling assumes a 160 bit hash, and yet we don't want to continue using SHA1)	oconnore	8.693971	-6.513697	comment	3.0	10.0	1671121520	-5.5723357
34014022	> I’d shudder to have to go back fro	> I’d shudder to have to go back from Git to SVN.What are some of the Git features that make a big difference to you? I use them on different projects and I end up using them both in the same very basic way (check out code, make changes, check code in).	criddell	8.584154	-6.474755	comment	3.0	10.0	1671195349	-11.858339
34071811	"sed -i ""s/function_name/function_nam"	"sed -i ""s/function_name/function_name2/g"" $FILES && git restore $FILESEdit: Not claiming this is better, just saying what I get by with. I have never used an IDE in my career so far, or any autocomplete or code modification features."	nx7487	8.623954	-6.5107512	comment	3.0	18.0	1671567124	-11.806066
34088353	A friend used to call this kind of s	"A friend used to call this kind of setup flag-oriented programming.I've suffered it when working for engineering companies where the PMs understood the logic but didn't understand why it's a bad idea to just create branches for everything.Not sure why programmers would inflict this ""methodology"" on themselves. And no, sorry, I'm not going to read the article. Too soon."	narag	8.630135	-6.5040655	comment	3.0	11.0	1671670273	-12.009283
22755370	That must have a hilarious commit me	That must have a hilarious commit message.	hunter2_	8.583681	-6.5307875	comment	3.0	10.0	1585790668	-11.878102
22797398	I alias 'git recent' to:    git bran	"I alias 'git recent' to:    git branch --sort=-committerdate -v

It gives me the following output (first line for not actually included):    [branch name]                                      [hash]  [commit message header]
    move-radio-and-checkbox-hints-up                   9dff690 Move the hints belonging to radios/checkboxes up
    update-rubocop                                     8cace1f Update rubocop and pry, fix some new offences
    fix-remaining-injected-content-placement           48dc51d Reorder elements of other inputs"	petepete	8.591154	-6.526825	comment	3.0	12.0	1586204434	-11.86354
22803461	git checkout -b new_feature_branch i	git checkout -b new_feature_branch is an onerous workflow?	drchopchop	8.570428	-6.5428295	comment	3.0	13.0	1586269446	-11.908314
22803734	Switching branches does get a bit an	Switching branches does get a bit annoying if you happen to work in multiple branches simultaneously and have to switch halfway through a task, or there's a lot of differences; however, that is also a matter of organization.It's happened to me though; one scenario is that you created a couple of merge requests for the same repo over the course of a day, and the next day feedback from code review or testing comes in. You end up having to switch to various branches to fix the reviews.But that's really not that big of a deal. The context switch is worse than the git checkout call.	Cthulhu_	8.574686	-6.537097	comment	3.0	10.0	1586271169	-11.92533
17879907	I have co-workers who work on a big 	I have co-workers who work on a big intranet web application that runs on IIS, and they never touch it.They recently finally switched to git for source control, and they want to do everything via GUI. I've tried to show them how some things are just easier/better from the command line, but if something isn't doable via GUI, they won't do it. One of them keeps committing line endings differently than everyone else, and he literally won't run git config --global core.autocrlf true because... I dunno why. He just doesn't want to, because it's the command line.	FactolSarin	8.565293	-6.453486	comment	3.0	15.0	1535657129	-11.881277
17903272	I've been working with gitlab CI for	I've been working with gitlab CI for the last year. Here are some of my feedbacks:- 6 months ago we seriously considered moving away because it was really unstable (even when running on private runners) but now its a lot smoother- with private runners you can have a very powerful CI without having to manage a master (as Jenkins) for a fraction of the costs (runner with docker-machine on spot instances)- beware that if your CI flow is more complex than just a simple pipeline to build and deploy your project (we have a project for our code, that then trigger a project for end-to-end tests, that then trigger a deploy to our env) you will need to do a lot of boilerplate code (you will need to manually manage artifacts if they need to be shared between jobs)- variables from a triggered pipeline	Rowern	8.689393	-6.5013804	comment	3.0	12.0	1535990378	9.048058
17903306	I think this is too much too late fo	I think this is too much too late for Jenkins.I can't speak for other countries but in London a lot of companies are now using Gitlab or Circle CI.I migrated all my builds (12 projects) to Gitlab CI. After figuring out the first CI pipeline using DockerInDocker, it was easy to then setup the remaining pipelines.Self hosting Gitlab was perfect for our needs (private docker registry). I use Gitlab for personal use too.I wonder if they will get rid of Ruby in the future though and go Java to make it more performant, as it does slow down sometimes.The Jenkins box is still running though, more out of sentimental value :)	mothsonasloth	8.709423	-6.531289	comment	3.0	16.0	1535990786	12.010074
17967400	Git 2.19.0 released	Git 2.19.0 released	rbanffy	8.541319	-6.4450393	story	3.0	158.0	1536751845	-11.889214
17971225	What do you alias it to?(Also, I ten	What do you alias it to?(Also, I tend to use just `git log origin..` rather than spelling out `origin/master`.)	JoshTriplett	8.52189	-6.4584975	comment	3.0	11.0	1536774748	-11.88062
17987428	"@danieldk: ""No, you do not need to h"	"@danieldk: ""No, you do not need to hold a copy of the repository. You only need a known-good hash. Commit signing is a way to vouch that a hash is good.""The overhead is such that you are better off holding the repo yourself a la linux kernel.Note also that SHA1 collisions are a practical attack these days: https://shattered.io/ . So if you rely on SHA1 hashes you have no guarantee..."	ElBarto	8.655615	-6.5008917	comment	3.0	11.0	1536935302	7.1922197
18001105	> And Git has the UX of software cre	"> And Git has the UX of software created by someone with no empathy.I would really like to understand what you expect a UX for a command line tool to look like. Maybe instead of throwing an error if you did something wrong, it would apologize to you first? Or perhaps it should preface all output with ""dearest Sir/Madam, here is the information you requested:"" ?"	craftyguy	8.561865	-6.479135	comment	3.0	11.0	1537131972	-11.872933
18977220	Just rebuild your container each tim	Just rebuild your container each time you change one bit.And get gitlab-ci to redeploy it automatically to a kubernetes cluster each time it changes.	zoobab	8.520027	-6.518928	comment	3.0	11.0	1548240613	-12.106894
19006393	"Funny how they say that Git uses a """	"Funny how they say that Git uses a ""Bazaar-style development"" process when Bazaar literally is another VCS.I'm also not convinced it's a good idea to merge your bug tracker and version control."	anilakar	8.563378	-6.4523363	comment	3.0	13.0	1548512799	-11.853087
19006433	Git won over Mercurial simply due to	Git won over Mercurial simply due to Github. There were some other minor contributing factors - association with Linus, speed - but they are insignificant compared to how popular Gihub was (for good reason) and therefore how many people were exposed to git.The Mercurial alternatives like bitbucket just didn't have the same spread, and we got stuck with year after year of teaching new people a difficult interface.	rkangel	8.520108	-6.541677	comment	3.0	14.0	1548513391	-11.952003
19007383	Would it not be significantly more f	Would it not be significantly more frustrating if you use git blame and you see:> Revert: Some WIP didn't work out.Git blame again from prior to that commit.> Added missing semicolon.and again:> Fixed spelling.and again:> Stupid typo, wrong method call.and again:> WIP, going to see if X can work.Before running git blame once more, finally getting to the commit message that actually pertains to the current line of code you're seeing. Including the explanation (commit message) for why it is the way it is, and very importantly when this line of code actually made it into the software?	Benjamin_Dobell	8.560347	-6.496422	comment	3.0	10.0	1548525050	-11.877182
19007405	"""Git has no first-class concept of f"	"""Git has no first-class concept of file name changes. Instead it tries to use heuristics to spot renames and sometimes they work and sometimes they won't.""Git has the ""mv"" command.  If you ""git mv"" a file, why would git have to guess or use heuristics to figure out that the file was renamed?"	pmoriarty	8.590495	-6.521706	comment	3.0	12.0	1548525232	7.8929396
19006685	Always surprises me how Fossil is po	Always surprises me how Fossil is popular on HN but very much not outside a few projects (e.g. sqlite)	aboutruby	8.516005	-6.521796	comment	3.0	21.0	1548516898	-11.963854
19013922	Git CLI is universally agreed to be 	Git CLI is universally agreed to be absolutely terrible, with its manuals actually making it worse. Just flick through one or two blog posts you can find here, many of which already made HN:https://www.google.com/search?q=why%20git%20cli%20sucks	d33	8.555692	-6.463147	comment	3.0	16.0	1548624850	-11.882917
19068008	Sr.ht experimental mercurial support	Sr.ht experimental mercurial support	Volundr	8.500515	-6.553204	story	3.0	45.0	1549170887	-11.979519
19069537	It would be awesome to get pijul sup	It would be awesome to get pijul support as well!I have started using sr.ht a bit and the interface is sweet but I want to use pijul for some stuff and it's the future imo (maybe it'll be assimilated into git like servo into firefox but future nevertheless)	openfuture	8.595224	-6.5532985	comment	3.0	13.0	1549201815	13.887395
19075476	Nice, but is there a way to just run	Nice, but is there a way to just run any command? I.e. just `gita <optional repo names/paths> <pass entire command line git -C repodir>`. This has advantages in that you don't have to go round via a command file, don't have to keep it synced across machines, don't have to remember what you put in the file etc, and can just use the git syntax which already took long enough to learn by heart :PI've used multiple multiple repository tools and in the end all I happen to use is one (usually versioned) file to store a list of repositories and then a command which just loops over all repos and applies anything to it. If I need custom commands I use git aliases so that works both for normal git and whatever tool used.	stinos	8.541138	-6.454638	comment	3.0	10.0	1549280077	-11.851503
19081307	There's an option between #1 and #2 	"There's an option between #1 and #2 that they're not listing. They could allow merges, but only merges after a rebase on top of upstream produced with --no-ff.The advantage of that is that you get ""linear"" history as far as the just-pushed topic topic building upon the last one, and you can use merges to group commits, which allows e.g. easy reverting of an entire buggy feature introduced over N commits by reverting out the merge."	avar	8.585438	-6.557836	comment	3.0	14.0	1549319500	-11.89722
19084330	Pijul is based on a different (and m	"Pijul is based on a different (and much more advanced) algorithm than Git. That doesn't mean it's the perfect tool - just as Git is better than SVN (even though they're based on the same underlying algorithms), Pijul might be the ""SVN-like"" tool waiting for its own Git...Edit: having said that, Git isn't perfect either, I'm keeping my fingers crossed for an even better tool!"	tomp	8.593034	-6.5557346	comment	3.0	16.0	1549365660	13.892224
19084435	Why not summarize it a little if you	Why not summarize it a little if you feel that info got lost.Technically if you need a patch you can generate it on the fly by comparing both objects (you can even do that in a bash script with `diff`, if you are willing to type in the logic to look up commit->tree->file->object-name first). So there shouldn't be anything lost. The only parameters I can see with storing diffs vs immutable objects is disk space vs processing time, which is also what git proofs by not storing old immutables and instead store diffs for old stuff (reducing space by increasing processing time).	runyor	8.646935	-6.5168467	comment	3.0	11.0	1549367031	-11.796379
19129656	In the intro video they say it’s “ba	In the intro video they say it’s “based on git but supports large files”.Are they using Git LFS [1] or did they make something else?And what is their proposed value add over using git directly?Edit: They say a little more about the large file stuff> DVC keeps metafiles in Git instead of Google Docs to describe and version control your data sets and models. DVC supports a variety of external storage types as a remote cache for large files.So from what they said in the video and what I read on the page this is probably a limited front-end to make using git easier for people that don’t know git.And in terms of the large file stuff it seems from what they are saying like they have implemented the equivalent of git-annex [2]. Or maybe they are using that even. I didn’t look to see if they wrote	codetrotter	8.565203	-6.450464	comment	3.0	18.0	1549828913	-11.89032
19150807	> My cries to use git were unheeded 	> My cries to use git were unheeded (would have required upskilling everyone on the team).What is the best practice workflow using git with SQL server views/procedures? Can you actually somehow track changes in the views/procs themselves so that if someone happens to run ALTER VIEW, git diff is going to show something?	beefield	8.582459	-6.5014215	comment	3.0	12.0	1550037564	-11.857088
19165385	I could be wrong, but I feel this ac	"I could be wrong, but I feel this actually enables the wrong kind of behavior we should expect from developers. We want fast, continuously integrated code that is merged early.
Usually that means using feature toggles so that we can see compilation issues without the code being active by default.This feature signals ""yeah it's OK to take your time and not merge stuff incrementally - here's a feature just for that since it's such an important part of your workflow"". 
Yes, people have been doing it anyway but at least it felt a bit like a hack, like it's not supposed to work that way.Am I crazy, or is this pushing back progress made in CI coding practices?"	royosherove	8.64224	-6.5349693	comment	3.0	15.0	1550174168	-11.861011
19247516	Some best practices for using Git	Some best practices for using Git	dolftax	8.555059	-6.461577	story	3.0	25.0	1551116428	-11.928319
19272943	Integrate with a ticketing system, f	Integrate with a ticketing system, force commits to match a pattern, and you can ensure the rationale is tied to your ticketing system (i.e., commits/merges have to be prefaced with FOO-####)	lostcolony	8.567536	-6.524384	comment	3.0	11.0	1551374155	-12.001716
19295531	I'm using gitea to self-host, works 	I'm using gitea to self-host, works well for markdowns and code, but bad for anything that is binary(pdf,media files,etc), because of git, which really does not fit for binaries, and git-lfs is a PITA to use still	ausjke	8.587228	-6.4483356	comment	3.0	10.0	1551633559	-11.918419
15754708	I think what the world really needs 	I think what the world really needs is just a better cli/porcelain for git starting with better and clearly defined terminology built around how people actually use git and not how libgit represents its data.I’ve toyed with the idea of making my own mostly-compatible interface but I wouldn’t want to be using a non-upstream syntax (especially if I’m the only one using it).	ComputerGuru	8.555651	-6.4699383	comment	3.0	11.0	1511331261	-11.901106
15756491	I think that git is quite good, but 	"I think that git is quite good, but I don't like the notion of 'squashing commits': when you squash commits you loose history!
I would prefer to have a ""fold/folder"" of commits which could be manipulated as 'one commit' but would instead be a set of commit and you could look inside the folder if you need the full history."	renox	8.576287	-6.5628886	comment	3.0	10.0	1511356539	-11.94506
15817010	Filecoin is one of the ones I'd stay	Filecoin is one of the ones I'd stay far away from. VCs got in before anyone else with special preferences, which taints the whole project. There are alternatives which don't come with the VC problem attached to them.	brndnmtthws	8.622008	-6.4428964	comment	3.0	19.0	1512059379	-11.854287
15849003	> Git has won the vast majority of m	"> Git has won the vast majority of mindshare and good will by being straightforward, ubiquitous, and well supported.Thanks for a good laugh.  The sheer volume of ""No the REALLY right way to think about git's totally brain damaged use of source control concepts.  This time we mean it."" tutorials shows that ""ubiquitous"" is true but ""straightforward"" and ""well supported"" are a lie.But you are correct.  The vast majority of coders have decided on git.  I will happily sit over here on Mercurial while you try to figure out the arcane git command for something that I was done with in Mercurial hours ago.The Mercurial->git gateways are now quite good and I can do my development in Mercurial and transfer it to git at infrequent intervals.  It's not like git people want to see all my intermediate co"	bsder	8.519692	-6.5523634	comment	3.0	33.0	1512436056	-11.939922
15886014	Git is not a purely functional data 	Git is not a purely functional data structure [1][1] man git-rebase	_0w8t	8.569663	-6.5588083	comment	3.0	23.0	1512831063	-11.875605
15889702	It's kind of interesting that nowada	It's kind of interesting that nowadays people assume that version control system == git.For a huge, non-open codebase there are some pretty large downsides to a fully distributed VCS in exchange for relatively few benefits.	nerfhammer	8.575202	-6.442454	comment	3.0	41.0	1512876647	-11.877096
15889792	Such as? Then why has everyone switc	Such as? Then why has everyone switched to git? (Hint, because it is fundamentally built on more powerful ideas than what came before it)	hossbeast	8.558752	-6.4701405	comment	3.0	15.0	1512878204	-11.89847
15889958	Google doesn't use perforce anymore.	"Google doesn't use perforce anymore.  It's been replaced with Piper, you can read about it in articles from about 2015 or so.  Perforce didn't scale enough.  I guess it's not clear to what extent Piper is a layer of infrastructure on top of perforce or actually a complete rewrite?  I was never super sure.  The articles appear to imply way more than a layer on top...You are exactly right that git doesn't scale though, go see the posts on git that Facebook's engineers made while trying, only to be met with replies to the extent of ""you're holding it wrong, go away, no massive monorepo here"", at which point they made it work with mercurial instead.  Good read though, lot of good technical details.  Can't find the link at the moment though :(, but it was from somewhere around 2012-13 ish.Edit:"	dmoy	8.617761	-6.5182757	comment	3.0	17.0	1512880807	13.831903
15890420	Can someone further explain how the 	"Can someone further explain how the pre commit phase works? I don't get how/why ""pre commits"" work without feature branches?How are my changes shared with the reviewer, if I there is no feature branch? Is my local code uploaded to that review tool mentioned in the article? And then what happens if the reviewer requests changes?I probably did get this completely wrong, so thanks in advance for pushing me in the right direction."	bookwormAT	8.580156	-6.494989	comment	3.0	12.0	1512891288	-11.897225
15889766	The lazy me thinks maybe 1 kitchen s	"The lazy me thinks maybe 1 kitchen sink repo is better.Here's my problem:I can be working on multiple projects at the same time. Each project has multiple modules (core, api, www, admin, android, etc -- I use microservices on Google App Engine). Sometimes, some modules have ""feature"" branches. Oh, did I tell you I work on both Desktop and Laptop?The problem is syncing. Before traveling, I need to make sure the projects/modules I'll be working on the go all have latest commit from Desktop.My question:Is there some ""dashboard/overview"" for all Git projects? So I can quickly tell, ""Ok, all projects are at latest commit, and oh I'm working on feature branch for project X and Y."""	wiradikusuma	8.536919	-6.444148	comment	3.0	10.0	1512877871	-11.88981
15891422	> Must have: Tooling that can intera	> Must have: Tooling that can interact on a file or sub directory level. Git cannot do that.I mean, when you get big, sure. But until you're big, git is fine. Working at fb, I don't use some crazy invocation to replace `hg log -- ./subdir`, I just do `hg log -- ./subdir`. Sparse checkouts are useful, but their necessity is based on your scale - the bigger you are, the more you need them. Most companies aren't big enough to need them.> Should have: Access control to view and change file on a subdirectory basis. Everyone can see the repo so you can't permissions users per repo anymore. It's optional but these companies have that.Depends on your culture (and regulatory requirements). I prefer companies where anyone can modify anyone's code.> Recommended: Global search tools, global refactorin	lclarkmichalek	8.571274	-6.4604278	comment	3.0	11.0	1512915051	13.823752
15903287	>> And the Git staging area should b	>> And the Git staging area should be an opt-in feature.Thousands of yes! `git commit -a` just doesn't add the untracked files it is the most annoying misfeature of any version control system. Oh, I added unwanted project directories? I would then just remove them and put them to `.gitignore`, or create a `.gitignore` prior to `init`.Of course I could just alias `add -A . && commit -m` on every machine I ever connect to for developing. There's a great, practical solution.	nurettin	8.613008	-6.49447	comment	3.0	11.0	1513058072	-11.879829
15903313	This may be sacrilege on here, but a	This may be sacrilege on here, but at my previous job I really enjoyed TFS. It's been awhile but the workflow felt a little more intuitive than git. And some of the merging features were nicer.	milofeynman	8.557465	-6.450274	comment	3.0	11.0	1513058516	-11.892471
15903379	Commit messages could just as easily	"Commit messages could just as easily be a policy requirement instead of a tool requirement. Maybe all the repos you interact with require a message for every commit, and that's fine.But maybe the default policy should be permissive. People might decide not to use any tool at all if this is the straw that broke the camel's back for them, and that's a worse outcome in my opinion.And, honestly, 90% of all commits I've seen use crap messages like ""stuff"", ""fixes"", or ""change 357"" that are so devoid of useful content that I'd argue that those commits would be better off with no message at all. Just date and author. At least then you won't be distracted by contentless messages that can't even be self-consistent most of the time. This isn't a swing at those people, I'm just being realistic."	infogulch	8.586231	-6.5266647	comment	3.0	14.0	1513059396	-11.899728
15903384	Unfortunately this is simply the rea	"Unfortunately this is simply the reality for many developers.I have worked with multiple people whose commit logs would look something like...> e96ddd0 update code> 65c3072 update code> dd9ccc1 update code> 7992ef8 update code> 6c536e6 update code> ...Over and over several dozen commits.  Which is technically fine if they know how to rebase.  The overwhelming majority of my commits are simply 'git commit -a -m ""CI-WIP""` (check-in work in progress), rarely do I realistically revert to any of them.Unfortunately, a lot of developers aren't willing to learn the 4 or 5 basic commands which make for a clean git history.And when I have to work with them, I really would prefer if git had something like `git save`.  Which in the backend kept doing something like `git commit -a --amend`."	cjhanks	8.587229	-6.5424223	comment	3.0	13.0	1513059541	-11.911185
15904688	Rebase is not simpler in any context	"Rebase is not simpler in any context - rebase rewrites history, which, if branches have been pushed to remotes, then necessitates force pushes, which in turn breaks any other instances of the same branch. By using rebase to ""keep history clean"" you are largely undermining git's power as a DVCS.Rebase as a tool is not inherently bad but it is definitely not simpler than merge - it introduces additional considerations, requires a deeper understanding of git for effective use and is a dangerous tool in the hands of people who do not understand what it is doing and in my experience most teams that are using it as a core part of their workflow are doing so for the wrong reasons (generally because of a fundamental misunderstanding of how branching and merging works in git and why it works that w"	saltedmd5	8.576637	-6.567813	comment	3.0	10.0	1513077635	-11.918074
15904741	In the beginning I tried to use git 	In the beginning I tried to use git exclusively through command line because I thought that's how real men do it.But after using gitkraken (or similar products) I will never go back to using git through its command line interface. Being able to see the whole repo structure is just so much more convenient and it helps to resolve most merging problems much faster. git guis all have their own problems, but overall using a git gui for me is the better choice in 95% of all use cases.	yoodenvranx	8.564934	-6.4878273	comment	3.0	10.0	1513078231	-11.870021
15905439	The problem with gitbash is its way 	The problem with gitbash is its way slower.Plus, the real reason you get Putty or SecureCRT if you’re lucky, is because they are actually terminal emulators and not a DOS shell.Sorry I don’t find Mona compelling at all.	putinontheritz	8.598407	-6.4723263	comment	3.0	10.0	1513085641	-11.748149
15918249	> Edit: GitHub has similar functiona	"> Edit: GitHub has similar functionality, but it doesn't know how to diff force pushes, so you would end up having to review the full diff again to ensure integrity.I realize this is a religious war I'm stepping into, but I fall on the side of ""if you are doing a force push of a branch already in code review you are doing something wrong"". Once commits are out in the open and in review between multiple developers, that is shared code history that encodes important information about the code review process itself. (I make obvious exceptions for things like accidental PII disclosure or similar bone-headed mistakes, but the longer a branch has been in code review, the less willing I am to allow it to be force pushed.)Of course, to each their own and your mileage may vary, but that comment abo"	WorldMaker	8.605972	-6.467734	comment	3.0	11.0	1513203746	2.1838229
15918381	What I personally do is commit the m	"What I personally do is commit the merge as is, with all the <<< === >>> conflict markers.Then, in the next couple commits, fix each conflict via a normal commit that mixes and matches ""mine"" and ""theirs"" as needed + deletes the markers.Each resolution commit is independent of the giant merge commit, and can be separately diff'ed and code reviewed via the github PR or any other tool.Also easier IMO to make the complicated resolution you want, or reset back to a previous resolution attempt without messing up the entire merge.The drawback is that some commits won't compile, but compilable mid-branch commits are not something that I view as a goal."	pkamb	8.627775	-6.5423336	comment	3.0	14.0	1513204805	-11.894604
15918496	Non-compiling commits make bisecting	"Non-compiling commits make bisecting harder, when the goal is to find the commit that broke the build or a specific test. IMHO having to skip over non-compiling merge commits only makes bisecting take more time, and it may also ""pollute"" the test pipelines if all commits are going to be built.
Additionally, merging and fixing the merge in separate commits makes it much hard to revert a merge later, in case it turned out that the merge introduced something unwanted).So I will always recommend doing the merge and fixing the merge in the same commit. Ideally this produces a squash commit that can easily be reverted later when needed. This makes the merge process more time-consuming, but it can help to keep the builds more stable, and to more easily track which commit (merge) introduced a part"	jsteemann	8.5985	-6.554492	comment	3.0	10.0	1513205869	-11.933978
15918516	It's absolutely resolved that way.Re	"It's absolutely resolved that way.Rebase should be the weapon of choice in all cases, except those where it would be prohibitively expensive.People are too enamored with the SVN ways though, or have even made up rationalizations about fictional concepts such as ""historical purity"". So you have a ton of people merging instead, producing code repositories that look worse than the worst perl code i've touched."	Mithaldu	8.579559	-6.5660815	comment	3.0	22.0	1513206046	-11.896222
15952402	> 2. data is erased for good because	> 2. data is erased for good because someone makes a mistake while using rebaseNo. Just no. Please stop spreading FUD like it's candy. Git only deletes commits after a GC, which won't erase commits from reflog and will keep unreferenced commits for at least a month before deleting them. And rebasing generates new commits, leaving the old ones exactly how they were. If somebody lost a commit after a rebase, and nobody nearby could help them recover it, they should consider spending a few hours learning about git.I've been using git for 4 years both at work (with a team of 40+ people) and at home, without ever having any of the problems listed here (except 3 which has nothing to do with git). It takes a few hours, maybe a few days to understand how git works and how to use it. Instead of bla	rootlocus	8.58011	-6.5860953	comment	3.0	20.0	1513612188	-11.918975
15952428	Most of these have nothing to do wit	Most of these have nothing to do with git, but are true of any distributed repository. At that point, your argument becomes: distributed repositories are bad for business.Then there's this:> Graphic designers, writers, HTML/CSS frontenders, managers, data analysts and QA staff can’t use Git, even though they all used Subversion.What rubbish. The features of subversion are a subset of git, and the git equivalents are easy to learn. For a svn user, there's literally only a single additional command they need to know: git push.	teilo	8.557008	-6.43947	comment	3.0	11.0	1513612396	-11.877046
15952454	Maybe it's not worth being in there 	"Maybe it's not worth being in there because of how simple it is, but I guess it would be useful for newcomers:    # Oh shit, I've changed 200 files and want to revert to the state of this morning
    $ git add . && git commit # often. Very often.
    $ git reset --hard commit_id"	oelmekki	8.566329	-6.5292444	comment	3.0	10.0	1513612568	-11.894375
15952738	rebase can be dangerous, but so prod	rebase can be dangerous, but so productive.  I think it's important to teach new devs how to properly use it.  Especially if you're working in a continuous deployment environment, where you may need to quickly revert something.	swalsh	8.593571	-6.555673	comment	3.0	25.0	1513614287	9.344527
15952345	I always fight for people really lea	I always fight for people really learning git, because that's when it finally starts to get good. And I always tell people that git is not the tool that everybody should use. Most people just need a simple data storage with diff management, like Dropbox or SVN.But even after nearly 10 years, the pressure from the aint-nobody-got-time-for-that crowd is still there. I really, really hope that the git devs don't feel pushed to simplify and therefore depower git. Thinking turning VIM into the Windows text editor.	erikb	8.574614	-6.4756384	comment	3.0	18.0	1513611860	-11.84869
15952407	> I'm planning on making a hard push	> I'm planning on making a hard push for git on the team I just joinedYou mean a force push. `git push --force` is one of my favorite commands. I've aliased `git yolo` to `git push --force --no-verify`.	Cthulhu_	8.585704	-6.4906178	comment	3.0	11.0	1513612235	-11.881608
15952891	You're entitled to your own opinion 	You're entitled to your own opinion of course, but you underestimate the efficiency of the command line, especially when you already have one open for other development tasks.I use one or more GUIs for visualizing branches, and old branch cleanup, and yes, committing single lines from hunks that can't be split.However for everything else CLI is fairly close to optimal, including interactive adding/rebasing, and don't want to use whatever shitty editor your tool has in it, I want to use vim with syntax highlighting so I can properly format my commit messages.  Even something as simple as viewing a full commit is faster in the CLI because you can just pipe it to less or send it to an editor versus whatever tradeoffs a GUI has to make to stay performant, make use of screen space, etc.One last	dasil003	8.676387	-6.491165	comment	3.0	26.0	1513615184	-11.797859
15952963	> I'm not 100% sure what's going on 	> I'm not 100% sure what's going on under the covers.This. A thousand times over. I like to see exactly what git is doing and when; I don't want any magic stuff under the covers done for me.	MonkeyIsNull	8.5344715	-6.4785404	comment	3.0	22.0	1513615599	-11.886511
15953184	`git add -p` adds by the hunk, which	"`git add -p` adds by the hunk, which is a unit of quantization bigger than a line.E.g. if you have two consecutive lines changed, it's not possible to split them, they are one ""hunk"".(Waiting for someone to chime in with how to split a hunk and change my life)."	theptip	8.597563	-6.5256133	comment	3.0	13.0	1513617054	-11.89294
15953238	Say you have 3 sequential lines, but	Say you have 3 sequential lines, but you only want to stage the middle one.  You can’t split it into smaller hunks by hitting ‘s’ during ‘git add -p’.  I’m sure there’s a way I’m just not familiar with but I just use Sourcetree for this on the rare occasion it occurs.	dasil003	8.6269045	-6.5318937	comment	3.0	10.0	1513617379	-11.876684
15953701	You're misunderstanding the purpose 	"You're misunderstanding the purpose i'm describing.  Imagine 100 commits a day, maybe more.  (I worked at a company that averaged 500 or more commits a day to the master branch.  There were 1000 developers working in a monorepo).  Some code is out in production, and suddenly we realize a specific commit is causing a problem.  The idea here is to revert the commit as soon as you can, and then spend your time fixing it.  When reverting code is easy, and the company has good logging to identify problems, you can deploy more often.  It's a good thing.But to enable this ""revert-first"" culture, you have to design your commits to basically be super easy to revert.  That means no merges in the master branch, you want to keep your revision history as clean as possible.  One commit, as little depend"	swalsh	8.587808	-6.547169	comment	3.0	11.0	1513620338	-11.905577
15956914	> Git is fundamentally better than m	> Git is fundamentally better than most of the alternativesNo way. Only if you define “good” as “good at the kind of project that git is good at,” where it will hold vacuously.I suffer daily through the cyst that is git LFS, and it’s a joke. It would be funny if it weren’t so tragic. I hear that it’s not doing any better in large scale mono repo land. Google doesn’t use it, afaik. Microsoft does (but multi repo, last I heard), Facebook doesn’t (custom Mercurial, some tasty quotes at [0]). Not a glowing “fundamentally better”, exactly.[0] https://code.facebook.com/posts/218678814984400/scaling-merc...	nothrabannosir	8.514419	-6.5004563	comment	3.0	12.0	1513644915	-11.89233
16075024	It isn't a sales problem either. It'	It isn't a sales problem either. It's a tooling problem.Git really ought to be treated as a low level tool that is called by a higher level tool that assembles content management workflows designed by developers that can be used by developers and non-developers alike.Non-developers ought to be able to make 'commits' with git and pull requests without even realizing that git is the underlying tool.Developers should just script their most common workflows and then use them 99% of the time.Unfortunately the tooling that sits atop git is largely all shit and people have gotten it into their heads that one needs to have a deep understanding of git's quirks to be considered a 'serious' developer.	crdoconnor	8.544904	-6.476524	comment	3.0	10.0	1515107876	-11.8844795
16082306	>I'm not really sure how I can prove	">I'm not really sure how I can prove that the code I'm running is the code you'll find on GH though.I think this attestation is something Amazon (and other cloud providers) could offer in the future - they're the only ones who can really prove it.""I, Amazon AWS, do solemnly declare that the code running on {service} is {git hash}"""	mappu	8.639372	-6.5043707	comment	3.0	11.0	1515191149	7.1423597
16087281	Or just don't .gitignore node_module	Or just don't .gitignore node_modules, then diff any changes to node_modules on update.	panarky	8.669717	-6.493975	comment	3.0	11.0	1515270667	14.251523
16121242	Forgive me for being skeptical. Wher	Forgive me for being skeptical. Where is this git-time-machine equivalent?	Veedrac	8.561441	-6.448637	comment	3.0	14.0	1515641705	-11.87577
16839517	How so?  What features do you get by	How so?  What features do you get by using SVN over git?	scarface74	8.580647	-6.473151	comment	3.0	10.0	1523740133	-11.869659
16839670	It's not terribly difficult for me t	It's not terribly difficult for me to track my issues, or a wiki, or even a static site alongside my source code just via plain text (and in fact I usually would prefer to). I can get the parent of a commit in Git, and if I can't remember the specific command I can just add an alias. Git's interface is hard to teach and unintuitive, but now that I know it, it'll be initially a net loss in productivity for me to learn anything else even if it's way more intuitive.I guess what I'm getting at is that even if Fossil is better than Git, the problems it's solving don't seem to be particularly urgent to solve. Less complexity is good, but it would need to be considerably more elegant than Git to make me not want to use a VCS that's basically standard now.I don't see anything in the FAQ, overview,	danShumway	8.542115	-6.5007124	comment	3.0	17.0	1523741869	-11.919465
16839773	Fossil does solve interesting proble	Fossil does solve interesting problems, and has it's practical unique features for some use cases.  And even if it didn't, having competition is nice, see clang vs. gcc.I use org mode files for my issues and wiki-like features for my projects, and it works because my projects are very-small scaled.  But having to commit issues and merge them can get boring very quickly.  I haven't tried fossil, but if it has a nice quick UI for that, I might be interested.WRT local push/pull, I don't have any problems with it in Mercurial (altho it's sth. I don't do often).  What happens with git?  WRT other problems, well, those are problems of all DVCSes and VCSes, so it's a bit too harsh to judge fossil by them, no?Git command line is not inelegant, it's confusing, even at the basic level.  An improveme	gkya	8.510754	-6.5319066	comment	3.0	13.0	1523743100	-11.953297
16899454	Gitlab is pretty much the only provi	Gitlab is pretty much the only provider other than CircleCI to get CI right.I use their hosted gitlab version, but have their CI runner on our ci box that runs docker. It's fantastic.	thejosh	8.54871	-6.4601717	comment	3.0	10.0	1524441986	8.932575
16979741	I'm just curious why more people don	I'm just curious why more people don't make use of chg to avoid the mercurial startup time. It seemed to solve it for me - are there drawbacks?	Murrawhip	8.482921	-6.5762615	comment	3.0	10.0	1525285167	-11.970794
17006957	> [...] and implement competent thin	> [...] and implement competent things like competent CI [...]I've got an OSX build box with a bunch of virtualbox VMs so I can build for Gnu/Linux (i386, x86_64, and arm), OSX, and Windows. Single slow box, so one runner at a time. It has to be running OSX because I haven't found any way to run an OSX VM on any other platform.I want to trigger CI on Gitlab merge requests.What does $competent_CI expand to?	jancsika	8.449117	-6.442621	comment	3.0	14.0	1525623964	8.959804
17011621	Sublime Text is a really nice and pe	Sublime Text is a really nice and performant text editor, but one thing I unfortunately just can't get past is how excluding files from fuzzy-finding (Cmd+P) is handled. Files like .gitignore are not respected, so I need to kinda-replicate what is in .gitignore for every project in Sublime-specific project files. I thought I'd write a plugin for that, but it's not even possible to completely model .gitignore exclusions using Sublime's system because that's not powerful enough [1]. Lastly, excluded folders and files are removed _completely_ from the sidebar instead of, say, being greyed out like in Atom or VS Code. This means that if I do need to look into, say, a file inside node_modules/, I have to open it through other means.[1]: https://forum.sublimetext.com/t/make-include-exclude-patte	denisw	8.64377	-6.468346	comment	3.0	12.0	1525688647	-11.825013
17072485	Git isn’t ideal, but it is right. It	Git isn’t ideal, but it is right. It’s right because it’s solving source code control for a huge percentage of software projects. Something better could be even more right, and adoption would be the measure.> git may have become successful, but that doesn't mean it's right.	paulsutter	8.545324	-6.469689	comment	3.0	11.0	1526372978	-11.885779
17103639	Gerrit is a review server that uses 	Gerrit is a review server that uses git. In fact, Gerrit now stores the majority of information in git itself for all the information it uses.So for Google external projects, they use git.> Although given Google's scale, I'm sure there's some teams/projects that use Mercurial.I doubt it. Their tooling is probably pretty specific, and now that code.google.com has shut down, they probably don't have any review servers that support it.	kardianos	8.490876	-6.495597	comment	3.0	16.0	1526667227	-11.92016
21019595	I was just told at my day job that t	"I was just told at my day job that the team will not be using VC for tracking production analytics code because ""using git is over-engineering""."	Godel_unicode	8.549947	-6.4474826	comment	3.0	11.0	1568920512	-11.883598
21020602	30 years ago? That was 1989. How man	30 years ago? That was 1989. How many companies were using source control in 1989? How about 1999? Still not very many. 2009? Well, now you will find quite a few using SVN, but Git hasn't really taken off yet.	irrational	8.605601	-6.438989	comment	3.0	10.0	1568926139	-11.85237
21025762	"isn't this just a wrap on top of 
gi"	"isn't this just a wrap on top of 
git rebase -i HASH^;
git commit --amend --author ""Jhon Doe""?Also, as already noted, this overwrites all the history after the commit, making it useless.Then people said it's a joke...I know I will get downvoted for this comment, but How did this make to the first page of HN?"	danilocesar	8.582583	-6.5133357	comment	3.0	10.0	1568981642	-11.878428
21112965	Continuous Integration. Don't unders	"Continuous Integration. Don't understand how anyone wants to run a software project without an independent and automatic test-runner.
For Github this means using Travis CI, CircleCI, Appveyor etc"	jononor	8.71911	-6.4594784	comment	3.0	14.0	1569833220	8.943842
21113056	My bet is on google. There's a _lot_	My bet is on google. There's a _lot_ of kubernetes/gcloud integration going on with gitlab.	PudgePacket	8.562691	-6.6070914	comment	3.0	20.0	1569834072	-12.176285
21132084	I agree that full sentences (e.g. li	"I agree that full sentences (e.g. like Email subjects or blog post titles) are better. Tagging commits with feature/bug/etc is not particularly useful, as more often than not the line between feature, bug, etc is blurry. At times it can also be unclear what tag to use, leading to arbitrary choices. For example: is a performance improvement a feature, or a bug fix? The tags also add no value when reading commit messages.Setting that aside, the conventional commit ""standard"" (https://xkcd.com/927/) doesn't focus on what I think is the most important aspect of a commit: a good commit subject and message. In fact, prefixing the subject line with certain tags limits the amount of characters you have for writing the message; assuming you want to stick with the usual 50 character limit."	YorickPeterse	8.557379	-6.539295	comment	3.0	19.0	1569973258	-11.928961
21134013	but isn't it an antipattern to gener	but isn't it an antipattern to generate change-logs from commit subject lines?	hakre	8.59765	-6.5237556	comment	3.0	16.0	1570000071	-11.911261
22832010	Related: Fossil SCM is  a distribute	Related: Fossil SCM is  a distributed source code manager (just like Git), but with the added benefit that documentation and issues also goes in the repository (so like GitHub, but packed into the repository). When you clone a Fossil repository, you get everything, not just the code.http://fossil-scm.org/Also been discussed on HN before, a selection:- Fossil VS Git (https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wik...) - https://news.ycombinator.com/item?id=19006036- https://news.ycombinator.com/item?id=12673229I haven't personally used it for more than toy projects, but looks very interesting and would love to use it more.	capableweb	8.502374	-6.5116835	comment	3.0	40.0	1586519034	-11.931543
22867851	can you elaborate on what you mean b	can you elaborate on what you mean by this?because if you're referring to requiring review approvals before a PR can be merged, that's available in the free plan (under branch protection rules).	raziel2p	8.657876	-6.439445	comment	3.0	10.0	1586881372	-11.891666
22943812	Git is so simple that you don't need	Git is so simple that you don't need a gui for the normal day-to-day stuff.And if you are fighting with the complex stuff, you are probably doing it wrong. Then no GUI in the world can help you.	panpanna	8.569652	-6.4801335	comment	3.0	15.0	1587548488	-11.870434
22943900	In my opinion git GUIs have two majo	"In my opinion git GUIs have two major adventages:1. you can see all the information at on glance: 
current branch, all local branches all remotes and remot branches, local changes, recent commits, current merge conflics2. cherry picking single lines for staging in multiple files is much faster in a GUI than via terminal (maybe there are clever tricks to make it easier I don't know of)"	laszlokorte	8.582284	-6.4897723	comment	3.0	20.0	1587549140	-11.877611
22982085	As the article notes, this is hard t	As the article notes, this is hard to do cleanly, depending on the exact semantics of what you want. And even with a full spec in hand, I don't think git's data model makes it particularly easy to compute this information.One method for doing this manually is to do an interactive rebase and re-order all the relevant commits to the end. You basically create a new branch that has all the other commits first, and then you can diff between that point and the branch head. With the example commits from the post, you'd order them A B D F G C E H; then git diff G H would show just the changes from C E H.This is a bit annoying in that it needs to use the working tree to apply all the commits in sequence, and you have to manually resolve any conflicts that arise, which gets more difficult the larger	zwegner	8.609917	-6.529737	comment	3.0	12.0	1587853158	-11.835155
23000556	Can this stage individual lines, and	"Can this stage individual lines, and then display a view of only staged lines and no un-staged lines? AKA only the things you are about to commit.In SourceTree this is called ""split view staging"" and I find it indispensable. But SourceTree is so old as slow and unsupported that I'm desperately trying to find an alternative. Most of the existing GUI clients don't have this option."	pkamb	8.651657	-6.5130887	comment	3.0	11.0	1588024430	-11.838838
23004567	I can see why it feels this way, but	"I can see why it feels this way, but often times it seems to me the opposite is true, like a phase transition: it remains a bunch of commits until at some point it 'suddenly' becomes a product, usable by the designated users, solving a problem, possibly generating revenue.
Like water that cools and cools and eventually turns to ice, even though that last quarter degree didn't change the temperature a lot."	cmenge	8.602312	-6.5069165	comment	3.0	10.0	1588059903	-11.962418
23038630	>I know git internals enough to know	">I know git internals enough to know what a ‘ref’ is, but IMHO it’s a word that’s pretty hard for an average git user to know. I would suggest at least having a tooltip with some text like ‘Git references: branches, tags, etc...’ so that beginners can understand what it‘s used for.In general this is against our principles. We prefer to teach people how to use powerful tools rather than make less powerful tools that are easier to use. I don't believe that users are not capable of learning new things. In this particular case, this is the first time anyone has commented on ""refs"" being difficult to understand in the 1.5 years that SourceHut has been around.>If I remember correctly, I thought that a way to submit patches through a web UI was being developed... Is it still true?Yeah, this is st"	ddevault	8.543049	-6.466666	comment	3.0	24.0	1588301613	-11.901792
23044431	if you need a branch naming scheme, 	if you need a branch naming scheme, then you probably have too many public branches.	finnthehuman	8.570849	-6.548831	comment	3.0	11.0	1588354182	9.026743
23045339	Wait, are you telling me that    git	"Wait, are you telling me that    git branch -b ohnowhathaveidone

isn't right??"	ragona	8.546971	-6.5182576	comment	3.0	10.0	1588359440	-11.840412
23047183	You'd be surprised how few people lo	You'd be surprised how few people look through commit history while bug fixing.There's a steady stream of people who don't understand why 'breaking' the commit history is a problem, and assume you have some sort of untreated OCD if you bother to even care.	hinkley	8.584818	-6.5424314	comment	3.0	41.0	1588372019	-11.903102
23047694	100%. Apparently relatively few have	100%. Apparently relatively few have experienced the power of `git bisect run`. More than once I've had to explain that no, this isn't just some idiosyncratic aesthetic preference, there's a reason your version control tooling is designed the way it is.	bJGVygG7MQVF8c	8.5795355	-6.483436	comment	3.0	36.0	1588377053	-11.877489
23053527	Git Branch Naming Conventions for th	Git Branch Naming Conventions for the Real World	kowsheek	8.528177	-6.5287685	story	3.0	18.0	1588441788	-11.858536
23110868	On the flip side, reorganizing a cod	On the flip side, reorganizing a codebase totally fucks the git history.	smcameron	8.570513	-6.537082	comment	3.0	17.0	1588905697	-11.932289
23111132	Just make sure to use 'git mv' for a	Just make sure to use 'git mv' for all your files so the history can be tracked.  'git log myfile' will only show the history for that file, but 'git blame' will follow the line changes across file moves.That aside, there are some many productivity and tooling gains around organizing your project properly, that it is worth history discontinuities.Also, I've found that the worse the project organization is, the less likely the team is to separate out different fileset changes into different commits to keep a useful history, or make the use of the git history at all outside of looking at a few recent commits or or sometimes looking at the last release.  I've heard this as very circular arguments.  Can't re-org because we loose history.  Can't maintain good history because the project is too 	vimax	8.569697	-6.532119	comment	3.0	11.0	1588908512	-11.948219
23120785	Write meaningful git commit messages	Write meaningful git commit messages, always. Even in stupid side projects that don't matter. Because then when you're at work, it will be second nature to write good messages, and your colleagues will absolutely appreciate it.I've been following the keywords here: https://github.com/joelparkerhenderson/git_commit_message	jmondi	8.579248	-6.5273485	comment	3.0	10.0	1588981808	-11.907058
23124629	Curious why facebook went for mercur	Curious why facebook went for mercurial?	searchableguy	8.505869	-6.5301595	comment	3.0	17.0	1589031846	-11.90956
23149700	Learning Git from Novice to Expert	Learning Git from Novice to Expert	juan_allo	8.540099	-6.4882283	story	3.0	52.0	1589248047	-11.892713
23275125	Exporting environment variables via 	Exporting environment variables via artifacts sounds like a strange decision, but I guess its one way to do it. After years of waiting for jobs to communicate other then relying on file artifacts this is somewhat disappointing.I would like to see parent/child pipelines recive some love as currently it does work but quirks are all around. For example, its not easy (or sometimes even possible) to pass pipeline variables from parent to child, pipline UI behaves differently when being part of relation (and many times unusuable or shows a wrong thing), not being able to repeat manual jobs with the same var initially passed, not even being able to run it again with any other var unless you delete all previous executions, strange limitations on masked secret vars, $ in your password will get eval	majkinetor	8.642292	-6.440007	comment	3.0	13.0	1590171017	9.049147
23317694	I've found the ecosystem of porcelai	"I've found the ecosystem of porcelain for git to be pretty terrible. I usually point learners to- http://rogerdudler.github.io/git-guide/
- http://think-like-a-git.net/
- and https://www.sublimemerge.com/Sublime merge is much better than most GUIs in that it doesn't try to paper over the git concepts. It's just a UI for executing the standard commands.I think the key features of a CLI porcelain, other than simply renaming some commands (e.g. `git branch new` rather than `git checkout -b`) would be:- Making staging optional. Committing with no staged files would be equivalent to `git commit -A`. If you do stage files, then it would only commit staged files.- Auto-stashing. Such that you could switch between branches, and your in-progress changes would disappear and magically pop back when y"	nicoburns	8.586698	-6.536076	comment	3.0	12.0	1590536099	-11.894174
23363787	(Author) Please reply to this commen	(Author) Please reply to this comment with any bugs you face and I’ll do my best to fix them ASAP.I recommend you check out the log command. It’s quite powerful and the closest to a “git history search engine” I’ve ever seen.	parentheses	8.5657	-6.4569006	comment	3.0	19.0	1590866069	-11.801253
28010924	Why is is still master and not trunk	Why is is still master and not trunk?	ChicagoDave	8.592788	-6.531119	comment	3.0	13.0	1627670385	3.4552379
28025896	All visual git tools I've used suck 	"All visual git tools I've used suck and wound up eventually corrupting the repo. Also I've noticed that all of my colleagues who learned git using these visual tools didn't actually learn git, and have no idea how to anything other than add/commit/push.I say ""just rebase your branch"" and I can see the panic grow in their eyes."	oauea	8.549794	-6.48706	comment	3.0	36.0	1627821995	-11.879718
28026139	I will agree that visually seeing th	"I will agree that visually seeing the tree is such a useful tool to have access to. I know that's not the true desire of your use case, but in case it's useful, I will add what is obviously the best git alias, 'git lg': https://coderwall.com/p/euwpig/a-better-git-loggit lg --all is probably my most 
used command in terminals and I think it gives me a better view of how projects are flowing on the whole."	akamoonknight	8.591694	-6.478867	comment	3.0	14.0	1627824921	-11.893805
28027385	Yeah, viewing a changeset and stagin	Yeah, viewing a changeset and staging only some files or just parts of files is really important to my workflow. Sometimes I leave myself comments or skip tests locally and I have no intention of committing those changes. Using a tool like sourcetree to review, add, and commit only the lines I want is very helpful and saves me time.I do use the command line for everything else, though. Well except interactive rebasing, I suppose. I pop back in to vscode for that. But even that gets started in the terminal.	dvlsg	8.675937	-6.579472	comment	3.0	10.0	1627834604	-11.87273
28027832	Except for 99% of all git day to day	Except for 99% of all git day to day tasks are done with like 7 commands.Git commitGit checkoutGit mergeGit pullGit pushGit rebaseGit stashI can’t remember I needed a command that wasn’t one of those and I exclusively use the cli.	nerfbatplz	8.568714	-6.537833	comment	3.0	10.0	1627837240	-11.909271
28028054	I'm mildly amused that your set of c	I'm mildly amused that your set of commands can't actually commit anything other than a brand-new file!I will admit that I'm a lazy git user, and do most of my commits with `git commit -a`, rather than `-am` since I do try and give a short paragraph explaining the reasoning behind whatever the title message claims is the purpose of the commit.I do run `git diff` first to see what I've changed, and if the diff has unrelated changes in different files I'll usually break it up into separate commits.Decent introductory list, though. It won't surprise you that I think diff should be learned immediately; whether or not you need rebase depends on the conventions of the codebase, and if someone can learn it later they should, it can get tricky.	samatman	8.575433	-6.5580473	comment	3.0	10.0	1627838484	-11.914763
28033387	How does -b mean “create” in checkou	How does -b mean “create” in checkout? I get that it means “branch” but why is “branch” what I use to create a new one? The problem here is obviously the choice made for checkout, not switch. But consistency is more important so it’s better to keep consistency than “correctness” here imo. This problem already happened in the past with -d (delete).	alkonaut	8.558126	-6.554299	comment	3.0	20.0	1627884532	-11.901696
28109924	I feel like I must be unaware of how	I feel like I must be unaware of how other people use git, if this is remotely relevant.Everywhere I've worked has used a similar flow. Commits in master correspond 1:1 to PRs. Your personal flow of local commits or branches is irrelevant; your PR is reviewed as a unit, and merged as a squashed commit on top of master. The description of the PR is either exactly identical to the commit message, or only slightly modified.Clearly lots of people don't work that way, because that doesn't leave any room for a messy git history. I also don't know why I should care about the in-progress commits of my coworkers when I'm reviewing a PR as a unit.	delecti	8.573486	-6.5108695	comment	3.0	12.0	1628455428	-11.928122
28154588	One of my direct reports once fixed 	"One of my direct reports once fixed one of my ""simple bugs"" with the astonishingly direct commit message:""Const, motherfucker. Do you speak it??!?""(which, I hasten to add, would have been unthinkable if it had been a bit of peer-to-peer banter, much less senior-to-junior, but as a way of winding up your boss, it was a absolute masterwork)"	glangdale	8.591152	-6.5362406	comment	3.0	11.0	1628765315	-11.912216
28179159	Rebase is not only useful, but neces	"Rebase is not only useful, but necessary for a distributed VCS to be useful. To be precise, you need to be able to create new commits from old ones using the VCS itself, and if you can do that, you can also rebase.One of the major reasons I use git for source control whenever I can is that 100% of its features are available at any time for me to use in any way I wish. Rebase allows me to make commits for whatever reason I want at any time, and it's useful because losing committed data is really hard.When I'm writing code, I put very little effort into how to structure my changes into commits; That's done when I'm preparing a PR or a patch series, when I'm out of the coding mindset and in the ""how do I make this reviewable"" mindset. When you're contributing to a project, these are two separ"	chousuke	8.571884	-6.565148	comment	3.0	10.0	1628931072	-11.888364
28257221	Maybe I’m weird, but at some point I	Maybe I’m weird, but at some point I stopped fixating on which tools to use and just settled on a personal workflow:* terminal open at root of project used for source control* one or more tabs for ssh/VMs etc* IDE/VSCode/vim for editingAny of those is fine. And sometimes I switch between them depending on my mood. If I’m out and about it can be nice to conserve battery and focus by going full terminal mode. If I have AC power and a full screen then I don’t mind an IDE as much.One thing I insist on is doing as much work with git from the CLI. IDEs often do things like staging new files automatically that I’m not a fan of.	mattgreenrocks	8.650581	-6.4818344	comment	3.0	12.0	1629555666	-11.827792
28302305	ReGit is a tiny Git implementation w	ReGit is a tiny Git implementation written in Golang. It uses the same underlying file formats as Git. Therefore, all the changes made by ReGit can be checked by Git.This project does not aim at implementing all the features of Git. It is just an experimental implementation for learning purpose.	kevinhack	8.566131	-6.4785414	comment	3.0	12.0	1629902652	-11.884609
28303702	You sound a bit like those people, “	You sound a bit like those people, “git is just directed acyclic graph of objects, it’s all that simple”.	ilammy	8.55095	-6.4963636	comment	3.0	12.0	1629909360	-11.8749
28393293	hm. vexing.I feel like this is mostl	hm. vexing.I feel like this is mostly accurate, to my knowledge, but reading this:> I do not claim that this way of looking at Git represents absolute “facts” in any hard and fast or literal sense. But I contend that if you conceive of Git in the way that I’m going to suggest, if you substitute these conceptions of Git for any misconceptions you might have now, you’ll be a much happier and more fluid Git user.…vexes me.“Think of git like bowl of peanuts and marshmallows” and other pointless, wrong, metaphors about how git works are a dime a dozen.Yet, here is someone who is clearly quite familiar with git, and they go to pains to point out they are simplifying and may not be correct in their explanations.Its good to be humble, but ffs, git is too frigging complicated if the best you can ge	wokwokwok	8.539879	-6.5015163	comment	3.0	13.0	1630596606	-11.912109
28393854	This is the way I understand git. Fo	This is the way I understand git. For me it's dead simple. I've tried to teach others over the years. Not a single person has got it so far.	globular-toast	8.525093	-6.509059	comment	3.0	11.0	1630599078	-11.899067
28393873	afaik, the commit a tag points to is	"afaik, the commit a tag points to is immutable unless you delete and recreate (and then nothing is immutable really).re ""ride"" - that's exactly what I'm trying to avoid. It's an additional concept that isn't needed to understand Git. You need to understand the model. The ""ride"" is an emergent property of the model and commands that you eventually understand, but not a core part."	bironran	8.589238	-6.5087533	comment	3.0	10.0	1630599200	-11.828925
28393755	Reminds me of:    Bad programmers wo	"Reminds me of:    Bad programmers worry about the code. Good programmers worry about data structures and their relationships.

    -Linus Torvalds

Anyway, it's not for everyone to get to understand git this way, I guess. Some people will just react ""just tell me how to do X in git!"""	megous	8.545257	-6.479747	comment	3.0	11.0	1630598601	-11.874225
28395003	> The problem with how people use Gi	"> The problem with how people use Git, I’m suggesting, is that their analogical or metaphorical conception of Git doesn’t work — it doesn’t fit the way Git actually behaves — if, indeed, the conception exists at all.No, the problem is not with ""how people use Git"". The problem is with git. We've known for years how to make clear, concise interfaces that help people understand what's going to happen. Git does not have a clear, concise interface. That is its biggest problem and will continue to be until it is changed to have a clear, concise interface."	thewebcount	8.545157	-6.497302	comment	3.0	12.0	1630604352	-11.899501
28425768	While auto-generated changelogs aren	While auto-generated changelogs aren't the best, they are better than nothing.  Too often I've seen projects without a changelog which is especially annoying when dealing with breaking changes.I've been considering switching to a changelog generator, either from Conventional Commits or from a folder of files just to avoid merge conflicts with the CHANGELOG file.If people want enforcement of Conventional Commit, check out https://github.com/crate-ci/committed	epage	8.592812	-6.521593	comment	3.0	13.0	1630861337	-11.910626
28438760	> Third, Paragon's repository has co	"> Third, Paragon's repository has commit messages which lack information, like ""Merge branch 'torvalds:master' into master.""> Torvalds said that ""Linux kernel merges need to be done properly."" He added: ""That means proper commit messages with information about what is being merged and why you merge something. But it also means proper authorship and committer information etc. All of which github entirely screws up.""100% agreed with this. On a related note I truly despair a little when people insist on blanket ""squash everything"" workflows where the source control UI defaults to (or has been configured to only allow) squash merges.It goes from one extreme of ""removing wip and todo commits from the history"" to ""remove commits almost entirely and lose all the context"". I'm guilty of the first "	lloydatkinson	8.580498	-6.5514307	comment	3.0	19.0	1630966903	-11.9425535
28468255	I don't know why it hasn't occurred 	I don't know why it hasn't occurred to me as a problem before, but branches/PRs can also modify the workflow, and their build runs the new modified workflow... I must be missing something, because that seems to make it way worse, forget symlinks and project-specific vulns, just print the env? Has modifying the workflow on a 'PR branch' only worked for me because I've been the repo owner perhaps?Edit to add: I think what I'm missing (haven't fully understood yet, just thought should share) is the importance here of the 'pull_request_target' event type used. The docs carry a warning:> Warning: The pull_request_target event is granted a read/write repository token and can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull r	OJFord	8.5665455	-6.456515	comment	3.0	18.0	1631184099	-11.924799
28538695	Is the official Git default master o	Is the official Git default master or main?	chagaif	8.516126	-6.5274405	story	3.0	1.0	1631711889	-11.721395
28557522	I really want one of these to take a	I really want one of these to take a git sha1 and make a unique code name for continuous releases ... but I haven't wanted to take the time to make sure no particular word combos wouldn't be offensive.  And 160 bits is quite a large domain, but I think occasional rare duplicates would be ok.Has anyone already solved this?	rrauenza	8.657356	-6.5104294	comment	3.0	14.0	1631826019	7.1649
28578726	> If only we could instead have an i	> If only we could instead have an intuitive version control systemWhat makes git any less intuitive compared to svn or cvs?  To use either of those or git effectively required reading through documentation to understand what each command did.	u801e	8.589811	-6.469934	comment	3.0	10.0	1631994503	-11.869904
28595412	> Git was not built for this - ...Bu	> Git was not built for this - ...But it does have a sort of plugin system to support other formats, right? Does an Excel format lend itself to being supported in this way?	jagged-chisel	8.573789	-6.44076	comment	3.0	10.0	1632154403	-12.016268
28665439	Downloads points to like a git-lfs p	"Downloads points to like a git-lfs pointer or something?   version https://git-lfs.github.com/spec/v1
   oid sha256:f53cea2b22f3343d76ca776c9378c212a6eeb1e67f4f8a26dc780d6247d7df38
   size 148824450"	icegreentea2	8.571336	-6.4558997	comment	3.0	10.0	1632697273	-11.892313
27845742	Probably the most popular one would 	"Probably the most popular one would be the ""new hotness"" that everyone used, or aspired to use, before git became popular, Subversion (https://subversion.apache.org/).There are others that aren't free (e.g. Perforce) and some that aren't quite dedicated to the monorepos & subtree workflow, but which handle it better by design (e.g. Darcs, http://darcs.net/).But, mostly I'm thinking of Subversion."	im_down_w_otp	8.600135	-6.446106	comment	3.0	10.0	1626362239	-11.8839655
12035582	> Latest commit 95f255a  on Mar 26, 	> Latest commit 95f255a  on Mar 26, 2015	aeosynth	8.603138	-6.4471483	comment	3.0	12.0	1467716820	-11.886812
12036508	http://homu.io goes a bit further (i	http://homu.io goes a bit further (it actually triggers CI builds of the merge results to check they are okay), but it seems it is currently unmaintained.BTW, I would gladly pay money for this! Even more in combination with features from Facebook's mention-bot/Rust's highfive.	killercup	8.630195	-6.5363116	comment	3.0	14.0	1467727793	-11.863653
12043630	Ask HN: What cloud automation platfo	Ask HN: What cloud automation platform do developers prefer?	morpheyesh	8.738452	-6.480381	story	3.0	4.0	1467818230	9.405409
12057733	This is cool. If anything though, i'	"This is cool. If anything though, i'm more intrigued by Pijul haha.I use Git day to day simply because it is the defacto.. but i have never liked it. I've longed for a better dvcs. Granted, i'm not sure i'll ever get it, but seeing new attempts is always appreciated.edit: It should be noted that in my case above, ""better"" simply means more intuitive. I'm not complaining about Git either. But, it has a history of not being intuitive.. i think we can all agree there. That's all i mean."	fizzbatter	8.58092	-6.538494	comment	3.0	13.0	1468003055	13.893463
12094827	This article has been written a mill	This article has been written a million times already. It's another holy war.  Vim, spaces, rebase. The sad part is that IMO merge people are on that side because they are afraid of rebase or don't understand it.	hashkb	8.614092	-6.5615177	comment	3.0	17.0	1468511381	9.264042
12094991	Clean project history is overrated.I	Clean project history is overrated.If you work on a sizeable team with code review before merge workflow, the tip of the repository will be moving faster than is pleasant or safe to rebase, and every so often, commits will exist in multiple different branches (in order to prevent blocking development pending a code review). You do not want to be rebasing commits such that they appear in multiple different branches with different hashes etc. It's a recipe for pain. And being blocked until code is reviewed and merged is hardly more productive.Even working like this, git bisect works just as well to find a commit, and git log on an individual file works just as poorly as it always does (e.g. changes in merge conflict resolution are hidden by default).Rebase if the commits only exist in your l	barrkel	8.575381	-6.5592494	comment	3.0	15.0	1468512467	-11.918182
12095074	> Clean project history is overrated	"> Clean project history is overrated.I go back and forth on this issue.On one hand, I like having commits that do one thing. Makes it easier to ""read"" a project's history, to revert things, to track down bug introductions.On the other hand, I like having a history of the mess of how I actually implemented something, because it's more accurate and more detailed, both of which help when I go all DETECTIVE-MODE: ACTIVATE.But on the other hand, the mess often includes such uselessly awful commit messages, and lots of terrible code that only existed for like 2 hours until I realized it was the wrong way to do it, and scrapped it. That's kind of a red earring.So I don't really have a firm opinion on it anymore. I just go with whatever I feel that day. That said, I'm a team of 1 and have been for"	sdegutis	8.573884	-6.5424385	comment	3.0	11.0	1468512993	-11.904191
12098495	Bitbucket has remained a standalone 	"Bitbucket has remained a standalone product, but I don't think many of its original mercurial userbase feel like it's been ""safe"".When Atlassian bought bitbucket it was the place to host mercurial repositories. Now it's a git hosting service that hasn't gotten around to turning off mercurial support yet."	timv	8.485743	-6.5221286	comment	3.0	14.0	1468547293	-11.969664
12106295	My feeling is that this is actually 	"My feeling is that this is actually a problem with github and the ""pull request"" method specifically. All of the back and forth, waiting for the contributor to update commits is a huge time sink for me. It takes 10x as much effort to merge a small pull request than to actually write the code myself.The solution I see, is to make it so that rather than commenting on pull requests, I ""adopt"" the pull requests. I merge them into a private branch, fix the spelling errors and the ""bad"" variable names, and then I push the bundle. For some reason, most contributors want to have a clean commit history and don't like this method. I agree that it is messy. I think that my ""solution"" points to the need for a better solution. Either one implemented by github or one implemented by a competitor which de"	timthelion	8.585351	-6.4465675	comment	3.0	14.0	1468676681	-11.855823
12220262	  curl https://.../hook.sh > .git/ho	"  curl https://.../hook.sh > .git/hooks/pre-commit
This seems like a bad idea, since you may already have a commit hook that this would clobber.Does anyone use any kind of plugin manager for git hooks? I know I can just build a shellscript (and have done so extensively) but is there something like pathogen / npm / bundler for a pluggable git hook architecture?https://github.com/brigade/overcommit seems to be an option, anyone have experience with that?"	web007	8.600502	-6.482801	comment	3.0	12.0	1470248917	9.329936
12292597	Change the base branch of a Pull Req	Change the base branch of a Pull Request	btmills	8.580299	-6.4560995	story	3.0	28.0	1471287494	-11.8936205
12304603	At the same time, with this workflow	At the same time, with this workflow (just like git flow) you're not doing continuous integration. Which is quite bad, imho.https://www.franzoni.eu/git-flow-is-superflous-and-complex/	alanfranzoni	8.5558405	-6.478831	comment	3.0	11.0	1471441422	-11.894062
12310811	This is a revealing peek at the comp	"This is a revealing peek at the complexity of merged history. You can't project a ""git space"" onto a line, so a (linear) listing of commits just misleads you into thinking that your history is linear. That complexity is why I always prefer to rebase and keep my history an actual straight line.TL;DR
- Merging is powerful, but comes with a cost.
- Rebase is your friend. Keep it simple."	pwfisher	8.577208	-6.55133	comment	3.0	10.0	1471503282	-11.909972
12358226	I have this alias in my ~/.gitconfig	"I have this alias in my ~/.gitconfig:    cancel = reset --soft HEAD^

I don't want an alias to hard reset, it seems to dangerous and a good way to lose some work. However a soft reset like this allow me to cancel the last commit and add an omitted file, or remove one from the commit, or simply to correct the commit message easily."	p4bl0	8.584659	-6.5274277	comment	3.0	10.0	1472124874	-11.899213
12459912	The screwed up and committed to mast	"The screwed up and committed to master should end with:     git reset --hard origin/master

(assuming that the remote is called ""origin"") With the example in the text, you have to know the number of commits you've made to master."	random567	8.566118	-6.542716	comment	3.0	11.0	1473400816	-11.925419
12460015	I absolutely love git now.I'm still 	"I absolutely love git now.I'm still at uni (at a highly ranked but actually crap university where we don't learn git properly) and this year was my 'year in industry' as we call it in the UK, and my first proper experience with git, aside from `git init` at the end of my project and pushing it to a repo.I've become so much more confident with git. Seriously, with one caveat (i.e., you haven't pushed your changes to a branch which other developers are working on), it is almost impossible to break irrevocably. Even if you do accidentally break master/develop/whatever, it only causes a bit of hassle and grumbling.Highly recommend that everyone take a bit of time to learn about ""undoing"" git commands, whether that's through soft resets, hard resets to origin, or the reflog.Reflog is also usefu"	mathieuh	8.55531	-6.506304	comment	3.0	15.0	1473402415	-11.897196
12460812	"Getting to ""Fuck this noise, I give "	"Getting to ""Fuck this noise, I give up."" is a very clear indication that you aren't competent enough and you should take a GOOD course about git as soon as humanly possible.Shameless plug: http://engineering.hipolabs.com/how-to-work-in-a-team-versio..."	lambdacomplete	8.546378	-6.4776816	comment	3.0	13.0	1473416131	-11.914489
12461476	One of the nice workflows that's alr	"One of the nice workflows that's already built in to the git command line tools is this one. When you're working on a branch and realise that a commit you made a few commits back has a mistake in it:    # Make correcting change
    git commit --all --fixup=<ref of commit with mistake>
    # Continue working on branch, then at some point
    git rebase --interactive --autosquash

The --fixup option creates commits with subjects formatted like 'fixup! previous commit subject'. --autosquash uses these subjects when building the interactive rebase list.Handy enough that I set rebase.autoSquash to true in my ~/.gitconfig so 'git rebase -i' always works like this."	mhw	8.577683	-6.558145	comment	3.0	13.0	1473424064	-11.911076
12461944	One thing not covered very well was 	"One thing not covered very well was what to do if you push to origin. My favourite way to fix this: use git revert to create an exact opposite commit to your bad commit.  git revert <bad commit>
  git push

It leaves a history of the mistake, for better or worse, but it does undo the mistake on origin."	mabbo	8.575516	-6.5284157	comment	3.0	14.0	1473427715	-11.906592
12462721	Somebody proposed to use a GUI. That	Somebody proposed to use a GUI. That doesn't solve the usability issues of Git. There's this triangle of what the user tries to do, what the commands and options are called and what they actually do. None of them really align, though with some careful use you can actually make Git do what you want - eventually.I would like to understand what's the yearly damage of such an important tool being so difficult to use. People committing the wrong stuff, unmergeable messes, people not being able to correct their mistakes, there must be thousands of Git rookies fucking up their Git repo or throwing away their work just as I am writing this.What would be the cost? Millions of Dollars? Perhaps even billions?It's about as bad as 0 being a legit value for a regular pointer.	dep_b	8.573197	-6.5120463	comment	3.0	40.0	1473432612	-11.912476
12464240	>But Git's internals are simpler and	">But Git's internals are simpler and the concept is much easier to understand,I'm only an occasional Git user, but am a heavy Mercurial user.I have never needed to understand Mercurial's internals.Are you suggesting a Git user will eventually need to understand it? That's a strike against Git already.From my observation over the years, people who use Git get ""stuck"" more often, because they are trying to leverage the extra power Git seems to provide. With Mercurial, you often can do similar powerful stuff, but they make sure you have to go through hoops to do it. As such, unsuspecting non-power users do not shoot themselves in the foot."	BeetleB	8.510313	-6.54335	comment	3.0	10.0	1473441658	-11.955885
12502353	How much of this could have been sol	How much of this could have been solved by simply using compression?  That is, instead of making up a new delta language, just store the full files, and let compression tools do their job.I thought this was the definitive reason why git tracks full files, and not diffs.  Turns out, that is just a better way to do things in most cases.	taeric	8.689658	-6.484278	comment	3.0	12.0	1473898011	-11.778222
12518449	MIT, you know I love you guys. I hav	MIT, you know I love you guys. I have a tremendous amount of respect for you and your work, and you haven't yet eroded the good will you got for helping to revolutionize computing on multiple occaisions, and also for establishing Switzerland, and thus being responsible to some degree for Hacker culture, and a whole other wide variety of important work, and the Lisp languages (including Scheme) as we know them to today.However, if you talk about how you've made significant advances to the state of the art in a field, and talk about a really cool project you made with this advance, and you do not tell us how you did it and link the git repo, than I don't care. Software is a collaborative effort. If you don't tell us how you got a result, or only give general overviews, then we have to re-dis	qwertyuiop924	8.542749	-6.469534	comment	3.0	25.0	1474072564	-11.829676
12523577	Wouldn't it have made sense to rever	Wouldn't it have made sense to revert the first subpar commit, pulled aside the contributors and explained to them what is acceptable?Disowning the project seems like a lose/lose situation.	ckdarby	8.58513	-6.4975777	comment	3.0	10.0	1474164371	2.2794979
12886492	    > I also consider `git add -A` t	"    > I also consider `git add -A` to be horrible
    > practice. Adding files manually makes you tons more
    > aware

Agreed, but I take it further than that - I always use `git add -p` because it forces me to read through everything, and make everything in the commit deliberate.Even if you think you just made a slight change to a file or two and definitely want everything, you'd be surprised how often it lets me pick up some aesthetic change, comment change, or dependency version bump that's completely unrelated to the commit message I'm about to write."	OJFord	8.583829	-6.514867	comment	3.0	23.0	1478458841	-11.895216
12886700	As a counterpoint, every time I've t	As a counterpoint, every time I've tried a git GUI (I've tried lots), I end up bashing my head against it within a few minutes. They usually make very basic things easy and anything even slightly outside the box basically impossible.I'm much more productive using a couple of git commands that I can type in a few seconds, rather than hunting for things in menus and dialogs for ages.> committing individual lines or chunks in my files instead of the whole fileThat's really git 101. I'd expect if you haven't learned to do that via the CLI then maybe you gave up too soon and jumped straight to GUI? `git add -p .` is very easy to use.	craigds	8.566983	-6.4929676	comment	3.0	11.0	1478461428	-11.908021
12939703	Don't forget to git push --force to 	Don't forget to git push --force to resolve conflicts!	tux3	8.575065	-6.4835935	comment	3.0	15.0	1478979040	-11.871508
12941355	> Bonus question) Why are we thinkin	> Bonus question) Why are we thinking about all of this. You should have just used s3?NFS and Ceph both support the standard POSIX file access model, notably including random-access reads and writes on a file without replacing the entire file and consistency models that let you reason about directories and their contents usefully. If your goal is to run the reference implementation of git, or something that is compatible with it, on the filesystem, you absolutely need something that supports this.You could write something new that speaks the git protocol but is designed to be backed by an eventually-consistent object store instead of a POSIX-compliant file store ... but that seems like an equally big challenge, honestly.	geofft	8.596556	-6.438166	comment	3.0	18.0	1479001369	-11.865779
12942452	Everyone says what Git branch workfl	Everyone says what Git branch workflow should you use, but honestly, it can be complicated especially for junior developers.Just commit everything to master and that's all! Sound stupid but worked best for us. I have seen a big software company using this, I learned this from them and never looked back!	Walkman	8.563706	-6.509749	comment	3.0	11.0	1479026391	-11.909758
12944333	I would strongly recommend avoiding 	I would strongly recommend avoiding a rebase-based strategy. When developers at my company run into git issues, they are almost always the result of a bad or confusing rebase.My team's process is simple and easy for anyone to follow: all feature work is done on feature branches. Branches should be kept small and atomic. When they've passed code review, squash and merge into Master.If you need to pull changes from master, always merge into your feature branch, never rebase.	jkubicek	8.578818	-6.5554423	comment	3.0	11.0	1479057286	-11.92596
12958596	How is git unnecessary and unfashion	How is git unnecessary and unfashionable noise?What do you propose will replace the tool a decent chunk of people use to work on large software projects together?	castis	8.55332	-6.491361	comment	3.0	10.0	1479222637	-11.904171
12965428	The author doesn't know anything abo	The author doesn't know anything about VCS. And Bram is almost right in this case, Linus wrote Git in 10 days.The thing is, Git is pretty much the most horribly over complicated user tool in history. Learning how to use Git properly is more complicated than learning how to use Unix. Several times more complicated. I honestly would be more comfortable giving a modern team who had never seen a VCS before just plain old CVS, because even if it's horrible, at least it's simple and you can just work around the stupidity. Git will leave you trapped in a hellscape of reading manuals and howtos and bloating personal repositories, and not really do anything particularly great except feature branches.DVCS is great when you need it, but when you don't need it, it's annoying as hell.	peterwwillis	8.585396	-6.4734344	comment	3.0	17.0	1479286304	-11.873475
12965580	Linus was moving off of BitKeeper, w	Linus was moving off of BitKeeper, which obviously was some of the inspiration for git - but the underlying model is nothing alike. Git's data model is much simpler than CVS, RCS, Subversion, BitKeeper and basically anything else that existed at the time, and it was also much faster. The command line interface doesn't reflect this properly, but it's the underlying model that counts.Git is nothing like a reimplementation of BitKeeper - the closest inspiration and model is actaually Monotone, which had the same basic concepts but was slow and clunky. IIRC, Torvalds credited monotone/Hoare for using merkle trees (and other things)	beagle3	8.575991	-6.4704113	comment	3.0	39.0	1479288518	-11.916409
13066617	This is a really well written partia	This is a really well written partial set of release notes. I was curious and looked at the full release notes [1], and I think these are pretty well written as well. I'm very impressed, especially given that git has such a large set of contributors.[1]: https://github.com/git/git/blob/v2.11.0/Documentation/RelNot...	mixedmath	8.578791	-6.522671	comment	3.0	12.0	1480456946	9.315225
13153932	"The amount of times the word ""update"	"The amount of times the word ""updates"" appears in the commits makes me feel much better at my difficulty of choosing succinct and unique commit messages."	mparlane	8.583062	-6.5169334	comment	3.0	15.0	1481496959	-11.900463
13154331	I don't see why it wouldn't be diffi	I don't see why it wouldn't be difficult to do a git implementation that replaces all the FS syscalls with calls to S3 or native ceph or some other object store.  If all they're using NFS for is to store git, it seems like a big win to put in the up front engineering cost.I mean, especially because git's whole model of object storage is content-addressable and immutable, it looks like it's a prime use for generic object storage.	ninkendo	8.591306	-6.477435	comment	3.0	11.0	1481500513	-11.922955
13163189	To be fair git could be given a tiny	"To be fair git could be given a tiny bit of ""smarts"" per language it's looking at. So say 2 different people add attributes to an HTML item it could use some sort of system that let's it run an HTML merge resolution routine that says ""hey that's cool let me just combine those"".At the same time adding extra smarts like that, while providing a better UX when it works, the times where it doesn't work especially if you don't notice it stopped working in a specific way...that all scares me.I'm not sure we're ready for smarts in our merging."	BinaryIdiot	8.576	-6.5053687	comment	3.0	15.0	1481586267	-11.915278
13163300	I posted this in a comment above but	"I posted this in a comment above but because it's relevant I feel it's worth putting here as well[1]:git rerere (reuse recorded resolution): https://git-scm.com/2010/03/08/rerere.html""it allows you to ask Git to remember how you've resolved a hunk conflict so that the next time it sees the same conflict, Git can automatically resolve it for you.""[1] This isn't explicitly against the rules but if it's in bad taste I'll happily remove it."	dabber	8.607548	-6.526588	comment	3.0	11.0	1481587450	-11.875335
13163457	You can get it back by making your b	"You can get it back by making your bisect test function return ""good"" whenever it sees a commit with merge conflicts."	jzwinck	8.614293	-6.537293	comment	3.0	10.0	1481589245	-11.8960495
13176267	Complete guess based on [1], but wou	"Complete guess based on [1], but wouldn't  git diff HEAD $(git merge-base HEAD master)

work?[1]: https://stackoverflow.com/questions/1549146/find-common-ance..."	trolor	8.626243	-6.5146394	comment	3.0	11.0	1481726719	-11.829373
13209200	There's this magical process called 	There's this magical process called continuous integration that internalizes the impact of bad (or, more likely, misguided) developers. Don't let them merge their branch until all tests pass. If their commit breaks something while all tests still pass, then direct them to write the missing tests.	dankohn1	8.719177	-6.52372	comment	3.0	25.0	1482116035	-11.841539
13228857	While an unorthodox merge strategy w	While an unorthodox merge strategy was used, this is what happens when you hole up in a topic branch for a long time. I bet this would've been easier had they merged smaller commits or PR's to master constantly. If one is afraid of deploying unfinished features, don't make them functional until they are ready. Tie them together once finished. Or did I miss something here?	msvalkon	8.599851	-6.5433717	comment	3.0	24.0	1482326629	-11.899262
13228906	The more I read stuff like this, the	The more I read stuff like this, the more I wonder how many problems would just go away for so many people if they used Mercurial instead.	hellofunk	8.486636	-6.5903745	comment	3.0	14.0	1482327164	-11.974556
13228956	I'm also very surprised - I thought 	"I'm also very surprised - I thought it was standard to merge master (target upstream branch) into the topic branch frequently (daily seems reasonable). I know some people do not appreciate ""merged <branch> into <other branch>"" commits in their history, but that is a small price to pay IMO."	sangnoir	8.590117	-6.553484	comment	3.0	17.0	1482327600	-11.917252
13229548	> most commands or command flags sim	> most commands or command flags simply help the user do something in an automated fashion that you could do by typing each specific command out (i.e., git pull --rebase)A tangent perhaps, but would you mind expanding on this? I use `git pull --rebase` frequently, and I'm not sure how this fits into what you described. Is it the specific command, or the automated shortcut? And what's the counterpart?Just trying to check my mental model.	darkerside	8.571992	-6.548181	comment	3.0	10.0	1482332038	-11.916508
13229582	Mercurial bookmarks are equivalent t	Mercurial bookmarks are equivalent to git branches, but Mercurial branches have no equivalent in git. In Mercurial, branches give you a way to track the branches a commit is a part of which is good for long-running branches (I think of things like master, maybe a long running refactor or major feature branch) while bookmarks are great for the more normal workflow of small, focused, feature branching. Neither of those are designed to cover a gap in the core design, they are a _feature_ of the core design that git doesn't even have.	blktiger	8.517257	-6.5525904	comment	3.0	42.0	1482332380	-11.953425
13230049	> It's stupidly simple at the end of	"> It's stupidly simple at the end of the dayThat reminds me a joke. On a particularly convoluted math lecture the professor writes on the whiteboard and explains at the same time: ""from here we can state that, obviously..."" He suddenly stops, slowly turns the head down, keeps mumbling ""so we can obviously..."". He slowly walks in the room, trying to catch the thought, then leaves the room... Some minutes pass. Then he comes back, with head up, widely open eyes and confidently continues - ""Yes, this is completely obvious - so from here we can easily get the following conclusion.""Git has a lot of nice explanations. However it's either a particularly edgy case, or all those great explanations somehow fail to easily conduct those core ""stupidly simple"" ideas forward to actual Git beginners. At "	avmich	8.5424385	-6.499297	comment	3.0	23.0	1482335786	-11.914294
13230479	The fact that you use a Windows-only	The fact that you use a Windows-only GUI for Hg is extremely telling. Git is fundamentally a Unix tool that follows Unix design expectations and integrates with the Unix ecosystem and expects the user to be a component command line user.	Sir_Cmpwn	8.5718775	-6.4626207	comment	3.0	22.0	1482338541	-11.84887
13229589	Git is just getting in the way of th	Git is just getting in the way of the classic old philosophical discussion of there should only be one correct way to think vs a more multicultural the more ways there are to think and adapt and overcome, the better.The technical discussion of git innards and workflow just get in the way of the core philosophical discussion, and the innards would fall into place if the philosophical question were answered (as if philosophical questions are ever truly answered, LOL)A classic example of the philosophical argument is Perl vs Python.  There's infinite ways to express yourself vs there is only one way that works.Now its very politically incorrect to say you like Perl in 2016 and I suspect Git is going to be in big trouble soon enough for the same philosophical reason.I would be interested in he	VLM	8.573887	-6.478959	comment	3.0	13.0	1482332415	-11.920434
13231050	"    ┌─────┐◀──────── master
    │Mer"	"    ┌─────┐◀──────── master
    │Merge│◀──────── bugfix
    └▲───▲┘
     │   │
     │   │
     │  ┌─┐
     │  │B│
     │  └▲┘
    ┌─┐  │
    │A│  │
    └▲┘  │
     └───┤
         │
    ┌────────┐
    │Ancestor│
    └────────┘

Which branch was commit `B` made on?  What did the `bugfix` branch look like one commit ago?"	stevelosh	8.574084	-6.5463033	comment	3.0	10.0	1482342622	-11.90306
13232415	I'm sorry, in what practice are you 	"I'm sorry, in what practice are you in where your commit messages are somehow so lackluster that a branch name (not even a PR!) can give you more information about why something is being done?And to make sure no one responds with some silly ""just because you don't have a use for it, doesn't mean don't have their uses for it"": I get what you're trying to say. I'm really just not buying it as an actual use case. If your commit message isn't sufficient enough to explain the purpose of the commit (ticket numbers, explanation, etc), it doesn't get approved. If you're relying on a <20 character branch name to give you sufficient context about a commit a year later, I simply have no words.>which I think a mercurial-style branch name answers.I find that extremely suspect."	justinlaster	8.570908	-6.532675	comment	3.0	14.0	1482352588	-11.9492655
13314295	Search commit messages	Search commit messages	moby	8.581455	-6.5333786	story	3.0	27.0	1483486199	-11.892422
13320895	How would you prevent this from bein	"How would you prevent this from being a back door into a person's house?  Or, more directly, how do you prevent applications from stealing phrases from each other?That is, you are basically saying that you want everything in $PATH.  This would be like if git had decided that ""log"" should just do ""git log"".  Certainly could make sense.  And I agree that users should be able to allow this.However, the applications?  I'm not as sold.  You are basically allowing a situation where the fundamental behavior of the system would change from installing a single skill.  And it might not be clear on how or why it changed.  (Certainly not to most users.)"	taeric	8.568595	-6.462256	comment	3.0	14.0	1483555390	-11.85897
13364338	Staging, unstaging, and discarding l	Staging, unstaging, and discarding line-by-line has been extremely flaky for me in v1 and v2. Often discarding a deleted line will insert the line in a completely unrelated part of the file, so instead of a deletion, you now have a deletion and an addition. And so on.In combination with GitUp, it's still a great tool, but it could need better QA so that even edge cases are solid.	gurkendoktor	8.672794	-6.5743527	comment	3.0	12.0	1484051417	-11.917162
13379811	Amusing and depressing, awesome stuf	"Amusing and depressing, awesome stuff.Git's rise to become the de facto standard revision control system has been fascinating to watch.I think it does provided real benefit over Subversion, but there are also smaller projects where the gain is marginal.The tooling around (in particular GitHub) and perception that git is the ""right"" way to do things probably helped it achieve prominence. As well as early adoption by a few high profile projects."	xja	8.5843935	-6.493354	comment	3.0	19.0	1484194930	-11.890452
13379938	"""How can I find out which branch eac"	"""How can I find out which branch each parent was originally made on"" -- ouch.  Ive dreamed of automatically tacking on branch names to commit messages to solve this very issue."	mooneater	8.569977	-6.546959	comment	3.0	14.0	1484197483	-11.920716
13384390	> Its user interface is a landfill f	"> Its user interface is a landfill fire.Are we talking about the same Git?  Its command line interface is quite straight forward and very simple to use to perform the usual everyday tasks.Can you actually point out a single example of what you perceive as a ""landfill fire""?"	geezerjay	8.550922	-6.480549	comment	3.0	13.0	1484243361	-11.901496
13386050	And if you learned SVN, you would ha	And if you learned SVN, you would have had a solid base for understanding GIT.  Would you expect students to learn source code control in the abstract or not at all?You have to do programming assignments anyway.  Why wouldn't you require students to learn and use the latest source code control tools while they're doing their development?Teach students to write tests, use source code control, utilize continuous integration, etc.Although the specific tools, languages, and approaches will evolve in the coming years - none of the above are going away soon.	crusso	8.602528	-6.4439116	comment	3.0	12.0	1484254707	-11.888789
13400833	Regarding the last git command you l	"Regarding the last git command you listed, I actually find it better to do    :r !git status -v

And at the to of the result, type my formatted git commit message, visually highlight the message I just typed, and then use the following vim command    :r !git commit -F -

Which reads the commit message from standard input."	u801e	8.595252	-6.525002	comment	3.0	14.0	1484431491	-11.868216
13492617	Here's what, Tim Pope, our favourite	"Here's what, Tim Pope, our favourite vim nerd has to say about this: http://tbaggery.com/2008/04/19/a-note-about-git-commit-messa... (Same, but with more words.)A point of contention seems to be the choice of the imperative, at least for the subject line. While I'm really used to it, both when reading and writing, many people seem to strongly prefer past tense (""Fixed bug …"" instead of ""Fix bug …"")."	svckr	8.584464	-6.5282216	comment	3.0	12.0	1485447611	-11.898723
13492958	Translation:  I won't want to do the	"Translation:  I won't want to do the extra work to format my commit messages.How I understand that:  If you can't format your commit messages, how can you be considered reliable to format your code how the company defines it?I'm sure someone can write a patch for git commit comments to enforce a 74 character limit on line width with CR\LF indiscriminately or separate them ""smarter"" by breaking words at 0020 after it crosses the 74 character width limit. But that's besides the point."	AckSyn	8.579143	-6.582244	comment	3.0	12.0	1485449619	-11.856609
13515609	We currently use short-lived feature	We currently use short-lived feature branches, merged via Pull Requests (+ review / automated testing) into the main development line. This way, we can communicate changes in a detailed manner before they are added to the product and make sure there is no unfished or bad code in the main branch. (The dev team is small, 5-8 devs).I don't see (yet?), what benefits TBD would provide in such a setup.	cygned	8.612171	-6.541629	comment	3.0	17.0	1485713305	-11.896657
13515683	"I would hesitate to proscribe a ""one"	"I would hesitate to proscribe a ""one true way"" as well but the longer I develop the more convinced I am that a having branch lives longer than a few days indicates a serious underlying problem (usually a lack of test coverage or faith in said tests)."	crdoconnor	8.642892	-6.5403986	comment	3.0	18.0	1485713950	-11.812812
13516828	In subversion the only way I can pos	"In subversion the only way I can possible develop with sanity is in an ""unstable trunk"". Branch off releases N weeks before shipping, and have only the requirement that trunk passes automated tests while release branches are manually tested. Obviously you don't release more than say once every month or two, but that's more than enough for most.I'm honestly not sure if the site is satire?No one develops in long lived feature branches in svn (rather, everyone does, but most only try it once before they realize the pain of trunk based dev is much smaller than that of svn merging)."	alkonaut	8.587356	-6.491179	comment	3.0	16.0	1485725615	-11.8809
13559020	GVFS: Git Virtual File System	GVFS: Git Virtual File System	vtbassmatt	8.578587	-6.4376698	story	3.0	6.0	1486120088	8.361115
13560041	Yes they did. They choose to scale o	Yes they did. They choose to scale out Mecurial to solve their problem. Wonder if they still use Mercurial?https://code.facebook.com/posts/218678814984400/scaling-merc...	mox1	8.505913	-6.551597	comment	3.0	13.0	1486132771	-11.966175
13560681	"My sysadmin: ""we won't switch to git"	"My sysadmin: ""we won't switch to git because it can't handle binary files and our code base is too big""Our whole codebase is 800MB."	cafebabbe	8.566924	-6.45965	comment	3.0	11.0	1486137573	-11.886569
13560866	Maybe something that has the data mo	Maybe something that has the data models of git but has a more consistent interface? Today on Git Merge there was a presentation about http://gitless.com/For example one of the goals is to always allow you to switch branches. Stash and stash pop would happen automatically and it would even work if you're in the middle of a merge.	sytse	8.581988	-6.506104	comment	3.0	12.0	1486138943	-11.902506
13561040	> when you run “git checkout” and it	> when you run “git checkout” and it takes up to 3 hours, or even a simple “git status” takes almost 10 minutes to run. That’s assuming you can get past the “git clone”, which takes 12+ hours.How on Earth can anybody work like that?I'd have thought you may as well ditch git at that point, since nobody's going to be using it as a tool, surely?    git commit -m 'Add today\'s work - night all!' && git push; shutdown	OJFord	8.568149	-6.4403143	comment	3.0	10.0	1486140066	-11.875291
21189257	I got a little tired of running to G	I got a little tired of running to Google every time I needed a non-trivial git command, so I set out to identify all (and only) the git commands I require for my day-to-day and capture them in one place. The result is this script. It can be run fully on your local machine, no remote accounts required. (But it still shows how to use remote repos!)I'd also be interested to hear what git commands others use frequently (that don't involve a GUI). I'm curious to know which workloads might require some of git's more advanced features on a regular basis.	carodgers	8.559149	-6.488898	comment	3.0	18.0	1570514895	-11.895807
21194600	I agree with basically everything yo	I agree with basically everything you wrote except I’ve had much better experience rebasing my feature onto origin/master instead of merging master into feature. Keeps the [branch] history cleaner.	arcticbull	8.587325	-6.5593085	comment	3.0	25.0	1570555211	-11.91835
21197281	"I hate merges. ""Merged ... into ..."""	"I hate merges. ""Merged ... into ..."" is such an uninformative message! Some codebases are filled with those. I prefer seeing each individual commit messages, so... rebasing all the way for me! One problem I have with this is that the committer date of all commits become identical instead of retaining their original date aligned with the author date (which I would like to be the committer date). Is there a way to workaround this or fix it in a ""non-dirty"" way? It might be the case that I am doing something wrong, if so, what am I doing wrong exactly, or how should I go about it?"	johnisgood	8.596984	-6.5460334	comment	3.0	21.0	1570568906	-11.877805
21200518	It’d be beautiful to see a plot of h	It’d be beautiful to see a plot of how that number of commits has accumulated over time	finnmagic	8.5728035	-6.453472	comment	3.0	13.0	1570601466	-11.874973
21205022	"It's better than ""Gits""."	"It's better than ""Gits""."	mellosouls	8.547356	-6.4560275	comment	3.0	13.0	1570639777	-11.880359
21246497	A thousand ways. One really good ide	"A thousand ways. One really good idea I read was that you write an empty script, which prints the instructions for each step and you press enter, it prints the next step. It can only print instructions at first, then later, you can write code to automate some (maybe even validate things) steps. Something like this:    def git_tag():
        print(""1. git tag the repository"")
        input(""Press enter to continue"")

    def git_push():
        print(""2. git push the repository"")
        input(""Press enter to continue"")

    def pip_deploy():
        print(""3. Deploy, run: python setup.py sdist upload"")
        input(""Press enter to continue"")

    def main():
        git_tag()
        git_push()
        pip_deploy()

As simple as that! Then later, you could write code for every step as you"	kissgyorgy	8.552651	-6.4723573	comment	3.0	10.0	1571046334	9.262905
21246166	I miss knowing what I'm doing :)Git 	I miss knowing what I'm doing :)Git has so many footguns it's unreal.	m0xte	8.586678	-6.491577	comment	3.0	17.0	1571041619	-11.890627
21290020	I do feel like Git commit descriptio	I do feel like Git commit descriptions are severely under-utilised for sure, but I believe there is a reason for that which until fixed, will prevent rich and contentful commit descriptions for flourishing.In the article order: the screenshot is from a commit detail page. How often do you land on this page? You need to specifically click through. If you are in a commit list, the only thing that sets title-only commits and commits with description apart is an ellipsis link which practically blends in with the background. It is not very well integrated nor discoverable. Also I don't believe the commit descriptions render as MarkDown (unlike issues) which is also a shame as it feels like less a doc then. But I might be wrong on this. But even outside of GitHub, how many other UI/IDE plugins a	tomashubelbauer	8.58464	-6.5244155	comment	3.0	15.0	1571393044	-11.89789
21290148	This is true when you can reference 	This is true when you can reference the commit to an issue. Then, seeing the simple commit message you can select if you want to dig up what happened by reading up the comments at the issue.On the other hand it really gets into my nerves when people don't use the task/issue/whatever manager system appropriately. Recently, I lost a couple of days trying to figure out how to compile a c++ framework because the other guy didn't document his pipeline. In general I'm really disappointed by the majority of my colleagues for the lack of comments inside and outside of our codebase and this is a persistent issue, at all the companies I worked for. Me along with other similarly irritated people, always ask for documentation if it is not given.	konsnos	8.592622	-6.5247784	comment	3.0	13.0	1571394666	-11.908963
21290855	Yes. As is convention, commit messag	"Yes. As is convention, commit messages should be a one line header, then and empty line an a body (if necessary).The whole thing should be width limited to 80 or 100 characters.And the subject line should complete the sentence ""If this commit is applied, it will..."". It should start with a capital letter, then move to lowercase, and necessarily will start with a verb."	ShteiLoups	8.595205	-6.5461383	comment	3.0	22.0	1571402420	-11.898909
21291804	Hmmm, I've always believed that no c	Hmmm, I've always believed that no commit should break a build, even if you're committing the fix right after. Otherwise you're going to cause problems for `git bisect` or other  practices of going through the history to find where a problem may have started.Do other people commit breaking tests and then fixes?	SamBam	8.622268	-6.536587	comment	3.0	11.0	1571409947	-11.901476
21291683	This message says much more about th	This message says much more about the author than it does about the commit.	twic	8.588502	-6.511798	comment	3.0	17.0	1571409122	-11.890646
21310674	"Isn't a bit off? It shows ""git diff"""	"Isn't a bit off? It shows ""git diff"" as a diff between staging and workspace when it should be between workspace and local repo."	rinchik	8.635386	-6.5047755	comment	3.0	10.0	1571653239	-11.836585
21318825	You should want those merges so that	You should want those merges so that you can later bisect where a problem was introduced.   If you start/end each day with a merge and leave the merge commits in, and you notice something goes wrong later, it's much easier to trace where the problem is.Rebase definitely satisfies my OCD and makes everything look pretty, but it's actually worse.	anon9001	8.584949	-6.559641	comment	3.0	20.0	1571701403	9.344319
21318931	Personally, I prefer to never use gi	Personally, I prefer to never use git pull, and instead use git fetch then manually merge or rebase as appropriate. It's one more command, but I find it helps me visualize exactly what I want to happen.	lazulicurio	8.573123	-6.549831	comment	3.0	14.0	1571702289	-11.90142
21319536	I started using git two years ago, a	"I started using git two years ago, and when I first asked all our senior engineers about it (after reading an article or two on HN about best practices) - the advice I was given was, ""Never rebase.""  Among the more Jr. Engineers there was this feeling that it was a dangerous command that should be steered clear of, and the typical approach, of branching off of remote master, making changes, pushing to your branch, testing your code in the CI/CD environment (with appropriate unit/integration tests), and then issuing a PR to be reviewed and merged into master was the appropriate use of git.I don't think I've ever seen anybody (except very advanced git users) ever use ""rebase"" - so, no, I don't think I would consider it a basic command.  Despite using git dozens of times every day, I don't be"	ghshephard	8.570485	-6.5662026	comment	3.0	10.0	1571708190	9.377315
21353808	Ask HN: I found opposition when impr	Ask HN: I found opposition when improving the accessibility of the website	maury91	8.726924	-6.4597754	story	3.0	4.0	1572002010	-0.51940477
21371387	I thought this committed all my term	I thought this committed all my terminal commands to a git repo. It doesn’t but now I want something like that.	pm90	8.61821	-6.4629917	comment	3.0	11.0	1572199750	-11.824915
21393151	> the notion of having an index and 	"> the notion of having an index and staging area would be fundamentally different (or absent)Mercurial indeed lacks a staging area> the notion of committing locally and pushing remotely would be fundamentally differentIf you enable phases, it does. By default, all local commits are ""draft"" commits, which can have history edited. But when you push to (or pull from) a public repository, it becomes a ""public"" commit, and Mercurial will refuse to edit those commits. There's also a ""secret"" phase, which Mercurial will refuse to push to a public repository. You can also configure whether or not remote repositories are public or not.The other fun feature is changeset evolution: when you rebase a changeset, Mercurial will keep the original changeset around with a link between the old and new versi"	jcranmer	8.506072	-6.577287	comment	3.0	17.0	1572391372	-11.951977
21393556	Both the first and the second are va	Both the first and the second are variants of the same action: make part of a workspace (defaulting to all of it) represent the specified point in the repository (defaulting to the current branch).The first one is selecting a subset of the repository, exactly one file, and making the filesystem copy contain the contents that are in HEAD.The second one makes the whole repository look like a different branch.The third is just the second, along with a branch operation (which is weird to combine in it).I’ll agree with you, though, just for a different command: git reset. That is a command that truly can’t be described in one sentence.	koenigdavidmj	8.555922	-6.53741	comment	3.0	12.0	1572395697	-11.899587
21393972	> Mercurial indeed lacks a staging a	> Mercurial indeed lacks a staging areaI'm sure someone will dispute that it is the same as the staging area, but mercurial does have the ability to only include some things in commits, and I use it daily. I admit I have no idea how it works on the command line, but in tortoisehg I can select individual files and hunks thereof to add to a commit (screenshot: https://imgur.com/ErPEjSN).It's my impression that loads of people use this feature and somehow don't notice it exists, and will openly agree that mercurial lacks a staging area. My opinion is that defaulting to including changes from all files previously committed is such a sensible default that it makes the feature so seamless that people forget it exists even whilst using it.Kinda like how people from the US think you can't turn lef	doubleunplussed	8.557395	-6.5633492	comment	3.0	14.0	1572400783	-11.943066
21393135	Git is what a version control UX wou	Git is what a version control UX would look like if it were written by kernel developers who only knew Perl and C	miohtama	8.568451	-6.4429646	comment	3.0	12.0	1572391275	-11.890767
21393678	One of the more noticeable differenc	"One of the more noticeable differences is that there is no staging area. So to commit your changes you only need yo go through a single step,hg commit.For the situations where you actually only want to partially commit things you can use ""hg shelve"", which is sort of like ""git stash"""	ufo	8.62594	-6.5574265	comment	3.0	21.0	1572397197	-11.919634
21418597	Definitely. I find SVN so much easie	Definitely. I find SVN so much easier. But we must all use Git because cargo cultism is cool, or something.	growlist	8.587533	-6.4750366	comment	3.0	17.0	1572615454	-11.882947
21418908	What garbage collection? Isn't stagi	What garbage collection? Isn't staging area actually a feature? I've never used anything else since when I started needing something like 5 years ago git was already a recommended choice, but I also never felt like I needed anything else.	kungito	8.652921	-6.553036	comment	3.0	12.0	1572617007	-11.907705
21419491	Unfortunately git does not handle bi	Unfortunately git does not handle binary files elegantly (unless you use git-lfs). You can inflate storage rapidly by, say, editing a 10M zip file a few times. I've had to GC more than one repo where someone accidentally added an innocuous binary file, and the next thing you know the repo has exceeded 2G of storage space.	jniedrauer	8.563937	-6.45185	comment	3.0	18.0	1572620246	-11.8749
21419174	git is actually pretty easy to drop 	"git is actually pretty easy to drop into a terrible methodology without too much disruption.git works by creating its own .git directory wherever you create a new git repository, but doesn't touch the files and directories outside of it until you tell it to.So you can have a directory of old code and you just cd to it and run 'git init', and now you have a git repository in the same directory.  It won't be managing any of the files yet, but it will technically be there.Because git is just a bunch of extra data in a .git directory, and because git is also built as a distributed VCS, the ""make a copy of a directory to back it up"" methodology actually works pretty OK with git.  Ideally you should be using 'git clone' to copy your directories and 'git pull' to keep them in sync, but if you jus"	saalweachter	8.550885	-6.443897	comment	3.0	12.0	1572618287	-11.871633
21532877	Please take this as nothing more tha	"Please take this as nothing more than my subjective opinion: I believe that humans don't have GI but HI - we have a ""world-view"" that is very idiosyncratic to being human, which is essentially heuristics all the way down - in other words, I don't believe there is a magical novel concept that explains HI, but that it is a collection of party tricks that evolved over time, i.e. hacky engineered system."	dkural	8.549283	-6.4859576	comment	3.0	13.0	1573706955	-11.869392
21585387	> Trying to build CI on every branch	> Trying to build CI on every branch before merging to master just won't work with the scale they are dealing with.Google does it with 50 times the developer count.> At 1000 developers, the rate of PRs coming in makes it impossible to determine what current master will be when the PR is ready to merge (i.e. when the branch has a green build).True, it is impossible to catch all errors like this, but you can catch almost every error by building and testing it against current master and then merge it with the master 20 minutes later when the build is done. I have seen maybe one build breakage a year being introduced due to this in projects I've worked on, so it isn't a big deal.	username90	8.709805	-6.5442576	comment	3.0	11.0	1574267778	-11.955951
21609011	I've seen this convention before. I 	"I've seen this convention before. I personally find it more useful to tag commit messages with [fix], [docs], etc. It makes it more easily searchable, which is IMO what you really want. You can:    git log --pretty=oneline --abbrev-commit | grep ""\[doc""

to see documentation commits, and count them by piping to `wc`.Emojis feel... complicated. What do they mean? Here you're just typing the literal word so not much to remember or search."	aylmao	8.589543	-6.513293	comment	3.0	10.0	1574450436	-11.856533
21675041	Also consider https://chezmoi.io/ wh	Also consider https://chezmoi.io/ which has many advantages over Stow+git (e.g. manage files that vary across machines, password manager integration, transparent encryption, create real files not symlinks, dry-run and diff modes, and many more).Disclaimer: I'm the author of chezmoi.	twp	8.574455	-6.462225	comment	3.0	10.0	1575201157	-11.921019
21679173	It's possible (and not that hard) to	It's possible (and not that hard) to define an integration process that prevents faulty commits from being integrated to the main branch.> If you insist on no errors on master ever you will kill throughout.Not sure why you believe this. It hasn't been my experience; just the opposite, in fact. By using CI in conjunction with a process that prevents errors on master, everything goes more smoothly, because people don't get stalled by the broken master.	jdlshore	8.686311	-6.5512266	comment	3.0	10.0	1575250052	-11.911572
21745887	It's nonlinear. With `git add -p` yo	It's nonlinear. With `git add -p` you can press keys to go back and forth through the hunks. If there are a lot of them then it can get tedious. With Magit, on the other hand, you see everything in a window and you can use all of your usual emacs commands to scroll/search that window, and then hit the key to stage the hunks as you desire.	chongli	8.595172	-6.4872513	comment	3.0	18.0	1575921743	-11.840351
39084303	if that's the only reason for the br	if that's the only reason for the branch, you can just as easily determine which commit is on which environment with tags	willsmith72	8.556421	-6.5271525	comment	3.0	12.0	1705880963	-11.885511
39084483	Seems strange.  Sometimes we’ll have	Seems strange.  Sometimes we’ll have feature branches that are made up of different parts, with different devs collaborating to build those parts out.  For this I don’t see a way around having some staging branch with two devs sending PRs to before you work out all kinks and merge the staging branch back into main	edgyquant	8.611125	-6.542324	comment	3.0	10.0	1705882359	-11.900578
39084671	They deleted every branch on merge, 	They deleted every branch on merge, and had us rebase for merges. Before trunk based development was introduced, everyone on the team understood what the flow was. Afterwards, whichever developer was picked to cut a release, took half a day to figure it out to make sure they didn't screw up.I would have rather just used SVN and called it a day.	giancarlostoro	8.599801	-6.5257635	comment	3.0	11.0	1705884043	-11.88737
39084947	No thanks.I've worked on teams using	No thanks.I've worked on teams using trunk based development before and I ended up being the one having to fix other people's messes, deal with them losing work, and the absolute hell of trying to find where a bug was introduced.The only people I really want on my team are those that understand Git. And even when there are team members that don't understand Git, I sure do and can pretty easily un-eff any situation someone gets themselves into.Seriously, Git is actually simple and it should be a fundamental CS class taught at all universities.	rplst8	8.57377	-6.5175138	comment	3.0	11.0	1705886518	-11.882793
39085293	“For one, if you're impactful enough	“For one, if you're impactful enough your name will be all over your company's git repositories in commits”Or… you’re a busy body that likes to move files around and pretty things up leaving your name on the blame and making it look like you did a ton of work. All you did was open it/save it in VIM.Let’s not praise false indicators. Lines of code isn’t a good measurement of quality, nor is lines committed.	reactordev	8.586934	-6.543042	comment	3.0	13.0	1705889718	-11.867944
39088849	Nice. I make music and use git for m	Nice. I make music and use git for my files, but often hit the usual space limitations and I hate dealing with git-lfs. I think there's a big use case for Diversion and music/video production.	Mizza	8.577232	-6.458141	comment	3.0	12.0	1705927224	-11.906872
39088967	> This is mostly a configuration iss	"> This is mostly a configuration issue. I guess this was done by a force push command. IFAIK, you can disable force push by configuration.If a feature can lead to actual unintended data loss, it should come disabled by default. Are there any other ""unsafe by default"" features in Git? What would be a sane general default that prevents unwanted data loss, and why is it the case?"	Rygian	8.556144	-6.4893665	comment	3.0	25.0	1705928049	-11.883209
39089012	--force always imply data loss. You'	--force always imply data loss. You're overriding the remote state.Do people use it in an unsafe manner because they don't understand git and there lies a problem that could be tackled? yes.With that, I don't think git has any feature that is unsafe by default.	guax	8.55618	-6.468064	comment	3.0	20.0	1705928405	12.5853405
39089210	So multiple people did a git reset -	"So multiple people did a git reset --hard origin/master and nobody complained or checked what and why this was done? That's not ""one data scientist with the wrong command"" but the whole team that fucked up hard IMHO."	bauruine	8.554446	-6.4864793	comment	3.0	33.0	1705929618	-11.872445
39089167	Being deceptive about Git's shortcom	Being deceptive about Git's shortcomings is going to raise eyebrows with anyone seriously evaluating your solution, which is already going to raise eyebrows because it's not free software.Most studios will try to avoid locking themselves into another expensive, annoying VCS that they have no control over. There's good attempts at FOSS p4 replacements now, you need to do better if you want to stand out.	meibo	8.558029	-6.4718556	comment	3.0	26.0	1705929394	-11.9126625
39090082	"> Don't focus too much on ""git compl"	"> Don't focus too much on ""git complexity"" as most people already know git so it just creates an argument.I'd say this phrase is both right and wrong.It's right in the sense that it creates an argument.It's wrong in that it creates an argument with the peanut gallery of git experts. But guess what, most people using git are not experts. They're software developers who don't want to learn the intricacies of git (probably most software developers out there), they're software development adjacent folks (think data scientists, etc) who for sure don't want to learn the intricacies of git, etc.The ""common person"" using git will most likely resonate on the ""git complexity"" argument."	oblio	8.541132	-6.4963684	comment	3.0	29.0	1705935182	-11.924297
39091164	As a game dev I find the pitch unexc	As a game dev I find the pitch unexciting.> git is bad we're betterHonestly, a modern git lfs workflow is really smooth.  I think it handles binaries fine.  Show me cumbersome git feature and why this works better.  You can't just tell me tools I use every day are unusable.I think the main pain of git is if you want to put everything in a single repo.  Big isn't a problem, getting just what a I need (checking out a single large model) is the problem.From the website I have no idea if this can do partial checkouts.  I assume yes but its not stated at all.> cloud nativeA lot of studios want on-prem and self-hosted private cloud support.  Cloud native is touted as a feature but details are left out.  That has me wondering if some things don't work when I try to host on-prem or that its an aft	jayd16	8.57451	-6.4633055	comment	3.0	12.0	1705940139	-11.933608
39089827	1. git is not hard if you learn it2.	"1. git is not hard if you learn it2. I regularly see people storing multiple gigabyte files in git..
I don't understand your issue with large files.3. cloud native? why? part of the point of git is to have a repo decentralized away from centralized clouds onto dev's machines, if your data scientist broke git then that means your main branch configuration is off, no one else had that cloned onto their machines, and the rest of you don't know how to recover lost data which is stored in the reflog.... even ignoring the lack of simple CICD.4. > Diversion is built on top of distributed storage and databases, accessible via REST API, and runs on serverless cloud infrastructureWhat!?!?!? That is NOT a selling point....all that for a VCS?You're literally taking everything that makes git great and "	hasty_pudding	8.546243	-6.4466386	comment	3.0	16.0	1705933557	-11.896683
39090794	> doesn't destroy the reflog or runs	> doesn't destroy the reflog or runs the GC server-side.Git doesn't give you access to the server side reflog either. So it's of not much use if you don't control the server.As for losing data with Git, the easiest way to accomplish that is with data that hasn't been committed yet, a simple `git checkout` or `git reset --hard` can wipe out all your changes and even reflog won't keep record of that.	grumbel	8.554474	-6.527481	comment	3.0	12.0	1705938908	-11.900274
39092511	"Little feedback on the ""how is it di"	"Little feedback on the ""how is it different from Perforce"" section of the web page.There have to be more advantages than ""it's in the cloud"" ...right? Also, for many this is potentially a huge hurdle / disadvantage. Who are you, and why should we trust you with our precious IP / code? (many game studios are on-prem very intentionally)Personally, I'm currently (being forced to) use Perforce and I've learned to tolerate it, but wish we could use git. There have to be more things that make your offering better than Perforce and you should really highlight them."	itslennysfault	8.616782	-6.507451	comment	3.0	11.0	1705945173	13.828982
39092621	> peanut gallery of git expertsThere	> peanut gallery of git expertsThere are people who use git for its original purpose (kernel devs and very few others) and then there is the remaining 99% of people who essentially use “github flavored git”, using only three or four git subcommands and for the most part never needing to understand its intricacies.Unfortunately, although they are using git-the-chainsaw-shotgun with all the safeties on, it’s nonetheless a chainsaw shotgun and sometimes they’ll run into issues where they or somebody in their company needs to be an expert and figure out how to un-scramble an egg, so to speak.If a new VCS can solve the 99% case and never need users to fall back to understanding nitty gritty details, it could very well have strong takeup especially among people who don’t give a crap about what V	philsnow	8.5500145	-6.475151	comment	3.0	12.0	1705945569	-11.879142
39104152	Yeah; and the merging is correct in 	Yeah; and the merging is correct in all cases. You don't get spurious conflicts like you can with git.Also the same system can work both in realtime and offline scenarios. And CRDTs can handle a lot more than just plain text editing.That said, one thing git does that I like is that sometimes I want conflict markers to be added to my document when concurrent edits happen on the same line. CRDTs (and REGs like this) store strictly more information than git does, so theoretically it should be possible to make a CRDT which adds conflict markers too like git does. But as far as I know, nobody has built that yet! I really hope someone does, because it would be really neat.I really want a git style version control system built on top of CRDTs with optional merge conflicts.	josephg	8.654858	-6.520283	comment	3.0	13.0	1706021938	-11.827796
39107977	I still find Go too tolerant on this	I still find Go too tolerant on this. It should scan your Git history and stash as well, and fail to compile if it finds any unused code there.	codeflo	8.579236	-6.5175	comment	3.0	13.0	1706036497	9.464609
39132845	>Yes, patches and trunk! We were sti	>Yes, patches and trunk! We were still using SVN back then.Is SVN really that obsolete? I thought it was still used	blharr	8.609801	-6.461465	comment	3.0	10.0	1706207352	-11.869169
39135839	I suspect that my opinion is in the 	I suspect that my opinion is in the minority here, but...> With modern trunk-based engineering, pull request branches are squash-merged onto mainCommit messages are useless because of squash-merges, yes. However, my opinion is that it's the very concept of squash-merges that is the problem, not commit messages. Squashing eliminates all sorts of valuable information, and I think it's harmful.	JohnFen	8.5773735	-6.559356	comment	3.0	28.0	1706219213	-11.945593
39136950	What should happen during a squash/r	"What should happen during a squash/rebase is that the semantic meaning of commits should be revised for maximum legibility of a future maintainer.If you did one ""thing"" on a PR branch, and it took you 10 commits to do it, those 10 should be squashed to one, and the commit message should be ""Added thing.""If you did 3 ""things"" on a PR branch, and it took you 10 commits, you should squash those 10 into 3 semantically meaningful commits: ""Added Thing#1"" ""Added Thing#2"" ""Added Thing#3"" This is doubly true if you ran into some complexity during the implementation that caused you to have to do the extra stuff -- that's exactly the type of detail someone looking back on commits needs to understand the development history.This is something that you are not allowed to do under most squash-merge poli"	mlsu	8.573395	-6.56894	comment	3.0	10.0	1706225586	-11.9257555
39140347	> You want to split it in multiple c	> You want to split it in multiple commits? Then it probably should have been split in multiple PRs .Sure, but GitHub/GitLab/Gitea don't let you write multiple PRs that depend on each other easily, like Phabricator/Gerrit/email do. Either it's a mess of branches merging into each other, multiple commits in the same PR, or wait for one PR to be merged before writing the next.	progval	8.566625	-6.5109777	comment	3.0	21.0	1706259953	-11.927016
39140795	I think GitHub is pretty good here: 	"I think GitHub is pretty good here: If you make PR #1 from branch foo with target main, and PR #2 from branch bar (a descendant of foo) with target foo (that is, a ""sub-PR"" of #1), then if #1 gets merged first (into main), #2's target branch will auto-update to main, which is exactly what you want.If #2 gets merged first (into foo), then branch foo of course updates to include the commits in bar, which is again what you want.What behaviour were you hoping to see?"	akoboldfrying	8.584301	-6.531973	comment	3.0	16.0	1706263459	9.05912
39215378	I use a similar strategy to this… mu	I use a similar strategy to this… much less formal but I’m excited to try this formal write up.My strategy was more like:1. Start making a big change.2. See what breaks.3. Move the big change to another branch.4. Fix one broken thing and PR to main.5. Rebase the big change back on top of main.Essentially trying to break off chunks of the larger problem in small commits. I’ve had about a 90% success rate with this strategy and when it works developers really appreciate reviewing the smaller commits than one monster change.I once heard that, “complex systems are built from simple systems,” and started to view my job more as identifying and working on the simple things to let the complex stuff fall out rather than attacking the complex stuff directly.Edit 1: one other thing I will add is that	tyleo	8.587586	-6.5429406	comment	3.0	12.0	1706791634	-11.931897
39217969	great commits are great. This is fan	great commits are great. This is fantasticAs an aside, I'm tired of documenting:- in code- in commits- in jira- in confluence- in daily standups- in release notes	fusslo	8.566241	-6.4847684	comment	3.0	16.0	1706806048	-11.956845
39218156	I really think git made a mistake in	I really think git made a mistake in conflating the immutable log of what was changed with the (ideally mutable) story of what got merged in. So you see people arguing over squashing commits vs rebasing vs merging. Squashing commits makes the history of commits a better story of features being added. Merging preserves the immutable log of the actual changes made to the code, and rebasing sort of does a bit of both.But, I don't see any reason we can't have our cake and eat it too. We're programming computers after all and we can make them do whatever we like.If I wrote my own git, I think I'd split commits into those two parts. I'd leave the history of changes immutable - probably with some sort of Merkle DAG like Git does. And then have a separate associated data store which stores the com	josephg	8.582625	-6.542671	comment	3.0	11.0	1706806807	-11.905351
39217603	One thing I disagree with is:> I wou	One thing I disagree with is:> I wouldn’t expect all commits (especially ones of this size) to have this level of detail.(emphasis added) - actually in my experience it's often the little ones, innocuous looking things that might really need a relatively longer explanation.Yesterday I wrote three paragraphs on why I added `--limit=999` to a `gh pr list` because it's confusing: there's already a `limit(` in the `--jq` argument, and the higher it is (given say infinite PRs in total) the lower the end result will actually be. (Yes I wrote a comment too. And probably spent even longer thinking about and working it up than writing about it; hopefully I'll recall it as an example the next time someone implies the job is about churning out code!)	OJFord	8.618779	-6.5302196	comment	3.0	11.0	1706804391	-11.884537
39218879	I can't tell if this is engaging wit	I can't tell if this is engaging with trolls or not, but I can't imagine that all of your interactions with your codebase are via `git log` with no other flags. Even the with the normal Git CLI that most of us use daily, most of us use `--oneline` or whatever to simplify useful calculations and visualizations like `--graph`, etc. But we're talking here mostly about code archeology, learning about the history of a block of code, so this comment seems somewhat ridiculous in that context.	schacon	8.556433	-6.4623613	comment	3.0	13.0	1706809863	-11.900042
39220404	> If you change a line of code witho	> If you change a line of code without doing git-blame on it first you're doing it wrong.Working on a project where this is necessary sounds like a hellish experience.The place for comments explaining why the code is needed is right next to the code! On an adjacent line!	kaashif	8.564444	-6.5042844	comment	3.0	11.0	1706817070	-11.920574
39221052	periodic reminder that `gitk` exists	periodic reminder that `gitk` exists, and has come with git since... pretty much forever? If you're reading `git log`, you really owe it to yourself to run `gitk` at least once to see what you've been missing for over a decade now.	TheRealPomax	8.550276	-6.4754667	comment	3.0	11.0	1706819653	-11.954678
39224654	Then don't write commit messages for	Then don't write commit messages for the future, write them for reviewers.Seriously, as somebody who reviews a lot of code, well-written commit messages are a godsend.It's an awful shame that GitHub doesn't allow commenting on commit messages. It's as if GitHub is being run by people who just don't know how Git is meant to be used.	atq2119	8.571497	-6.4954243	comment	3.0	14.0	1706844575	-11.905236
39237616	Lots to digest here! I have been kee	Lots to digest here! I have been keeping an eye on Pijul so it is cool to see some of its features implemented in jj. Sapling[0], similarly, is a new VCS tool out there which can work with a git repo. It also has anonymous branches, no staging area, supports stacked commits and can track the history of a commit over time. I've been using a similar workflow to the article's author: git with a UI to handle commits of hunks of a file to group related changes. My working branch often has unrelated changes that get tossed from branch to branch as I am able to commit. I haven't figured out where these new tools fit into my workflow yet, but I am glad there's new options that will help making working on a project more flexible and organized.[0]: https://sapling-scm.com	memco	8.584164	-6.53553	comment	3.0	10.0	1706935820	-11.943249
39238464	Why many developers are struggling i	"Why many developers are struggling is beyond me, and so much git-hate, too. It is a powerful tool, but you can get started and a long time (or forever) around with few commands to accomplish your companies workflow - takes half an hour to learn these and put them in your notebook. If you struggle with git, how do you do with your programming  language, IDE, debugger? All are vastly more complex.Imo it is some internal objection (due to hate? laziness?) to deal with it.Yes, the UI is not intuitive in all parts and partly ugly or from some viewpoints inconsistent, but that lately improved much. Nevertheless, complex is different. Much more effort went into mastering chosen shell, much more unintuitive is the IDE I have to use.. but those are tools, and that's my job.> WTF is ""detached HEAD""?"	throwbadubadu	8.582818	-6.520337	comment	3.0	13.0	1706948266	-11.89195
39238888	I think it's an odd direction to go,	"I think it's an odd direction to go, focusing on a new ""query language"" and CLI tool rather than something that allows a git repo to be used as a storage backend in a normal RDBMS. Then you wouldn't have to implement the SQL grammar & logic, and you'd get a query optimizer for free. Using something like Postgres's foreign data wrappers maybe.It doesn't look like this query language has much domain-specific syntax at all. It's just SQL with git as a storage backend."	RadiozRadioz	8.593078	-6.48754	comment	3.0	10.0	1706953695	-11.879427
39290969	An ex-manager (ex-Google, too) insis	An ex-manager (ex-Google, too) insisted we move from GitLab to Gerrit, and mandated that all commits be a maximum of 5 lines, ideally fewer.This led to a complete loss of all context; without that overview, you might very well be releasing code faster, but it could be the wrong solution to the original problem - and crucially, you won't know until it's out in the wild.A preference for smaller, more focused PRs is fine - it certainly makes them easier to review independently - but I think putting any sort of limit on the size makes your team more likely to omit things like tests and also to not have sufficient context to understand the overall problem space.	stephenorr	8.628083	-6.509115	comment	3.0	15.0	1707325120	-11.9211235
18030933	Interactive rebase is absolutely com	Interactive rebase is absolutely coming (you can already edit commit messages and squash commits). UI support for Git Flow is going to depend on user feedback. I expect we will eventually, but even if not, we will be adding a plugin API, and it would naturally be doable via that.	jskinner	8.594332	-6.561635	comment	3.0	16.0	1537436105	9.194724
18030756	For my needs, GitX (rowanj fork) is 	"For my needs, GitX (rowanj fork) is still unbeat: http://rowanj.github.io/gitx/
It has the exact right amount of UI complementing the command line, and some delightful features, e.g. amending the last commit is possible via a checkbox below the commit message.What I don't like about Sublime and now Sublime Merge, is the unusual way of setting preferences by editing files. I understand that hacking in a JSON file has benefits, but if you just want to use that tool, it's tiring having to google how to change a setting. To me, it feels a bit like losing control.
E.g. I wanted to check whether SM supports line wrapping—I'm still not sure whether it does, after browsing the available menu items a bit."	manmal	8.605273	-6.502893	comment	3.0	13.0	1537433482	-11.8294
18032430	Who other than FB albeit customized 	Who other than FB albeit customized is using Mercurial in prod?	MordodeMaru	8.500567	-6.559366	comment	3.0	11.0	1537451583	-11.964125
18038231	Inversely, this is counteracted by t	Inversely, this is counteracted by the logic to not use Git:https://sqlite.org/whynotgit.html	Daviey	8.620803	-6.502384	comment	3.0	12.0	1537520515	9.901618
18103776	> closing development branch when yo	> closing development branch when you merge into master???Why's that a horrible default? It doesn't happen to match the workflow you use? It matches the one I use. So I can understand it's not ideal for you but they can't suit everyone with a binary default so what makes it so 'horrible'?	chrisseaton	8.559768	-6.5541735	comment	3.0	16.0	1538266244	-11.769153
18188423	Multiple staging urls for each branc	Multiple staging urls for each branch under {branch-name}.staging.example.com	sadik_ay	8.694011	-6.5685735	story	3.0	7.0	1539202317	-11.915342
18229204	You should only use merging to merge	You should only use merging to merge two divergent or unrelated histories. Merging should be a tool you use infrequently. GitHub has trained you to do it wrong.	Sir_Cmpwn	8.582394	-6.5529594	comment	3.0	20.0	1539696915	-11.916913
18229415	How else do you get bugfixes onto a 	How else do you get bugfixes onto a release branch when the main develop branch has already moved on?  Should you rebase your feature branch on the release branch instead, then merge it?	jdlyga	8.608612	-6.544935	comment	3.0	10.0	1539698459	-11.962413
18229605	I started version control with CVS. 	I started version control with CVS. Just a bit better than copying.I started distributed version control with monotone. That felt better but the central db felt a bit unnatural.A bit later came mercurial and I was really happy with it. It all made sense. Easy interface and when you wanted to do something strange like rewrite history, you had to use a plugin.Then came git (rhymes to better know your sh*t). I'm not surrounded by the smartest guys but most people I met only have a superficial understanding of git and looking at these flight rules kind of confirms the complexity of git.I strongly believe that 80% of the current users of git would be better off with mercurial. But then everybody uses git for the remaining 20%.	lixtra	8.578515	-6.4822583	comment	3.0	27.0	1539699944	-11.888536
18229437	It makes a merge commit which is usu	It makes a merge commit which is usually unnecessary. If there were no conflicts, there's no need to have a commit fixing them up. If you just want to know who integrated the patch, git stores the author and committer fields separately.Most git users in touch with the design goals of git use branches sparingly, either for long lived projects (with hundreds of commits) or as a sandbox in which work is frequently rebased into a concise history of a few patches, which are usually integrated upstream without a merge. Merges are also used to merge disparate trees, like when Linus merges in trees from around the kernel development scene (since each kernel subsystem maintains their kernel tree as almost independent projects, using merge makes sense to integrate the foreign histories into the upst	Sir_Cmpwn	8.587744	-6.540497	comment	3.0	15.0	1539698646	-11.932594
18230390	Everyone talks about how confusing G	"Everyone talks about how confusing Git is, and I think it's because they do'nt understand what the commands do. Don't get me wrong: you can royally screw up your repository with the wrong command, but 85% of your issues can be solved with checkout, pull, add, commit, push, merge, reset, status, stash, branch. When things get really heavy you may have to use rebase. And in spite of what people say, there is a nifty log that's perfect for revisiting a snapshot of your CLI's action: reflog.When I first started using Git, I was told, ""When you want to make you commits public, use `git push -u origin <branch>` where branch the branch you're pushing to."" That advice is technically correct, but I had no idea what -u nor origin was. I took 5 minutes to decipher the command. I walked away understan"	noxToken	8.560284	-6.5272245	comment	3.0	13.0	1539705410	-11.906264
18230655	Consider `git checkout` and having a	Consider `git checkout` and having a file called `master` at the root level of the repo.	crooked-v	8.538141	-6.496531	comment	3.0	17.0	1539707115	-11.813703
18230766	Of note: Git has 3 of those:* git ha	"Of note: Git has 3 of those:* git has clones* git has bookmarks, that's ""normal"" git branches* git has anonymous branches, it's called ""detached head"" and is completely broken* git does not have named branches (that's the branch name being part of the commit's immutable metadata)"	masklinn	8.554389	-6.547509	comment	3.0	13.0	1539707780	-11.899783
18236322	> nothing is really reversibleThis i	> nothing is really reversibleThis is a dealbreaker for me if it means what I think it does, which is that you can never change history to pretend the order of commits was different from what it was in reality.I understand that certain people's preferred source control workflow involves keeping around every little intermediate commit. That's fine. But a tool should not impose workflows on me, or prevent me from modifying my data in the way I personally choose.Imagine if vim didn't let you save files with words spelled wrong, because its authors didn't agree that that was a valid way to write prose.	umanwizard	8.603787	-6.534461	comment	3.0	13.0	1539753836	-11.868259
29757129	In my experience doing mentorship, a	"In my experience doing mentorship, a lot of people are taught git in a super rushed way and tend to have the mindset of ""here's this incredibly complicated program you will never understand, please learn these magic commands and hope you never get a merge conflict"" which isn't particularly useful because they're now scared of their tools.We need to teach tools like git (and some editors!) as their own thing, completely separate to programming languages. Not ""now we've written some code, let's put it in git"" but ""here's a tool called git, let's show how it works with some text files""Honestly - you spend 20 minutes with someone teaching them that git only stores diffs and how that actually works and they leave much more confident and willing to experiment on their own.A plain text TODO list "	lexicality	8.554245	-6.4931793	comment	3.0	12.0	1641032200	-11.89106
29756866	> some of the git's naming was also 	"> some of the git's naming was also not intuitive for me, For example, calling the scratch area ""index"".I think this is the real problem. Git is actually really simple. The mental model is not even difficult - you can describe it in a sentence or two.* Each commit is a snapshot of your code at a certain point. Like making a copy of your project and renaming the folder (but stored more efficiently). Commits also include metadata to say which previous commit(s) they are based on.That's it.All the difficulty comes from figuring out what the hell all the badly named and confusing commands do. As you mentioned I think ""the index"" is probably the worst - why not ""draft commit"" or just ""draft""? That's what it actually is. It's so bad people even invented an unofficial name for it (""staging area"")"	IshKebab	8.575823	-6.5388713	comment	3.0	13.0	1641028434	-11.911268
29764283	Absolutely agree. The single master 	Absolutely agree. The single master branch, commit when you feel like it workflow is very simple, and still miles better than just copying files in the file system.	p1necone	8.581136	-6.5089645	comment	3.0	43.0	1641082218	-11.885594
29764629	"Normally lauding a ""sub-optimal"" tec"	"Normally lauding a ""sub-optimal"" tech means the optimal tech isn't a fit for the problem space or the cost of adoption is higher than the benefits. Something like Tarn doing everything in C/C++ which is arguably good and arguably bad but works. It is unclear that switching languages would be a net win or loss.In the case of not using a VCS system ""sub-optimal"" means he's making his own life difficult for no gain. It is difficult to see that it is anything other than a mistake - a 20 year old project with 700k lines of code is going to benefit from version control. The only saving grace is that Dwarf Fortress development predates git so at least there is a good excuse for how it happened this way, but it is still a mistake.We all make mistakes though, so the world will continue to turn if T"	roenxi	8.569747	-6.4637413	comment	3.0	26.0	1641085326	-11.875303
29784594	Seems like a nice tool, but if you r	Seems like a nice tool, but if you really used git, I don't really see how this situation described at the readme.md could happen :-)  you think you just lost days of work	sahkopoyta	8.567791	-6.4793816	comment	3.0	12.0	1641235705	-11.935135
29784796	Git has a built-in Ctrl-Z that is ca	Git has a built-in Ctrl-Z that is called “reflog”. Acknowledging that git’s UI commands such as “reflog” may be technical, and nonstandard, and poorly named, does dura provide something that git doesn’t, and is it a good idea to add yet another application/layer/dependency to the git workflow? Would it be just as effective to add a git alias called “undo”, or something like that?	dahart	8.568524	-6.5239544	comment	3.0	12.0	1641236545	-11.873115
29796156	Anyone could win instantly by pointi	Anyone could win instantly by pointing out git. The hype is new, but not the concept.	mkr-hn	8.539148	-6.4663596	comment	3.0	17.0	1641311775	-11.853426
29841468	For ardour, we almost never squash c	"For ardour, we almost never squash commits because we prefer our (always linear) git history to show the actually ""story"" of a branch's development.There are two exceptions.1. branch developer suffered from several ""thinkos"" along the way, the branch doesn't contain that many changes, and there's simply no benefit to seeing the contrast between the initial (mistaken) changes and the final result.2. the branch commits create a situation where git bisect can't be properly used because intermediate commits will not compile. Squash is one option here, though it is often preferable to just re-branch and re-work commits to avoid both the bisect problem and the squash.With a 21 year development history, we have found it invaluable to be able to trace the ""thought processes"" behind a series of com"	PaulDavisThe1st	8.587145	-6.5727043	comment	3.0	10.0	1641574440	-11.941027
29885333	I fixed a bug the other day that I w	I fixed a bug the other day that I was so embarrassed about, I intentionally left the commit message cryptic.(It was a personal project.)Sometimes the best documentation is seared into your soul as a mark of shame. I think I’ll wake up a few times wincing about it.	sillysaurusx	8.579028	-6.532471	comment	3.0	10.0	1641861135	-11.896158
29893582	I (submitter) hit this with pre-comm	I (submitter) hit this with pre-commit, for whatever reason `pre-commit` hooks all seem to specify `git://` addresses, which had been copy-pasted into our config (some by me).I've never otherwise used `git://`, and I simply changed them all to `https://`, but I suspect it's mostly that sort of thing that'll bite people - something suddenly stopped working because something else made that decision, and maybe it's buried in a dependency used in CI, and a python library for running git operations, so you can't even find it by grepping, etc.So while mine especially wasn't hard to fix, I just thought it might be a helpful PSA for people to keep in mind and maybe remember if something goes wrong.	OJFord	8.605439	-6.459691	comment	3.0	11.0	1641918466	-11.87035
29912741	My commit messages usually just try 	My commit messages usually just try to answer the prompt “why does this commit exist?” That’s because future me will be asking that when I open the commit after finding it in `git blame`.	teeray	8.575271	-6.5238385	comment	3.0	15.0	1642021987	-11.871736
29913831	I have nothing against this tool in 	"I have nothing against this tool in particular;I am however quite worried that this kind of tool will just enable this already terrible habit that a lot of developers have; which is to mindlessly commit changes and then make PRs full of ""asdf"", ""typo"", ""fixing comma"", ""blaaaaa"".With this tool, these developers won't even have to waste time typing `git commit` and will happily submit PRs as a bunch of ""autosaved"" commits.This further reduces git to being just a means to an end: the end being able to just mindlessly push code over a fence and see it magically deployed."	gouggoug	8.588966	-6.488563	comment	3.0	13.0	1642027678	-11.9215975
29979741	Why does any post discussing _any_ a	"Why does any post discussing _any_ aspect of git always results in these type of comments? ""git is complex"", ""git command line is confusing me"", ""life would be easier is we all used subversion"".Please let us discuss git in peace.(Although I admit that this one was funny)"	zibzab	8.545695	-6.478621	comment	3.0	14.0	1642516619	-11.914663
29979812	"""Zipping the folder"" and keeping a c"	"""Zipping the folder"" and keeping a copy of it is literally the sole purpose of a version control system. These kind of comments baffle me, quite honestly. But that is my fault, not yours.Could you tell me what you think git is for and why you use it?"	globular-toast	8.576269	-6.439272	comment	3.0	22.0	1642516875	-11.875
29982008	As much as I love and depend on git,	"As much as I love and depend on git, the visible user interface seems a bit ugly.  You can get used to it over time, but it has a certain non-unix flavor that I dislike...There should be a purely unix way to use git, as in ""everything is a file"".  Sure, you can go to the .git folder and there are files in there.  But the structure of these files does not directly represent the structure of the repository.  What I want is to ""mount"" a git repository, so that I can explore its contents using cd, ls and cat.  Also, by editing these files I implicitly make commits and create branches to the underlying structure.  Would that even be possible?EDIT: A disturbing feature that I don't see a way out is that in git there are ""standard"" and ""history-rewriting"" operations, and there is a clear distinct"	enriquto	8.559802	-6.453652	comment	3.0	10.0	1642525197	9.131675
29993683	> as made apparent by how many compa	> as made apparent by how many companies have yet to migrate to git from e.g., Perforce and SVN.So like, hardly any? Almost all companies use Git these days. As I understand it an exception is game companies because Perforce is much better at handling large binary assets (Git LFS is a pretty ugly hack).	IshKebab	8.552676	-6.4613175	comment	3.0	10.0	1642600895	-11.882876
30000002	> 4.  use `git add -p`I strongly rec	> 4.  use `git add -p`I strongly recommend tig	okl	8.574472	-6.5136714	comment	3.0	11.0	1642625802	-11.933236
30000055	Rebase is great, but it's usefulness	Rebase is great, but it's usefulness really depends on the commit history.If your branch consists of 10 commits of trying various things, then the sum of changes in all the commits can easily become significantly larger than the final branch diff. In that case resetting is orders of magnitudes faster than fiddling with rebase.	sandgiant	8.574479	-6.5690618	comment	3.0	12.0	1642626085	-11.93105
30070708	The one thing I want added to Node-R	The one thing I want added to Node-Red is an editable, sanely git diff-able on-disk text format for its configuration. I want to be able to edit either in GUI or in text, and then view the result in the GUI (and have it work of course!).Does anybody know if there's any plugin for or way of achieving that? When I last looked into it, people were checking in the config files (whatever format they were, perhaps proprietary) but they were a mess, may as well be binaries or PDFs etc. for all the value you'd get out of git for them.	OJFord	8.633955	-6.485336	comment	3.0	16.0	1643110684	-11.846861
30095547	These desktop applications look nice	These desktop applications look nice, but personally I’m much more comfortable with CLI tools. I have no idea what my colleagues are doing that use GUI git programs. I can’t even stand editor integration plugins.Edit: On topic, just test k8s config changes in prod :^)	tokumei	8.591448	-6.4826283	comment	3.0	13.0	1643251407	-11.861552
30117646	Ask HN: How can I learn GIS skills t	Ask HN: How can I learn GIS skills through self-study?	openknot	8.535361	-6.469424	story	3.0	3.0	1643390745	-11.895445
30242536	Actually, that make me remember stat	Actually, that make me remember statements of Linus Torvalds on Git at Google Tech Talk Conference:But I did end up using CVS for seven years at a commercial company and I hated it with a passion. When I say I hate CVS with a passion, I have to also say that if there are any SVN users in Subversion, users in the audience, you might want to leave because my hatred of CVS has meant that I see Subversion as being the most pointless project ever started, because the slogan for Subversion for a while was, CVS done right or something like that.And if you start with that kind of slogan, there’s nowhere you can go. It’s like — there is no way to do CVS right. So that’s the negative kind of credit.https://singjupost.com/linus-torvalds-on-git-at-google-tech-...	psychoslave	8.612159	-6.4381523	comment	3.0	40.0	1644227649	-11.858873
30336580	Agreed. It was a version control sys	Agreed. It was a version control system for humans. Unfortunately the Hg people decided that the only stable interface would be the CLI, which made it infeasible to build the likes of GitHub around Hg, and GitHub (not Git itself) is what drove Git's success.	throwaway894345	8.543633	-6.4604235	comment	3.0	16.0	1644865300	-11.921909
30337388	Does that actually happen, though? D	Does that actually happen, though? Do managers have enough time to go through git commits, chats, etc. Sounds like a full-time job on its own	beebeepka	8.553747	-6.4379935	comment	3.0	10.0	1644868606	-11.861917
30398660	Couldn’t that bring inconsistencies 	Couldn’t that bring inconsistencies eventually? If one commits and the other doesn’t.	hashimotonomora	8.599176	-6.534336	comment	3.0	19.0	1645291010	-11.922581
30399378	"> You lost me at ""free from the inde"	"> You lost me at ""free from the index"".If you click the link that text points you to (i.e. https://github.com/martinvonz/jj/blob/main/docs/git-comparis...), there's an explanation there for how to achieve the same workflows. I get that it's different, but I don't think it's worse. I consider myself a (former) git power user (I think I have ~90 patches in Git itself) and I've never missed the index since I switched to Mercurial ~7 years ago.> This is very welcome.Thanks :)"	martinvonz	8.559692	-6.5224004	comment	3.0	16.0	1645296210	-11.903239
30399415	I remember that well too (along with	I remember that well too (along with Rational Clearcase), and you may totally be right, but git does feel different because it works so well with all sorts of projects, big and small.  There were always operations that required hacks.  With git that doesn't feel the case to me,perhaps with one exception (but I don't think this is git's fault as much as it's mine for not knowing git well enough to use the tools it provides):  if I'm working simultaneously on two different branches (for example one branch is a bug fix that requires 20 minutes to build and deploy before I can test it, so I work on other things while it's running), I often have two different checkouts so I can (mostly) avoid having to git stash.That said though, you are probably right something will eventually supplant git.  I	freedomben	8.574768	-6.522287	comment	3.0	18.0	1645296466	-11.909111
30400033	Try using git worktrees: https://gee	Try using git worktrees: https://geekmonkey.org/rethink-your-git-workflow-with-git-wo...	halfdan	8.570863	-6.500128	comment	3.0	27.0	1645301040	-11.885152
30400655	While I agree that git could use a r	While I agree that git could use a rethink from a user tooling perspective, I really appreciate the existence of the index. I’m not tied necessarily to this specific implementation of it, but having a staging area where chunks are added piecemeal is an enormous benefit.I honestly wish git forced `-p` for operations that support it. I’ve worked on too many teams where people would just commit everything in their working directory, and it would inevitably make reviewing their PRs a nightmare. Particularly with times where changes were accidentally committed wholesale that shouldn’t have been part of that set of changes.	stouset	8.56227	-6.5125055	comment	3.0	17.0	1645305792	-11.90568
30400878	> just commit everything in their wo	"> just commit everything in their working directoryBut that's what they've tested. I've had far more problems in the other direction, where the commit doesn't contain the complete set of things that it's supposed to but because all the tooling - every single IDE and compiler - is looking at the working directory not the index, I've missed something.The index is definitely confusing for new users and users of other VCS.> having a staging area where chunks are added piecemeal is an enormous benefit.It would be quite fun if we could have hierarchical commits, so I could add bits to a commit without having to squash/amend. Then you'd see the top-level work item as a ""commit"" and the individual changes as ""subcommits""."	pjc50	8.608211	-6.546152	comment	3.0	14.0	1645307537	-11.909079
30480462	Is Github still the type of place th	"Is Github still the type of place that changes your branch names from master to main, (for your own good of course) and bans usage of the word ""meritocracy"" so as not to hurt people's feelings?"	yucky	8.509801	-6.5223784	comment	3.0	16.0	1645901219	-11.718403
30587434	I’m curious how git bisect was appli	I’m curious how git bisect was applied here. Wouldn’t you have to compile the whole kernel somehow and then run your test program using that kernel? Is that really what was done here?	bananabiscuit	8.573785	-6.5125513	comment	3.0	13.0	1646659598	0.87977135
30647280	Not sure if this is well known, but 	Not sure if this is well known, but press period `.` when viewing a PR, repo, or file and github will send you to a in-browser visual code editor. Able to make commits in there too, perfect for [nit] comments	ydnaclementine	8.614076	-6.4519014	comment	3.0	11.0	1647040339	-11.883749
30680127	> Split your merge request into smal	"> Split your merge request into smaller, independent merge requestsIMHO - This depends on the change. It is not simple if you are working on a refactoring that touches 100s of files.Review is needed where more developers share the concerns:Eg.1. DB Schema changes
2. API Schema changes
3. Changes related to backward compatibility with Biz Logic
4. End to end Design of the changeOpen to learn if anyone thinks otherwise."	the_arun	8.636284	-6.473063	comment	3.0	11.0	1647302687	9.47367
30711806	Here you go:  $ while ! git push my;	"Here you go:  $ while ! git push my; do sleep 1; done

Works for me eventually, although commits do not appear in web interface (they do in the actual repository)."	5e92cb50239222b	8.575559	-6.5126815	comment	3.0	12.0	1647528686	-11.903852
30713538	>I also push often because I'm forev	>I also push often because I'm forever aware disks can fail. I'm not leaving a day's worth of work on my local drive and hoping it's there the next morning.I separate file backup and version control. I keep every git repository I'm working on in Dropbox, and don't ever worry about how often I'm committing and pushing. I don't think git should be considered a substitute for a proper continuous backup system.	meowface	8.5629635	-6.4567747	comment	3.0	10.0	1647537454	-11.904238
30713776	Here is my last five commit messages	"Here is my last five commit messages: ""width*height is area"", ""fixing stuff i broke"", ""rm properties we dont need"", ""rm more useless attributes"", ""nicer figures"". I do my best to keep the code base as clean as possible, but I couldn't care less about keeping the commit history pretty. Any time spent on prettifying git history is better spent on documenting the existing* code imo."	bjourne	8.584773	-6.529992	comment	3.0	15.0	1647538578	-11.894524
18309624	After the merge, we'll probably bran	After the merge, we'll probably branch out and become an even better SharePoint for developers	tenderlove	8.729467	-6.4661975	comment	3.0	11.0	1540564887	9.142318
18310356	No, the author is right. Git us in i	No, the author is right. Git us in its core a database for managing patches. Understanding the needs of Linus Torvalds as his role of Kernel maintainer is about the only good way to understand why git is so strangely designed.	gmueckl	8.60064	-6.4465914	comment	3.0	14.0	1540569028	-11.885647
18310556	The best (known to me) informal intr	The best (known to me) informal intro into the architecture of Git is The Git Parable: http://tom.preston-werner.com/2009/05/19/the-git-parable.htm...	nine_k	8.554722	-6.4994397	comment	3.0	12.0	1540570278	-11.878855
18311040	    > Which is the VCS most suitable	"    > Which is the VCS most suitable for ....

Git.It doesn't matter what your question is. :-)I mean, come on, it's not like you have a choice. You gotta use whatever your teammates/coworkers/organization is using.That said, yeah, there's a lot of pedagogic problems with git stemming from the INSANE inconsistency of command-line. The only redeeming quality? It works and it's popular."	crispyambulance	8.575752	-6.4695277	comment	3.0	21.0	1540573329	-11.877123
18311565	I really hope Git isn't the end of t	"I really hope Git isn't the end of the road for VCS.  I work in visual effects and video games.  Most video game studios still begrudgingly use Perforce for project data.  Many also have a separate Git server for code.  Perforce or SVN is still the go to solution for binary assets.  Trying to explain Git to programmers is difficult enough, for artists who have never used the command line it is unreasonable.  Every time I've seen an ""asset library"" it's usually written from scratch instead of built on another VCS.  I've made some crude attempts at building on Git and the data just structure isn't appropriate.I know it's a bit unreasonable to expect the same tool for everything (but that's what you were implying).  The binary problem is more manageable for code with a few UI assets (like ico"	pfranz	8.601252	-6.48452	comment	3.0	15.0	1540577581	-11.869046
18369810	I started with SCCS, then moved to R	I started with SCCS, then moved to RCS, then to CVS for a long while. I'm now an occasional Git user.  The number one problem with SCCS is a locked checkout paradigm: one person gets to edit at a time.  Also, it doesn't manage directories, only files. Read here for some alternatives: https://en.m.wikipedia.org/wiki/Comparison_of_version_contro...	russfink	8.683846	-6.4447327	comment	3.0	19.0	1541246585	-11.8547535
18398372	Notably he was also answering other 	"Notably he was also answering other questions in the AMA, so it possibly only took him 2 minutes. It is not a difficult feature to implement anyhow, it probably went like this:    vim tools/Text.js
    self.addEventListener('click', function (e) {
      if (e.detail === 3) {
        self.selectAll();
      }
    });
    :wq
    git add tools/Text.js
    git commit -m ""Add triple click select all""
    git push origin master
    Done."	sophistication	8.58767	-6.506336	comment	3.0	18.0	1541588607	-11.900074
18512989	Yes. Git is powerful, but sadly has 	Yes. Git is powerful, but sadly has deep problems in its conceptual design. This is the reason why even mid-level engineers don't understand it fully.Love this work!	hackpr	8.55227	-6.4488344	comment	3.0	43.0	1542925963	-11.899264
18514828	I would hate to be restricted to a G	I would hate to be restricted to a GUI tool to achieve what git add can do from the command line. Using stashes would be just reimplementing the index using less convenient UI.I really don't understand what's so difficult about the index... It's just the stuff you will be inserting into the repository when you next commit. Having it separated enables a very convenient workflow that would've required manually using patch and diff when using tools that don't support you.Git is more than just revision storage. I like to think of code as clay, and the index as a tool you use to mould that into the final construct that gets baked	chousuke	8.567635	-6.532984	comment	3.0	16.0	1542955844	-11.898571
18578915	> Source control was very, very stan	> Source control was very, very standard 15 years ago.For commercial shops, perhaps. But back then the bar for using source control was much, much higher, so for many small projects, people didn't bother. There wasn't anything as simple as `git init`.There were a few public CVS and SVN servers that were appropriate for open source projects, but for anything personal or commercial, you had to use a local, single-user repo or set up your own server. (Back then, the only viable DVCS systems were commercial.)	TimTheTinker	8.58546	-6.438685	comment	3.0	10.0	1543698208	-11.869741
18588538	I also balked at it, but for the opp	I also balked at it, but for the opposite reason. Everyone should be able to sit down to a terminal, make a change to a repository, and commit it.I mean even if you don't know the command (or they are using a different version control system then you are used to) you can always check the help or man page. It's still a trivial task.	jgforbes	8.580635	-6.4501286	comment	3.0	13.0	1543843413	-11.855576
18663409	My take: these aren’t good commit me	My take: these aren’t good commit messages. The verb isn’t supposed to be what you did, otherwise it would always be “add” or “change” or “fix”. The verb is supposed to be what the program does thanks to this change. E.g. “Check server fingerprint”, not “Add server fingerprint check”.We already know you changed or added something, it’s a git commit.	jimmytucson	8.5748415	-6.5149703	comment	3.0	14.0	1544618791	-11.91463
18663955	> This is also the primary reason wh	> This is also the primary reason why I highly dislike merge commits: They make git logs extremely unreadable.I really really disagree. If the branch has one logical commit then no merge commit is needed. Otherwise the merge commit shows what happened and more importantly that these N commits came into the mainline as a single change.	gdfasfklshg4	8.587645	-6.547085	comment	3.0	33.0	1544623544	-11.918257
18679105	git user experience is very bad, obj	"git user experience is very bad, objectively and not because of the complexity or the learning curve. A good UX allows you to learn patterns which are applicable across the application. git, on the other hand, offers you an absolutely bewildering mismash of commands and switches to express whether the operation involves a remote, the index or the working tree. This could've been and should've been consistent but no such thing.Beyond the consistency argument, Jef Raskin: Humane Interface argues for universal undo which git almost has via the reflog except it should've built a safety net for git reset --hard which is possible  https://gist.github.com/chx/3a694c2a077451e3d446f85546bb9278 (and no, disk space usage isn't a concern for 99.99% of the codebases, ""disk is the new tape"" predates git"	chx	8.568599	-6.5234175	comment	3.0	18.0	1544772014	-11.900846
18701201	The more interesting question with g	The more interesting question with git statistics is what they are actually useful for. Tools like this seem to be guided by which data is available and easy to extract. What is commits per hour useful for?Sometimes these metrics are useful. For example, the top committers are interesting, because it instantly gives you a good hint who is very experienced with the codebase and its structure.Two metrics I find useful to know where to refactor: Files with the most commits and with the most authors.	qznc	8.568241	-6.447381	comment	3.0	11.0	1545073428	-11.8695135
18702738	So I installed and use `git open`. H	So I installed and use `git open`. How do these applications get to work, prefaced by `git`? Wouldn't `git quick-stats` just invoke `git` with an invalid parameter?	Waterluvian	8.566597	-6.501273	comment	3.0	10.0	1545084855	-11.881209
18725570	If you’ve not gotten a chance to use	If you’ve not gotten a chance to use Magit yet, I highly recommend it.  Along with Org Mode, it’s one of the modern killer apps for Emacs.I barely even bother to use git at the command line these days, and I’m pretty sure that with some of the changes Mr. Bernoulli is working on someday I’ll be able to never use it.Magit is the porcelain/TUI git always needed.  It’s really that good.	rauhl	8.643198	-6.4691534	comment	3.0	13.0	1545319162	-11.762107
18823177	I think they don't branch code becau	I think they don't branch code because perforce branches are horrible and merging them back to HEAD is extremely painful process for monorep.	sigsergv	8.627046	-6.533165	comment	3.0	29.0	1546599812	13.832858
18823349	Branching enables me to share unfini	Branching enables me to share unfinished work with my collaborators. Sometimes I don't want to commit to trunk yet but still share code and collaborate on a part of the code base.	weinzierl	8.612311	-6.5268817	comment	3.0	28.0	1546602505	-11.890953
18823898	So basically it's a branch?	So basically it's a branch?	fouronnes3	8.619106	-6.555279	comment	3.0	12.0	1546609162	-11.821385
18865932	How well does git perform for usual 	How well does git perform for usual text (not code)? I only use git for code and as far as I know it compare only whole lines, which is not very useful in a text where a paragraph has no line brakes and is about half a page long.I write in Word as well and merging edits from collaborators with my in-the-meantime-updated document is really anoying and error-prone. I found https://www.simuldocs.com/, but haven't tried it yet.	objplant	8.636068	-6.476784	comment	3.0	10.0	1547050927	13.676722
18920556	I use it quite a lot, especially wit	I use it quite a lot, especially with `git add -p` to stage only parts of a file for an atomic commit.	aurumpotest	8.600513	-6.510014	comment	3.0	17.0	1547644790	-11.902827
18920606	I disagree with this idea. The best 	I disagree with this idea. The best way to learn git is to read the git book, in this order: chapters 1, 10, 2, 3, and the rest at your discretion. This way teaches you about the internals first, and if you understand the internals the rest of git is pretty intuitive.https://git-scm.com/book/en/v2	Sir_Cmpwn	8.557487	-6.5032115	comment	3.0	22.0	1547645268	-11.907763
18921562	Great idea. This kind of culture is 	Great idea. This kind of culture is why there are a lot of people that don't and probably never will use git.	Mirioron	8.553015	-6.475963	comment	3.0	10.0	1547652200	-11.873205
18921685	But why is the exceptional case the 	But why is the exceptional case the default?Surely, most of the time when you go to commit, it's all the files you've changed?	url00	8.591823	-6.529953	comment	3.0	10.0	1547652996	-11.914945
18922647	`git log -p` is my favorite obscure 	"`git log -p` is my favorite obscure git command.
Shows you commit by commit changes. If you specify a path, it limits to only those files. If you do a single file you can do `git log -p --follow <file_path>` and it will track the file across moves and renames.Also `git whatchanged` is a super helpful command to see just the list of files that changed in each commit"	war1025	8.566373	-6.495179	comment	3.0	12.0	1547658991	-11.8890915
17214360	"ok, seriously, is ""using git push to"	"ok, seriously, is ""using git push to do a deploy"" a thing?
WTF?"	_ZeD_	8.561514	-6.4542236	comment	3.0	10.0	1527944212	-11.879202
17221010	how would you compare it to other gi	how would you compare it to other git interfaces ? unless you used to use the bare git program in a shell.	agumonkey	8.557703	-6.4885025	comment	3.0	18.0	1528051202	-11.881068
17228304	> on all the major Git platformsmiss	> on all the major Git platformsmissing notabug.org and savannah	rambojazz	8.5365715	-6.4475307	comment	3.0	10.0	1528124155	-11.89707
17230852	But git has always has been, and sti	But git has always has been, and still is open source. Of course, Fossil has some advantages but claiming the OS high ground shouldn't be one.	petepete	8.478055	-6.522133	comment	3.0	12.0	1528138141	-11.976842
17246125	The patch-based workflow is very sim	"The patch-based workflow is very similar to how the Linux kernel review workflow works. Arguably, this is the way Git is supposed to work - submit patches, discuss them, then merge them once they're ready. Every idea is one commit, no checkpoints or ""fix typo"". Pull requests are used to merge other maintainer's trees that have many commits in them. It also ensures that there's a permanent link between a commit and its review, since there's a 1:1 mapping.Gerrit works similarly, but Phabricator's UI is much more friendly.For small projects or teams, the overhead of introducing a new tool may not be worth it, for for large projects with many contributors, the workflow is - in my opinion - strongly superior.If you set Github to ""squash and rebase"" and enforce a ""one PR per idea"" rule, you will"	lima	8.5898695	-6.4384027	comment	3.0	22.0	1528284980	2.186371
17246023	Used Phabricator/Arcanist for one ye	"Used Phabricator/Arcanist for one year straight, it wasn't fun. It's pedantic, buggy, happy to mutate your branches or ""revisions"" (PRs) unless you take specific care (which won't happen until you've been bitten enough times).Wrapping git is essentially a flawed idea; there are just too many corner cases (rebasing, resetting etc) for a wrapper to handle them all."	vemv	8.525362	-6.471342	comment	3.0	15.0	1528283276	-11.923996
17248142	> But there isn't a way to view the 	"> But there isn't a way to view the ""interdiff"" between the version of the branch before review and the version of the branch after review. Review tools like Phabricator, Gerrit, and email lists allow one do view that diff.Yes there is. You even get a link to view that exact diff whenever someone updates a PR. It shows changes since you last viewed the PR, up to its current state."	WhyNotHugo	8.634083	-6.4849143	comment	3.0	13.0	1528300473	1.966036
17248515	I only tried out Phabricator briefly	I only tried out Phabricator briefly, and it was pretty good. But the data model bothered me in how it introduces its own abstraction of patches on top of the git branch model. It seems redundant, and also seems like an SVN-inspired model that just felt like a step backwards from having the power of plain git (as in the ability to create diff objects and branch and rearrange them arbitrarily in a pretty simple way, and have multiple people working on these branches at the same time and keeping in sync with each other). I know you can still use plain git locally with Phabricator, but the extra layer of abstraction seemed to only add complexity since now you basically have different data models locally as you do on the server whereas previously they were the same. And what you gain from it d	dcosson	8.519586	-6.49778	comment	3.0	11.0	1528302560	-11.917825
17253053	It does explain it. He wrote that “G	It does explain it. He wrote that “Git keeps track of changes in sets of files.”	chris_wot	8.579338	-6.5013647	comment	3.0	10.0	1528342536	-11.894159
17266921	His rants are also pretty particular	"His rants are also pretty particular about not rewriting published history. As he said on the linked message, ""[...] I didn't notice the history screw-up until too late, [...]"", so he probably already had pushed to the public ""master"" branch on the git.kernel.org servers. Once it's there, other kernel developers might already have pulled from it, so trying to rewrite the git history to remove the commit would only lead to an unholy mess (and the offending commit coming back) the next time he merges from them."	cesarb	8.57407	-6.5370626	comment	3.0	11.0	1528474780	-11.905406
17268471	Is there a way so you can rebase and	Is there a way so you can rebase and push without breaking everyone who already pulled your repo? I have this issue continuously when using rebase on branches that have gitlab or github merge/pull requests. I need to create a different branch all of the time.	spockz	8.571907	-6.5501814	comment	3.0	10.0	1528483158	9.342314
17354139	In that vein, I invariably have one 	In that vein, I invariably have one massive commit on every project to remove trailing whitespace first. That way when my well-behaved editor removes them with each commit, it's not littering up the diff.	colinbartlett	8.618851	-6.5232058	comment	3.0	22.0	1529491974	-11.817603
17354210	I go from git to SVN. It's just easi	I go from git to SVN. It's just easier for me to work with and once the team gets used to it, it's a win-win.	macht	8.570236	-6.4785786	comment	3.0	14.0	1529492750	-11.88089
17354251	SVN is really heavyweight for branch	SVN is really heavyweight for branches and tags. It used to take like a minute to branch with SVN but when we swapped to git it took like less than a blink.Also —rebase is way better than merge. I haven’t had to merge git for over 6 months but with SVN I was doing it twice daily, at least.	aetherspawn	8.579303	-6.4992285	comment	3.0	11.0	1529493177	-11.886842
17360564	A Git protocol parser written in Go	A Git protocol parser written in Go	guessmyname	8.582613	-6.468134	story	3.0	97.0	1529534832	-11.90592
17483755	CVS was awful, but it was so much be	CVS was awful, but it was so much better than RCS, which operated only on single files. There was a time in the late 90s when CVS + Bugzilla + Tinderbox was the state of the art of CI if your toolset was all open source. I used this combination at multiple workplaces 1998-2002. It worked and we shipped, but we didn't really understand how bad the tools were.At Sun all stuff was in Teamware, except when it wasn't, because every group at Sun could do whatever they wanted to (we used SVN in the x86 ILOM team). Teamware was good but suffered by being a wrapper on top of SCCS.SVN was a revelation after CVS. I resisted switching to git from SVN for a long time because the mental model for SVN is so much simpler: everything is in one central place, every change is marked with a monotonically incr	jdblair	8.642682	-6.438908	comment	3.0	34.0	1531057423	-11.849262
17483765	It also tells you how quickly softwa	It also tells you how quickly software employment has exploded, that so many (half? more?) developers have never used any version control (fundamental) tool other than one that's been common for only a decade.As recently as the first dot-com boom, Git didn't even exist. Even Subversion was brand new, and it was mind-blowing how much easier it was to work with than CVS.One aspect of history that this article glosses over is that Git is not the only or even the first third-generation version control tool created. The earliest buzz I remember around DVCS was for darcs and bazaar, neither of which I've heard mentioned since about 2009. Mercurial and Git were released around the same time as one another, and were in a vim-emacs sort of grudge match for a few years before Git became the clear wi	cimmanom	8.564024	-6.4796357	comment	3.0	16.0	1531057566	-11.882224
17484297	This is a really fun article.  I sta	"This is a really fun article.  I started with CVS, graduated to Subversion, and now to Git.  It makes me really curious what the next paradigm shift will be!The way I see it the evolution of these version control systems was driven by the precipitously falling price of disk space.CVS only stored a tiny bit of metadata locally so almost every operation required contacting the server.  That made using CVS very slow and branching expensive.Subversion stored a whole separate copy of every file locally.  This made the critical ""show me just my local changes"" operation an order of magnitude faster and made branching cheap, at the expense of doubling the disk usage.Git stores the entire history of everything locally (compressed).  This makes most operations an order of magnitude faster still, so "	foreigner	8.585422	-6.472149	comment	3.0	19.0	1531064427	-11.871098
17483727	I started my software engineer using	"I started my software engineer using CVS. I was using CVS as recently as 2014.Why? Two reasons. I'd played with git but hadn't really understood the power of trivial branching (though I was one of those CVS power users who could branch, but tended to use my IDE to manage it). I remember thinking to myself, oh this is like CVS, because that is how I used it when I played with it.The bigger reason is that I was managing a team of 2-4 developers that rarely worked on the same thing. We all worked in the same room. The codebase was relatively small (35k loc). I could see no good reason to make the change when CVS was ""good enough"". I was the same reason we used the same old crufty bug tracker--too many features to write to spend time upgrading infrastructure. Unless it was a 2x efficacy improv"	mooreds	8.626772	-6.4577103	comment	3.0	29.0	1531057054	-11.884281
17484954	I hope pijul will gain traction soon	I hope pijul will gain traction soon: https://pijul.org	alkonaut	8.608794	-6.553414	comment	3.0	12.0	1531070604	13.874306
17485096	Why are branches in SVN error prone?	Why are branches in SVN error prone? We branch constantly and haven't had any serious problems.	nradov	8.604868	-6.5229497	comment	3.0	24.0	1531072030	-11.886452
17522173	No, he uses commit messages as log o	"No, he uses commit messages as log of his thoughts, and commits need to have changes, thus each ""log only"" commit deletes or adds those same whitespaces in a never ending cycle.In between you find some actual code changes (with also long commit messages).It's not that he's finished - I hardly guess so because he complains that he'd need 10 years of time to polish everything out perfectly (in his opinion) and he only has one - it's just his style for a log book..."	tlamponi	8.58198	-6.511879	comment	3.0	13.0	1531483650	-11.91091
17539117	Isn't this effectively what code com	Isn't this effectively what code commits are for? If you've done something worth noting, it should probably be in a commit anyway.	johnramsden	8.582239	-6.488594	comment	3.0	10.0	1531721534	-11.901577
17547943	This is interesting work.I've never 	"This is interesting work.I've never noticed the referenced git operation as being slow.  In my experience,    git log -- <path/to/file/or/dir>

has always seemed instantaneous or nearly so.  It's quick even on code bases that are quite large (years of work from large teams, 10's of thousands of commits).Maybe data and performance information on before vs. after bloom filters would help clarify the specific design goals.I love seeing bloom filters in use in widely-used software in real life, in any case!"	jaytaylor	8.599692	-6.4664884	comment	3.0	28.0	1531812113	-11.842075
17547963	Does it work when I'm looking for al	Does it work when I'm looking for all commits changing a directory? I.e. Do directories get added to the bloom filter or just filenames?	lozenge	8.604086	-6.5519905	comment	3.0	14.0	1531812552	-11.895689
17590577	I think you're missing something rea	I think you're missing something really profound here. I wrote my masters thesis on identity problems in version control systems (Git, Mercurial, Subversion, and the like). These systems are forced to take a stance on the Ship of Theseus problem — they're tracking the identity of files/documents whose entire contents, name, and format may change over time.Different systems have chosen to take very different stances on this. As it turns out, taking a stance on what makes a file a file (or a ship a ship) — being explicit rather than vague — does not solve the problem. Not even close. In fact, one of the many little things that make Git a brilliant piece of software is that it refuses to take a stance on identity. Git is intentionally vague about what makes a file a file. It doesn't actually 	zukzuk	8.549795	-6.4875207	comment	3.0	11.0	1532319994	-11.901492
17606615	There is a set of code changes local	There is a set of code changes locally and those changes are bundled off to the test server to run the full test suite? That's a branch.Now let's say I break a project sharing this code and because I'm not an expert in all 2 billion LoC and 3000 projects google is running I need to enlist some help in fixing what I broke. Presumably there is a way for the developers on that downstream project to pull in my change set? That's a shared branch.Now assuming I can get all of these planets aligned correctly I'm going to need to take this set of changes and put it into the master version aren't I? That's merging my branch into trunk.	flukus	8.649476	-6.514936	comment	3.0	11.0	1532487365	5.4564085
17607457	Still All on One Server: Perforce at	Still All on One Server: Perforce at Scale (2011) [pdf]	guessmyname	8.640701	-6.491912	story	3.0	60.0	1532503473	13.818505
17632915	Out of all these, I wish I could use	Out of all these, I wish I could use git bisect the most. Working on large codebases with large teams, the command itself is a godsend.Unfortunately a PC with Symantec Endpoint Protection makes the filesystem dog slow to the point that the one time I needed it and it should've taken about 13 steps to find where the bug was introduced, it was faster to redo the feature without accessing the previous code	arenaninja	8.576961	-6.4714227	comment	3.0	10.0	1532782076	11.577198
17633257	I advocate:git add -pfor interactive	I advocate:git add -pfor interactive staging. It’ll present each hunk of code with a y/n prompt. This is a good habit to prevent committing any debug code or stray marks.	magoon	8.6042595	-6.5155926	comment	3.0	10.0	1532787290	-11.901823
17673566	Ask HN: At work, do you you use Git 	Ask HN: At work, do you you use Git for your Excel workbooks?	bjoerns	8.583292	-6.459758	story	3.0	2.0	1533231604	-12.090145
17682067	Git is cryptographically secure, but	Git is cryptographically secure, but it's not foolproof.However signing a single commit verifies the parent commits (similar to the blockchain) so it isn't necessary for every commit.Signing tags and commits is great, but if you decide to use this in your normal workflow, you’ll have to make sure that everyone on your team understands how to do so. If you don’t, you’ll end up spending a lot of time helping people figure out how to rewrite their commits with signed versions. Make sure you understand GPG and the benefits of signing things before adopting this as part of your standard workflow.	eboyjr	8.608312	-6.456526	comment	3.0	14.0	1533319599	-11.7805395
17689260	> Why do people make a huge fuss ove	"> Why do people make a huge fuss over git? Why?It's unclear to me what you're referring to, but the part I can answer is this:> How is git hard?IMHO because it is not intuitively obvious what it means for your ""HEAD"" to be ""detached"", or for you to ""rebase"" onto a ""remote branch"", or why ""checking out"" a file reverts your changes, or why ""checking out"" a branch suddenly clones its files, or why you'd ""add"" a missing file to remove it, or why you ""committing"" doesn't actually commit your changes to the central repo, etc."	mehrdadn	8.553074	-6.5076127	comment	3.0	23.0	1533433401	-11.910565
17689274	I want to edit the commit message of	"I want to edit the commit message of a commit that is 5 commits in the past, that I have not pushed yet.  What is the command to do it?Okay so it turns out I made a minor typo in that commit and I want to change it without adding any more commits.  What is the command to do it?Okay so now I want to take all commits that have ""bugfix pickme"" in the subject and cherry-pick them to master.  What is the command to do it?With a decent interface, these actions are basically trivial.  I've been using git for several years and I have to think way too hard to figure out what to type just to get what I want to happen.  All too frequently I just say 'screw it' and make a sad commit because my job is writing software, not wrestling with git commands."	rabidrat	8.58339	-6.5266633	comment	3.0	17.0	1533433694	-11.924858
17689518	Since `git status` is my most common	Since `git status` is my most common command I've got it aliased to just `s`. Every time I use another machine it throws me off when the command doesn't work :)	frenchie14	8.576468	-6.505756	comment	3.0	11.0	1533439830	-11.865055
17750126	The one caveat is that git has a som	The one caveat is that git has a somewhat more expansive view of what counts as a rewrite of a line of code than what would be counted as a rewrite when writing a book.	koboll	8.557052	-6.480306	comment	3.0	12.0	1534168953	-11.829938
17770078	I am a self taught developer who nev	I am a self taught developer who never went to college, is git normally not taught in school?	someguy101010	8.530123	-6.4578757	comment	3.0	10.0	1534369690	-11.902451
17783062	Are there any active Fossil instance	Are there any active Fossil instances available for free/open source projects? I found Chisel, but am not sure whether many of the projects are active.Also, the design of Fossil and Chisel is s bit difficult to read on mobile.	brylie	8.498757	-6.5160894	comment	3.0	12.0	1534516386	-11.945334
17783065	`git gc` will also garbage collect a	`git gc` will also garbage collect any ref that isn't used by a current branch/tag (under refs/heads and refs/tags), the index (staging), originals from filter-branch (refs/originals), and reflogs.The question isn't whether the data will be garbage collected, but how the active data AVOIDS being garbage collected - git gc only targets a pretty small amount of refs to preserve.	snuxoll	8.601383	-6.548132	comment	3.0	10.0	1534516394	-11.881788
17827137	NIST Git repo	NIST Git repo	samfisher83	8.548227	-6.440729	story	3.0	40.0	1535031621	-11.89417
17867165	I'm looking at this will little know	"I'm looking at this will little knowledge of how this makes the blockchain application easier. What seems odd to me is that merging branches isn't supported? So you can't perform a bunch of ""transactions"" and then merge them back into your master state. Maybe someone could illuminate the purpose this solves a little more clearly, as I'm guessing it has nothing to do with my naive understanding."	2T1Qka0rEiPr	8.603012	-6.537555	comment	3.0	10.0	1535539085	-11.890753
16300152	You can use the debugger on low leve	"You can use the debugger on low level api calls to get pretty much anywhere in the codebase. If you want to find whats changing a  label to ""foo"" you can hook into every set_Text call and put a conditional breakpoint on all label changes to break on ""foo"", then just go up the callstack to find the logic. This strategy works on network interfaces and file interfaces as well. I abused this on our 2M+ SLOC legacy codebase and it has saved me many hours.Also use version control to identify the most commonly edited files in the project. These are usually the files that are doing all the work (80/20 rule) and you likely need to know of them.git log --pretty=format: --name-only | sort | uniq -c | sort -rg | head -10"	macromaniac	8.608869	-6.4870934	comment	3.0	13.0	1517698412	3.948018
16372458	I wonder how most people work with t	I wonder how most people work with their source control system. In general, I find it far easier to use git or svn from the command line because when I'm bouncing around between editors and OSes, it's always the same user experience so you get to leverage that experience better. Works for me anyway.	h_r	8.580252	-6.46455	comment	3.0	10.0	1518569851	-11.878054
16400216	After we merge a pull request with r	After we merge a pull request with rebase + fast forward merge, there is no merge commit created. This leads to a linear commit history.Does anyone know anyway to look at the linear commit history alone (not GitHub) and tell where a pull request was merged and who merged it?	asmdev	8.585307	-6.5487337	comment	3.0	10.0	1518866432	-11.921403
16401040	> I personally prefer merging via sq	> I personally prefer merging via squash since it keeps a linear commit history without polluting the history with tons of intermediate work-in-progress commits.How do you deal with cases where your changes require more than a single commit?  Some changes are easier to review when they're separated into several logical commits rather than having one giant diff from a single commit.	u801e	8.580821	-6.5629663	comment	3.0	11.0	1518880870	-11.928501
16408385	You're missing my point.  I'm not ta	"You're missing my point.  I'm not talking about ""good code practice and data models and such"".  I'm talking about how you digest and model the problem as a whole, that is where the 10xer shows his quality.Consider git vs svn for example.  Linus was familiar with Subversion and its predecessors (CVS, RCS) before he created git.  He knew that that model of change control was inherently flawed, and that he could create a better base model.  According to Linus, he built the git core in 10 days.  Even though svn had decades of a head start and tens of thousands of hours put into it, it only took a few years for git to rapidly supplant svn.  The reason?  Because the problem was modeled better.  After 7 years of using Subversion, I was still getting bitten by weird bugs, had a terminal fear of br"	dasil003	8.571681	-6.4881396	comment	3.0	15.0	1518986294	-11.895211
16413538	Have you tried `textconv` instead? Y	Have you tried `textconv` instead? You can configure git to generate your CSVs on the fly and show the differences between CSVs when you do `git diff`. See: https://www.kernel.org/pub/software/scm/git/docs/gitattribut...	kdmytro	8.67219	-6.5031376	comment	3.0	12.0	1519055384	-11.775166
36547849	A couple of things:git add ., git ad	"A couple of things:git add ., git add -u, etc, etc... bulk adds like that are bad git hygieneNonconstructive commit messages like ""..."" are similarly awful.And don't forget to git stash/git stash popPut yourself in the shoes of another developer who has to parse all that crap in the commit log. At my last job that sort of thing would never pass code review.To say nothing of the fact that you're typing all these commands potentially several times an hour, sometimes every day, for years, and adding an additional distraction to something that I got down to a pretty tight feedback loop.One alternative, the one I like the most, is you link your folders with some kind of sync mechanism (Dropbox) and can then freely (within limits) switch back and forth, and you can do all your surgical commits a"	pdntspa	8.579441	-6.5086913	comment	3.0	23.0	1688198544	-11.87758
36557343	It's not inconvenient -- it's great.	It's not inconvenient -- it's great. I would never run a pre-commit hook someone else wrote. I'm not a child, I don't need my hand held. If I want to create a commit object, create one.I don't understand folks who want their tools to fight them.	xyzzy_plugh	8.609541	-6.518434	comment	3.0	11.0	1688262281	-11.903477
36576748	Indeed you did, 10 years ago.  This 	Indeed you did, 10 years ago.  This is the (mega!) commit:https://github.com/WebKit/WebKit/commit/93a48aa964f25ce8ec9f...I often wonder how much more productive I could be if I didn't need to split changes like this into 50 small commits, where every intermediate commit is working and has passing tests...	londons_explore	8.56203	-6.465947	comment	3.0	51.0	1688407835	-11.878638
36581799	> there's that one coworker who know	"> there's that one coworker who knows a bit more about Git than everyone else, who helps get us back on track whenever our local repos end up in a strange stateevery single article about git comments on this ""feature"" of git...isnt it time we all removed the aura of geniousness to git and bloody moved on to something better?, (like svn for instance)"	pestatije	8.551767	-6.4621286	comment	3.0	13.0	1688440968	-11.889299
36606582	"Not to mention removing ""master"" as "	"Not to mention removing ""master"" as the main branch name in Git."	cubefox	8.513357	-6.513856	comment	3.0	11.0	1688588671	-11.702336
36607147	That's a good point.But Git was init	That's a good point.But Git was initially written by one cranky Finn, in ten days.It totally changed the way we all work.	ChrisMarshallNY	8.546737	-6.459551	comment	3.0	21.0	1688591348	-11.879653
36707450	We've been using this for a few mont	We've been using this for a few months to manage pull request merges for our mono repo. It's greatly improved the merge process. It makes trunk based releases faster and reliable. Kudos to the team for adding this feature.	zabil	8.615049	-6.45023	comment	3.0	10.0	1689246776	7.5656834
36707727	It's completely embarrassing, whatev	"It's completely embarrassing, whatever marketing person wrote it needs to be got rid of.> The result: your team can focus on the good stuff—write, submit, and commit.  No tool sprawls here.The good stuff? Tool sprawls? Is this written for teenagers?> Merge queue is designed for high-performance teams where multiple users regularly commit to a single branch.I think you meant ""highly active"". High performance means something else. But I can kind of see it emerging from your awful sales person brain."	da39a3ee	8.69371	-6.5219793	comment	3.0	14.0	1689248819	9.236219
36707809	Squash and rebase. Linear commit his	Squash and rebase. Linear commit histories.	John23832	8.577494	-6.5625024	comment	3.0	12.0	1689249356	-11.926979
36748256	Purpose.If I feel like there's a sma	Purpose.If I feel like there's a small chance of my commit being accepted, or ever mattering, it's hard to fake the motivation to work on it.	CoastalCoder	8.584676	-6.5115833	comment	3.0	10.0	1689522143	-11.913444
36773527	If anyone is interested in building 	If anyone is interested in building a competitor to GitHub based on mercurial, please reach out. Email in bio.	calderwoodra	8.465156	-6.4556694	comment	3.0	11.0	1689692429	-11.953723
36778634	If somebody from Github is reading t	If somebody from Github is reading this: when will merge queues land in Github Enterprise Server? I work on a project that badly needs the feature.	nrclark	8.651063	-6.5056043	comment	3.0	16.0	1689712064	9.04852
36779306	> Do people not merge master into th	"> Do people not merge master into their branch before pushing? All that seems like mostly problem caused by having too long living branches.On projects with a high commit velocity and a large team, simply merging main and running the tests is not enough. The likelihood that a new commit lands on main before your tests finish is high, and restarting the process every time there's a new commit is time consuming. Merge queues are the only way to ensure that main does not break from conflicts that arise ""in between"" commits."	luketheobscure	8.675306	-6.542299	comment	3.0	13.0	1689715582	-11.88833
36783729	I found lazygit after building somet	I found lazygit after building something of my own thay solves some of these problems for me - git-fuzzy [0].I'd like to share some of my thoughts about the comparison.lazygit is a TUI for git which can behave in a standalone fashion. It's also designed to be quick and easy to use to perform quite advanced actions but ones that a seasoned git user may really want when working with git history. Since I'm already a seasoned git user the main feature I like about lazygit is the ability to surgically work with patches.All that said, a majority of my workflow is tightly bound to git-fuzzy. I use its CLI composability quite heavily in combination with aliases and functions - git-fuzzy excels in this particular way (`git fuzzy log $(git fuzzy branch)` which I invoke using `gl $(gb)` by way of ali	parentheses	8.582546	-6.504174	comment	3.0	27.0	1689757591	-11.854504
36784368	I use VSCode but not git lens. I don	I use VSCode but not git lens. I don't think it does much that Lens doesn't, it's indeed a different workflow for me: I don't like to use the mouse so the clicky-clicky workflow of Lens doesn't work for me, I'm much faster with lazygit (and I can instantly drop to the `git` CLI if there's something I don't know how to do with lazygit, as I'm already in the terminal).I'm not particularly keen to have my VCS and my code editing in the same software really, although I wouldn't say that it's a superior approach.	williamdclt	8.604486	-6.4691825	comment	3.0	11.0	1689763643	-11.844511
36784485	I don't know Rider, but I assume thi	I don't know Rider, but I assume this is a limitation in all of their IDEs. Yes, you can commit only certain changes within a file. But you can only do that based on whole chunks. For example, if you add two new lines at the end of an existing file, you cannot commit only one line but not the other. The same limitation applies to changelists (at least in IntelliJ IDEA and Webstorm).	FrontAid	8.607964	-6.5275545	comment	3.0	11.0	1689764445	-11.898016
36831772	if 99.99% of dev use Git you have to	if 99.99% of dev use Git you have to use Git, using your own solution that no one else uses or know or need to know is bad.That's pretty much the opposite of progress.At one time, 99.9% of developers used CP/M. At time, 99.9% of web was done in PHP. At one time, 99.9% of developers IBM XTs. At one time 99.9% of developers used SourceForce and SVN.Stuff changes. Monoculture is bad for the tech industry.	reaperducer	8.559021	-6.4831443	comment	3.0	12.0	1690076214	-0.4954001
36832156	Seems like a textbook example of NIH	Seems like a textbook example of NIH to me. By the time you understand git well enough to design a good replacement, you’re bound to be an expert and ought to appreciate more the design of git.If you don’t like the lack of a good GUI or web application, you can just build one that works the way you want and still works with git.	zeroimpl	8.549547	-6.4808474	comment	3.0	13.0	1690080718	-11.8869705
36832165	Yes, which is why git is a pain in t	Yes, which is why git is a pain in the butt to install and you have to rely on your OS packages (which includes all the kitchen sink stuff) or a GUI installer with all the necessary dependencies vs. Fossil which is just download executable and done.	qbasic_forever	8.475369	-6.467431	comment	3.0	35.0	1690080858	-11.905049
36832223	I saw this video few days ago which 	"I saw this video few days ago which describes some of the alternative to Git and of course Fossil is one of them. I have used Fossil in some projects and found to be ok. 
I found Pijul https://pijul.org/ described in this talk to be very interesting. It was discussed on HN before. 
Source:
https://www.youtube.com/watch?v=M4KktA_jbOE"	kasperset	8.505325	-6.527331	comment	3.0	13.0	1690081517	-11.941981
36832105	Git is a “distributed version contro	Git is a “distributed version control system” (DVCS). You’re just adding the term “source code” for no particular reason.I make video games. Video games contain far more data than mere source code. Almost all game devs use Perforce because Git is insufficient.Artists and designers desperately need more version control in their lives. They are mostly absent because their programmers use Git which is insufficient. Its a god damn shame how much of our businesses use “stuff_final_final_05.psd” for “version control”.	forrestthewoods	8.579089	-6.4834723	comment	3.0	25.0	1690080240	-11.883504
36833155	> you are trying to force a bad usec	> you are trying to force a bad usecaseThe world has non-text files that require version control support. Version control systems are mostly bad-to-terrible for anything other than source code. Implying that the use case is wrong is borderline offensive.It’d be nice if there were some artist/designer friendly version control systems. I can teach someone who has never even heard of version control how to use Perforce in 10 minutes. It’s darn near idiot proof and near impossible to shoot your foot off. Git is not easy to use. This is evidenced by the tens of thousands of blogs explaining how easy and simple to use it is. If that were the case there wouldn’t be need for all those posts!Someday.	forrestthewoods	8.581254	-6.4771338	comment	3.0	12.0	1690095680	-11.882149
36834292	Point could be made people don't rea	Point could be made people don't really use git anymore - they use github as the primary interface. Branching, merging, review, etc.	mattbillenstein	8.535922	-6.439642	comment	3.0	11.0	1690110738	-11.872179
24424048	How to Rename Your Git Repositories 	How to Rename Your Git Repositories from “Master” to “Main”	speter	8.50428	-6.531653	story	3.0	2.0	1599675664	-11.735643
24441647	For making commits, does anyone else	For making commits, does anyone else still stick with using git add -p , along with the s/e options?Granted I don't use Emacs but I haven't found any plugin in any editor that gives the same confidence and flexibility as git add -p.	nickjj	8.58134	-6.5141654	comment	3.0	16.0	1599824943	-11.909393
24454396	Anyone know if they're still on Merc	Anyone know if they're still on Mercurial?	jeffbee	8.495029	-6.54707	comment	3.0	32.0	1599935671	-11.980556
24456375	Why? Git is such a worse, over-engin	Why? Git is such a worse, over-engineered experience.Github won, so we're all forced to use git now, but mercurial is really a simpler interface and a more straightforward mental model.	ForHackernews	8.518654	-6.535324	comment	3.0	10.0	1599949219	-11.930327
24587120	"Try also ""tig"" which is something in"	"Try also ""tig"" which is something in between git --log and gitk.Also, I firmly believe that git is very simple if you use it right. I'd you are deep in the manual with exotic commands and flags it's most likely your own fault.Edit: forgot to add that saying git is not complicated always gets heavily downvoted on HN. So goodbye digital karma..."	panpanna	8.552554	-6.4697905	comment	3.0	17.0	1601015559	-11.887166
24593174	Can someone with more domain knowled	Can someone with more domain knowledge than I comment on whether or not this project is mathematically possible?I remember the reason given for not making git patching sound was because all the sound algorithms known to the git author were slower in the common case, and only better in less common cases.Darcs is really fast for what it does, but git is way faster by doing less.	aidenn0	8.573637	-6.4704022	comment	3.0	11.0	1601061377	-11.875036
24595626	They're in the middle of a big rewri	They're in the middle of a big rewrite, which will be out Real Soon Now.To understand the basic idea, this series of blog posts is excellent:https://jneem.github.io/merging/To me, it seems clear that a patch-based VCS is the future. Whether or not it will be pijul that brings us this future, I don't know...	dilap	8.593699	-6.5795174	comment	3.0	17.0	1601082944	13.92378
24597475	> patch-based VCS is the futureSorry	> patch-based VCS is the futureSorry for being ignorant, but isn't git patch-based? I always thought of git commits as patches. You can directly convert one into a patch and vice-versa.	dmos62	8.57993	-6.4856296	comment	3.0	10.0	1601112021	-11.856119
24643434	I enjoy how well-crafted Fossil seem	I enjoy how well-crafted Fossil seems to be; just like SQLite, which a sibling comment also mentioned. I really want to use Fossil, but it would be way too hard for me to not have the index/staging area of Git. [1] For all the software that claims to be 'opinionated', Fossil really is that.[1]: https://fossil-scm.org/home/doc/trunk/www/gitusers.md	kipari	8.510588	-6.5362515	comment	3.0	29.0	1601497734	-11.939008
24644236	GitUp – The Git interface you've bee	GitUp – The Git interface you've been missing all your life	wetpaws	8.554874	-6.4562583	story	3.0	38.0	1601501865	-11.885724
24643619	It would seem the authors consider r	"It would seem the authors consider rebase harmful:
https://fossil-scm.org/home/doc/trunk/www/rebaseharm.md"	rstupek	8.513259	-6.575597	comment	3.0	23.0	1601498767	9.465359
24643740	I'm sympathetic to a lot of what the	I'm sympathetic to a lot of what they have to say, but this has always been a sticking point for me:> Cherry-picks work better with small check-insMaybe it's just bad git tooling or me using the tools wrong, but if I need to cherry-pick and there are conflicts, it is always way easier to squash everything down and pick it in one go— if I don't do that, I end up resolving the same conflict over and over as new commits pile in on top of it and meet a conflict-resolved state that they then have a further conflict with.	mikepurvis	8.594394	-6.537585	comment	3.0	11.0	1601499410	-11.864175
24654399	"The branch is now called ""main"" beca"	"The branch is now called ""main"" because the previous name ""master"" was found to be problematic due to historical racism / colonialism. And so it remains historical racism / colonialism the cause for the name of the default branch for newly-created repositories on Github."	ominous	8.5044565	-6.5329375	comment	3.0	14.0	1601576629	-11.759022
24654804	It's clear by all the negativity tha	"It's clear by all the negativity that people here care a lot about this, but I really don't understand why.  What's so important about keeping the name of the branch ""master""?"	mcphage	8.500769	-6.4951234	comment	3.0	12.0	1601578607	-10.783626
24686712	Merge commits are noise, a clean his	Merge commits are noise, a clean history is has no merge commits	fs111	8.589412	-6.546873	comment	3.0	13.0	1601898021	-11.926562
24686752	I squash commits. Well, I rebase so 	"I squash commits. Well, I rebase so that changes are logical rather than historical. This is because when people read the commit history, which actually happens regularly, they would actually like a complete story, not 15 commits of ""fix audit"", ""fix review"" and ""fix typo"" - let alone refactors where previous work in the PR is thrown out, which you can by definition never care about.Commits so small that they're nonfunctional also break bisect."	FeepingCreature	8.574892	-6.5643654	comment	3.0	16.0	1601898378	-11.918915
24686971	"What do you use your ""cleaner histor"	"What do you use your ""cleaner history"" for? I seldom go back and look at historical commits unless I'm debugging, in which case I'd prefer to know what actually happened at the time with as much information preserved as possible."	m12k	8.578196	-6.5446672	comment	3.0	14.0	1601899906	-11.8943205
24687033	When you have to find a subtle one l	When you have to find a subtle one line breakage that happened years ago, you’ll be happy that you had a single commit with 30 lines of code instead of a squashed commit with 3000. It makes it much easier to isolate the case of a problem and fix it in many cases.I’m asked “how long has this been broken and what caused it?” and answer it via git blame or bisect probably every few weeks. This is life on legacy projects.	grumple	8.588384	-6.526152	comment	3.0	16.0	1601900438	-11.931581
24687123	My gripe with merge commits is they 	My gripe with merge commits is they don't integrate nicely with `git blame`. If I'm looking through historic commits (to understand why a change was made, or perhaps to debug an issue) I'll often `git blame` the line and diff that commit. If the commit is super granular, I can't get the context of the whole change: I need to dig for the merge commit then look at that, which is faff.If there's a way that I don't know to show merge commits in blame rather than the actual source change commit, then I'd be all over it. Until then, single (whole) units of change per commit.	CrunchyTaco	8.579114	-6.5362163	comment	3.0	10.0	1601901205	-11.954822
24687332	`squash` is a tool and it's neither 	"`squash` is a tool and it's neither good nor bad; it needs to be applied where it makes sense.  
The title is indeed click-baity. It would have been more interesting to read that the bug/mistake was caused as a result of squashing. It's not the case and I take issue with the way the author describes his commits.The problematic commit is described ""Extract CreateTokenValidationParameters method"", without an explanation of why the refactoring is necessary or what problem is it solving. It looks like it is improving code readability, but it doesn't go as far as fixing the more glaring issue with global variables. Other commit messages seem to follow the same pattern.In other words, the commit:- has minor code readability improvements- contains no useful message for the future programmer (why "	plextoria	8.574521	-6.560973	comment	3.0	18.0	1601902751	-11.903474
24688776	Same here, I especially love `git re	Same here, I especially love `git rebase -i <base>` it opens an editor and I have an option to edit specific commits, reword the commit, squash multiple commits together (don't use this one often) or do fixup (which basically merges commit to the previous one)	takeda	8.580083	-6.551612	comment	3.0	12.0	1601912785	-11.932236
24688869	If you work on a very large projects	If you work on a very large projects with many released version and need to cherry-pick fixes to back-port, you'd be very, very, VERY glad that each branch got squashed.The story told in the article mainly shows to keep your PR focused. You can squash as long as you don't do 2-week-long 37-commits branches.	pierrebai	8.574068	-6.562601	comment	3.0	11.0	1601913306	-11.938203
24689193	>I've always disliked Git's squash f	>I've always disliked Git's squash feature, and here's one of the many reasons to dislike it. Had this happened in a code base with a 'nice history' (as the squash proponents like to present it), that small commit would have been bundled with various other commits.This question always boils down to this metric. Which happen more often...1. A circumstance arises where the dynamics of fine grained commits make the problem more obvious.2. I have to interact with the git historyNow(and this is just me) I interact with the git history for one reason or another multiple times a day every day. I have been using git for 10+ years and I haven't yet encountered the first circumstance yet. Its not to say I won't encounter that circumstance and when I do I'll probably pine for the fine grained commits	SassyGrapefruit	8.565707	-6.5701585	comment	3.0	14.0	1601915184	-11.956378
24688807	I wish more people would naturally c	I wish more people would naturally come to this conclusion in their careers, but many people I have worked with just don’t care about maturing their git disciplines. All it takes is one teammate who thinks it’s a waste of time to undo the progress of everyone else.For context, my career has been in web development start ups, which generally reward the cavalier and tolerate the careful.	corytheboyd	8.541458	-6.483419	comment	3.0	11.0	1601912939	-11.927233
24720311	> You have to figure out with every 	> You have to figure out with every commit what actually changed and based on that change what needs to be tested and built.I feel this problem and I wonder, is there any ready-made solution for that?	methyl	8.631088	-6.5431957	comment	3.0	10.0	1602172419	-11.870887
24733978	Git is a database. It's designed for	Git is a database. It's designed for storing the changes made to files over time.But hey, if there's a different kind of database that you think would be better here, I'd be fascinated to see it. Just make sure that it can1. handle major structural changes to the files being tracked (e.g. JSON schema revisions)2. store and retrieve these changes as efficiently as git3. do the above with as little work required by the userGood luck!	yoz	8.588644	-6.477347	comment	3.0	13.0	1602274655	-11.872941
38666626	> ...I go back in git history to whe	"> ...I go back in git history to when the config was introduced to understand why it was done the way it was, in case I am missing something. I call this ""paying the Chesterton Tax.Maintaining code I wrote 15-20 years ago I find myself doing this with my own commits. I have to get back into the mental place I was when I wrote the original code and then it usually becomes clear if it was an expedient hack or a thought-out solution for a corner case.The worst feeling is ""cleaning up"" some code, discovering the edge case under which the ""simple"" case fails, then re-implementing the same solution."	EvanAnderson	8.557034	-6.501192	comment	3.0	12.0	1702751993	-11.929049
38764615	Don’t forget a bunch of useful git a	Don’t forget a bunch of useful git aliasesalias gcm=git commit -malias gaugcm = git add -u && gcm	jerpint	8.566135	-6.4964867	comment	3.0	17.0	1703527240	-11.870258
38771097	CPython seems to use squash merges, 	CPython seems to use squash merges, which means only one commit will end up on the main branch after merging this PR. The history on branches is irrelevant and can be completely messy, full of merges and other experiments; the main branch has one commit per actual feature/change.And eh, conventional commits seem like pointless bureaucracy to me.	Kwpolska	8.574507	-6.5524344	comment	3.0	24.0	1703592479	-11.872662
38772366	I question the value of commit messa	I question the value of commit messages at all.  Sure, at some level you need a summary of what a change is trying to do, but we have that at 5 levels now and they are completely redundant.  Generally there is a ticket in some system for tracking changes, whether it's Jira or Github itself or some other system.  Then you have a PR/MR that is attached to a branch which you are trying to have merged.  Then there are the commit messages themselves.  These are all completely redundant to each other, and nobody in their right mind should want all of these at the same time.  It's too many places to look for the same exact information, there's no reason to maintain it in more than one place.Some truly awful standard for formatting commit messages, how to do something that has at best dubious valu	ltbarcly3	8.583831	-6.534195	comment	3.0	11.0	1703603458	-11.903485
38809652	Realistically, how much does merging	"Realistically, how much does merging vs rebasing actually matter - do you save days of time over the year, or just a few minutes cumulatively because the commit graph is prettier?I understand that it makes the history ""cleaner,"" but how frequently do you end up bisecting manually searching the repo's commit history?Even on large projects with dozens of feature branches that eventually make it through a dev / main / prod branch, I've never had a problem when merge was the default rule. But maybe we never hit an otherwise common problem."	StableAlkyne	8.580643	-6.554051	comment	3.0	12.0	1703880810	-11.896999
38810501	> It's insane that everyone is re-wr	> It's insane that everyone is re-writing their development history to avoid issues with their source control systempeople rewrite their history because theyre irresponsible with pushes. it's got nothing to do with the source control system.  You're supposed to push small isolated encapsulated commits with a good names. I never do that while developing. I would have the same problem on any VCS> And squashing should never be preferred by anyone if the tooling was actually any good. For PRs? You should be able to define a group of commits and look at it as a whole, not just operate on a single commit. For clutter?once again responsible commits are supposed to be small, isolated, single change commits. so in a large feature a good developer would have tons of commits this makes the PR easier 	hasty_pudding	8.578121	-6.540057	comment	3.0	10.0	1703885846	-11.920046
38812038	Does anyone know how to realize vers	Does anyone know how to realize versioned articles with Hugo? The visitors of an article should be able to see different edits and diff them. (this has nothing to do with git)	sureglymop	8.6125965	-6.486924	comment	3.0	11.0	1703899108	-11.8844385
38821021	Martin, small commits interrupt flow	Martin, small commits interrupt flow, contain intermediary trains of thought that aren’t relevant, and decompose the entirety of the feature in to unrecognizable pieces removing all wholistic meaning.Stop doing it.	aantix	8.581734	-6.524577	comment	3.0	10.0	1703986629	-11.901948
38832263	I do it almost daily too. What _is_ 	I do it almost daily too. What _is_ rare, is finding a commit message that tells me anything useful that I couldn't have derived from the diff also. I don't need your life story, but sometimes some context about why something was needed is great.	sverhagen	8.580373	-6.530777	comment	3.0	11.0	1704121819	-11.924467
38832488	I personally prefer conventional com	"I personally prefer conventional commits.https://www.conventionalcommits.org/en/v1.0.0/The subject line says what the purpose of the change is (CI/CD, tests, bug fix, new feauture), what component it primarily focuses on, and then a plain text one line summary.For example:    ci(GitLab): Add rust build directory to cache
    
    This should improve build times by caching most of the compile tree between builds. In testing, I’ve observed builds drop from 2m to 30s when scheduled on a node with a primed cache.

It also forces me to keep my commits focused. If I can’t create a one line summary of what I’ve done, it probably needs to be broken up into multiple commits."	r3trohack3r	8.59113	-6.519046	comment	3.0	13.0	1704123353	-11.897464
38835160	Why do people like Mercurial branche	Why do people like Mercurial branches? Was it revamped? I hate it when I used it.By all means, I prefer Git branches.	aeurielesn	8.514866	-6.549896	comment	3.0	16.0	1704141765	-11.933694
38844350	A git branch is a pointer. It can po	A git branch is a pointer. It can point at whatever.This shouldn't be confusing, but it is because that's not a natural way to think about revision control, so we instead have to relitigate it all the time for people that haven't learned git's obtuse naming conventions.	Espressosaurus	8.560253	-6.5476313	comment	3.0	35.0	1704216974	-11.893806
38844739	> It seems like the natural way to m	> It seems like the natural way to me. What do you think the natural way is?A branch is a DAG of commits terminating at one commit.They should have just called it a pointer if it's a pointer. But here we are anyway.	Espressosaurus	8.57206	-6.550668	comment	3.0	18.0	1704218754	-11.893081
38844784	That’s not right. A branch is a sing	That’s not right. A branch is a single pointer to a single commit. Just open your .git folder. It’s then Git itself that follows that commit’s pointer to its parent(s).The branch, like the tag, is a single reference to a commit.Do this:    $ cat .git/refs/heads/main	lakpan	8.573725	-6.547867	comment	3.0	11.0	1704218983	-11.902188
38844998	Git is a distributed system, meaning	"Git is a distributed system, meaning that you're supposed to have different histories.Git gives you the tools to allow any member of the team to reconcile those histories cleanly for others.Forcing everyone to be in sync all the time also means lots of merge conflicts.Git allows for everyone to drift in their own way and provides tools for them to reconcile that drift in a way that others can integrate easily.Until you embrace the distributed nature and start using tools to manage your history (rebase & reset) , you will suffer with git.I cringe when editors refer to ""rebase & reset"" as ""weird"".Rebase and reset are the primary power tools of git. Along with reflog, revert, interactive-add .The worst repositories I've seen are people who `git merge` 20x a day to stay ""in sync"" and create la"	tonymet	8.573836	-6.5413947	comment	3.0	23.0	1704219904	-11.919907
38888689	Yes.It depends what you're doing. Mo	"Yes.It depends what you're doing. Most of the basic commands, they're snapshots. When you get into things like rebase especially, you have to think in terms of diffs.I'm not sure what ""histories"" are, as a distinct thing from snapshots, kind of seems like the same thing."	kadoban	8.656519	-6.5556602	comment	3.0	10.0	1704518634	-11.730232
38889099	Even the fact that it's snapshots (b	"Even the fact that it's snapshots (but possibly compressed) is an implementation detail.  I actually really like the generalized ""smallest/fastest/simplest way to create new file from old file"" explanation.  ""Fastest"" was a primary goal of git.  Same with Mercurial.  Other distributed revision control tools that were designed around the same time (bzr, darcs) didn't optimize for speed and you could tell."	krupan	8.589182	-6.5065565	comment	3.0	18.0	1704523785	-11.908962
38889216	Well-said, although I disagree that 	"Well-said, although I disagree that it's ""muddled"".The data model is that commits are snapshots, and diffs between snapshots are computed as needed. The whole system is designed around this.Packing is an implementation detail.The fact that internally it can store snapshots as diffs is more or less unrelated to the user-facing diffs. IMO it's confusing to even mention it in an educational context, except in response to the question of ""how does Git prevent repo size from exploding?""."	nerdponx	8.604327	-6.5204854	comment	3.0	14.0	1704525114	10.28125
38889338	> I actually really like the general	"> I actually really like the generalized ""smallest/fastest/simplest way to create new file from old file"" explanation.You might like that explanation because it fits a mental model you may have acquired previously, but at the user interface level, Git stores snapshots. It's not an implementation detail, it's what the entire command line is based on."	codeflo	8.582113	-6.521045	comment	3.0	14.0	1704526498	10.286641
38889628	> the merged commit can actually be 	"> the merged commit can actually be literally anythingThat cannot be stressed enough. Years ago a searched for a weird bug and could not find it. Of course I did not look at merge conflicts because ""they don't really introduce anything new"". But it turned out that a merge commit had introduced an arbitrary line, not related to its parents.Also the opposite is true: You can make a conflict free merge of two correct parents and the result is broken code. It does not seem to happen very often in real life, but it's a risk one should be aware of.I wonder how many merge commits there are in the Linux source tree that introduce something new by conflict resolution or break something existing without conflict resolution involved.At work we are a small enough organization that we don't really merg"	usr1106	8.610226	-6.537417	comment	3.0	16.0	1704529526	-11.903303
38889695	> GITJust out of curiosity: What do 	> GITJust out of curiosity: What do you think GIT stands for?	msla	8.551852	-6.4658623	comment	3.0	11.0	1704530377	-11.863856
38889100	The exact way in which git handles c	The exact way in which git handles commits is very muddied - it's snapshots on the surface, a bit of diffs when packed and a lot of operations on commits are actually 3-way merges (including merges, rebases, cherrypicks and reverts). Keeping track of all these matter (esp the operations that use diffs), but it can also get overwhelming for a tool.In my opinion, it's probably good enough to understand the model git is trying to emulate. Commits are stored more or less like snapshot copies of the working tree directory with commit information attached. The fact that there is de-duplication and packing behind the scenes is more a matter of trying to increase storage efficiency than of any practical difference from the directory snapshot model. Meanwhile, the more complex git operations (merge	goku12	8.587559	-6.529721	comment	3.0	21.0	1704523823	10.271345
38889202	If we don't care about implementatio	If we don't care about implementation details then isn't it mathematically equivalent to say that a commit is a diff or a snapshot?Each commit knows its parent. So from the diff you can calculate the snapshot, and from the snapshot you can calculate the diff.	OscarCunningham	8.589367	-6.5516515	comment	3.0	11.0	1704524936	-11.53163
31793208	That's the entirety of git.  Extreme	That's the entirety of git.  Extremely fast. Bummer UI.  It's status quo and no changing.  Despite using git for 10+ years, I frequently have to look up commands and then I end up scratching my head as to why the CLI UI is like that.	42e6e8c8-f7b8-4	8.5684185	-6.474342	comment	3.0	65.0	1655582053	-11.850226
31793773	Solo devs maybe. Merging and branchi	Solo devs maybe. Merging and branching are so much worse in svn that it’s not good enough for “most developers”, aka those working on professional projects with a team of developers. Sure we used to make do with svn, but I have no desire to go back.	dalyons	8.615728	-6.5329127	comment	3.0	20.0	1655585976	-11.888651
31815258	I still don't understand how git won	"I still don't understand how git won the source control battle so decisively. I respect git for what it's good at and its power, but from what I've observed it's far from clearly being the obvious choice of source control for closed source software shops. 
JIRA I can take or leave, it does the job - it's hard to imagine anyone being driven to hate it, but I can believe having it badly configured would be a serious drain on productivity."	wizofaus	8.544148	-6.455337	comment	3.0	13.0	1655756047	-11.881828
31852554	> Adding my own 0.02, what some of u	> Adding my own 0.02, what some of us are facing is resistance to adopting git in our or client organizations because of the presence of SHA-1. There are organizations where SHA-1 is blanket banned across the board - regardless of its use. [...] Getting around this blanket ban is a serious amount of work and I have very recently seen customers move to older much less functional (or useful) VCS platforms just because of SHA-1.Seems like this company could just use the current SHA-256 support then? Especially if it's the type of company that does all its development in-house and there's no need for SHA-1 interoperability.	armada651	8.690527	-6.5322127	comment	3.0	14.0	1656005921	-5.5534015
31852641	Almost feels like by the time git fi	Almost feels like by the time git finally transitions to SHA-256 some bitcoin miner somewhere will have a solved preimage weakness on SHA-256.	WorldMaker	8.680996	-6.5176578	comment	3.0	12.0	1656006297	7.18919
31852797	It's frankly amateurish for the git 	It's frankly amateurish for the git dev to delay this. The longer this lasts, the more painful it'll be whenever the switch will finally take place.Linus shouldn't have used SHA-1 in the first place, it was already being deprecated by the time git got its original release. Then every time a new milestone is reached to break SHA-1 we see the same rationalization about how it's not a big deal and it's not a direct threat to git and blablabla.It'll keep not mattering until it matters and the longer their wait the more churn it'll create. Let's rip the bandaid that's been hanging there for over 15 years now.	simias	8.68019	-6.499166	comment	3.0	17.0	1656006957	7.146143
31852882	> Linus shouldn't have used SHA-1 in	> Linus shouldn't have used SHA-1 in the first place, it was already being deprecated by the time git got its original release.Using SHA-1 to begin with was fine. However, commit hashes should have been prepended with a version byte to make it easier to transition to the next hash algorithm.This would mean an old Git client could report an error to the user of the nature “please upgrade your software to support cloning from this Git server” instead of failing with an error that’s inseparable from “the Git server is broken” when trying to clone a Git repo using SHA-256.	runeks	8.682291	-6.5013022	comment	3.0	12.0	1656007305	7.142172
31855778	I'm the person and Git developer (Æv	"I'm the person and Git developer (Ævar) quoted in the article. I didn't expect this to end up on LWN. I'm happy to answer any questions here that people might have.I don't think the LWN article can be said to take anything out of context. But I think it's worth empathizing that this is a thread on the Git ML in response to a user who's asking if Git/SHA-256 is something ""that users should start changing over to[?]"".I stand by the comments that I think the current state of Git is that we shouldn't be recommending to users that they use SHA-256 repositories without explaining some major caveats, mainly to do with third party software support, particularly the lack of support from the big online ""forges"".But I don't think there's any disagreement in the Git development community (and certainl"	avar	8.670309	-6.514945	comment	3.0	23.0	1656022598	7.1940637
31855955	> Git-like version control requires 	"> Git-like version control requires a Merkle DAG.This is false, you are conflating the abstract algorithm with a narrow implementation. That's like saying the only possible sorting algorithm is quicksort.With all due respect, you seem to be only loosely familiar with database architecture, both theory and historical practice. Nothing you've described is actually novel. That you are unfamiliar with why no one builds things this way, despite many attempts, does not lend confidence.I am actually a big fan of people trying unorthodox approaches to databases that have never been tried before, this just isn't such an example. Which doesn't make your approach wrong per se, but it leaves you exposed to learning why other people tried and abandoned it.Tangentially, the ""prolly tree"" is intrinsicall"	jandrewrogers	8.611698	-6.475258	comment	3.0	13.0	1656023899	-6.942614
31875169	Mercurial is built on what is almost	Mercurial is built on what is almost the same model and has what I think is a better UI/UX. Some people say that git is technically superior but you really need to be an advanced user for it to matter, or work on a really large project.At work, we switched from SVN to Mercurial, and from Mercurial to Git. Most people were happy to switch away from SVN, but few enjoyed the change from Mercurial to Git. Personally, it took me much longer to get used to Git than with Mercurial, even though Mercurial was my first DVCS. I now have a slight preference for git, but I am happy with either (just don't bring back SVN!).Why Git came to dominate and not Mercurial? I am not sure, but I don't think technical reasons explain everything. Its association with Linux probably helped a lot.	GuB-42	8.528308	-6.539223	comment	3.0	11.0	1656163883	-11.935839
31875528	Good modern software always offers a	"Good modern software always offers an undo option. Where is ""git undo""?"	amelius	8.581187	-6.532936	comment	3.0	16.0	1656166978	-11.880823
31875828	I've had the exact opposite experien	I've had the exact opposite experience. I've had to bail out cli purists because they just can't see what went wrong.Objectively git kraken has more visual information density. To get the same information on the cli requires multiple commands and the user has to hold the information I'm their head between the commands.Git kraken's buttons are also tightly correlated to commands and you can even bring up a window that shows what cli commands are being run under the hood.	jgoodhcg	8.581009	-6.493754	comment	3.0	10.0	1656169171	-11.855625
31924443	> But if I were going to tell everyo	> But if I were going to tell everyone just one more thing, it would be:> It is very hard to permanently lose work.Unfortunately, this is not quite true.  Git checkout will silently and irretrievably clobber all the changes in your working tree [UPDATE: if you do 'git checkout [path]', but that is not an uncommon thing to do.]It is true that it is very hard to lose work that you have committed.  But even this is not necessarily a good thing if, for example, you accidentally committed something that contains sensitive information that you want to delete.  (And God help you if you have pushed such a change upstream.)The sad fact of the matter is that while the underlying data structures are beautiful and tremendously useful, the UI/UX is a dumpster fire.It's actually not that hard to put a d	lisper	8.56436	-6.5138326	comment	3.0	38.0	1656529824	-11.906353
31925301	> My question is why hasn't anyone c	"> My question is why hasn't anyone come along and fixed it? Git has the plumbing vs. porcelain separation.Dozens have, but by the time their replacement porcelain gets anywhere near useful they’ve attained a grasp of the plumbing more than good enough they don’t need it anymore.> My second question is, if the underlying model is so f*cking elegant, how did it lead to such a confusing interface?Mastery of structural elegance doesn’t mean you have also mastered interface and experience. In fact it’s often not the case.> I can't offhand think of another piece of software where ""the model is elegant but the interface is confusing"" is such a common critique.Every database. The relational model is a beautiful thing, sql is a horrendous shit-show."	masklinn	8.550932	-6.515489	comment	3.0	10.0	1656534329	-11.912211
31926277	Never `git checkout -f` or `git rese	Never `git checkout -f` or `git reset --hard` unless you know you want to throw away extant changes from the workspace.That's it.  Know that, live that, and you'll never lose work because of Git.	cryptonector	8.557999	-6.5316834	comment	3.0	16.0	1656540428	-11.909149
31926446	But what’s the precise rule defining	But what’s the precise rule defining what constitutes the commits of a branch, after you reach a merge point? Does the branch end there? If not, which parent of the merge does it go? It’s not clear a priori.	layer8	8.585251	-6.54949	comment	3.0	10.0	1656541598	-11.911505
31926656	I have a healthy suspicion of the pe	I have a healthy suspicion of the performance of file-watchers. I hope this feature doesn’t make Git faster at the expense of “all filesystem operations crawl”.	saagarjha	8.594322	-6.446832	comment	3.0	13.0	1656543021	13.695206
31934205	I don't think it's fair to frame thi	"I don't think it's fair to frame this as specific to GitHub, or even as a thing to wring hands over.New devs - especially those coming from bootcamps (I say this without judgement) - mostly start with practical skills. Industry-standard ways to just get things done. That's how you get a job, that's how you get off the ground. This goes beyond source-control; languages/frameworks, tooling, etc. You enter the territory - with your finite bandwidth for learning - where it's most immediately useful. And then over the years you move out from there, incorporating more and more nuance and detail and auxiliary knowledge.There's no need for moral panic. ""Where it's most useful to start"" has shifted, sure. But that's natural; I don't think it's a new phenomenon or in a fundamentally worse place than"	brundolf	8.526327	-6.449248	comment	3.0	33.0	1656604093	-11.814944
31935105	Would love to see Fossil get wider a	Would love to see Fossil get wider adoption:https://www.fossil-scm.org/Single 6mb executable with a version control system, web server, bug database, forums, import/export/sync with git, repo browser, much saner CLI than git, etc. Been using it for 2+ years for all my projects and love it.	QuadrupleA	8.51388	-6.492165	comment	3.0	14.0	1656607276	-11.935787
31965831	> CI is a post-commit workflow. How 	"> CI is a post-commit workflow. How often have you or a coworker pushed an empty commit to ""re-trigger"" the CI?Build can be triggered manually in every CI system I know. Why would I push empty commits?"	Scea91	8.711741	-6.4946723	comment	3.0	10.0	1656833390	-11.918994
31967079	The TBD [0] crowd disagrees with you	The TBD [0] crowd disagrees with you.I agree with you though.Not that I don't see the value proposed by TBD, but I think you can have >90% of said value and none of the downsides using a well thought out branching strategy.[0] Trunk-Based Development: https://trunkbaseddevelopment.com/	cassianoleal	8.613322	-6.5338273	comment	3.0	10.0	1656849849	-11.871126
31968132	Agreed, but for instance, I am worki	Agreed, but for instance, I am working on a project hosted on AWS where the trigger build action is not allowed for my user. Empty commit is my only option.	gusbremm	8.596573	-6.4986424	comment	3.0	19.0	1656859906	10.562327
31968141	on the front page right now:- a git 	"on the front page right now:- a git explainer centered around git internals, serving as an indictment of git's ux- a parser for a restricted subset of yaml, serving as an indictment of yaml's excesseson the front page yesterday:- an rsync explainer centered around rsync internals, where part 1 details how rsync is wrapped in a dockerfile and a perl script in order to be made useful- a sad thinkpiece on how baroque the web has becomeon the front page the day before:- a go utility weighing in at tens of source files that implements what should be a built-in feature of AWS- an article on encapsulation in rust, the buried lede of which is ""you must audit your transitive dependency graph in order to retain the benefits of rust""why do so many technologies feel like self-harm?"	0x69420	8.596792	-6.5275464	comment	3.0	11.0	1656859948	-11.910843
31968521	It's a recurring and perhaps inevita	It's a recurring and perhaps inevitable problem. We've collectively been building software for a long time but any given individual hasn't. No-one has seen all the good ideas that have gone before and sometimes been forgotten. Everyone is influenced to some degree by whatever ideas are currently popular within their group.We developed distributed VCSes and the ability to do smart things with branches and combining contributions from people all over the world at different times. Then we somehow still ended up with centralised processes where everyone has to merge to trunk frequently and if GitHub goes down then the world stops turning. It turns out that just using git as git wasn't such a bad idea after all.We were told that dynamic languages like JS and Python are so much more productive a	Silhouette	8.57476	-6.4456267	comment	3.0	12.0	1656862849	-11.811654
31978714	Don't forget Master -> Main for git.	Don't forget Master -> Main for git.	fastball	8.529319	-6.5212355	comment	3.0	13.0	1656951478	-11.757987
31984859	  > And do you seriously not see the	"  > And do you seriously not see the need of rebasing?

Git user for a decade. I never rebase, not professionally and not in my personal projects. I merge the work of other devs, no matter how ugly their history.I don't see any real problem that rebase solves, but I do see that it mangles history and makes troubleshooting e.g. git bisect much more difficult."	dotancohen	8.56909	-6.569383	comment	3.0	16.0	1657000966	-11.918599
31985812	Are you really sure that is the case	Are you really sure that is the case here? I think everyone that starts working with git is a bit hung up by its complexity at least for a year, if not more.It seems to me that, as it should be, every professional SW dev has managed to work with git at some point in their life, then. Because git is simply what you will most likely use nowadays.But still, everyone remembers how hard it was to start out. Which is why, I think, these blog posts about git are so popular all the time.	troppl	8.538746	-6.480713	comment	3.0	10.0	1657010080	-11.901134
31986038	> I see people on here complaining a	> I see people on here complaining about cargo-culting from the cool kids (k8s, spotify's team structures, etc., ect.), but I see git as exactly the same.The big advantage of git is github and co, not git itself. By switching and using mercurial you lose all of the advantages of github too.	maccard	8.519786	-6.53061	comment	3.0	14.0	1657012208	-11.933397
31984801	With only push, pull and branch, how	With only push, pull and branch, how do you refer to an old version? Hence commits, or something like it, are needed.And do you seriously not see the need of rebasing?Furthermore, you seem to mistake git's distributed nature for some sort of backup scheme. That's not the case. The idea that every repo is equal is tremendously useful.	gspr	8.56966	-6.5465794	comment	3.0	23.0	1657000433	-11.917581
31985157	I didn't recognize the author, but c	I didn't recognize the author, but came here to say the same thing: where are the ideas on how these improvements would be implemented?Without making an attempt at implementation, you (the generic you, not the person I'm replying to) have no idea what the real issues are. Even failed or partial implementations are more instructive than armchair criticisms, or thought experiments where you can just handwave away all the competing constraints that need to be considered, whether in Git or in any erstwhile successor.	enasterosophes	8.5787	-6.472915	comment	3.0	10.0	1657003881	-11.905706
32001487	I checked and you're right: The endp	"I checked and you're right: The endpoint that returns the file list has a hardcoded set of excludes and pays no attention to `.gitattributes`.I think it's reasonable to respect the linguist overrides here so I'll open a PR to remove entries from the exclude if the repo has a `-linguist-generated` or `-linguist-vendored` gitattribute for that directory [1].  So in your case you can add  build/** -linguist-generated

to `.gitattributes` and once my PR lands files under `build` should be findable in file-finder.Thanks for pointing this out!  Feel free to DM me on twitter (@cbrasic) if you have more questions.[1] Recursively matching a directory with gitattributes requires the `/**` syntax unlike .gitignore: https://git-scm.com/docs/gitattributes#:~:text=with%20a%20fe..."	brasic	8.6522	-6.4801946	comment	3.0	10.0	1657117563	-11.846783
32024198	> unraveling mysteries of the commit	> unraveling mysteries of the commit messages that were written with this attitude https://github.com/nim-lang/Nim/pull/19211#issuecomment-9859...Curious to know what your vision of commit messages is. My commit messages look exactly like the excerpt in your linked issue: they describe what has been done.	dmos62	8.582732	-6.5284443	comment	3.0	12.0	1657267811	-11.907474
32045416	Was hoping for the same, so lets dis	Was hoping for the same, so lets discuss...Anyone have strong opinions about only allowing squash commits, vs allowing merge commits?Having used both professionally, I don't think the benefits of squash commits only outweigh the hurdles for new developers.  Merging is just easier, and I don't think the merge commits in master are really all that jarring?	rubicon33	8.575885	-6.561927	comment	3.0	12.0	1657465517	-11.943278
32078399	I use that all the time as a shortcu	I use that all the time as a shortcut to push new git branches without having to type the whole name.	SAI_Peregrinus	8.547161	-6.5085216	comment	3.0	10.0	1657679451	-11.816736
32153647	Trunk Merge	Trunk Merge	dapirian	8.69307	-6.4871864	story	3.0	14.0	1658246572	9.194298
32161764	"""It is really hard to lose stuff""Ind"	"""It is really hard to lose stuff""Indeed. This also means that garbage keeps piling up in git repos.This is how I make sure, I do lose stuff eventually:https://github.com/no-gravity/git-gc-all-repos.shA script that goes through all my repos and performs garbage collection."	mg	8.568095	-6.507107	comment	3.0	10.0	1658294628	-11.891489
32163414	The quote is kinda wrong in that poi	"The quote is kinda wrong in that point 1 and 2 are mixed up. Branches are just pointers to commits. Commits contain a reference to their history.
It's only kind of incorrect because in praxis branches are used to refer to a history (a sequence of commits). But it's also misleading once you have to do anything more complicated than just commiting/merging.When I started out using git I was working with the same assumptions, but I was perpetually confused. Git became a lot easier to use once that misunderstanding cleared up.Maybe it's just like that for me but I think we might be doing newcomers to git a disservice by explaining the basics of git in this simplified manner."	eulenteufel	8.564037	-6.5419917	comment	3.0	22.0	1658310211	-11.903982
32162918	"I love this quote from Part I:""Git h"	"I love this quote from Part I:""Git has an elegant and powerful underlying model based on a few simple concepts:  1. Commits are immutable snapshots of the repository
  2. Branches are named sequences of commits
  3. Every object has a unique ID, derived from its content


Built atop this elegant system is a flaming trash pile. """	praptak	8.556665	-6.5533104	comment	3.0	29.0	1658305234	10.271906
32165973	"What's `git gui`?    $ git gui
    g"	"What's `git gui`?    $ git gui
    git: 'gui' is not a git command. See 'git --help'.

    The most similar commands are
      ci
      gc
      grep
      init
      lg80
      pull
      push"	cassianoleal	8.594175	-6.483911	comment	3.0	12.0	1658325916	-11.857399
32190820	I use git daily and it works, but ma	I use git daily and it works, but man did it take a long time until I got confident enough to not make a backup.tar.gz before some more complex operation. And I still hate the fact that there are N additional obscure ways to do each operation.Mercurial otoh was a joy to use, never surprised me - it just worked. I think github is the only reason git won. Ah well, water under the bridge...P.S.: hginit rules.	bornfreddy	8.53118	-6.4708595	comment	3.0	27.0	1658489400	-11.884285
32190906	That was not my experience at all.Co	"That was not my experience at all.Consider just the simple task of ""forget about the last commit I made."" Mercurial has like five different ways to do this (hg rollback, hg uncommit, hg strip, hg prune, hg histedit), which work in three totally different ways under the hood (obsolescence markers, backup bundles, or just YOLOing it in the case of Rollback), and which may change their behavior depending on whether you're using `evolve`. As a novice, it's not clear which you should be using (hint: use the evolve extension) or how to recover from mistakes.Git also has several ways to do it, but all operating on the same principles. Whether you `git reset` or `git branch -m`, or `echo $(git rev-parse $BRANCH~) > .git/refs/heads/$BRANCH`, you're just moving pointers around, and the reflog makes "	sio8ohPi	8.577111	-6.5680285	comment	3.0	12.0	1658490236	-11.930406
32191909	One thing I miss about Mercurial was	One thing I miss about Mercurial was only having to type enough of a subcommand to be unambiguous. `hg st` is much shorter than `git status`. I wish all CLI tools worked that way.	kej	8.501411	-6.529519	comment	3.0	10.0	1658498353	-11.946971
32195065	I disagree that the vast majority of	I disagree that the vast majority of commit messages are you describe. But even if that were the case, I don't think the majority of commit messages being bad would mean they don't matter.	michaelmior	8.571989	-6.5237727	comment	3.0	13.0	1658512676	-11.919917
32215166	I’m going to be a little crass for a	I’m going to be a little crass for a moment: people don’t know how to use their tools! Why are we even talking about “stacked PRs” and “branchless” workflows?! It’s clear the author is documenting their git learning process and that’s great, really. But I’m just surprised how pedantic people get about forcing others to use a tool in a way that caters to their own limited understanding of it. Or, even worse, caters to limitations in the 3rd party UI being used to interface with it (ye ol’ git vs GitHub problem). Learn your tool and then you can worry about the higher order things that are supported by it.	dcow	8.547558	-6.469726	comment	3.0	39.0	1658681131	-11.887633
32215397	> have to spent their days explainin	> have to spent their days explaining how GIT (yes, really...) works to a small army of juniors.I sympathize with the other comments explaining that Git is highly nontrivial, but I think the point is being missed. Why should I have to teach a junior how to use an essential tool of the job, when I can just point them to good books/guides on the Internet?My list would definitely include:Hire people who can and are willing to read. Be it for learning or for understanding specs.I'm not one of those people who gets upset at people coming to my cube to ask questions - I actually enjoy it (far more than them IM'ing me). But if it's something easy to find on the Internet, or clearly documented in a local wiki/manual, they should have at least tried to read it.Similarly, I'll take the time to docum	BeetleB	8.539831	-6.4893737	comment	3.0	21.0	1658682376	-11.900307
32216959	If you work at asynchronous/remote w	If you work at asynchronous/remote work company, i.e. your coworkers are in different timezones and can't review immediately, what else are you going to do? Put out exactly one code review per day until your feature is fully merged? Some things like refactoring changes can be reviewed and committed individually, but lots of feature work is fundamentally dependent on the previous work.Stacking PRs is like pipelining for CPUs. It's efficient under the hypothesis that there aren't too many invalidations/stalls. The linked tooling `git-branchless` (I'm the author) is aimed at reducing the impact of such an invalidation by significantly improving the conflict resolution workflows.	arxanas	8.586717	-6.5377965	comment	3.0	12.0	1658691992	-11.922278
32221842	Because many people are afraid of wh	Because many people are afraid of what is not familiar, that's it.It's not hostility, but a rather a case of shying away from reading the docs and changing the way they work.From my experience not everyone is conductive to try and adapt to new ways, and many people do not use git CLI or SSH. They just use GitHub's gh CLI command.	bayindirh	8.547879	-6.49142	comment	3.0	11.0	1658737706	-11.897137
32296880	Squash, Merge, or Rebase?	Squash, Merge, or Rebase?	kiyanwang	8.578509	-6.57431	story	3.0	19.0	1659286649	-11.9610195
32303841	Ask HN: How could you effectively co	Ask HN: How could you effectively collaborate with non-vcs users?	hirsutehippo	8.592326	-6.4632187	story	3.0	4.0	1659347473	-11.826683
32315499	I’d do a git commit —amend instead o	I’d do a git commit —amend instead of a rebase to keep the number of commits to 1	gigatexal	8.577255	-6.553829	comment	3.0	13.0	1659418894	-11.908469
32321954	This repo's commit messages are not 	"This repo's commit messages are not good:""A few more minor tweaks.""""A few more minor changes.""""Some extra file-list safety checks.""https://github.com/WayneD/rsync/commits/masterThose are the full commit messages. By way of comparison, here's what commit messages to git itself look like:https://github.com/git/git/commit/198551ca54f6ff1c95c9357ccc...https://github.com/git/git/commit/dee8a1455c8ad443ef59e0d5b7...Each commit contains paragraphs of explanatory material. Jeff King's commit messages are ""gold standards"" to me, often well exceeding the size of the diff itself:<a href=""https://github.com/git/git/commit/aa0834"	js2	8.583701	-6.525055	comment	3.0	10.0	1659462232	-11.905044
32351617	Until one of your tools makes a back	Until one of your tools makes a backwards incompatible change, and then boom, your whole git history goes down the memory hole. You've got to vendor everything too. Since with a broken commit you can always have git slide back one commit. But it's much harder to spin up a Docker container with the same distro you were using for every part of the bisect.	jart	8.569795	-6.531897	comment	3.0	10.0	1659673334	-11.873015
32351845	Yeah but the other problem in pull r	Yeah but the other problem in pull requests is that if someone makes changes since the last time I reviewed and then they force push I can’t see the difference from the last time I reviewed. Also if they rebase and push multiple commits there’s no guarantee they would all pass CI which means you can’t guarantee it will work with bisecting.	alexrtan	8.586043	-6.5339947	comment	3.0	16.0	1659675145	-11.880613
32366973	As someone who makes lots of merge r	As someone who makes lots of merge requests, please don’t add the further statement. In my experience while it’s well intentioned, it (understandably) frustrates contributors because it’s making an assumption that they aren’t valuing your time, which you don’t know.Just my 2¢, at the end of the day do what feels best for you, but you may drive away some contributors.	kkirsche	8.704474	-6.439121	comment	3.0	10.0	1659783939	-11.785918
32370863	First of all, I'm long time going gi	"First of all, I'm long time going git n00b (still mainly p4, and g4 for a bit user), but welcome any hints to easy going with git (have to use it occassionally).Saw this though for switch/restore:""THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE."""	malkia	8.5566225	-6.526863	comment	3.0	25.0	1659814272	-11.8987255
32371487	I don't know what it is called, but 	"I don't know what it is called, but it forces what comes after to be interpreted as a filepath.This is not git specific, but a common convention for CLI tools. Try running:    > touch -- -i foo
    > rm -- -i foo

And compare what happens without the ""--""."	gizmo686	8.657002	-6.4757085	comment	3.0	12.0	1659819036	-11.812567
32377353	Oh that’s super annoying. We use tha	Oh that’s super annoying. We use that to draw attention to important things that changed in certain commits, for instance we attach human readable diffs to lock file change commits.Beyond that sometimes it’s super helpful to add comments as a human directly to a commit noting details about that specific  change set that don’t make sense in the commit itself.This is one of the most boneheaded moves I have seen GitHub make.	donatj	8.579589	-6.4879427	comment	3.0	24.0	1659887247	-11.890818
32386990	If you build an image for testing on	If you build an image for testing on every commit and don't have a retention policy set up, you could be using a massive amount of space without realizing it. I can see why they did this.	game-of-throws	8.607196	-6.508869	comment	3.0	14.0	1659973685	9.064579
32388782	Git excels at tracking human keyboar	"Git excels at tracking human keyboard output.  A productive developer might write 100KB of code annually so a git repo can represent many developer years of collaborative effort in just a few MB.  That is, unless you require git to track large media files, third party BLOBs, or build output.However, sometimes tracking these things are necessary, and since there isn't an obvious companion technology to git for caching large media assets (""blob hub?"") or tracking historical build output (""release hub?""), devs abuse git itself.I wish there were a widely accepted stack that would make it easy to keep the source in the source repo, and track the multi-gb blobs by reference."	elevation	8.575438	-6.457034	comment	3.0	10.0	1659981392	-11.876758
32423431	I hope this article is satire.Users 	I hope this article is satire.Users are absolutely right to be upset at Gitlab, Docker, etc. who pull a bait-and-switch on the community. Users adopt the product because of the infra foundation is free, and then comes the rug pull when the product reaches market saturation.This almost always happens right after a capital raise...	dudeinjapan	8.562348	-6.4693203	comment	3.0	14.0	1660210810	10.118183
22010971	There's nothing philosophical about 	There's nothing philosophical about it! There will exist a conflict as far as Git (or any other) version control system is concerned. That's all he saying!	xwowsersx	8.5706215	-6.4664793	comment	3.0	15.0	1578665287	-11.841142
22021598	From https://pijul.org/manual/why_pi	"From https://pijul.org/manual/why_pijul.html#patch-commutation:> In Git, importing just a few commits from another branch is called ""cherry-picking"", and involves changing the identity (the hash) of those commits. This usually works the first time. However, when done again, as the maintainer of a stable branch probably wants to do, this often causes counter-intuitive conflicts.If you're doing this in git to apply a fix to a master branch and multiple release branches, you're doing it wrong.  You should be basing the patches off the merge-base of master and the oldest release branch you wish to land the change into.If you work this way, you can merge the patch cleanly into all target branches, and this new patch becomes the new merge-base.  So you can actually continue to apply new patches "	frutiger	8.607821	-6.5594096	comment	3.0	33.0	1578768890	13.895693
22021715	> If you're doing this [..], you're 	"> If you're doing this [..], you're doing it wrong. [..]This is not 100% true (see my answer to the second part below), but the point of Pijul is that you don't need to ""do things right"" to avoid the potential problems of your version control system. In the end, a version control system is just a tool, not a way of life or a work methodology.Sure, there are example projects where the Git way is the best, but they are quite rare (one example is Software Heritage [1]).> If you work this way, you can merge the patch cleanly into all target branches, and this new patch becomes the new merge-base. So you can actually continue to apply new patches without any conflicts.This is not actually true, and is the whole point of Pijul.
In Git, your suggestion works only as long as (1) there is never any"	pmeunier	8.604853	-6.558217	comment	3.0	21.0	1578770141	13.897301
22035139	My team's code hasn't been able to r	"My team's code hasn't been able to run locally for at least 7 years. All development consists of committing changes to SVN trunk and running a Hudson build to update a shared dev server. We have hundreds of commits per day, mostly with unhelpful messages like ""up"".halp"	thescriptkiddie	8.586939	-6.465382	comment	3.0	11.0	1578928798	-11.883008
22080917	Are you sure about that?> This combi	Are you sure about that?> This combination speeds up the data transfer process since you don’t need every reachable Git object, and instead, can download only those you need to populate your cone of the working directoryIf you're only downloading what you need to populate the working directory how is it that `.git` will have the entire repository?	vlovich123	8.568346	-6.451062	comment	3.0	11.0	1579304760	-11.8814535
22132336	I stopped doing small commits. In th	"I stopped doing small commits. In the past as soon as I was ""done"" with something I would commit, even if one line.What would end up happening sometimes later in the day I would decide revert or modify the change, so my commit history ends up flooded with bunch of small commits.I ended up writing a script that checks my current work, and if enough changes or time has past, then a commit is recommended:https://github.com/stvpn/sunday/blob/master/git-train/git-bo..."	svnpenn	8.575488	-6.5277133	comment	3.0	11.0	1579814973	-11.9410515
22139014	5 Useful Tricks You Didn't Know for 	5 Useful Tricks You Didn't Know for Git	tonatiuh	8.552691	-6.4715962	story	3.0	17.0	1579879526	-11.90286
22192915	Why not just use github, gitlab or o	Why not just use github, gitlab or other VCS? Personally, I enjoy using Dropbox for music projects (which VCS are not well suited for), but for code...(I apologize if I sound as if I'm telling you what you should be doing; I am really just trying to understand the motivation behind such a decision - but I fully understand that even if something seems bizzare to me, it's just my personal humble uninformed opinion).	golergka	8.562819	-6.4467583	comment	3.0	10.0	1580403556	-11.849608
22210216	IMO the pursuit of, or even a concep	IMO the pursuit of, or even a concept of 'clean history' is a fallacy and waste of time. It is a level of obsession which I think is just not worth it. Furthermore, a commit log is not the same thing as release notes. More often than not you need release notes for a product to be constructed in a user centric manner, describing features or changes which affect them - and that actually comes from the original requirements lists and not the minute implementation details.IMO don't rebase, don't worry about 'clean' history. Obsessing over those is time consuming and risky. Just do your work and move on. Let your manager/lead deal with the external world.	wdfx	8.578259	-6.5440745	comment	3.0	12.0	1580561173	-11.902284
22221589	Yep, I wish GitHub made it easier to	Yep, I wish GitHub made it easier to do diffs between a specific commit and many other commits, like with a timeline. Would be great for visually tracking down when a change was introduced or how the code has evolved over time.That was an inspiration for a tool I built called Yestercode [1] (though it uses undo history, not version control).[1] http://web.eecs.utk.edu/~azh/pubs/Henley2016VLHCC_Yestercode...	azhenley	8.615929	-6.515091	comment	3.0	10.0	1580706825	-11.861843
22239672	> That cute rhetoric will not fool a	"> That cute rhetoric will not fool anyone.Well, let's see, the Fossil equivalents are:1. Do nothing at all for a conversion from the SHA-1 to SHA-3 — yes, 3, not 2 as in Git! — because it's automatic for months now and dead easy going back 3 years now. (https://www.fossil-scm.org/fossil/doc/trunk/www/hashpolicy.w...)2. ""fossil diff""3. ""fossil ci""4. Why are you rebasing in the first place, again? https://www.fossil-scm.org/fossil/doc/trunk/www/rebaseharm.m..."	wyoung2	8.52801	-6.558829	comment	3.0	28.0	1580843360	-11.933108
22240285	Articles like this are eye opening t	"Articles like this are eye opening to me, in a bad way. Every once in a while, I get really curious about giving Fossil a try, because it does have some legitimately cool ideas, and then I see the documentation saying things like:> Rebasing is the same as lyingAnd I think, ""Holy crud do I not want to be part of this community.""The nice thing about Git is that (within reason) once I understood it, I was able to use it in very flexible ways.It's really common for different projects I manage to range all over the place from the extreme ""commits as literal history"" perspective all the way to the ""commits as literature/guide"" perspective. Sometimes I don't rebase at all, sometimes I rebase a lot. Sometimes I commit everything, all the time, sometimes I refuse to commit any code that isn't a dep"	danShumway	8.54842	-6.54205	comment	3.0	16.0	1580846539	-11.945486
22239122	The way I read the fossil's authors 	The way I read the fossil's authors comments, old commits continue to use sha1 hashes. A repository will be vulnerable to sha1 collision attacks as long as there is an object in the repository that has not been hashed with the new algorithm.For example, floppy.c could be replaced in a repo with file with the same sha1 hash as long as the last commit that modifies floppy.c used a sha1 hash.Right?	seniorsassycat	8.655842	-6.5148873	comment	3.0	28.0	1580840946	7.245361
22298318	We have a checklist system. Dependin	We have a checklist system. Depending on which files are on your commit or which database objects are modified, you're presented with a checklist specific to the things you're changing. When something goes really wrong, the outcome of the post mortem often includes adding to or changing the checklist for the affected files/filetypes/team/whatever. It's not a perfect system, but it beats reading our long, confusing wiki pages.	Damorian	8.60549	-6.5348234	comment	3.0	10.0	1581428246	-11.857503
22301789	I'm curious why the decision to redr	I'm curious why the decision to redraw the entire tree when a node has been touched, rather than just that node or that branch?	elif	8.645403	-6.5571094	comment	3.0	12.0	1581449456	6.9633784
38955434	Just thinking aloud. Change-tracking	"Just thinking aloud. Change-tracking software like git works with ""patches"", that is, changes applied to a source file to produce the changed file. They are hardwired to work with text files like source code, with short lines, and with line-oriented changes.But nothing prevents such a system from working with arbitrary files, as long as there is a tool to create a ""patch"" or a ""diff"" (that is, a description of a change) and a tool that can apply such ""diff"". Git does have a mechanism to plug in both of these tools, depending on the file type.I have a very vague idea of what CAD files are internally, but I suppose they are some kind of a database, and they are not colossal (unlike e.g. video files or such). They certainly could use this mechanism to allow tools like git (or hg, or maybe eve"	nine_k	8.646309	-6.4804587	comment	3.0	14.0	1704993997	-11.798886
38968283	I hate the “sub command” model and c	I hate the “sub command” model and consider it user hostile.  Among other things it makes the shell’s ! commands harder to use.Instead of git add you should have git-add.  Few bother to get this right.	gumby	8.556171	-6.4950294	comment	3.0	17.0	1705069560	-11.902446
39054800	I think it’s simpler than we may thi	I think it’s simpler than we may think: don’t hire anyone who hasn’t pushed a git commit in a management position.Knowing code is the new knowing how to read and write, we should be less tolerant of “non-technical”, “in English, doc!” type people in positions of power in tech companies.	redrove	8.562587	-6.4515333	comment	3.0	13.0	1705668363	-11.909549
32597916	Can someone explain what we are look	"Can someone explain what we are looking at? Perhaps a simple point by point explanation of what was done, what the expected behavior is and what we observe instead?Do I understand correctly that these are the events that happened:* septicmk forked v6d-io/v6d to septicmk/v6d* septicmk created a pull request from septicmk/v6d:main to v6d-io/v6d:main* septicmk merged 
sighingnow's commit 61f3741 to septicmk/v6d:main (perhaps while updating their fork?)* GitHub says septicmk merged commit 61f3741 to septicmk/v6d:main?If so is that not right? They did merge a commit in their fork at septicmk/v6d:main, didn't they?Does GitHub say anywhere that they merged commit to v6d-io/v6d:main? That would be very interesting and a real issue!I agree the big ""Merged"" button on top of the pull request is very "	ctrlmeta	8.6073885	-6.45101	comment	3.0	15.0	1661451987	-11.8859005
32633649	Ask HN: Git repos add an arbitrary t	Ask HN: Git repos add an arbitrary time/change dimension to files?	solarmist	8.579819	-6.4896092	story	3.0	2.0	1661733521	-11.881205
32639009	>  It just stores the full content o	>  It just stores the full content of every file every time it’s modified and committed.That's not true; otherwise each git branch folder would be huge, but it's not. It stores the snapshot of changes in branch folders	mandeepj	8.589758	-6.4974337	comment	3.0	10.0	1661784726	-11.914031
32639334	This is a good mental model.  The in	This is a good mental model.  The internals are the internals.  But the model users see is that a repository is a bag of commits (deltas) that organize into a tree, with branches and tags being names for specific commits.  With this model in mind anyone can become a Git power user.	cryptonector	8.550788	-6.508775	comment	3.0	19.0	1661786445	-11.884252
39356481	A part of Git's complexity is due to	A part of Git's complexity is due to the fact that it was originally meant to be just the plumbing. It was expected that more user-friendly porcelain would be written on top of the git data model. Perhaps that is still the best bet at having a simple and consistent UI. Jujutsu and Got (game of trees) are possible examples.	goku12	8.550458	-6.498625	comment	3.0	32.0	1707821352	-11.921945
39357399	"I chuckled at the title - ""So You Th"	"I chuckled at the title - ""So You Think You Know Git"" - no, one does not think one knows git :-)"	foobarian	8.517681	-6.4882865	comment	3.0	10.0	1707831039	8.264838
39357531	I stopped pretending as if I know wh	"I stopped pretending as if I know what I am doing and instead use visual Git tools, such as SmartGit or the one that comes with IntelliJ. Being a Git ""command-line hero"" is for show offs.Porcelain can be just infuriatingly confusing. For example, ""Yours and Theirs"" can mean the opposite in different contexts. The whole user interface has no common style or theme - it needs a new ""visual"" layer in order to not drive one up the wall."	renegade-otter	8.5587015	-6.4973245	comment	3.0	10.0	1707831885	-11.889837
39357647	After watching your (very enjoyable)	After watching your (very enjoyable) talk in the other thread, schacon, one thing struck me - there _is_ a way to work on multiple branches at the same time: worktrees.What's the advantage of a tool like this over that?	ckolkey	8.595307	-6.528828	comment	3.0	18.0	1707832745	-11.899382
39357022	One thing about git I learned the ha	One thing about git I learned the hard way is the use of diffs and patches (more accurately, 3-way merges) for operations like merging, cherry picking and rebasing. Pro-git (correctly) emphasizes the snapshot storage model of git - it helps a lot in understanding many of its operations and quirks. But the snapshot model can cause confusion in the case of the aforementioned operations - especially rebasing.For example, I couldn't understand why the deletion/dropping of a commit during a rebase caused changes to all subsequent commits. After all, I only asked for a snapshot to be dropped. I didn't ask for the subsequent snapshots to be modified.Eventually, I figured out that it was operating on diffs, not snapshots (though storage was still exclusively based on snapshots). The correction on 	goku12	8.579804	-6.5600424	comment	3.0	13.0	1707827603	-11.912637
39357909	This seems like an incredibly poor i	"This seems like an incredibly poor idea to me. You now have the problems of rebase (your commits no longer represent a consistent repo snapshot), but even worse (your commits _never_ represented a consistent repo snapshot!).Is there a way to identify commits made by GitButler? Can I configure my host to reject them automatically?And the ""generate a commit message for me"" button really nails the kind of poor decisions that lead here."	Nullabillity	8.560863	-6.507176	comment	3.0	12.0	1707834536	-11.852956
39359288	It works fine. The only thing that i	It works fine. The only thing that is a problem is “branch” and “commit”, things that use the index. But that makes sense. If you have setup two virtual branches and then from the cli run “git commit”, which branch do we commit to?	schacon	8.565618	-6.52763	comment	3.0	11.0	1707841570	-11.911893
39358461	Edit: I now realize much (most?) of 	"Edit: I now realize much (most?) of this already exist as part of the temporarily hidden Timeline feature in GitButler: https://docs.gitbutler.com/features/timelineNow we just need automatic (possibly virtual[1]]) commits that get created whenever one does a refactoring or other wide, sweeping tool assisted changes and soon my skills as dev archeologist would either become less valuable (because everyone can see what happened[2]) or more valuable (because just like no one I know except me uses bisect no one will use this and it will simplify my job.)This is (in my opinion) a great idea for a paid IntelliJ/VS Code/etc plug in but I realize I won't have time to do it.[1]: ""virtual commits"" is just my marketing speak for adding extra metadata without polluting the branches we usually relate t"	eitland	8.577754	-6.53508	comment	3.0	11.0	1707838063	-11.909106
39369823	Notably, in these cases you usually 	"Notably, in these cases you usually only need to track down a last-known-good commit hash and any GitHub fork of the original project, and GitHub will happily let you view and fetch that commit even if it's not included in that particular fork. (People have called this a bug, but for this kind of code rescue it's more of an unintentional feature.)In this particular case, https://github.com/PySimpleGUI/PySimpleGUI/commit/ca37e593fe... (five commits newer than GGP’s reference, which has commit a0d3e7ce1f5b015962e9d538f94cd517a9a79692) seems to be the last FOSS revision before the maintainer deleted everything.  $ git clone https://github.com/PySimpleGUI/PySimpleGUI
  $ cd PySimpleGUI
  $ git fetch origin ca37e593fe07177f409639933392b4c2fa94f736
  $ git switch -c foss FETCH_HEAD"	mananaysiempre	8.653777	-6.462878	comment	3.0	11.0	1707919277	-11.850326
39403647	I care, because it introduced a ton 	I care, because it introduced a ton of unnecessary pain into my workflow. Yes really. I now have a mix of repos using `master` and `main`, and I have to remember which one to use.One repo uses `master` but a subtree uses `main`. If you make a mistake and checkout `main` you end up clobbering your whole working tree with the subtree.I also have tooling that used to happily assume `master`, which worked fine 99% of the time. Now it works 50% of the time, and even worse the name of the main branch is just a convention, so you can't even read a setting to see which one to use.I don't care about the specific name. `main` would definitely have made more sense from the start (classic terrible Git naming). But I do care about pointlessly changing it and breaking everything.	IshKebab	8.517392	-6.533455	comment	3.0	12.0	1708121564	-11.725871
39404225	`git gui` seems to be the easiest so	"`git gui` seems to be the easiest solution to me.
The interface is not pretty, but it does what one would expect and it’s fast."	pantalaimon	8.5817585	-6.476896	comment	3.0	11.0	1708124734	-11.864344
39405765	My favorite line in my .gitconfig is	"My favorite line in my .gitconfig is an alias that prints out the commit history as a tidy graph. (The default `git log --graph` uses 6 whole lines per commit!)    [alias]
        lg = log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all -n 15

Which I took from this Stack Overflow post:
https://stackoverflow.com/questions/1057564/pretty-git-branc..."	CodeIsTheEnd	8.594375	-6.516719	comment	3.0	12.0	1708137054	-11.851871
39434915	What are the benefits of keeping it 	What are the benefits of keeping it in git? Are the commit messages useful?Not trying to knock the idea, I just can't imagine branching or reverting or being curious about the history of a to-do list. Maybe it could be cool for statistics over time.But I'm really curious to hear how you're using it!	AlecSchueler	8.579868	-6.526735	comment	3.0	13.0	1708377334	-11.889834
39453242	git can already do this as long as t	git can already do this as long as there isn't a conflict. Maybe pijul has better three way conflict resolution, but those can be risky, and avoiding those rare situations wouldn't offset the vast amount of tooling that got has.	ynniv	8.598623	-6.5534296	comment	3.0	19.0	1708520461	13.890573
39453410	Which tbh is a bad thing. Just becau	Which tbh is a bad thing. Just because change a doesn't textually touch change b doesn't mean they don't interact.Unless your VCS is handling CI for integrating changes on push, you really need to pull down the upstream changes first and test them combined with your code before blindly pushing.	jacoblambda	8.640627	-6.518158	comment	3.0	10.0	1708521567	-11.821971
39453419	Funny timing of this post.  This pas	Funny timing of this post.  This past weekend, I dedicated myself to creating a comprehensive set of tools for integrating Pijul seamlessly into Emacs.  This includes collaboration features through org-mode, which I believe will be refreshing.  I'm eager to share it with the community shortly.  For fellow Emacs & Pijul enthusiasts, keep an eye out!	vim-guru	8.598508	-6.5574775	comment	3.0	18.0	1708521621	13.896023
39453699	I like how Pijul has a math-centric 	I like how Pijul has a math-centric approach under the hood. The name needs to be changed if they want to get traction.	devaiops9001	8.594046	-6.597334	comment	3.0	11.0	1708523170	13.902893
39454578	Hey what does this item in the FAQ m	"Hey what does this item in the FAQ mean?> Do files merged by Pijul always have the correct semantic?
> No. Semantics depends on the particular language you’re using, and Pijul doesn’t know about them.That makes it sounds like Pijul might sometimes merge two functionally correct versions of a file into an unfunctional, incorrect one? Is this referring to a problem git and other merge tools have as well, or is it unique to Pijul and a result of being so good at merging without conflicts that it sometimes lets through semantic conflicts?"	dahart	8.60098	-6.573054	comment	3.0	13.0	1708527411	13.915836
39454712	> However, channels are different fr	"> However, channels are different from Git branches, and do not serve the same purpose. In Pijul, independent changes commute, which means that in many cases where branches are used in Git, there is no need to create a channel in Pijul.I've never understood this. AFAIK, the only use case I've ever seen for git branches is ""I have some code, but don't want it going live yet"". Maybe it's a WIP demo, maybe you want someone else's eyes on it, maybe you just want to back your current state up on a remote server because your laptop is going to explode.Am I misunderstanding, and Pijul manages that without channels? Or is there a common case git branches are used that I missed?"	zck	8.577423	-6.5434914	comment	3.0	12.0	1708528123	13.895319
39456965	I don't want this to be interpreted 	I don't want this to be interpreted as a negative comment about Pijul: I didn't try it, and don't want to judge.My question is: what is the motivation for making distributed VCS?  Over the entire lifespan of Git the number of times I had more than one remote... I can probably count on my fingers.  And I've been in infra / ops for the better part of my career.  And, all those times were exceptions.  I'd do it to fix something, or to move things around one time, and then remove the other remote.  Other times it was my hobby projects I shared with someone in some weird way.Most developers who aren't in infra will never see a second remote in their repositories even once in their career.  It seems like developing this functionality adds a significant overhead both in terms of development effor	crabbone	8.560953	-6.4424505	comment	3.0	13.0	1708537504	-11.867764
39479721	I had some colleagues at a former co	"I had some colleagues at a former company who absolutely swore by this.Being used to trunk-based development, my approach was simply to make small commits.  And if you insist on PRs, make small PRs.  Although not totally cost free, they are easy enough to create that the overhead is trivial even with very small PR sizes.I asked them how this improved on just making small PRs, particularly with the need for extra tooling an complexity, and all I got was blank stares.Reading the blog entry, I don't see anything that goes beyond ""just make small PRs.  And now here's some tooling that's totally unnecessary if you make small PRs, but you'll have to organize your big PRs as a set of smaller PRs anyway""What am I missing?"	mpweiher	8.654312	-6.4486833	comment	3.0	18.0	1708691245	-11.901932
39483751	But shouldn’t you use rebase? E.g. i	But shouldn’t you use rebase? E.g. if you’re developing a new feature on a central repository, and a bunch of commits happen to the repository in the meantime, wouldn’t it be best practice to do a rebase before you push your own commits to the repository?	rayiner	8.591403	-6.5642405	comment	3.0	15.0	1708710295	-11.977885
39522894	That’s exactly what my company’s leg	"That’s exactly what my company’s legacy code base looks like..
No one wants to reformat the files because then it will mess up with git history.It was horrendous to look at at first, but I’ve gotten used to it by now and just apply the same random style to whatever snippets I modify. :)"	finger	8.665377	-6.505268	comment	3.0	10.0	1709034145	-11.81706
39575122	Git: Programmatic Staging	Git: Programmatic Staging	icholy	8.675301	-6.5525384	story	3.0	26.0	1709407918	-11.919255
39590935	I can see why in your head that may 	"I can see why in your head that may look like a successor to git, but the... news... be it good news or bad news for you... is that everything you've described is actually almost entirely orthogonal to git.When researching the question of ""Why did X occur?"", I absolutely, positively, beyond a shadow of a doubt, do not want to filter through literally hours of keystroke-by-keystroke data. I need some sort of indication as to what states are worth looking at. Those are commits. Whatever further thing you may want to say about them, like ""well, whenever the tests all pass we'll add a checkpoint"", well, you can do that today. If you don't, it's either because you haven't thought of it, or the resulting multiplicity of commits is already too much to deal with.Moreover, just having a CRDT histor"	jerf	8.570005	-6.537086	comment	3.0	11.0	1709562642	-11.917526
39596104	I've started using worktrees recentl	I've started using worktrees recently and I have nothing but praise for it. It's especially useful to me because I work on multiple features and want to reduce friction from context switching. I basically have a structure like `/worktrees/<project>/<worktree>`. I use it alongside direnv and have my .envrc in the top-level project. That essentially allows me to set up project-specific environments for all of my worktrees. This works neatly with emacs projectile mode and lets me switch between different projects/features seamlessly. My head feels a lot lighter not having to worry about my git branch state, stashing changes, and all that jazz. I think it's a great tool to have in your repertoire and to use depending on your needs.	thisisthenewme	8.592959	-6.51312	comment	3.0	13.0	1709586408	-11.889922
39610553	And Fossil is an entirely different 	And Fossil is an entirely different VCS.What’s the alternative? That at least N projects cooperate and agree on a common design before they do the implementation? (Then maybe someone can complain about design-by-committee.)	avgcorrection	8.472848	-6.5221944	comment	3.0	11.0	1709682340	-11.959786
39637625	Microsoft had issues git’s ability t	Microsoft had issues git’s ability to scale. According to this[1] they found and submitted solutions to allow git to scale to their needs and worked with the git team. It sounds like Facebook wasn’t partnering with them to solve the problem? The article mentions Microsoft had repos with 6m files and says things now take seconds.I’m not personally dealing with repos of this size, but it sounds like this is a problem of the past, thanks to Microsoft. I have a hard time believing Facebook would be a bigger beast than Windows.[1] https://devblogs.microsoft.com/bharry/scaling-git-and-some-b...	al_borland	8.507945	-6.443623	comment	3.0	10.0	1709870204	-11.89403
39667412	Dunno, I’ve spent countless hours ca	Dunno, I’ve spent countless hours carefully grooming my git commit histories so they make sense and convey a coherent story, just to have them destroyed by some squash zealot at merge time .“Squash before merge” workflows seem to be more common these days and I have to think it’s mostly a push by people who do not know how to do interactive rebases and history rewrites.	loloquwowndueo	8.570856	-6.572642	comment	3.0	10.0	1710160675	-11.947805
32668533	Sequential IDs also let you think ab	"Sequential IDs also let you think about ranges: a feature was introduced in 11, broke in 17-23, and worked thereafter.I used SVN like this in grad school: data files included the SVN $Id$ of the script that generated them. This let you work around bugs and experimental changes. For example, you might hardcode a delay, realize it should be longer, and then eventually decide to let the experimenter adjust it on the fly. This is easy with sequential ids:   if version < 11:
      delay = 50
   elif 11 <= version < 29: 
      delay = 100
   else
      delay = params.delay

Using git hashes, you'd need to maintain an exhaustive list of every version ever run, which is even tricker because there isn't a sole source of truth like an SVN repo."	mattkrause	8.685703	-6.442049	comment	3.0	10.0	1661980931	6.1794944
32668430	We had a similar rotation on Chrome 	"We had a similar rotation on Chrome team for merges from WebKit (pre fork), and it was similarly a lot of work and clunky tooling!A few times in my career (including this one) I have thought, ""We are sure going to a lot of effort to maintain a modified copy of that code while also preserving our changes atop it as we sync, and this is exactly the kind of workflow that Git was designed to enable.""  Like, the Linux kernel dev workflow is all about different maintainers maintaining different branches and merging between them, and that is where Git comes from.So in a setting other than Chrome I have tried out using Git to try to manage these sorts of situation.  I have found in practice many engineers aren't comfortable enough with Git to have it end up helping them out tooling-wise.  This is "	evmar	8.628123	-6.4977226	comment	3.0	38.0	1661980421	6.1707096
32709473	Almost impossible to pinpoint what c	Almost impossible to pinpoint what changed thanks to thousands of lines of completely irrelevant changes and shitty commit messages. It seems the only changeset that might be relevant out of +2,273 -1,531 is the +11 -7 from https://github.com/basujindal/stable-diffusion/pull/103/comm...? Does it even work?	oefrha	8.5890875	-6.446945	comment	3.0	19.0	1662261622	-11.880334
32709937	The managers and executives need to 	The managers and executives need to have visibility into git commits and deployments. They should literally be able to see the front end and read the progress on the back end code, along with some simple reports as it goes.If they can't understand that stuff they should not be making decisions.But basically it's a list of stuff done, with proof, and stuff left to do.Then they can see the progress bar moving and make decisions based on that. To get estimates, ask for explanations of what is involved in the remaining steps. Again, they should have technical competence to get a rough estimate from those reports.	ilaksh	8.550086	-6.4589725	comment	3.0	11.0	1662266888	-11.921746
32771469	I'd love to see a git history for ou	I'd love to see a git history for our current US legislation	matthoiland	8.545944	-6.4411116	comment	3.0	11.0	1662668162	-11.869137
32808812	> I still believe that a squash+merg	> I still believe that a squash+merge (or sometimes, rebase) workflow pairs better with pull requestsUnpopular opinion, but I find the value of having the actual surrounding context in which the code was developed more valuable than having a flat history.	donatj	8.5766735	-6.5546618	comment	3.0	15.0	1662983786	-11.94987
32808858	It depends on that context, if they'	"It depends on that context, if they're the end of day ""work in progress"" or ""typo"" commits, I don't see the value in retaining those.A non-linear commit history is much more difficult to run a bisect on which was enough to sell linear for me."	cube00	8.57856	-6.5369244	comment	3.0	11.0	1662984103	-11.907514
32809921	It's not intuitive, but it's an amaz	It's not intuitive, but it's an amazing tool that has stood the test of time for decades. I used to struggle with Git, but after putting in a little extra time and studying it more, now I feel like it's a crucial tool in my toolbox and I can use it for much more than _just_ storing my code. Git helps me understand what my colleagues wrote, gives me incredible control over breaking my work apart, and gives me tools to troubleshoot issues (bisect).	meesles	8.550995	-6.49033	comment	3.0	12.0	1662989455	-11.912224
32810055	Not them, but I would hope the messa	"Not them, but I would hope the messages are better than ""WIP"" and expose context vs a commit that simply says 'Implemented X feature"". I usually leave those for a tag."	rovr138	8.588454	-6.5266457	comment	3.0	34.0	1662989976	-11.888228
32810125	If you don't have commits called WIP	If you don't have commits called WIP you're not committing enough. You're doing it wrong.I kid, I kid! But I do commit just to push a back up before getting on a train, or a convenient point to diff against as part of a refactor, etc.They should all be a single commit by the end.	kjeetgill	8.592011	-6.5476	comment	3.0	28.0	1662990310	-11.91989
32810437	The whole point of squash commits is	The whole point of squash commits is to maintain bisectability while having breaking commits on your private branches.	kevin_thibedeau	8.576521	-6.56316	comment	3.0	17.0	1662991501	-11.940017
32811406	It's git that removed them, not me: 	It's git that removed them, not me: rebase re-writes history, that's the whole point. They simply do not exist in the repo anymore after the rebase operation is committed.In fact, following the same merge history as in the first example, I should have named the final ones C3''', C5''', and C9', since they get re-written several times. But, most of the time, this is entirely irrelevant to their history (especially when they don't even touch the same files as the changes being merged in).Note that C7, C11 and C15 completely disappeared, since they are unnecessary. Instead of being extra commits clogging up the log, they are the history rewrite events that don't need to be consigned.	simiones	8.581497	-6.575497	comment	3.0	11.0	1662995005	-11.919053
32829877	> At GitHub, we store a lot of Git d	> At GitHub, we store a lot of Git data: more than 18.6 petabytes of it, to be precise.That actually seems kinda small.Git’s lack of good support for large files means there’s probably an exabyte of data that, imho, should be source control but isn’t.	forrestthewoods	8.567847	-6.448938	comment	3.0	35.0	1663101383	-11.879726
32832132	Just use pijul. Backend might be goo	Just use pijul. Backend might be good but I'm tired of gits ui and  am impressed with pijul so far (very unfurnished yet,)	cutierust	8.564094	-6.4754577	comment	3.0	20.0	1663117940	-11.916627
32831567	Git is written in C. It hasn't been 	"Git is written in C. It hasn't been a ""rube-goldberg-machine pile of scripts and binaries in several languages"" for a long time (almost a decade)."	hactually	8.594746	-6.461457	comment	3.0	11.0	1663112817	-11.874018
32832934	Most people should `git clone --dept	Most people should `git clone --depth 1` most of the time. Large businesses should do trunk-based development with something other than git that scales using distributed file systems with phantom checkouts, negating the need for LFS blob stores.	1letterunixname	8.576597	-6.470897	comment	3.0	12.0	1663125374	-11.88114
32834862	I'm interested in Pijul and the theo	"I'm interested in Pijul and the theory I've read about the patches model makes sense but I'm still looking for an answer to my standard question on Pijul:""What real world situation does git barf at that Pijul would handle better"". I'm sure there is one, but I have yet to see it."	rkangel	8.5942545	-6.560614	comment	3.0	10.0	1663147141	13.895728
32843009	If you want opensource and local sto	If you want opensource and local storage look up Dendron. It is a VSCode extension in a similar vein, uses markdown so easily track changes in git/etc as well.	runevault	8.713933	-6.4437265	comment	3.0	10.0	1663187754	-11.808421
32882632	>You need to buy into the phab workf	>You need to buy into the phab workflow which is diff based not branch based.What do you mean by this?	2muchcoffeeman	8.559278	-6.5127544	comment	3.0	15.0	1663457055	-11.868353
32886210	Yeah, there's a process. It's someth	Yeah, there's a process. It's something that I've done a bunch of times for a bunch of clients.There's so much low-hanging fruit there that's so easy to fix _right now_. No version control? Good news! `git init` is free! PHPCS/PHP-CS-fixer can normalise a lot, and is generally pretty safe (especially when you have git now). Yeah, it's overwhelming, but OP said that the software is already making millions - you don't wanna fuck with that.I've done it, I've written about it, I've given conference talks about it. The real bonus for OP is that the team is small, so there's only a few people to fight over it. It's pretty easy to show how things will be better, but remember that the team are going to resist deleting code not because that they're unaware that it's bad, but because they are afraid	samuellevy	8.565208	-6.4662776	comment	3.0	19.0	1663496655	-11.899655
32937787	Or you just write sensible commit me	Or you just write sensible commit messages. Commits together with the messages should require as little out of band information as possible.	rowanG077	8.590153	-6.5174093	comment	3.0	13.0	1663848902	-11.894661
32966038	My opinion is that maintainable code	My opinion is that maintainable code is written first for reading by humans and second for executing by computers.Unless I'm writing throwaway prototype code (famous last words, lol), I try to write code such that I will be able to figure out what my intention was 6-18 months from now when I'm staring at a piece of code in a panic trying to debug a production issue.That doesn't mean I'm going to get it right when I write this code. Instead, I'll be able to better ascertain what my assumptions were, how they fell apart in practice, and what a minimal, correct fix that doesn't make things worse might be.Edit: Incidentally, this also applies to my commit messages. I’m writing them primarily for my future self so that I can figure out WHY I made a change,  not WHAT the change was.	aaronbrethorst	8.580241	-6.522543	comment	3.0	18.0	1664049166	-11.926324
16441530	I used svn blame a lot recently, but	I used svn blame a lot recently, but never to trace the cause of bugs. I break out the usual tools (debugger and brains) for that. I only resort to blame to understand how a particular odd piece of code came to be (e.g. commented out leftovers that were last touched years ago and forgotten). Even then, I mostly need to see how line changes relate and when they were made. The author is merely a reference of last resort - a pointer to a person who might, with some luck, still remember that he worked on that part.When I find a bug in code that a colleague has written I simply tell him about my changes to it. That keeps him in the loop and gives me a confirmation that my attempted fix should indeed be OK. Of course,  in more formal projects, tickets and code reviews would replace that process.	gmueckl	8.578294	-6.4731865	comment	3.0	13.0	1519334677	-11.92081
16441076	What about git-no-blame? Something l	What about git-no-blame? Something like your tool but it replace the name with empty spaces instead of your name.	gus_massa	8.565061	-6.4796376	comment	3.0	13.0	1519331262	-11.900428
16450348	Eclipse git support is superior as w	Eclipse git support is superior as well as the pom editor.	chapill	8.573068	-6.4497647	comment	3.0	15.0	1519426515	-11.87077
16532036	patches on mailing lists before git,	patches on mailing lists before git, are those also somehow transferred to the repoGiven that conceptually git is just a linked list of patches, I can't imagine why they wouldn't have that history	mdaniel	8.579755	-6.440092	comment	3.0	11.0	1520369700	-11.848262
16563005	No.  Git is better, GitHub is better	No.  Git is better, GitHub is better, most package managers for finding things are better, stack overflow is better, help forums are better, tools are often free, cloud access and compute power is better, instructional videos on youtube are better, online classes are better.I don't want to go back to 10 years ago and definitely not 20 years ago.  I have never been more productive than now.	shortoncash	8.547817	-6.482062	comment	3.0	15.0	1520776680	1.655598
16587567	I would argue git is not novice frie	"I would argue git is not novice friendly. It's original intended audience was not lay people learning how to program. It was seasoned kernel developers working on the Linux source tree. It (made) assumption(s) it's userbase were experts in their domain.> Naturally, people get confused and reach for the docs, which are filled with even more newbie-hostile terms like 'tree-ish', 'hunks' and 'refspec'.Yup, these are everyday terms for an expert in computer science and algorithm and software design. If I were a student in medical school I'd expect the books I'm learning from to use the expert terminology of my domain of study when describing the body and functions and not laymans terms such as -- ""the hip bone is connected to the Red-Squishy-Thing .... ELI5 me plz"" ...I agree git is complex, a"	tenken	8.546387	-6.509073	comment	3.0	20.0	1521055705	-11.846491
16587815	If you grew up with Unix commands it	"If you grew up with Unix commands it makes sense (mostly), if you grew up with Photoshop it's really not very friendly.Stackoverflow top item on how to redo a commit (one of most common things a new user may need to do):  $ git commit -m ""Something terribly misguided""
  $ git reset HEAD~
  << edit files as necessary >>
  $ git add ...
  $ git commit -c ORIG_HEAD

I run a ton of aliases - some of them functions - just to do basics. I really like git - but it is a very steep learning curve for many."	mtkd	8.560373	-6.5140934	comment	3.0	11.0	1521057838	-11.924037
16587842	Those people have not worked on larg	Those people have not worked on large enough teams; we had 50+ committers to an SVN repo before switching to Git, and it was very apparent where the limitations with that 'simple' workflow were.	cortesoft	8.566447	-6.472924	comment	3.0	22.0	1521058066	-11.880008
16588375	Why?Unless I'm misunderstanding, you	Why?Unless I'm misunderstanding, you seem to be saying that being a programmer implies having a desire to understand every program's internals. But I don't care how Photoshop stores the 30-layer document I'm editing, and I feel like I shouldn't have to. I can't see why Git should be treated differently.	uryga	8.544735	-6.4851522	comment	3.0	12.0	1521062205	-11.908158
16588880	that can happen, but it can also ser	that can happen, but it can also serve as an excuse.in git, for example, why can’t i switch branches with uncommitted changes? it makes no sense why i can’t do that, but yet, there it is.> there’s a reason why more complicated tools like git have taken over from less-capable tools like Subversion and CVS.i don’t think the reasons have much to do with usability or even capability. i came to git from perforce, where the latter was much easier to use, reason about, fix issues, and has much better tooling, in particular visual tools. it’s also amazing how slow git is.	nikofeyn	8.564677	-6.502811	comment	3.0	14.0	1521066313	-11.899996
16589293	I don't know how many committers hav	I don't know how many committers have been on the average project I've worked on, but it's probably 25+, and I've worked on several with 50+ - and I don't know how you'd even make Git work at that sort of scale. Obviously people do actually do this, so I assume it must work somehow; I just don't see how it's going to work particularly well.The larger projects I've worked on have typically used Perforce, but I used Alien Brain (which is pretty terrible) for some of the older ones. The check in/check out workflow, which is the same in each case, is basically what makes it all work once you get past a handful of people. Just simply being able to see who else is working on a (almost certainly perfectly cleanly mergeable) file that you're contemplating modifying is a big time-saver.(I've used S	to3m	8.591829	-6.493011	comment	3.0	17.0	1521070051	-11.955092
16589596	I don't understand the hatred for pe	I don't understand the hatred for perforce. It works really well. The times I need an offline branch to work on and keep history of commits are very rare.	shaklee3	8.632246	-6.51694	comment	3.0	13.0	1521073847	13.8326025
16590356	Shameless plug, I'm the author of Gi	Shameless plug, I'm the author of Git Evangelism. This is the guide I built to onboard my coworkers during our transition to Git. This guide is updated regularly and differentiates itself by putting the reader in a position to succeed during their first attempt at Git by providing sane defaults (which Git does remarkably poorly) like setting Sublime Text as the text editor (instead of Vim) and configuring Beyond Compare as the diff tool and mergetool. GE gives a brief introduction to the commands to move you towards being productive early-on and orders the commands that the user is likely to encounter the need.https://github.com/ryanrodemoyer/git-evangelismI like Vim, but it's incredibly intimidating and frustrating that you get presented with Vim if all you want to do is experiment with m	hnrodey	8.588528	-6.509807	comment	3.0	10.0	1521087053	-11.838604
16617146	Last time I checked (a few weeks ago	Last time I checked (a few weeks ago), Gitlab's CI/CD system is great for most use cases as long as you can describe your pipeline as a list of non-interactive tasks -- some of which may be parallelized -- that each can run in a Docker container.For one of the software projects I'm involved in, I have more complex needs. We release binaries for multiple platforms so our Jenkins master delegates certain tasks to slaves running on specific OSes. Then at the end the Jenkins master downloads the built artifacts from all slaves and publishes everything to our artifact hosting server. As far as I can tell, Gitlab CI does not support this.In future CI jobs I may even require user interaction, e.g. I may ask a human to sign off a report. I don't think Gitlab CI can do this.But if your needs aren't	FooBarWidget	8.570964	-6.473992	comment	3.0	11.0	1521452393	9.057072
16650581	I'm curious for the people that use 	I'm curious for the people that use GitLab CI/CD, what's the pro / cons vs Jenkins and the like?	Thaxll	8.674593	-6.516734	comment	3.0	14.0	1521738649	12.009638
16668420	One tool that I would like (and is p	"One tool that I would like (and is probably) out there is tool that would easily let me compare and merge directories.  I think this goes beyond Beyond Compare.  But here's my use case:I have videos, images of our children in various places (my phone, one drive, dropbox, maybe usb sticks) that I want to go into the target directory (probably one drive).  the tool would go through all the other directories, checksum them against all the other directories, and then present them as ""these are the files that should be merge into your target directory"".Can regular diffing tools do something like that in an easy manner?"	Bizarro	8.743642	-6.482596	comment	3.0	14.0	1521920123	8.732357
16674722	Recovering commit after Git reset --	Recovering commit after Git reset --hard	realslimshanky	8.56898	-6.5563216	story	3.0	10.0	1522013535	-11.90132
16680516	Well, you'll always have to trust so	Well, you'll always have to trust some point on being immutable.A git repository can mutate, but so can a central registry or a proxy. Once a version is cached in a registry or a proxy, nothing stops people with enough privileges from modifying that cached version.So really the only thing that changes is just who you trust.	strkek	8.55951	-6.458561	comment	3.0	11.0	1522084292	-11.846915
16806463	SourceTree is actually a pretty good	SourceTree is actually a pretty good GUI for git; it shows the commit tree just like you said.	emilecantin	8.569499	-6.456143	comment	3.0	22.0	1523401652	-11.8638
16806531	This is a great question. Where I wo	"This is a great question. Where I work we use TFSVC and the VP of Engineering is willing to green-light a switch to Git as long as we can make a data-driven, objective case for why Git is better. In other words: ""the devs prefer it"" or ""using Git makes me happier"" don't wash as valid reasons. Branching in Git is certainly much easier but the counter that ""you can branch with TFSVC too"" is true, even if it's slower and eats up your hard drive space faster..."	parvenu74	8.55395	-6.4837756	comment	3.0	10.0	1523402211	-11.888889
16806612	>A lot of smart people don't.I'm sor	">A lot of smart people don't.I'm sorry, I don't buy this at all. Git is one of the most simple source control tools there is. If you can't understand a DAG then there isn't much else you probably can understand in the development world.>This manifests as frequent unintended resultsNo it doesn't. Every time I've seen people complain about ""unintended results"" it's literally been because of the above, and they've been complete morons so I'm never surprised when these people have ""trouble"" with git. You're building a graph, and you're doing pretty basic manipulation of that graph.>I never had any such problem with PerforceUh what? Permission issues? Terrible branch performance? Merging between branches is basically a gamble -- it's actually insane how much this used to mess up over the most b"	kadenshep	8.56112	-6.5304103	comment	3.0	31.0	1523402755	-11.923562
16806685	> Git has no file object, it version	"> Git has no file object, it versions the repo, not files.As someone who has used (in a professional setting) version control systems ranging from RCA to SVN to the current crop (git, mercurial, even darcs), the fact that git versions the repository as a whole instead of individual files is a godsend.You've not known hell until you've had to deal with an RCA/CVS repository with 15+ years of history and thousands of files, each that maintains their own version history (and associated version number!).I'd gladly take the comparative ""slowness"" of git when dealing with large repositories.> Git is basically a tarball server. Calling that a source management system is an enormous stretch.What, in your opinion, is the definition of a version control system then?"	jperras	8.570134	-6.4666915	comment	3.0	28.0	1523403363	-11.889469
16806320	What the hell, speaking against git 	What the hell, speaking against git makes you a hipster now? I was called a hipster for proposing git over CSV and SVC.	tetha	8.554599	-6.47015	comment	3.0	30.0	1523400491	-11.873836
16806869	"The ""index"" is a silly dongle in Git"	"The ""index"" is a silly dongle in Git. One way to get rid of it would simply be to make it visible as a special ""work in progress"" top commit, visible in the history as a commit. ""git add -p"" would just hoard changes directly into the WIP commit, if it exists, otherwise create it first. Some sort of publish command would flip the WIP commit to retained status; then a ""git add -p"" would start a new WIP commit. ""git push"" would have some safeguard against pushing out a WIP commit.The ""--cached"" option would go away; if you have a WIP commit on top, then ""git diff"" does ""git diff --cached"", and if you want the diff to the previous non-WIP commit, you just say so: ""git diff HEAD^"".stashing wouldn't have the duality of saving the index and tree. It would just save the changes in the tree. Anythi"	kazinator	8.573504	-6.553533	comment	3.0	49.0	1523404978	-11.892851
16806877	OK, enjoy Git then.Your claim about 	OK, enjoy Git then.Your claim about merging is false though, demonstrably.  Picking a repo gca when you could have used a much closer file gca is better.  BK does that and automerges, correctly, more frequently and is way way faster than Git.I've written two source management systems.  I'm confident in my knowledge.  Arguing with some random dude who thinks he knows more than me is not really fun.  So go enjoy Git.  Lots of people are too busy/whatever to know what they are missing, maybe that's you.  It's not me, I kinda like my audit trail to be accurate.Even Linus admitted to me in my kitchen that Git's audit trail is lossy.  But go enjoy Git, I'm glad it works for you.  Knock yourself out.	luckydude	8.56931	-6.515552	comment	3.0	15.0	1523405027	-11.929244
16807067	I worked at a pretty well regarded a	I worked at a pretty well regarded and reputable organisation that still used SVN. (Pretty sure they still do).If not for my yammering there wouldn't be any git in use by any team there. (Only a year ago)All the code progressed fine. git would still have improved it but nobody had bothered to switch yet.	JauntyHatAngle	8.578391	-6.4656224	comment	3.0	14.0	1523407179	-11.864657
16807177	> Git won not because it was that mu	> Git won not because it was that much better than the others. It won because the Linux kernel uses it.This is a pretty silly assertion to make. You're actively ignoring the SCM's that were chosen by far larger org's. Git took the dev world by storm because it was better. Not because an open source OS used it. Other SCM's had years worth of developer training and interaction with their systems and STILL lost. Years worth of sales connections, demos, networking, you name it and STILL lost.>They are also losing work because git makes it easy to shoot yourself in the footExample?	kadenshep	8.542919	-6.4546223	comment	3.0	11.0	1523408498	-11.894767
16807827	This might sound a little out of tou	This might sound a little out of touch, but am I the only one who doesn't think git is that hard? It is a collection of named pointers and a directed acyclic graph. The internals aren't really important once you have that concept down.	jimmy1	8.561122	-6.5004277	comment	3.0	51.0	1523417663	-11.838071
16807961	"Rebase is ""rewind local changes"" ""pu"	"Rebase is ""rewind local changes"" ""pull"" ""replay local chances""Basically it makes it so that all of the local-only commits are sequenced after any remote changes that you have not seen yet.[edit]YZF is correct.  In the context of pulling (i.e. ""git pull --rebase"") my description is correct.  However in general rebasing branch X to Y that diverge from commit C is:rewind branch Y to commit C; call the old tip of Y Y'play all commits from C -> X on Yplay all commits from  C -> Y' to branch Y."	aidenn0	8.573137	-6.579545	comment	3.0	11.0	1523419771	-11.924248
16808237	The only thing Git can really fix is	"The only thing Git can really fix is changing it's command flags to be consistent across aliases/internal commands. That's about it. The whole point of an SCM is that graph that you want to move away from. People have asserted your claim many times but can't ever give specific things to fix about the ""abstraction.""There are about 5/6 fundamental operations you do in git/hg. If that's too much then again, there's not an abstraction that is going to help you out."	kadenshep	8.571205	-6.528177	comment	3.0	28.0	1523423501	-11.884493
16808645	So, in git, to show descendants of a	"So, in git, to show descendants of a commit, you use    git rev-list --all --parents | grep ""^.\{40\}.*<PARENT_SHA1>.*"" | awk '{print $1}'

whereas in fossil, you use    fossil timeline after <COMMIT>

I mean, one of these looks just a little more straightforward than the other, doesn't it?Also, a cursory test in a local git repo just now showed that command seems to print out only immediate descendants--i.e., unless that commit is the start of a branch, it's only going to tell you the single commit that comes immediately after it, not the timeline of activity that fossil will--and all it gives you is the hash of those commit(s), with no other information.I use git myself, not fossil, but if this is something you really want in your workflow, fossil is a pretty clear win."	chipotle_coyote	8.520239	-6.5592937	comment	3.0	11.0	1523429241	-11.911449
16806845	A version control system is an accur	A version control system is an accurate audit trail of everything that has happened in the repository.  Every create, delete, rename, every rwx mode change, every content change.In BitKeeper files work like they do in Unix, there is a (globally) unique name for each file object.  Where the object lives in the repository is an attribute of that object, as are the contents, the permissions, who has changed etc.Here's a super common workflow that's easy in BitKeeper and miserable in Git.  I'm debugging an assert.  I want to see who added the assert.  I pop into the gui that shows me the per file graph and contents, search for the assert, hover over the rev and see that it was done a long time ago.  I look in the area above the assert and I see a recent change, hover over that, see the comment	luckydude	8.596391	-6.506989	comment	3.0	13.0	1523404666	-11.887913
16808101	I never had any problems the past 6 	I never had any problems the past 6 years I've been using Git professionally. But then someone asked me what to do when Git prevents you from changing branches and not knowing they did not stage, I told them to stash or commit. They stashed and the changes were gone.My point is, while your basic commands do the work, your habits and knowledge keep you from losing code like this without you knowing.	nurettin	8.561189	-6.5058036	comment	3.0	13.0	1523421884	-11.898255
16808865	That term makes sense.But just as yo	That term makes sense.But just as you wouldn't call a symlink to a zip archive a zip file itself, you also shouldn't call a branch a ref.	y4mi	8.632804	-6.4890347	comment	3.0	12.0	1523432228	-11.791342
19329256	I'm not entirely sure I want to sit 	I'm not entirely sure I want to sit through a 10 minute linting process every time I do a quick `git add -A && git commit -m WIP` locally.  Why does it need to be a pre-commit hook instead of a simple PR check?  PR checks obviously need to be done anyway.	ninkendo	8.62776	-6.5057974	comment	3.0	16.0	1551975545	-11.897883
19338075	Ask HN: What is the best keyboard dr	Ask HN: What is the best keyboard driven Git clients?	FloatArtifact	8.657284	-6.465113	story	3.0	6.0	1552057525	10.489213
19388569	Thanks for sharing. I too agree on t	"Thanks for sharing. I too agree on this: ""... Git is complex is, in my opinion, a misconception... But maybe what makes Git the most confusing is the extreme simplicity and power of its core model. The combination of core simplicity and powerful applications often makes thing really hard to grasp...""If I may do a self plug, I had recently written a note on ""Build yourself a DVCS (just like Git)""[0]. The note is an effort on discussing reasoning for design decisions of the Git internals, while conceptually building a Git step by step.[0] https://s.ransara.xyz/notes/2019/build-yourself-a-distribute..."	sransara	8.541855	-6.5079956	comment	3.0	31.0	1552566397	-11.889983
19389801	Not rebasing does not affect reviewi	"Not rebasing does not affect reviewing a branch in the least, unless your diff software is seriously broken.Comparing a branch to trunk shoudl only shows the actual difference. That you merged trunk multiple times shoudl have zero bearing.The only way it could ever confuse anyone is if they review every commit and somehow fail to pass over merge commits.The single most aggravating thing in git are its self-appointed super-users who /almost always/ properly use its power until one day they don't. Then they make life miserable for everyone else while we all ""just wait, I'm fixing it""."	pierrebai	8.611369	-6.5897913	comment	3.0	12.0	1552575644	-11.866415
19430008	Git wasn't released until 2005, so w	Git wasn't released until 2005, so what did they use before then? I know it says they pulled the history from 24 snapshots.	beckler	8.563944	-6.4484534	comment	3.0	18.0	1552997098	-11.878258
19442774	The Case for Pull Rebase	The Case for Pull Rebase	megakemp	8.580591	-6.5525327	story	3.0	14.0	1553093398	9.186459
19480736	Slightly offtopic, I have always con	Slightly offtopic, I have always considered a strange failure of git that branches are second class citizen in git, not worthy of the same versioning mechanisms as files. It is not unreasonable to expect a versioning system to be able to track the history of branches. And if I don't want to loose a file, just because it was deleted some time in the past, surely I also don't want to loose a branchjust because it was deleted. I don't buy the 'I want to be able to hide f-ups' argument.	stkdump	8.577713	-6.5137706	comment	3.0	14.0	1553497042	-11.894843
19480948	git push --forceIt doesn't actually 	git push --forceIt doesn't actually delete the commits, but you can't find them anymore if you don't remember the hash of the former head commit of the branch	progval	8.566076	-6.533628	comment	3.0	11.0	1553501419	-11.84219
19481318	If you have a job where you arent al	"If you have a job where you arent allowed to commit directly to master / development branches this is probably how they enforce it. It keeps juniors from pushing bad code without peer review. It forces developers into doing PRs instead. Protected branches are the first thing we setup when we make a new repository at work once we hit the ""getting good enough for production and autobuilds"" stage of development."	giancarlostoro	8.5791855	-6.488537	comment	3.0	12.0	1553508506	-11.926434
19541870	Git Implemented in OCaml	Git Implemented in OCaml	testcross	8.562403	-6.4694366	story	3.0	82.0	1554113422	-11.869318
19568493	> The most obvious difference is tha	> The most obvious difference is that Git's index is a bit boneheaded, so I'm ignoring it.> In fact, the entire concept of the staging area has been dropped, as it's both confusing and clunky.Sounds like its on the right track.	tomohawk	8.6051855	-6.5264583	comment	3.0	51.0	1554339271	-11.904052
19568786	Interesting, so you commit things th	Interesting, so you commit things that are different from the code that is sitting in your working directory at the time of the commit?	ori_b	8.603839	-6.5229707	comment	3.0	17.0	1554343671	-11.922805
19591447	I use stow. But honestly, I don't th	I use stow. But honestly, I don't think it's better than git.	sametmax	8.535884	-6.46426	comment	3.0	12.0	1554567236	-11.881023
19596595	How many new concepts a new user nee	"How many new concepts a new user needs to learn, and how many mental models a new user must develop in order to effectively use your software.
Twitter is simple, Git is complex."	lucio	8.499603	-6.5254927	comment	3.0	13.0	1554642684	-11.861044
19661458	I'm actually surprised they use GIT 	I'm actually surprised they use GIT internally. I would have thought they have their own custom VCS. It says a lot about the success of GIT.	eclipseo76	8.554868	-6.445966	comment	3.0	13.0	1555273189	-11.879147
19664603	> Most Continuous Integration tools 	"> Most Continuous Integration tools run the CI build on your branch to say if it can be merged or not. But that is not what is of interest here. If you know what you’re doing there is a pretty good chance that the code you have just pushed is working already!
> Your CI tool should perform a local merge of your branch to the main branch and run the build and tests against that.100% this - I've never seen it written down anywhere so concisely before! What's the point in CI running automated tests on only your changes, when you have already done so locally? If you are pushing your changes just to get your unit test results (and code formatting checks etc), you are doing it wrong! :) merging it first makes much more sense / has much more value."	indentit	8.690633	-6.524083	comment	3.0	22.0	1555328355	5.9253626
19698633	"A ""feature branch"" means something m"	"A ""feature branch"" means something much different to my teams. A feature branch for us is a short-life topic branch, and typically for one use case, kanban card, etc.We use short-life topic branches for each feature, each bug fix, each infrastructure-as-code change, each documentation update, etc.We prefer short-life topic branches vs. committing to the `master` branch (or equivalent `develop` branch) because of multiple reasons:1. A topic branch gives good code isolation for distributed development: I can share a topic branch with you, directly, without needing to merge to master.2. A topic branch makes it really easy to do many kinds of popular git workflows; this includes many popular CI servers, git automation scripts, git aliases, etc.3. A topic branch is great for integrating early a"	jph	8.580856	-6.528962	comment	3.0	10.0	1555673509	-11.912649
19705269	While I've naturally gravitated towa	"While I've naturally gravitated toward the ""capitalize and use the imperative,"" I've never been down with the ""good commit messages are 50 characters or less"" mantra. Why 50? Is there an important tool that breaks if my commit message is 55, 60 or even (gasp) 70 characters? Is there a real case to be made that ""Add total vocab entries per capsule limitation"" is a good commit message that becomes an utter irresponsible trash fire if one spells the entire word ""vocabulary?""Yes, short, clear commit messages are good. I'm not saying ""write a paragraph""; I'm not even saying that it's bad to have an arbitrary maximum length beyond which a commit message can be considered poor form. It's just that 50 is a weirdly arbitrary choice."	chipotle_coyote	8.596147	-6.536886	comment	3.0	18.0	1555745299	-11.921003
19705377	> Think of it like a short email tha	> Think of it like a short email that explains to your (future) colleagues and future selfNote that commit messages don’t live with the code. If you find yourself writing why something should be in the new state, consider putting that “explain why” as a comment next to the code, so anyone’s text editor can read it.	afarrell	8.579817	-6.5157766	comment	3.0	19.0	1555747687	-7.6813684
19705460	Hmm, I think it depends on the case.	"Hmm, I think it depends on the case. Sometimes it's appropriate to leave comments on the file, while sometimes trivial changes don't need to be mentioned and explained only at a commit message.Oh and while it doesn't ""live"" with the code, I can at least look up a line in question and see which commits have changed it, along with their commit messages."	jerieljan	8.580771	-6.5206637	comment	3.0	11.0	1555749916	-11.902289
19706047	Commit messages are a poor place to 	Commit messages are a poor place to document code because they don't stay with the code. If the code isn't obvious, comments work wonders and often make the commit message more focused on documenting commit history not actual code.	Waterluvian	8.576254	-6.529281	comment	3.0	15.0	1555761352	-11.904668
19706698	They're associated with a line with 	They're associated with a line with a file.  git and other SCMs provide tools that allow you to see what commit is associated with a given line, what the state of the file was at the time the commit was made and when lines in that file were removed subsequent to that commit.> If you find yourself writing why something should be in the new state, consider putting that “explain why” as a comment next to the code, so anyone’s text editor can read it.The problem here is that there's no guarantee that the comment gets updated when the code does.  Whereas, a commit is always associated with the code at the time it was written.  If the code is changed, then that old commit is no longer associated with it.	u801e	8.580044	-6.5218263	comment	3.0	10.0	1555770794	-11.8990555
19739393	I like the idea of creating a source	I like the idea of creating a source control protocol that can be implemented with any number of tools rather than having wars over particular implementations of source control products.(And would Git really have beaten Mercurial if GitHub had been HgHub instead? GitHub's success was more about process than the technology of Git, IMO.)	mikece	8.521666	-6.5170965	comment	3.0	13.0	1556119941	-11.9148
19780206	"""Ideological and eventual practical "	"""Ideological and eventual practical problems too"" is way too general.The very specific flash-point was Linus throwing an unjustified hissy-fit defending Larry McVoy of BitKeeper being difficult about Andrew Tridgel (Tridge of Samba fame) ""reverse engineering"" the data traffic of Bitkeeper for inter-operability (really just sniffing client packets with wireshark or something).Whether the name ""git"" pertains to Tridge or Linus himself who in retrospect decided he acted like a spoiled brat is still not known :)"	craigsmansion	8.578282	-6.4465923	comment	3.0	12.0	1556557464	-11.894255
19801985	I've seen perforce here and there st	I've seen perforce here and there still.	sleepybrett	8.675196	-6.4957166	comment	3.0	10.0	1556747372	6.892982
19802062	Mercurial.  Same idea, better interf	Mercurial.  Same idea, better interface.	jstewartmobile	8.509325	-6.552625	comment	3.0	16.0	1556747836	-11.967359
19878325	Mercurial's interface is just fine, 	Mercurial's interface is just fine, and these days it's just as powerful as Git.Things could be better.  There's an existence proof.  It just lost the mindshare war and so now we're stuck with Git, which I still have to look up basic syntax for because its command set is contradictory and makes no sense.  (Is it git <x>?  git <y> --x?  git <z> <a-b>?  Something else entirely?  Who knows!)	Espressosaurus	8.518638	-6.549604	comment	3.0	13.0	1557500005	-11.951235
19878336	I've heard this before, and it seems	"I've heard this before, and it seems reasonable on the surface. The argument I make against this viewpoint is: ""git rebase gives us powerful tools that allow us to curate a good commit history in the same way we use refactoring to uphold good software design practices."""	Sir_Cmpwn	8.572203	-6.562415	comment	3.0	11.0	1557500095	-11.892436
19878381	"""git rebase"" does exactly what you w"	"""git rebase"" does exactly what you want, except when it's totally unrelated to what you want because what you actually want is ""git rebase -i HEAD~3"" which does something basically completely different (from a users point of view)."	gpm	8.570095	-6.561923	comment	3.0	20.0	1557500288	-11.828564
19878651	No, gwright is correct, and my guide	No, gwright is correct, and my guide fails to capture the nuance of this detail.Each commit has a link to its parent, and represents the tip of a linked list. .git/objects is a heap of all commits (and other objects), and .git/refs contains a list commit IDs that define each head (e.g. master). git rebase will often introduce new versions of a commit to the heap and update the heads to reference new histories, but the old commits stick around and can be accessed through the reflog - with their full original history intact.	Sir_Cmpwn	8.570332	-6.560822	comment	3.0	20.0	1557502037	-11.901774
19878320	"The warning regarding ""public, share"	"The warning regarding ""public, shared, or stable branches"" is always warranted, but I think those warnings end up reverberating where they needn't.  Before interacting with anything public or shared — when working solo or locally — `rebase` can be hugely helpful. When starting out with something complicated, I often make separate commits for different files or steps; using rebase to reorder commits or amend can make turning your first steps into a viable change much easier, and can help with merge conflicts down the line.  I also find it helpful for large commit messages; rather than needing to write everything at once, making liberal use of `fixup` or `squash` can keep disparate thoughts or bug fixes manageable.I'd never use it on a public or shared branch, but `rebase --interactive` and "	Amorymeltzer	8.553075	-6.5902147	comment	3.0	12.0	1557499974	-11.97059
19878831	> No commits are harmed in the opera	> No commits are harmed in the operation of `git rebase`. All the commits you had in the repo before the rebase are still in the repo.They are still in the repo, but if no treeish item (eg. a branch) points to them, then they'll eventually get garbage collected.Still, glad to see people are trying to elucidate git rebase. A small subset of its functionality is fundamental part of my workflow and I wouldn't know how I'd use Git without rebasing.	dmitryminkovsky	8.562514	-6.5737495	comment	3.0	31.0	1557503029	-11.916929
19878896	the old commits stick aroundThey kin	"the old commits stick aroundThey kinda are, but that's like saying that deleted files are not deleted, but stick around for a while.While technically true, for most practical purposes _rm <file>_ deletes the file. The fact that each and every ""git 101"" manual has to explain how to recover deleted commits, means something is wrong.It's like saying: ""Here's the key, and in case it doesn't work there's a pry bar in the garage"". This is usually a pretty good indicator that the lock is broken."	AlexTWithBeard	8.569464	-6.539023	comment	3.0	12.0	1557503362	-11.923428
19879409	Yep. Specifically, git will never de	Yep. Specifically, git will never delete a commit, unless it is old (like 30 days old or older I think?) and is not part of a branch. I suppose there may be some arcane commands to force a deletion, but it wont happen by accident or by normal usage.Like you, I felt much more comfortable using git after learning this.	Buttons840	8.562378	-6.5274563	comment	3.0	19.0	1557506014	-11.890117
19879592	This is technically true, and a comm	This is technically true, and a common reposte when talking about preservation of history edits.Unfortunately, the reflog is confusing and hard to use correctly in the case of an interactive rebase with multiple steps.  It is hard to figure out exactly how far back you need to go in the reflog to get to moment before the rebase started if you want to start over.  It also just so happens that its when an interactive rebase goes awry that I really want to reach for the reflog to fix the damage.	brandmeyer	8.591792	-6.570773	comment	3.0	11.0	1557506871	-11.925582
19903753	I strongly prefer git merge over git	I strongly prefer git merge over git rebase.Using rebase results in a cleaner history and simplified workflow in many cases.  However it also means that when you have a disaster, it can be truly unrecoverable.  I hope you have an old backup because you told your source control system to scramble its history, and you don't have any good way to back it out later.For those who don't know what I mean, the funny commit ids that git produces are a hash signifying the current state of the repository AND the complete history of how you got there.  Every time you rebase you take the other repository, and its history, and then replay your new commits as happening now, one after the other.  Now suppose that you rebased off of a repository.  Then the repository is rebased by someone else.  Now there i	btilly	8.577915	-6.554809	comment	3.0	13.0	1557780237	-11.904119
19907196	Git is just for programmers. It was 	Git is just for programmers. It was made by and for kernel developers, no less. There are better tools for other people.If you don't care what a DAG is, you will never understand what git is or what it's for. No arguments. Git is a tool for building a DAG. If you don't need a DAG you don't need git.	rich-tea	8.552361	-6.4833317	comment	3.0	18.0	1557814523	-11.912649
19907175	OK hot shot. Tell everyone here how 	OK hot shot. Tell everyone here how you've never fucked up commands and had to blow out a repo and start over and how were all idiots for having done that.It's a tool. Any tool can be confusing if the person isn't taught how to use it. Git requires teaching so there's a lot of room for misunderstanding.	thatoneuser	8.539043	-6.4535775	comment	3.0	13.0	1557814282	-11.914715
19907498	I was thinking if I would post what 	I was thinking if I would post what you did it would get downvoted but yeah, if you find git hard how or why are you writing code? That is surely a lot harder. Not sure why  it is downvoted as sure it might not be a popular opinion but it seems to hold...	tluyben2	8.540406	-6.4899416	comment	3.0	10.0	1557818775	-11.898916
19907587	> If Fossil can’t be compared on the	> If Fossil can’t be compared on the same level, maybe that’s a sign it solves fundamentally different problems.Or Fossil provides a superset of the others.  Like comparing a corkscrew, which only opens bottles of wine, to a swiss army knife that has a corkscrew.  They both solve the same problem, but one of them also solves other problems and is generally a more useful tool to keep around in your pocket.The world didn't lose much with Hg losing to git.  But with Fossil losing, we lost a great deal.   As a consequence we have a world where people feel locked into the proprietary bug trackers their git host provides.  Had Hg prevailed, that situation would be no different.  The only way the world would be different if Hg had prevailed would be fewer posts on HN whining about git's interface	darkpuma	8.497866	-6.551607	comment	3.0	12.0	1557820109	-11.93862
19907960	This particular pattern should be fi	This particular pattern should be fixed in a future git (hopefully). There's a new command that supports all thesegit restore --staged file   # reset the index from HEADgit restore --worktree file # reset the worktree from the indexgit restore --source=HEAD --staged --worktree file # reset both the index and worktree from HEADStill in development [1] so if you think something can be improved, I'd love to hear it.[1] https://github.com/git/git/blob/pu/Documentation/git-restore...	bicolao	8.558154	-6.522394	comment	3.0	16.0	1557825654	-11.914512
19908311	"Am I the only one who reads ""reflog"""	"Am I the only one who reads ""reflog"" as ""re-flog"", that is, to be painfully whipped again?"	dzdt	8.610458	-6.5700088	comment	3.0	11.0	1557830238	0.3037719
19937226	Physicists finally moving from SVN t	Physicists finally moving from SVN to Git.	another-dave	8.571354	-6.451025	comment	3.0	13.0	1558078619	-11.88417
19961581	I strongly agree that git has a UX i	I strongly agree that git has a UX issue, and the widespread adoption of it over mercurial is a perfect example of inertia leading us to get stuck in a local minima.	dual_basis	8.522809	-6.514599	comment	3.0	14.0	1558367103	-11.935247
19961946	I haven't tried hg but from what I'v	I haven't tried hg but from what I've seen one major advantage of git that gets under-acknowledged is its speed. Git is fast and fast really does matter for a version control system you use constantly. Is hg as fast as git?	api	8.525773	-6.515603	comment	3.0	10.0	1558368963	-11.93072
33043690	Because it is visual noise. It's rea	Because it is visual noise. It's really hard to track, especially on the CLI. It's also a lot easier to reason about the codebase through time if it's basically a linear track.We started off with merge commits and moved to squash rebase (team history to team clean), and I gotta say, I absolutely love team clean in the overwhelming majority of cases.The only time team history is handy is as a sort of temporary space on feature branches where you are sorting out complex merges, debugging, or trying different patterns. But all of that gets squashed away onto main eventually.	kortex	8.577124	-6.556772	comment	3.0	18.0	1664595986	-11.93118
33043033	"What I wish github supported was ""gi"	"What I wish github supported was ""git rebase && git merge --no-ff"", or as Azure DevOps calls it ""semi-linear merge"".A fairly linear history is a lot easier to read but it is nice to preserve the branch by having a merge-commit."	epage	8.55209	-6.448417	comment	3.0	20.0	1664589322	-11.860824
33044935	> This is a mistake — no one finds v	> This is a mistake — no one finds value in it, so it should be kept private.Just anecdotal, but I disagree vehemently. In my experience, an easy way to follow Chesterton's fence ( to figure out why a piece of code is the way it is before modifying it's behaviour), is to  understand the decision making process that was being followed and not just the blob of code that added it (Even more so on older repos where the original author may not be around).Many a times, it becomes obvious that the code was written under a very different understanding of the what the system evolved to be, and as such can be changed accordingly, and inversely that the code makes certain strong assumptions when written which hold true even today.This is why as a thumb rule, especially for junior developers just gett	madmax108	8.567713	-6.486024	comment	3.0	10.0	1664611923	-11.908297
33045070	That is a strawman argument: you are	That is a strawman argument: you are pretending that bad commit messages are the result of retaining commit history.	eurasiantiger	8.598127	-6.5415626	comment	3.0	28.0	1664613892	-11.90622
33058799	Programming in the past was far easi	Programming in the past was far easier, you had better tools, like Visual Basic, and Delphi. They had excellent built in documentation, with working code examples. Delphi even included an installation builder, for bundling your program. It all just worked. Your program would run in any Windows environment you or your customers were ever likely to use.For the most part, those programs written with those tools still work.Today everything is update on the fly, and subject to random breakage. GIT is better, everything else has gone downhill.	mikewarot	8.664765	-6.4647136	comment	3.0	11.0	1664735538	-12.0150385
24751373	Next up for anyone willing to take t	Next up for anyone willing to take the bite: Build a unified for CLI for Mercurial and Git. It's a challenge but it's worth it :)	xixixao	8.527176	-6.532614	comment	3.0	10.0	1602476678	-11.950461
24760555	It's not fair to complain about how 	It's not fair to complain about how hard a tool is to use without comparing it to the alternatives. If git is a failure as claimed then the alternatives should be better, no? We have a list of known version control software [0], how many of these are better than git and how many are worse? I've heard Mercurial and Fossil are pretty good but I still haven't been pressured to give them a try. However, most of that list is filled with software people hated enough to ditch for git.I think it's very likely that git is solving a problem hard enough that it can't be simplified much further. If it can be simplified, I would expect to hear a growing minority of users pushing for people to switch to the next system.[0]: https://en.wikipedia.org/wiki/Comparison_of_version-control_...	neckardt	8.560177	-6.47377	comment	3.0	19.0	1602544003	-11.884782
24760752	Git the plumbing is a huge success s	Git the plumbing is a huge success story. Merkle trees, distributed development, lightweight branching, format so simple you could literally write tooling for it as a bunch of shell scripts–it's really great.Git the porcelain is terrible, and while I wouldn't call it a failure its user experience is a detriment, not an asset, to its overall niceness.	saagarjha	8.672428	-6.454722	comment	3.0	10.0	1602545944	-11.811149
24760912	Git is a success. Claiming otherwise	"Git is a success. Claiming otherwise is silly.Git's user interface (porcelain) is not a great thing. Not because it's a CLI, but because it's not great for non-power end users.Case in point: Lousy naming inconsistencies. Git supports a staging area, but sometimes calls it a staging area & other times calls it an index. ""Index"" is a terrible term, because the word has too many other meanings. It's time for them to use one term (""staging area""); the inconsistency makes things harder to explain & use.Git is excessively complicated for simple uses, and it's easy to go wrong. Otherwise there wouldn't be sites like https://ohshitgit.com/ and cartoons like https://xkcd.com/1597/Mercurial (hg) shows that it is possible to have a distributed version control system with a simpler and clearer UI.Git "	dwheeler	8.558758	-6.500509	comment	3.0	12.0	1602547207	-11.890082
24760765	Git is not a success story?I wonder 	Git is not a success story?I wonder if the author of this tweet is aware that Git has almost entirely conquered the development world these past few years. That doesn't happen as a result of having a bad user experience.Git is a powerful tool that does an excellent job of versioning and collaboration, and I can't imagine wanting it to be any more user friendly than what it currently is.	jasoneckert	8.531019	-6.4472575	comment	3.0	17.0	1602546041	-11.887382
24864226	Hard parts:- It's Markdown, not Word	"Hard parts:- It's Markdown, not Word- Finding an editor that felt comfortable. (BTW, iA Writer is awesome for this.)Easy parts:- ""You never have to care about formatting again!""- ""Two people can edit stuff at the same time and we can work out the differences later, instead of playing the 'who has the most recent version?' game.""- ""Look, you just write text and a nice document with logos pops out the other side, and all of the documents look nearly identical without even trying!""- ""Git shows you the full history of every line of this file.""- ""Hey, cryptographic signatures you can use to irrefutably prove the history of the document!""- ""This 'pull request' thing in GitHub shows you exactly the changes you made, like 'track changes' except they're all in one place!"""	kstrauser	8.647902	-6.47802	comment	3.0	13.0	1603407687	-11.83376
24885607	You can’t decentralise issues and pu	You can’t decentralise issues and pull-requests.Edited: as pointed-out, Fossil supports decentralized issues (but not PRs). However, Fossil is a totally different system than Git.	hk__2	8.498158	-6.4791317	comment	3.0	10.0	1603627069	-11.900596
24908674	Git filtering mechanism isn't intend	Git filtering mechanism isn't intended to be used the way Git LFS has used it	rmedaer	8.570174	-6.444331	story	3.0	9.0	1603814175	-11.913124
24921226	But you don't force push with Gerrit	But you don't force push with Gerrit?Just update your change set, then push to refs/for/<branch_name> again.	depressedpanda	8.572943	-6.5247574	comment	3.0	14.0	1603904588	-11.892889
24922308	> I think git in general should copy	> I think git in general should copy the approach of Fossil and include issue management and wikis along with the repo, to keep things consistent and avoid vendor lock-in.A few paragraphs I recently wrote elsewhere:The entire state of code forges as a general thing in 2020 is all the evidence you could possibly want that version control systems (Git, I'm talking about Git) are themselves massively deficient in design.I rant about this all the time, but there is an entire class of argument about how & whether to use GitHub / GitLab / Gitea / Phabricator / Gerrit / sourcehut / mailing lists / whatever that would mostly vanish if the underlying data model in the de facto standard was rich enough to support the actual work of software development.  Because it's not, we find ourselves in a situ	brennen	8.574929	-6.490324	comment	3.0	12.0	1603909444	-11.901702
24976987	Forgetting to run the formatter befo	Forgetting to run the formatter before git committing is not that big of a deal.	ampdepolymerase	8.592048	-6.4989524	comment	3.0	13.0	1604385392	-11.833297
24981385	I am in the process of migrating a c	I am in the process of migrating a client’s CI to GA and have seen rough edges.One example is there is no native way to serialize workflow execution. This means if you run two commit-based triggered actions in quick succession, you can have tests pass that should not. (They run against the wrong checked out code!)I had this happen in front of the client, where it appeared a unit test of assertTrue(False) passed! It was so undermining of GA I had to chase down the exact status and prove ability to avoid (using Turnstyle) to the client. I wrote an email to the GA team specifically telling this story and expressing my concern.Another is scheduled actions, where even if you specify a cron, the action has a window of several minutes when a GitHub runner will execute it, and there are cases wher	bredren	8.631734	-6.4514575	comment	3.0	11.0	1604422568	-11.907771
25002135	> Git will be hard to beat.With the 	> Git will be hard to beat.With the latest kurfuffle at Github, I've started moving to fossil. Having everything, wiki, pull requests, etc. as part of the repo is looking like a good move.Why let yet another corporation have control over something they should have never been given?https://fossil-scm.org	minerjoe	8.507772	-6.5183463	comment	3.0	23.0	1604611464	8.714368
25002686	Good luck. I mean that.Git isn't per	"Good luck. I mean that.Git isn't perfect, but I've been using version control since Apple Projector (in the late 1980s), and Git has done the best for me. I've been using it for many years.I don't miss Projector one tiny bit.VSS (Visual SourceSafe) was a dog. It was direct file-based, and server connections would get very busy. It was the old-fashioned kind, with the need to check out files.But it had one very cool feature: You could create ""aliases"" of repo components; essentially creating a virtual repo that pointed into several other repos, taking just a couple of files from each.I could see how that would be a technical nightmare to implement, but I like it a lot more than ""the whole kit & kaboodle"" approach that Git takes.I also used Perforce for many years. It was a robust and depend"	ChrisMarshallNY	8.587435	-6.444298	comment	3.0	15.0	1604614635	-11.858433
25002939	I think all git has going for it is 	I think all git has going for it is its existing inertia and GitHub. I think the foundations were a bigger deal when git was newer. Other DVCSes have decent foundations.Going against git is an atrocious user interface (if it were good then [1] would be neither funny nor sad). Most people just memorise a few commands and if they stop working they transfer their changes elsewhere, delete the repo, and start again. Sometimes a team will have a “git expert” who has merely memorised a few more commands and is better able to get a repo out of a broken state. Git fails badly at an important for a developer tool: largely getting out of the way.[1] https://git-man-page-generator.lokaltog.net/	dan-robertson	8.545311	-6.4721637	comment	3.0	15.0	1604616521	2.9744687
25003421	When I interviewed Jim Blandy, the c	When I interviewed Jim Blandy, the creator of Subversion, he said one of his mistakes was trying to be clever with merges. In Git a merge is whatever you say it is and that is actually probably the flexibility that people what.Is that where the innovation is here, Darcs style patch sets?	agbell	8.609979	-6.498861	comment	3.0	13.0	1604620500	-11.8629875
25002316	Soaking as someone who is completely	"Soaking as someone who is completely unfamiliar with Pijul, the explanation on this page is pretty lackluster.""It is based on changes rather than snapshots""Well, every VCS I'm familiar with is based on changes/deltas. I assume that these terms have specific meanings here that I'm not familiar with, but it manages to sound like the author has never heard of git or Mercurial."	wtracy	8.592143	-6.558828	comment	3.0	10.0	1604612469	13.891227
25002762	I’d take a new git with just the UX 	I’d take a new git with just the UX fixed. If the underlying implementation of a new VCS is also better, that’s great, but my main problem with git isn’t that it’s not sound but that the UX is a steaming pile of legacy cruft, and it’s really more an API for version control than a polished interactive app for humans.	alkonaut	8.582196	-6.4711404	comment	3.0	12.0	1604615123	-11.87949
25003540	> Git will be hard to beatIf I were 	"> Git will be hard to beatIf I were the Anu people, I would focus on having a seamless compatibility layer that could manage Git <-> Anu repositories (there are undoubtedly many headaches that would occur synchronizing the two different models). This would allow developers to silently interact with ongoing git repos using the ""better"" tool. Getting wholesale migration to a new platform seems a significant challenge, but allowing developers to slowly build mind share with an improved workflow would be possible.Disclaimer: I hate git."	5d749d7da7d5	8.539663	-6.443371	comment	3.0	10.0	1604621613	-11.848869
25004897	Slightly off topic - can we use git-	Slightly off topic - can we use git-diff-able databases for faster syncing of clients with servers?Or is there no practical difference?We can return just the latest updated documents by maintaining a lastUpdated timestamp on client and server docs. But this would be at a document level. So, only the fields that have changed would be sent to the client.	dreamer7	8.639609	-6.500774	comment	3.0	12.0	1604636873	9.6945915
25005799	This might be a silly question, but 	This might be a silly question, but is there a reason why git can't also diff binary files? If I have a huge binary file and I change a few bytes in the middle, what's stopping Git just checking that in as a diff? I don't see what's so special about text...[edit] just did some research and it looks like Git will store the delta of a binary file in its packfiles, just like a text file. The question is just how delta-able sqlite binary files are.	framecowbird	8.615886	-6.4918613	comment	3.0	10.0	1604648257	-11.842
25044544	I personally only use stashes when I	I personally only use stashes when I've given up on my current approach and want to reset but I might change my mind later (rarely happens). I don't think they're appropriate for stuff you want to keep across branches, there's no real visibility and they'd be easily forgotten.	gtsteve	8.5736265	-6.5485206	comment	3.0	11.0	1605005361	-11.946652
25044991	> You could commit and rebase and al	"> You could commit and rebase and all sorts of clever mangling of the history.
> OR you could use the right tool for the jobStashes are just another form of DAG node with their own special syntax and commands and quirks.  I've already learned one set of commands for all that, why learn a second, less general set of commands?I have started using stashes in one very specific case:1.  I realize I'm on the wrong branch
2.  I've made no commits
3.  The right branch has changes to files I've modified    git stash push
    git checkout -b newbranch upstream/right
    git stash apply
    ...verify...
    git stash list
    git stash drop [id]

Careful and safe, but not actually much faster than my old workflow, and I haven't the foggiest idea how to fix things up with stash if I've made several co"	MaulingMonkey	8.577824	-6.54907	comment	3.0	11.0	1605009573	9.397943
25045265	The issue is that Git sucks at rebas	The issue is that Git sucks at rebasing. Every conflict you fix when rebasing will need to be fixed again next time you rebase.	gwenzek	8.581325	-6.5617104	comment	3.0	10.0	1605011785	-11.926078
25045678	"Does anyone know how to make this ""c"	"Does anyone know how to make this ""cactus"" workflow work better on github?We use it in our organization and between us we know to always manually rebase before merging. However, when we receive an external PR from someone else it's a pain. It's also easy to accidentally forget to rebase before merging."	ufo	8.589279	-6.541475	comment	3.0	14.0	1605014996	-11.849079
25090477	Why renaming Git’s master branch is 	Why renaming Git’s master branch is a terrible idea	h1x	8.521123	-6.524916	story	3.0	12.0	1605331081	-11.710105
25102831	At the time, Steve agreed to share t	At the time, Steve agreed to share the email transcript from this incident:https://paste.sr.ht/~sircmpwn/5f6ae83ffc961215cb82f1a98f78a0...Judge for yourself if we were out of line. Steve's repository was basically an archive of his Instagram account, hundreds of high-resolution images. This is not what SourceHut is designed for. Mercurial repositories in particular have an outsized impact, because we generate nightly clonebundles from larger repos, and because images are uncompressible this results in a disproportionately large amount of wasted CPU time and disk space.We updated our approach, in any case, to use the following email template instead:https://paste.sr.ht/~sircmpwn/3d32eb7bbc564170c3d30f041e5e8d...And we expanded on acceptable use in the documentation:https://man.s	ddevault	8.486872	-6.501639	comment	3.0	15.0	1605460957	-11.967802
25121624	I would also love to get some recomm	I would also love to get some recommendation on git. I'm using the github desktop gui atm (very new to this world), but I'd like to start learning git. it is kinda intimidating.	funtkungus	8.55142	-6.466934	comment	3.0	10.0	1605604834	-11.873223
25122549	So this, to me, is not a 'benefit of	So this, to me, is not a 'benefit of git' it articulates in some ways how bad it is (although very powerful).Most people can get going with those 99% commands quite quickly, the problem with git is any move from the known path creates some pretty amazingly complicated scenarios.And those '1% of the time' commands blow up into time-consuming rabbit holes of complexity. Often, Stack Exchange has several answers for the same question, highlighting just how much inherent complexity there is in the product.Managing software versions across repo can be a very, very complicated problem. Git provides you with a pile of tools to do 'almost anything'.A 'well designed product' would make the toolsets and concepts focus heavily on the 'main operations' and then have clear, clean rational idioms, pract	jariel	8.556061	-6.474275	comment	3.0	12.0	1605612968	-11.895184
25122429	> I probably could sit down for a co	"> I probably could sit down for a couple of days and fully understand how git worksThis means it isn't hard. If you are capable of understanding algorithms of any complexity you should be able to learn how to use git (and how much of it) without treading on ground that is dangerous for you to use. All of this ""it's too hard"" rhetoric is infantilising or coddling people who frankly shouldn't be trusted to code anything of importance anyway. There's no shame in admitting your own limitations, but there is definitely shame in lowering the bar for others so much you are actively harming the industry."	krageon	8.540426	-6.494144	comment	3.0	41.0	1605611917	-11.906703
25122681	Everyone starts at the ground floor.	Everyone starts at the ground floor. What would you tell a beginner who has to figure out 20 different technologies including git to get a basic web project going?Besides, nobody is arguing git needs to be made weaker, just that it would be nice if it had a more gradual learning curve. Easy things easy, hard things possible. If you can’t see how git is hard you’ve forgotten what it is like to be a beginner.	Joeri	8.534801	-6.4951377	comment	3.0	10.0	1605614061	-11.847838
25122700	Imagine SQL databases worked exactly	"Imagine SQL databases worked exactly like they do now under the hood, but instead of current SELECT/UPDATE/INSERT/DELETE they used like 15 different commands with at least 4 switches each.So instead of SELECT you'd have FETCH, PULL, CHECKOUT, CLONE, READ, PEEK, and OBSERVE. And each of them could in some cases also modify or even delete the data depending on the switches.Imagine there was no division between DML and DDL - you just have to remember which option switches change the schema in addition to doing some other things.And then people would say ""SQL is very simple, just learn relational algebra"".That's how I feel about git :)With SQL I know for sure I can't break the database by doing a select. I know I can't change schema by doing a DML.With git I'm pretty sure I can't break anythin"	ajuc	8.672528	-6.52142	comment	3.0	14.0	1605614173	-11.8198595
25122845	Why can't there be an equivalent of 	"Why can't there be an equivalent of stash that keeps track of which parts were added and which weren't?If switching branches wouldn't conflict with my current change, why do I have to stash/checkout/unstash instead of just doing it?Why can't I pull without fetching?Why will none of the 5 or so push configurations just do ""push the current branch to the branch of the same name on the remote""?Why is there no way to stop git from setting master as the upstream every time I do git checkout -b myfeature origin/master?Why do I have to detach from a branch before deleting it?None of this stuff is inherent to the problem or due to being a precise model of things; quite the opposite."	lmm	8.576691	-6.542734	comment	3.0	13.0	1605615253	9.296824
25123020	While this sounds all nice it actual	While this sounds all nice it actually fails to model Git as it is. Git is an object database and its objects are blobs, trees and commits not diffs, so your premise is based on a misconception.	matthiasv	8.590112	-6.514397	comment	3.0	38.0	1605616558	-11.857584
25123079	I’ve had to use perforce before and 	I’ve had to use perforce before and was not a fan. Granted, I didn’t have to use it full time and can’t claim to be an expert, but I hated the notion of locking files, change lists, yuck. All of it felt so clunky compared to git.	eloisius	8.588594	-6.5120587	comment	3.0	10.0	1605617063	13.831219
25123442	The JetBrains merge tools are the be	The JetBrains merge tools are the best ones I've found!I have it configured as my git mergetoolThe only problem is it takes absolutely ages to start up, which is maybe a JVM thingI wish there was a way to have git pass all of the conflicting files in a merge to the mergetool at once. Instead of having to wait for JetBrains to load up for each individual file and close after each one :(	anentropic	8.684308	-6.4985127	comment	3.0	14.0	1605619524	-11.858888
25123480	Nothing has stopped anyone from crea	"Nothing has stopped anyone from creating this perfect GUI(or better CLI) for Git that a lot of people seem to be missing.""Show me the code"". Or in this case show me the GUI.Maybe the problem is just actually hard and the Git we have is the best current solution."	toopok4k3	8.574542	-6.4942617	comment	3.0	12.0	1605619797	-11.87008
25123526	You should, or do you just merge upd	You should, or do you just merge updated remote branches into your stale local branches? A lot of new developers seem to do that here until we explain to them how it messes up the history.	aeyes	8.56694	-6.5649533	comment	3.0	10.0	1605620076	-11.898233
25123549	Fair enough. The blob stores a diff.	"Fair enough. The blob stores a diff. The commit stores a reference to... the diff. This is a division between the concept of the object and the implementation. But it's not an example of a diff-storing model failing to model git as it is; git as it is is storing diffs.If a commit references a ""blob"", and the ""blob"" that it references is, in fact, a diff, why would we say that the commit ""does not reference a diff""?"	thaumasiotes	8.613598	-6.537498	comment	3.0	10.0	1605620219	10.328895
25124386	No it's not.If you're a dev/SWE you 	"No it's not.If you're a dev/SWE you should be able to grok a semi-complex CLI API to control software... but the further the world gets into ""everything as UIX"" and ""everything has to be 'easy'"" the more we stray from incredibly powerful, immediately available CLI tooling.I know of too many highly-paid people who literally refuse to learn the CLI `git` or `docker` and limit themselves/skillsets by doing everything through the comfort of a UI. To me, it's a mark of laziness.Git isn't ""too hard""... it solves an incredibly complex problem. It has a lot of capability and complexity under the hood to deal with all of the craziness of distributed development paradigm."	folkhack	8.583976	-6.4946785	comment	3.0	13.0	1605625059	-11.867552
25125255	> You really believe that git stores	"> You really believe that git stores -- in full -- every version of a tracked file?Yes, it does.> Every commit that deletes the whitespace from an otherwise empty line in a 30KB file is another 30KB of hard drive spaceYes, it is.""It's worth repeating that git stores every revision of an object separately in the database, addressed by the SHA checksum of its contents. There is no obvious connection between two versions of a file; that connection is made by following the commit objects and looking at what objects were contained in the relevant trees. Git might thus be expected to consume a fair amount of disk space; unlike many source code management systems, it stores whole files, rather than the differences between revisions. It is, however, quite fast, and disk space is considered to be c"	cesarb	8.601759	-6.46052	comment	3.0	11.0	1605628756	-11.909108
25126001	Why is small frequent commits a good	Why is small frequent commits a good practice? What is to be gained from committing a change to a file, then a commit to undo the previous one if you decide the change wasn't useful/needed?Also, cherry is often needed daily in short bursts around releases.Blame is rarer, absolutely, but I don't think you're using your version control to anywhere near its full potential if you don't use blame (and log) while investigating complex bugs.	simiones	8.586811	-6.5342817	comment	3.0	11.0	1605632046	-11.907333
25126750	I think you're missing the forest fo	"I think you're missing the forest for the trees here. The point of version control systems is to make developing software easier. It's a tool that exists for the convenience of its users. It's reasonable for people developing software to ask for the ability undo a change or restore a repository to the way it was a second ago. Telling a team of people using Git ""it doesn't work like that"" is unhelpful because it's not impossible for a version control system to work like that and the point of any software is to help them do what they're trying to do.This doesn't mean that Git has to accept any feature under the sun and it might be that Git isn't most appropriate tool for teams that want such a feature. But there's nothing holy or fundamental about an implementation detail of how Git does thi"	Spivak	8.577119	-6.4792085	comment	3.0	10.0	1605634817	-11.876501
25188194	Store all those things as text and y	Store all those things as text and you can stick them in git	tomc1985	8.5491	-6.4381742	comment	3.0	12.0	1606147617	-11.889045
25237865	The issue I run into with this comes	The issue I run into with this comes part of the code review.So some developer is going to fix some code, and the code is ugly. So the developer fixes the bug and makes the code prettier and push it as a single commit. I am then left with figuring out which changes are related to the bug fix and what is related to the cleanup.If I tell the developer to first fix the bug and then cleanup in a separate commit, it may be inefficient since the fix after cleanup may not be the same as fix before cleanup. It may also lead to the cleanup being skipped because his work is technically done after the fix.If I tell him to cleanup first and fix later, it's also seem to lead to issues since the developer has typically already figured out how to fix it since he came into the code with the mindset of fix	tuwtuwtuwtuw	8.579454	-6.5281577	comment	3.0	12.0	1606575280	2.8735986
25247300	Is there any hope in Pijul of _any_ 	"Is there any hope in Pijul of _any_ kind of interoperability with git at all?Back when there used to be some projects still stuck on svn that I wanted to work on, I was able to use git locally and just kind of ""publish"" via svn when I was done.Would anything like that be possible? That'd be the killer thing for me to be able to give Pijul a real try."	kadoban	8.595151	-6.552004	comment	3.0	10.0	1606677755	13.8908825
25330082	Have I been working in a bubble?I'll	Have I been working in a bubble?I'll give a coworker a hard time for making large infrequent commits, but I've never seen someone afraid to commit code.  This sounds like the value proposition for version control hasn't really clicked for them.Are they comfortable branching?	reificator	8.577089	-6.4973807	comment	3.0	11.0	1607326240	-11.892433
25333246	A couple from my pet peeve list -1) 	A couple from my pet peeve list -1) ATOMIC COMMITSNothing worse than a single commit, to address 10 separate comments. I don't want to have to go back, and cross reference my comments with your wall of changes2) DO NOT SELF RESOLVE A COMMENTWait for the reviewer to checkout your solution, I want to learn through your fix, aswell as make sure it's what I expected.	nullandvoid	8.580349	-6.507342	comment	3.0	12.0	1607355965	-11.903279
25402003	That pipeline sure does look conveni	"That pipeline sure does look convenient. Let's see how it will handle a path with spaces.  $ git status -s | grep '^ D' | awk '{ print $2 }' | xargs git checkout --
  xargs: unmatched double quote; by default quotes are special to xargs unless you use the -0 option
  $ git status -s                                                          
   D ""g h i""

I'd be lying if I said I was surprised, to be honest."	kaszanka	8.625159	-6.527176	comment	3.0	14.0	1607809376	-11.7284775
25459001	Conceptually, a git commit is a snap	Conceptually, a git commit is a snapshot. Simple as that. The user doesn't need to worry about how git manages its data internally.> I believe that Git becomes understandable if we peel back the curtain and look at how Git stores your repository data.This strikes me as misleading in the same way this StackOverflow answer [0] is misleading. In terms of how git stores data, commits are not always snapshots. Internally, git sometimes uses delta compression to reduce storage space. This is of no concern to the user, conceptually a commit is still a snapshot, but it's just not true that git naively stores each commit as a full snapshot.Peeling back the curtain isn't helpful to someone trying to understand the basic git model. Also, as the article makes no mention of delta compression or of 'pac	MaxBarraclough	8.592825	-6.519406	comment	3.0	11.0	1608231833	10.285086
25459046	Why does thinking about commits as s	Why does thinking about commits as snapshots make cherry-pick and rebase easier to understand? I've always thought of and taught commits as diffs because git does a good job of abstracting away the distinction.EDIT: To be clear, I think this is one of the _few_ abstractions that git doesn't leak. It does a pretty bad job everywhere else.	phailhaus	8.580066	-6.538931	comment	3.0	19.0	1608232015	10.358932
25460698	There's nothing intrinsically superi	There's nothing intrinsically superior about storing commits as diffs - subversion stores its commits as diffs (or at least, it did a decade or so ago,) and I haven't heard anyone enthusing about svn in a long time.	ldite	8.58917	-6.4851947	comment	3.0	14.0	1608240580	-11.890074
25461095	I wonder if this is why Mercurial is	"I wonder if this is why Mercurial is so much simpler and easier to understand than Git -- precisely because Git was forced to adopt a more ""out there"" approach. Personally I'm sad Git won out over Mercurial -- the latter is a much better technology from my experience."	feoren	8.512621	-6.543438	comment	3.0	16.0	1608242497	-11.937581
25460892	A fascinating bit of history is that	A fascinating bit of history is that the reason for this data structure was to explicitly distance git from BitKeeper.BitKeeper was used by many kernel developers, until one of them (the co-inventor of rsync, unsurprisingly) reverse-engineered its protocol, leading its proprietary owner to end its offer of a free license to Linus Torvalds and other developers.While searching for a replacement, the Linux community sparked two projects: Mercurial (which uses changesets, similar to BitKeeper) and Git (which uses Merkle trees). Git was created by Linus in the unexpected free time that this event created; and he mentioned being weary of Mercurial and having adopted this design for Git to remove any ambiguity that they were creating a BitKeeper clone.Incidentally, BitKeeper did demand that its c	espadrine	8.555917	-6.5108495	comment	3.0	29.0	1608241475	-11.925742
25465385	I don't know about ponies, but for s	"I don't know about ponies, but for snapshots, I disagree: snapshots don't model diffs properly, and many operations in Git are essentially trying to simulate patches:- Merge and rebase both try to ""replay"" patches. But because Git doesn't work with patches, it actually only simulates that, using heuristic algorithms such as 3-way merge. This works most of the time, but not always (see https://pijul.org/manual/why_pijul.html).- Conflict resolutions in Git cannot be modeled as patches, and you need `git rerere` to simulate that. This is not anecdotal, since conflicts is the one situation where you need the best and most intuitive tool.- Short-lived branches are another poor simulation of patches: if Git were really working on patches, you would be able to create a branch ""after the fact"", me"	pmeunier	8.602271	-6.559562	comment	3.0	10.0	1608283908	13.91046
25464819	Our company will never transition fr	Our company will never transition from SVN to Git because the transition tools fail on our ancient SVN repo. Learn from us: switch now because switching later may not be an option.	jimbob45	8.567804	-6.468173	comment	3.0	13.0	1608277653	-11.881493
25467744	I'm sure many will come down hard on	I'm sure many will come down hard on my comment and disagree. But speaking as someone who teaches at a university and also works in industry and is involved in hiring, I don't think becoming an expert in git is worth your time. At this stage in your career you should spend your time mastering algorithms, data structures, and a compiled language like Java or C++. I would put emphasis on learning how to use your language of choice idiomatically (e.g., iterators, streams, the standard library and its core data structures, etc.). In my experience, the best way to do this is practice Leetcode every day. Doing one question a day (a 30-60min commitment) will put you leagues ahead of your peers. Combine this with reading a major book on your language (e.g., Effective Java or Modern C++ Design, etc	smiths1999	8.522745	-6.4920526	comment	3.0	13.0	1608303908	-11.920525
25515660	> What's more troubling is that git 	"> What's more troubling is that git can't do some very basic stuff well, like merging branches. I mean you can do the merge, but good luck trying to revert it[+] or trying to get git to deal intelligently with non-linear history in general.IME Git handles non-linear history pretty well. AFAICT any DVCS will inherently have the same problem; you can't necessarily memory-hole the fact that the merge has happened because other people may already have your merge. What are you claiming is the ""right"" way to handle that case?> In theory it would be possible to work around that by everyone agreeing on a canonical first commit to start each repo with, but in practice that's of course unlikely to happen.I believe there is a known commit hash that's there in the datamodel. So it would be possible to"	lmm	8.57819	-6.537634	comment	3.0	34.0	1608712367	-11.898052
25527170	Yep, SVN is simpler and easier for s	Yep, SVN is simpler and easier for single developer / simplistic projects.  GIT is much easier for larger multi developer concurrent development.I like being able to commit while I am on a plane. (Not that this happens everyday, it’s more about the orinciple)	zadokshi	8.575831	-6.494539	comment	3.0	15.0	1608815859	-11.891461
25527327	>> until you start branching and mer	>> until you start branching and merging a lotSVN has 3 way merge too so this isn’t the issue it was in other VCS’s>> The problem is all the drawbacks of trunk based developmentThose were all addressed reasonably well by about 2014, e.g. upsource (my preference by far) or crucible. TeamCity’s merge after private build feature etc.Ironically these days i see a big push to use git in a way that would work pretty well in svn too.The biggest hassle with svn was long lived branches. Back then we encouraged devs to branch and then somehow smoosh it all back together (painful). Then we said ok do it more frequently in atomic commits (i liked that model) then DVCS took off largely in the open source world and now major dev houses (well i guess except google with p4 - but they do provide a git inte	CraigJPerry	8.584214	-6.5170574	comment	3.0	10.0	1608817179	-11.890446
25528703	It takes about an hour to read and u	It takes about an hour to read and understand that documentation and I highly recommend doing so. And once you do git becomes far more intuitive. The key concepts to understand are commits and refs. To a first approximation a branch is just a variable ref and a tag is a constant ref. A commit is a node in a generally sparse upside down tree and refs are pointers to said nodes. Once one realizes that then pretty much everything makes sense. For example the difference between rebase and merge is how they affect the structure of the commit tree.	User23	8.555309	-6.5267243	comment	3.0	10.0	1608826350	9.757504
25536290	This is also my biggest issue with G	This is also my biggest issue with Git. And integrated/streamlined support for large files.	amelius	8.576128	-6.438869	comment	3.0	26.0	1608902272	-11.850226
25539672	The former, until you run git gc, in	The former, until you run git gc, in which case the latter happens.	glandium	8.539049	-6.4602637	comment	3.0	24.0	1608936523	-11.874127
25564882	Not sure if Stow fixes these, but he	Not sure if Stow fixes these, but here are some problems I've had with that setup:1. If you want to delete a file, you have to delete it (rm) in one place and delete it another way in another place (git rm).2. Adding a new file in-situ (in the home directory) requires some finessing to get it back into the git repo and symlinked properly.3. No easy way to apply a rename operation.4. After changing the checked out branch, there is no easy way to apply these changes to the home directory.	ironmagma	8.537647	-6.5439386	comment	3.0	16.0	1609199922	-11.902863
25627733	> There are step-by-step instruction	> There are step-by-step instructions in the comments explaining what's going on.This is a big red flag. As everyone has been saying since decades, comments are for the why, not the what.Also, recall should be upper bound to the time it takes to find the relevant commit message. Having to actually recall from my brain why something was done is a terrible way to work: presumably at most two people in the original group know why, the people may not even be there anymore, and recall is far from perfect.	l0b0	8.582326	-6.5714164	comment	3.0	12.0	1609731725	-11.91196
25649168	Git is a distributed system, so even	Git is a distributed system, so even if you lose access there isn't a huge data loss.	rubatuga	8.537971	-6.4496384	comment	3.0	14.0	1609872094	-11.89146
25662744	>but every commit will replace entir	>but every commit will replace entire module(s) flawlesslyThat's big commits, you're not supposed to do that. Masters commit individual characters that replace entire modules flawlessly.	whatshisface	8.603965	-6.5627894	comment	3.0	10.0	1609968431	10.265687
25676432	They could very well be using Git in	They could very well be using Git internally. But they don't want to release the full history of their development process, complete with authors, commit messages, and intermediate commits -- that's likely to include or imply a lot of information that isn't appropriate to release.	duskwuff	8.548343	-6.4479156	comment	3.0	12.0	1610049417	-11.868257
35697433	Up to about 10 years ago I used to w	"Up to about 10 years ago I used to work on projects where up to 100 people (of those about 20 coders, the rest artists and designers) committed directly into the main branch without a formal review process, and it was ok (this was with SVN though).Code review happened informally ""after the fact"", usually as the first thing in the morning when updating (each person simply looked through the changes of other people in the part of the project they felt responsible for - usually those changes were no surprises because people talked to each other before doing this).""Post-commit"" breakage was surprisingly rare, and when it happened it was quickly fixed. One just was a bit more careful checking for errors before committing changes.I cannot imagine how this scenario could work with git though."	flohofwoe	8.581213	-6.48891	comment	3.0	14.0	1682406698	-11.882546
35811996	First: This is not an attack on youI	First: This is not an attack on youI have such an issue with this response because it just seems like “you’re holding it wrong”  a la the iPhone “scandal” where apple attempted to blame an engineering flaw on its usersI would imagine most people’s use case (mine certainly is) for RxJS boils down to “call a JSON API and receive a response”.  That shouldn’t be a hard problemImagine if someone complained about the complexity of Git and the answer was to “write your own DVCS”The entire point of abstractions is that I don’t need to understand what’s going on underneath them	JohnCurran	8.542327	-6.4376383	comment	3.0	12.0	1683182495	-11.908777
28670017	I worked on a Tensorflow feature in 	I worked on a Tensorflow feature in 2018. There was no branching involved. Fork the main repo, build the feature on your child repo, make sure all unit tests pass and then send a pull request to the main/master of the parent repo. Typically someone reviews the code, you incorporate code review comments, pass all unit tests, CI-CD pass, PR approved. That's it. Your code is in the next production cycle.So yes, you work locally on a fork of the repo but not the main/master repo. I'd surprised if all devs have access to push to main/master.I think having branches leads to a lot of merging issues. Because technically, the branch will then be used by multiple devs. So it's like dealing with multiple masters, kind of.Personally, I prefer the TF approach. Oh I forgot to mention, the release tags a	deepGem	8.584397	-6.5038614	comment	3.0	12.0	1632746935	-11.894239
28672017	Any workflow that involves breaking 	"Any workflow that involves breaking master for everyone seems broken at some level.Not saying I have a better solution off the top of my head, but ""just fix it with another commit"" is a big red flag IME."	pc86	8.596052	-6.5341215	comment	3.0	11.0	1632757102	-11.937376
28673386	I don't see how this could ever work	I don't see how this could ever work on evolving languages, different GIT versions would produce different commits and read commits differently based on the latest C++ standard. This would potentially lead to version control bugs where different GIT versions creates different results from the same commit, that is horrible, version control needs to be 100% bug free in that regard.The only reasonable application would be to use a language AST parser to better identify relevant text diffs, but the commits still needs to be stored as text.	Jensson	8.663328	-6.49047	comment	3.0	10.0	1632762801	-11.807128
28683470	I'm curious what devs are doing abou	I'm curious what devs are doing about this right now. Sometimes I'll pull and BAM gross merge conflicts. Is there a git command I could run first? A workflow to adopt? I feel like some new tool from an academic paper will never make it into my toolbox.	bckr	8.61672	-6.522554	comment	3.0	14.0	1632840526	-11.848488
28758028	Oh I meant the opposite - a 'what' d	Oh I meant the opposite - a 'what' description (bad) being just an English re-run of the code in the commit ('add missing indentation') vs. 'why' that explains what problem it fixed/feature it added ('fix syntax error on navigating to page blah').I meant that a good 'why' commit subject that gets propagated to release notes is more likely helpful to an end user - ooh nice yes I have had that problem, cool it's fixed, I don't care exactly what fixed it.	OJFord	8.599956	-6.527109	comment	3.0	16.0	1633433909	-11.912873
28801246	What I really want to see is a blog 	What I really want to see is a blog post on Git as an undo engine.This is related to the idea of using Git as general storage, in that the undo history can be persisted, and then reconstituted by a new process.  The trick would be to make all actions compatible with conversion to and from a commit.	rectang	8.581146	-6.5159745	comment	3.0	15.0	1633711169	-11.806631
28801995	How feasible is it to store raw cont	How feasible is it to store raw content in the Git content-addressable-store (CAS)?  Git blobs are Zlib compressed.I'd like to be able to store audio files uncompressed, so that they could be read directly from the CAS, rather than having to be expanded out into a checkout directory.	rectang	8.570744	-6.446164	comment	3.0	17.0	1633715314	-11.940607
28845038	"It is not yet possible ""to create a "	"It is not yet possible ""to create a git commit that has the exact same hash as another git commit"" in the sense that if someone else has already done a commit you can make another commit with the same hash.What is possible now is something that is much easier: if you have enough money and time, you can create 2 commits with the same hash, which start with some different parts, which may be chosen arbitrarily, then they have to include some parts that must be computed to ensure that the hashes will match and which will be gibberish that might be disguised in some constants or some binary blob, if possible.Then you can commit one of them and presumably you can later substitute the initial commit with the other one without anybody being able to detect the substitution."	adrian_b	8.638207	-6.5040827	comment	3.0	21.0	1634072546	7.178727
28847571	Commits aren't patches. They contain	Commits aren't patches. They contain the whole tree. Retroactively changing a commit can't possibly introduce conflicts with other commits on top of it, the worst it can do is introduce big funny-looking diffs.	sirclueless	8.604451	-6.510765	comment	3.0	11.0	1634092252	-11.8717
28890301	"""man git"", second paragraph."	"""man git"", second paragraph."	mid-kid	8.548039	-6.472199	comment	3.0	17.0	1634409853	-11.896026
28891293	Lots of exclusively technical types 	Lots of exclusively technical types don't understand why people are confused by heavily documented but awful interfaces. That's why HFE became a field and why UX practices should inform software development from the get-go.Documenting a lousy interface is not a solution— it's a mitigation strategy and usually a lazy one. Most people find git's interface to be confusing, arbitrary, and frequently astonishing in destructive ways. Maybe you're exceptionally gifted in keeping a large bank of seemingly arbitrary commands in your head, or maybe you speak git frequently enough to have native proficiency. Unfortunately, you can't generalize that to all other users, and it doesn't invalidate their difficulty.Since most folks new to git are likely new to CLIs— having a tutorial two levels deep in ma	chefandy	8.516716	-6.5386496	comment	3.0	17.0	1634416864	-11.915792
28891382	Are there any good CLI wrappers over	Are there any good CLI wrappers over Git that make it more accessible and consistent? The only one I know of it Gitless and it looks like development on that has stopped. (Also I don't know if it's actually considered good)	ziml77	8.571539	-6.467596	comment	3.0	12.0	1634417460	-11.867893
28897664	You are begging the question. Git wo	You are begging the question. Git works well with plaintext because it is a product of the 1970s thinking that OP is bemoaning. If we built tools to do Git-like things on rich text file formats, they’d work just as well. (And Track Changes does a subset of those things surprisingly well inside Word, fwiw)And OP didn’t specify binary output. The output format could be anything we standardised on, just so long as it supports rich editing environments. That is, we shouldn’t have to write in the output format; the two can (and probably should) be disconnected.Markdown is both a terrible output format and editing experience, especially when you get complicated. It’s the worst of both worlds.	bonaldi	8.642418	-6.496421	comment	3.0	13.0	1634488583	-11.711292
28955196	> Like how easy is it to selectively	> Like how easy is it to selectively stage portions of files in the git CLI?It’s not hard (`git add -p`) unless you need line-wise selection.The main issue in my experience is that it’s completely linear so you need perfect memory and to never make any mistakes: git shows each hunk individually and tells you to make your choice before it shows the next, no take-backs.Magit shows the entire diff and lets you jump around, and selectively unstaging is just a “d s” away.	masklinn	8.612085	-6.518089	comment	3.0	11.0	1634894616	-11.891528
28955528	VSCode with Gitlens is the best git 	"VSCode with Gitlens is the best git GUI experience I've had.  
I prefer most operations via git cli, but for commiting partial changes and merge conflicts, it's everything I could ask for."	k4rli	8.608558	-6.4850326	comment	3.0	11.0	1634898787	-11.837356
28956366	I am the same.After the pandemic sta	"I am the same.After the pandemic started and I had to witness over screen share how colleagues ""use"" (fight) git with all sorts of GUI tools, I had to realize that no GUI can be good enough while one doesn't understand git, or, even worse, it can be contraproductive, because people using these GUIs _think_ they understand, but they don't.I even ended up creating a (tailored) 
2x90min git course...All that said, I heard magit praised so many times, I still have some hope that it's really as good as its reputation.(Tried fugitive, which is the vim-world's answer to magit, even learned it properly but realized I always juzt <C-z> to the terminal and do stuff with the cli)"	kmarc	8.626198	-6.4798174	comment	3.0	19.0	1634905342	-11.862588
28957831	> Magit has great support for stagin	> Magit has great support for staging parts of linesThis is news to me.> select the section you want to stage and press 's'.It stages line-wise for me. How do I get it to stage less than an entire line?	amake	8.65692	-6.5378118	comment	3.0	15.0	1634913676	-11.864586
28957517	> Git history is intended to be immu	> Git history is intended to be immutable when working with others.That's another pet peeve (though maybe less git's fault): immutable, yes, but then rebase is pushed quite liberally. Arguably not by git itself, but by many online learning resources.It's convenient, and mostly works, but then occasionally really stings you....yet undoing the last commit, arguably the least aggressive of history-rewriting commands, remains awkward.	rich_sasha	8.572123	-6.5466814	comment	3.0	13.0	1634912449	-11.908143
34131355	> Git should be your only source of 	> Git should be your only source of truth. Discard any local files or changes, what's not pushed into the repository, does not exist.Completely agree with that.	myfirstproject	8.572082	-6.4689217	comment	3.0	13.0	1672002916	-11.869404
34195253	Git allows one to sign commits. It w	Git allows one to sign commits. It would be quite pointless if it was signing mere MD5 hashes.	_flux	8.642202	-6.491254	comment	3.0	13.0	1672483233	-11.772017
34196661	Git isn't relying on collision-resis	Git isn't relying on collision-resistance, it's relying on second-preimage[0] resistance, which is to say: in order to sneak a hash collision in to a git repository, you have to sneak _something else_ that's already trusted (e.g. via code review) into the repository; collisions can't (yet) be generated for arbitrary hashes.I haven't heard of any second-preimage attacks against MD5, much less SHA-1, so mlindner was correct in asserting that MD5 would be fine (assuming 128 bits are enough). See also the analysis in [1].More to the point, if you're able to sneak something into a repository in the first place (e.g. a benign file that generates a collision with a malicious file), then you're probably able to sneak in something more directly (e.g. [2]) that won't rely on both getting something i	gsu2	8.667796	-6.5188484	comment	3.0	19.0	1672496632	7.172872
34301992	Git is pretty easy to use but people	Git is pretty easy to use but people tend to overcomplicate it. Just push changes to your branch. Merge when ready. And keep your branch up to date with your main branch. Easy.	yrgulation	8.554812	-6.502293	comment	3.0	11.0	1673204709	-11.904969
34302163	It’s Stockholm syndrome mixed with y	It’s Stockholm syndrome mixed with you being an expert at a specific tool.The reality is, Git is unintuitive, and makes nearly every common thing the average person wants to do a complete pain in the ass. I understand you (and I) know how to get things done using Git, but as a society and a technically community, we should strive to make things better.	blkhp19	8.535422	-6.4829593	comment	3.0	12.0	1673205715	-11.870557
34302366	I don't really understand how SmartG	I don't really understand how SmartGit failed you? In your table of results it covers at least as many features as the others.I call this out because I have been using SmartGit as my only git gui now for about 10 years and I think it does a grand job. It doesn't hide any information about the repo and makes just about any operation pretty straightforward. I also find it's built in diff and merge tools better than others. It also performs well enough and had been super stable.(I am not affiliated with SmartGit, just a happy customer).	wdfx	8.544666	-6.439376	comment	3.0	12.0	1673207054	-11.870471
34302792	> The tool developers want every com	> The tool developers want every commit to be feature-complete and that it won't cause broken builds at least in the master branch. This is impossible to achieve in the regular commit-merge workflow.You need to add the interactive rebases to achieve the goal.Why is this impossible to do with a commit-merge workflow?  If I do work on a development branch, then merge it into the main branch, only the merge commit appears in the main branch, and that merge commit has the final feature-complete commit.  The main branch then has an unbroken sequence of feature-complete commits.The only two complications are (1) avoiding fast-forward merges with the --no-ff flag and (2) viewing the history using the --first-parent flag.  The first ensures that you always have a merge commit, even in cases where 	MereInterest	8.587848	-6.549	comment	3.0	16.0	1673209962	-11.935188
34320278	Ask HN: Low tech Git alternatives fo	Ask HN: Low tech Git alternatives for non-software folks?	georgeburdell	8.562515	-6.484162	story	3.0	3.0	1673322594	-11.887392
34364541	> people take the limitations of git	"> people take the limitations of git and existing OSS tooling as a given and project those failings onto whichever paradigm they are arguing against.Very much agree. We have the whole ""rebase to a single commit for your PR"" vs. ""keep a history of what actually happened"" argument. One side wants to view concise, comprehensible change histories and be able to bisect them to see the origins of bugs etc, the other wants to use an rcs/vcs for one of the primary tasks an rcs/vcs is supposed to undertake - recording and keeping safe a version history of code as it is developed. To each the other side is wrong to even want that.There have been source control systems in the past that would cater to both quite happily. Nightmarish, terrible, slow, heavyweight source control systems that involved lea"	Nursie	8.569256	-6.4710574	comment	3.0	17.0	1673590926	-11.896144
34413033	>Until it starts generating PROFIT, 	">Until it starts generating PROFIT, anything else like: clean code, unit testing etc, makes zero sense. And also for the record, whenever I'm trying to figure out where something went wrong, commit are not the thing I look at, it's the code changes in the commit.Look, I work in a ""squash commits, messages are for detailing tickets"" place. I can understand not liking commit messages (although you really should, they are comments for your changes!). But this whole idea of ""it's okay to have completely awful code because you are still growing :)"" is how you get permanent spaghetti that costs absurd amounts of money to fix. There is nothing more permanent than a temporary solution, and deluding yourself into thinking uncommented, messy, untested, godawful code is acceptable ""for now"" will neve"	alexb_	8.587309	-6.5304327	comment	3.0	16.0	1673967108	-11.950085
34417515	[Edit: According to @rlpb's comment,	"[Edit: According to @rlpb's comment, git 2.39.1 is already available on Ubuntu]To install the latest git on Ubuntu:  sudo apt upgrade git

[Former post included instructions on how to install git from https://launchpad.net/~git-core/+archive/ubuntu/ppa]"	sshine	8.544339	-6.467797	comment	3.0	15.0	1673984162	-11.864264
34437760	Ironically, you have a very strong o	Ironically, you have a very strong opinion on people with strong opinions. Going as far as saying if you have a strong opinion on how to use git means you're a junior is a bit extreme, in my opinion.	monsieurbanana	8.532426	-6.4754634	comment	3.0	12.0	1674114404	-11.890493
34440916	Sure, Git stores data in a trie. Eac	"Sure, Git stores data in a trie. Each file is one blob identified by hash, and directories (called trees in Git) are blobs where each line is a directory entry with a name and the hash of a file or another tree.  This means that modifying an object /down/a/long/path/like/this.txt has to create copies of all the trees on the way up.  The technical term for this is ""write amplification"", and in Git it is affected by path length among other things.Got stores data in a probabilistic tree (GotKV[0]).  The number of nodes before you get to data will scale logarithmically with the size of the entire filesystem, not the depth of a specific object.Then there is the issue of large files.  A file in Git is always 1 blob.  Syncing a large blob is not easy because if you are interrupted and have to res"	brendoncarroll	8.587203	-6.472797	comment	3.0	14.0	1674140029	-11.895764
34444041	Haha appreciate you taking a look. O	"Haha appreciate you taking a look. One use case is to prevent merge conflicts, especially when working on a fast-moving project. Merge conflicts generally occur when you make changes on some old code. Jamsync constantly ""rebases"" your changes on top of new changes so that your code will always be up to date. Obviously some merge conflicts will still occur but much less so in this approach."	zdgeier	8.619333	-6.543882	comment	3.0	11.0	1674154511	8.971014
34446497	Heh… there are really two types of c	"Heh… there are really two types of coders. Those who things commits should have a single, obvious, minimal purpose, and who will split off unrelated changes into separate commits…… and those who tag you as a reviewer on +8,298, -1,943 commits/PRs with the commit message ""JIRA-PROJ-84138""."	deathanatos	8.57917	-6.480877	comment	3.0	20.0	1674166829	-11.923365
34446570	> … and those who tag you as a revie	"> … and those who tag you as a reviewer on +8,298, -1,943 commits/PRs with the commit message ""JIRA-PROJ-84138"".At my workplaces, we've told people who do this to break up their larger commit into smaller ones before reviewing. If they haven't done that initially, well, their life is going to get harder for a few days."	satvikpendem	8.58505	-6.51121	comment	3.0	13.0	1674167279	-11.89556
34445949	I find commit messages have more val	I find commit messages have more value when they don't just repeat what you can see by looking at a diff but when they explain the reasons behind.	pachico	8.583412	-6.5325146	comment	3.0	15.0	1674164150	-11.91168
34458299	There is only one thing about subver	There is only one thing about subversion I miss when using git -- the deletion of branches (which were, admittedly, just directories in a folder called branches) was version controlled, so you could recover deleted branches.	CJefferson	8.573119	-6.4619865	comment	3.0	14.0	1674242370	-11.870184
34458756	What's better about git? I haven't u	"What's better about git? I haven't used svn, but have used perforce/mercurial professionally/git professionally, and use git personally, but I find all of them to provide the same ""feature set"" when doing basic development: have your own branch, and merge it in to the main branch when done/reviewed.Merging seems the same on all 3 version control systems I've used... I've heard that git branching is better(?), but haven't seen that being used anywhere really."	somerando7	8.571087	-6.5052996	comment	3.0	17.0	1674244098	-11.9021225
34479988	Were you trying to teach them with t	Were you trying to teach them with the CLI though? That's a terrible approach. The CLI is awful and Git is a visual thing.It's like teaching someone to drive a car using LOGO.The way to teach Git is:1. Explain the mental model (correctly). Basically a commit is a snapshot with deduplication to avoid huge file sizes.2. Show them how to use a good Git GUI. There are a lot of bad ones. I would recommend Git Extensions (terrible name but it's actually quite good). Or maybe GitX on Mac.3. Let them learn the CLI slowly in their own time.	IshKebab	8.549383	-6.4890695	comment	3.0	15.0	1674409339	-11.888848
34480329	This is why I'm in love with Mercuri	This is why I'm in love with Mercurial. It has a very simple mental model which is not far from Git, but Mercurial's commands and presentation are so much more comprehensible.	garganzol	8.515974	-6.5458307	comment	3.0	17.0	1674411031	-11.938713
34481276	You won't have to put your entire li	You won't have to put your entire life on break in order to understand the fundamentals of git and why it works the way it works. Going through https://jwiegley.github.io/git-from-the-bottom-up/ and really understanding the material will take you a couple of hours at max, but will save you a lot of time in the future.Wanting to understand things before using them is hardly elitism, not sure why you would think that.Just like you probably don't want to fix bugs without understand the cause, it's hard to use a tool correctly unless you know how the tool works.	capableweb	8.545209	-6.487484	comment	3.0	11.0	1674415310	-11.918308
34481561	You're not alone. Git is an embarras	You're not alone. Git is an embarrassment to our profession.	howinteresting	8.540813	-6.4604964	comment	3.0	37.0	1674417300	-11.890513
34483482	Merging is an operation which takes 	Merging is an operation which takes three inputs: left, right, and common ancestor. This is a very old algorithm, the diff3 utility on Unix is at least from the 70s I think? The reason history is a graph is to walk the graph and find common ancestors. Subversion's model cannot do this (screw off, pedants, I know they added an attempt at detecting common ancestors after Git had long since supplanted Subversion in relevance).And if you can't merge, you can't branch. And if you can't branch, you need locks.	juped	8.617809	-6.5376487	comment	3.0	10.0	1674429940	-11.876374
34488151	Yes, this another thing doesn't get 	Yes, this another thing doesn't get said enough to a beginner:A branch is nothing more than a pointer (or mark) to a commit.This realisation along with the `git reflog` command I wrote above, made for a tremendous mental shift and suddenly almost everything around git just clicked together.	sakisv	8.565654	-6.5493345	comment	3.0	10.0	1674478020	-11.90472
34488509	If there's any command that's not ne	If there's any command that's not needed, it's git pull.  This command basically combines git fetch and git merge.  But merging the remote changes into your local branch isn't always appropriate.  I know that you can change the second action to rebase if you use the --rebase flag, but you have to remember to do that.I personally prefer just running git fetch and then deciding whether I want to merge, rebase, or just reset my local branch to the upstream commit and running the approriate command for that.	u801e	8.5753765	-6.5429044	comment	3.0	17.0	1674480780	-11.9134655
34489693	Checking out the branch via git is a	"Checking out the branch via git is a single command that's neither longer nor more complicated than the ""gh cli"" version.For years, it's been the default command in a single-click ""copy"" field under the ""code"" dropdown in a PR, not because git is complicated and anyone needs to ""look up"" the command, but because that's a fast and efficient way to grab a branch.Replacing the `git` single-liner with a `gh` single-liner does nothing for the user but make them dependent on the `gh` tool."	strix_varius	8.56733	-6.4986863	comment	3.0	21.0	1674486689	-11.821314
34493050	Hey Aditya, you can make your comman	Hey Aditya, you can make your command a little more unix-y if you feel so compelled by just renaming `shite.sh' to `shite' and run the shell script as a utility since it's already `chmod +x`'d.Then you can `shite(1)` anywhere you want after you put the command in your PATH and feel like a proper `git(1)`.Good `shite(1)` mate. Love it.	andrewmcwatters	8.611409	-6.478713	comment	3.0	14.0	1674499292	-11.769675
34576302	Git is pretty universally known as r	Git is pretty universally known as referring to an ignorant and unpleasant person.	Gigachad	8.563172	-6.482631	comment	3.0	12.0	1675058445	-11.821796
23408730	Are your venvs themselves the git re	Are your venvs themselves the git repo too? Sounds like they're not, because you have a different project folder.What's your rationale for now putting the venv inside the project and ignoring it? À la node_modules.I've shifted to this after years of your method and like it. I do hate .gitignore expanding arbitrarily. But that's life.	silviogutierrez	8.659249	-6.513507	comment	3.0	10.0	1591218300	-11.831133
23484489	Huh? I don’t know about Facebook but	Huh? I don’t know about Facebook but Google for sure does not use Mercurial as monorepo backend (nor does it use Git). There are Git and Mercurial-alike clients to interface with the in-house backend which is a Perforce like thing. Neither Git nor Mercurial would be fun to use at Google scale. Dropbox has a much smaller monorepo hence they can clone the whole Git thing on developer machines. I assume doing the same with Mercurial is impractical as no one has patience for something that slow.	mehrdada	8.503809	-6.5194774	comment	3.0	12.0	1591840651	-11.912997
23527353	"""root"" might be more appropriate tha"	"""root"" might be more appropriate than either ""main"" or ""master""."	musingsole	8.518555	-6.5228314	comment	3.0	15.0	1592229522	-11.722519
23531470	"Script to change it back
https://git"	"Script to change it back
https://github.com/DaniruKun/rename-branch"	mesozoic	8.524314	-6.5388417	comment	3.0	18.0	1592247454	9.046664
23534431	> you caan get most of the useful gi	> you caan get most of the useful git-like time-travel semantics (modulo schema migrations) out of timeseries data with a separate transaction history tableWell, not really. Dolt isn't just time travel. If all you want is time travel (or append-only data), you can do that with Postgres or MySQL pretty easily and get great performance. What Dolt brings to the table is actual Git semantics, a real commit graph you can branch, merge, fork, clone. You can inspect the historical values of each cell and examine the author and commit message for each change. Two people can clone a database, both insert / update / delete rows, and then merge each other's changes. If they touched the same rows, they'll have a merge conflict they have to resolve. If you find somebody's data they've published in the 	zachmu	8.6021595	-6.4853077	comment	3.0	16.0	1592265187	9.7330885
23568518	Not to mention it dirties up version	Not to mention it dirties up version control. It's a lot easier to tell which _significant_ things changed from the last commit when you're scanning a diff and no formatting changes are highlighted.	stimpson_j_cat	8.639104	-6.4936814	comment	3.0	26.0	1592517197	-11.862142
23582654	Everyone is forgetting “monotone”, a	Everyone is forgetting “monotone”, a DVCS developed by Graydon Hoare (who later went to create Rust) of which the Git model is essentially a simplification (and much much less related to BitKeeper)There was a lot of experimentation with VCSes at the time: arch -> tla -> baz ; bzr ; monotone ; cdv ; mercurial ; git ; even sun was finally getting merge tracking.Monotone had the best structure but a slow and clunky implementation. It was adopted and simplified (in different ways) by git and hg;  eventually git won by virtue of being way faster and demonstrably effective for a project the size of the Linux kernel (and Linus’ celebrity status didn’t hurt either)But graydon hoare deserves a lot more credit than he received - Linus did credit him at the time, but no one seems to remember.	beagle3	8.623903	-6.522821	comment	3.0	15.0	1592642311	-11.861341
23597285	How Does Git Know What a Python Func	How Does Git Know What a Python Function/Class Definition Looks Like?	gilad	8.56392	-6.464202	story	3.0	34.0	1592799033	-11.867939
23620926	> the single worst change is that yo	> the single worst change is that you can't see the latest commit status from the repo screen. Instead, you get the commit hash, and have to click a tiny ellipsis button to get the commit message and the status indicator.Omitting the commit message is a net improvement to me; I've found that the commit message of the random commit that happens to be at top of tree is completely unhelpful for someone browsing the repository, and especially someone new to the project.However, showing the status indicator inline does indeed seem like a good idea.That said...> You cannot see if your default branch has passed CI/status checks now.If it hasn't passed CI and status checks, it shouldn't be in your default branch.(There are cases where periodic status checks may get re-run after merging, such as ch	JoshTriplett	8.588541	-6.5067644	comment	3.0	11.0	1592949739	-11.926414
23660112	I just spent a few minutes reading t	I just spent a few minutes reading the readme, and I still can't figure out why this tool (or GitBook) is directly connected to git. OK, a bunch of markdown and json files in folders form a book. How is this connected to git?I totally get storing the markdown files/folders in git, but surely any other version control system would be fine too?	creato	8.547069	-6.4685807	comment	3.0	11.0	1593242786	-11.888057
23671118	Git is so pervasive in software deve	Git is so pervasive in software development that I think you will be at a disadvantage if you give up on it.This is the sort of situation where I would recommend taking a step back, finding a good book that covers the topic, and read it cover to cover. At least for me, taking time outs like this to learn something in an academic manner has paid big dividends over the years.	njhaveri	8.540232	-6.4818015	comment	3.0	12.0	1593370497	-11.888461
23699286	> We expect you to use git, commit c	> We expect you to use git, commit code as you go along, and build the app iteratively -- just as you would during a normal workday.This seems a little bit odd to me.How long do you expect people to work on their home assigments in order for them to commit often? Is it days, or weeks? I don't imagine multiple commits for a 3 hour poject.For a new project there aren't any well defined states of the code that make sense to be persisted. This means the commits will be arbitrary and their messeages not very meaningful.	gozzoo	8.574625	-6.4690614	comment	3.0	24.0	1593592851	-11.883169
19988555	Hi!I'm one of the (less active) main	"Hi!I'm one of the (less active) maintainers. Four years ago I migrated the CL cookbook from sourceforge where it'd been gently resting for quite a few years (nearly a decade), and put it onto github, put together a CI system, and away it went.  A few volunteers have been diligently working away on improving it, particularly `vindarel`, who has really taken the lead for content work in the last couple years as I've been pulled away by other things.since 2015 we've had 492 commits into git, and these fine people have contributed to the git tree:      Alexander Artemenko
      Andrew
      Andrew Hill
      Ben Dudson
      Burhanuddin Baharuddin
      chuchana
      Danny YUE
      Dmitry Petrov
      Fernando Borretti
      HiPhish
      Johan Sjölén
      Kevin Layer
      LdBeth
      Mom"	pnathan	8.538392	-6.44024	comment	3.0	18.0	1558586651	-11.903451
20005043	On the other hand, I don't know who 	"On the other hand, I don't know who these articles are really for. I have _never_ met a developer who struggles with git. Not many claim to understand it deeply, but all can rebase, cherry-pick, use the reflog, etc. and almost never do they run into issues.It mystifies me. Git isn't hard, nor complicated. ""Checkout"" has a few too many meanings, and thats the singular gripe I have with it."	F-0X	8.542128	-6.487347	comment	3.0	12.0	1558730129	-11.900515
20005579	The very first factual claim in the 	"The very first factual claim in the article is wrong:""The most basic usage is: git reset useful_func.clj
This will replace the useful_func.clj in the current working directory with the last committed version in the repository HEAD.""Not a good start. What it actually does is reset the path ""useful_func.clj"" in the index (AKA staging area) to the HEAD state. It doesn't touch the working directory."	wincent	8.556715	-6.5484357	comment	3.0	11.0	1558734465	-11.885579
20029233	> The BSDs run off of good old fashi	> The BSDs run off of good old fashioned ego driven software development done by people who care deeply about software.On the other hand, ego driven software development can also freeze technologies or development processes to what the main ego(s) want(s).Case in point, FreeBSD, NetBSD, OpenBSD and CVS. And even they will admit CVS is sub-optimal for development, see: https://wiki.freebsd.org/VCSWhy, https://wiki.freebsd.org/VCSCvsProblems. Note: I'm not saying Git is the solution, but CVS is bad. They should at least use SVN or any of the many systems that have learned from CVS' mistakes.TL;DR: Pick your poison regarding development practices.	oblio	8.622067	-6.448742	comment	3.0	39.0	1559045205	-11.844924
20057455	This is a great idea, thanks for it!	"This is a great idea, thanks for it! I've done similar things with using fzf to git add, git diff, and so on, but I hadn't thought of using it to pick a commit to rebase from.I made a few changes so I figured I'd post them back here in case you're interested:    pick-commit = # equivalent to your git log... cut...
    rif = ""!f() { rev=$(git pick-commit); [[ $rev ]] && git ri $rev~; }; f""

""rif"" = ""rebase interactive fzf/fuzzyfind"". The function and test just makes it exit cleanly if you escape out of the filter instead of giving ""fatal: invalid upstream '~'"" (and I changed it from ^ to ~ because I think ~ is usually what one should use over ^, but I'm willing to be corrected). And obviously I already have 'ri' aliased to 'rebase -i'.While I'm here, here are my similar git aliases for addi"	kbd	8.578794	-6.5353436	comment	3.0	11.0	1559264711	-11.849037
20129234	> git stash # i might need this one 	"> git stash # i might need this one day
And i never need it."	tehlike	8.566881	-6.5099235	comment	3.0	10.0	1559946719	9.43523
20186776	Whenever I code something moderately	Whenever I code something moderately challenging, I come back and do it again, and maybe again until it’s good and proper. I love history rewrite in mercurial.The code gets better, but the business outcome remains unchanged so it may look like waste. But it’s not waste - the micro skills acquired in the exercise accumulate.	DenisM	8.594247	-6.533212	comment	3.0	10.0	1560547395	-11.915735
20334355	Ask HN: What timesaving Git aliases 	Ask HN: What timesaving Git aliases do you use?	glenscott1	8.582865	-6.507422	story	3.0	9.0	1562070710	-11.844302
13612592	Ehh... nice in principle (and I do s	"Ehh... nice in principle (and I do small deploys all the time for work), but too many artificially-small changes can easily cause you to ""miss the forest for the trees"".  Each change is small and LGTM-able, but they can add up to a misbehaving system unless you have full context (which, because they're small, does not exist in the diffs).If it's conceptually a single unit, keep it a single unit.  Pushing dead code in small pieces that waits for a small master switch doesn't give you additional safety (though it can give you easier merges).>Reviews for large diffs are closed with a single “lgtm,” or miss big-picture problems for the weeds.That means you have bad reviews.  If it can't be figured out, how was it written?  Take the time and do it right.  Yes, it's a large commitment - is it la"	Groxx	8.600835	-6.480445	comment	3.0	11.0	1486690157	2.248722
13644260	Git stores diffs, not snapshots. A c	Git stores diffs, not snapshots. A commit is a changeset, literally a patch that you can export with `git diff`. Ordering of is layered on top of that and informs things like merges.Can you explain a little more what you mean?	jdbernard	8.595726	-6.5303116	comment	3.0	22.0	1487086933	10.317467
13644343	I don't understand, you will have to	I don't understand, you will have to use more words. I've never used darcs, and as a git user I don't see how you could cherry-pick by default for commiting. By default, I would say you… create a commit object with the author/date/message/tree/parent metadata recorded in it.	falsedan	8.57595	-6.538763	comment	3.0	15.0	1487087435	-11.883366
13644610	So, I didn't believe you because my 	"So, I didn't believe you because my internal mental model of a git repo is a DAG of changesets. And indeed, that is a good way to think about it, because almost all of git's operations behave like this. Commit history is almost always presented to the user as a series of diffs.But, you are correct. Internally, git stores the full contents of files and computes the diffs on the fly.For others' benefit, if you want to test for yourself, create a new repo, add a file and make a series of commits with changes. Git objects are compressed with DEFLATE (zlib) so gunzip and unzip won't work. I used https://github.com/jezell/zlibber because I was too lazy to write my own quick zlib wrapper. Then doing    for o in .git/objects/*/*; do cat ""$o"" | inflate ; echo """"; done

lists the contents of all the"	jdbernard	8.592969	-6.513839	comment	3.0	15.0	1487089335	-11.888254
13644121	Git (and mercurial, and a few others	"Git (and mercurial, and a few others) are snapshot-based. That means that they think of the world as states, with changes between them.Darcs, and pijul, are patch-based. That means that they think of the world as an ordering of patches. Patches aren't the same as commits: commit orderings, for example, are fixed, whereas patch orderings are computed. They can change when you e..g merge a ""branch"". Branching is similarly ""simpler"": a branch is just a collection of patches, not just a single commit with an implicit DAG attached to it."	lvh	8.5882845	-6.548119	comment	3.0	56.0	1487086161	13.878277
13644702	It sounds as this is mostly an inter	It sounds as this is mostly an internal difference. Certainly, the mental model you described can be used on git reasonably well, from the user's point of view, and they won't get steered too far off course with it.	falsedan	8.5645075	-6.4925	comment	3.0	13.0	1487089842	-11.902966
13645065	I thought git stored diffs too. But 	I thought git stored diffs too. But I don't understand what difference it makes, isn't the commit storage format an implementation detail? If you want to get to B from A, then I can store B or store B-A. When I have B and want to show a diff, I can calculate B-A. When I have B-A and want to show a diff, it's a no-op. When I have B and want to work, it's a no-op, but when I have B-A and want to work, I have to populate the working tree with A + B-A. It doesn't feel like there's a fundamental difference in the model either way.But if you don't have A in the first place, then there's a real problem, how to take B-A and reconstruct B, without knowing what A is. You have to find A, and there may be multiple acceptable A's. It seems like the fundamental difference here would be not having a stri	dahart	8.62144	-6.54447	comment	3.0	12.0	1487092226	10.269504
13645120	All that sounds like differences in 	All that sounds like differences in the intr internal model. From everything I have understood it wor would be possible to reimplement git to store only patches, their position in the commit tree and the commit hash, and have it behave exactly like the git reference implementation.Is the difference between patches and git commits in a DAG really only a difference in internal representations or is there a user-facing difference?	halomru	8.594494	-6.5320263	comment	3.0	12.0	1487092495	10.338828
13652156	Just using a random commit name like	Just using a random commit name like 'minor bug fix', 'updated version' for these kind of commits will save a lot of headaches like this.One can do better by adding random lines/ logs in lot of files and sneakily remove password from one of them and then give a random commit name.But then it all boils down to your mindset at that particular moment when you are commuting.	palerdot	8.586206	-6.5014424	comment	3.0	10.0	1487168586	-11.896999
13669360	No/manual rebase sounds awful	No/manual rebase sounds awful	jjirsa	8.586714	-6.56676	comment	3.0	26.0	1487348536	9.343735
13669560	If you like a readable commit histor	If you like a readable commit history, rebase is useful to reorder and squash unnecessary commits. Some repositories, like Rails have a lot of merge commits. Why should I have to read through them? Also, all kinds of failed tests may have been developed in a feature-branch during month-long development.Interactive rebasing lets you avoid that mess, I don't think it is that complicated. Mercurial uses the same underlying data structures, so I don't understand how rebasing can be more complicated on Mercurial than Git.	iso-8859-1	8.578735	-6.575795	comment	3.0	12.0	1487349704	-11.928813
13669921	Here's my story. I wanted to use ver	"Here's my story. I wanted to use version control on my research projects, but asking my collaborators to use Git was too much. They were supposed to figure out a staging area and pushing and pulling and then they'd get a bizarre error about a merge conflict. They'd do a search and Stack Overflow told them to type in an incantation. The repo is messed up, the collaborator goes back to email, and I'm left sorting through the rubble formerly known as a repo.I switched to Fossil a few months ago. Nice website that holds all the information. fossil commit -m ""Message"" is all they need to know. If they forgot to pull, it stops and tells them to do so. They type fossil update and go on with their lives. Zero problems so far and a more productive workflow overall."	bachmeier	8.542403	-6.486809	comment	3.0	29.0	1487351921	-11.895191
13713611	What about git?This makes it technic	What about git?This makes it technically possible to get a backdoored linux repo with the same commit hash.EDIT: this is wrong, it's not a second pre-image attack only a collision attack. That is, you can create 2 git repositories with the same commit hash, but not a git repo that matches an already existing repo. In other words, you can create 2 things with the same hash, but can't control what that hash actually is.You might be able to fashion 2 commits to the linux repo with the same hash but a different modification though.	rocqua	8.648388	-6.497863	comment	3.0	18.0	1487856238	7.157684
13713675	> What is currently still not feasib	> What is currently still not feasible is to create a custom git repository whose HEAD matches that of the Linux kernel.I'm not convinced that's good enough.In git, the SHA1 is always the hash of a gzip, which is subject to tricks[1] where a header might be prepared and then some padding inserted to collide a malicious tail.[1]: http://swtch.com/r.zip	geocar	8.67416	-6.5119214	comment	3.0	10.0	1487856764	7.144075
13714399	> What is currently still not feasib	> What is currently still not feasible is to create a custom git repository whose HEAD matches that of the Linux kernel.Hang on, that doesn't matter though, does it?I was under the impression that git's SHAs were to be treated as repo-wise unique; not universally. There must non-adversarial 'collisions' across repositories already, surely?I thought this attack potentially allows creating two commits in the same repo with the same hash - although it may only be possible for these to be root commits.	OJFord	8.650605	-6.504261	comment	3.0	10.0	1487862428	7.1807637
13722225	> Wow, Linus raises an entirely diff	> Wow, Linus raises an entirely different issue which is that the PDF-based attack can't and won't work on git at all. Due to length prefixing it is extremely difficult to insert some nonsense into the middle of a git object which is how this attack works on PDFs.Please note that the shattered-{1,2}.pdf files both have exactly the same length. And even with cleartext it is easy to pad passages so they contain the same amount of bytes. See how the quoted paragraph above has exactly the same number of characters as this one.	Perseids	8.649946	-6.4682565	comment	3.0	10.0	1487928101	-11.834977
13722609	> 1) Git doesn't rely on SHA-1 for s	"> 1) Git doesn't rely on SHA-1 for security. It relies on HTTPS, and a web of trust.Some security-focused developers sign git tags and/or commits, specifically to have things verifiable end-to-end and not having to trust HTTPS and all the middle men that entails.Would that not be a case where git relies on SHA1 for security? Someone could replace a tag or commit with a malicious version that verifies fine since it has the same hash the original developer signed.> 3) Even if someone managed to pull off a preimage attack, creating a ""poisonous"" version of one your git repository's objects, they'd still have to convince you pull from their repo. This requires trust.In the case of signed commits/tags, this opens projects up to malicious action by hosting companies and others. Usually signed co"	throwaway7767	8.658719	-6.5183897	comment	3.0	12.0	1487934161	7.1823063
13725291	A bit hard for me to tell what happe	A bit hard for me to tell what happened here, maybe because I don't know anything about SVN. The two PDFs with equal SHA1 hashes were git commited to the repository, but converting that to an SVN commit failed because... SVN can't handle two separate files with the same SHA1 hash?	raziel2p	8.666466	-6.518693	comment	3.0	16.0	1487954978	7.139915
13725662	> It would simply restore the wrong 	> It would simply restore the wrong file without noticing anything was amiss.Why hasn't Git switched to SHA-2?  People have been warning that SHA-1 is vulnerable for over a decade, but that vulnerability was dismissed with a lot of hand-waving over at Git.  Is it a very difficult technical problem to switch, or just a problem of backward compatibility for existing repos (i.e., it would be expensive to change everything over)?	sverige	8.683729	-6.529358	comment	3.0	32.0	1487957506	7.1809597
13725847	> Why hasn't Git switched to SHA-2? 	> Why hasn't Git switched to SHA-2? People have been warning that SHA-1 is vulnerable for over a decadeBack then Linus shot this down in his typical abrasive fashion:http://www.gelato.unsw.edu.au/archives/git/0504/0885.html	mintplant	8.689617	-6.525487	comment	3.0	10.0	1487958671	7.1790876
13734386	"> ""A hash that is used for security "	"> ""A hash that is used for security is basically a statement of trust [..] In contrast, in a project like git, the hash isn't used for ""trust"". I don't pull on peoples trees because they have a hash of a4d442663580. Our trust is in people, and then we end up having lots of technology measures in place to secure the actual data.""This is horseshit, and Linus should not be saying these hugely misleading statements about security principles.The point of a hash is to remove the need for trust between the trusted person who tells you the hash and the infrastructure you get the actual data that was hashed, from (edit: and, between you and the latter).In other words, once you get a good non-colliding hash from a trusted person, then you don't need to worry about malicious infrastructure sending yo"	infinity0	8.654566	-6.5030904	comment	3.0	45.0	1488063529	7.157662
13733923	I'm disappointed in HN community for	I'm disappointed in HN community for how this comment was treated. I'm a git lover, but this comment is a valid, well (enough) presented opinion. We live on people having different opinions. That's what makes us stronger than other communities!@stephenr: Well then you'll miss stuff like that. I honestly recommend checking out git in depth in your spare time. Just like learning lisp it will increase your programming skills even if you never use git in production! Maybe you come to love it for the same reason I do: incredibly well done architecture under the hood. It's the first time I could completely grasp what a VCS wants to do and how it's achieving its goals.	erikb	8.55322	-6.468845	comment	3.0	11.0	1488057924	-11.883006
13739254	Would having a git push hook that ch	Would having a git push hook that checks for remaining/added todos with this be a good idea?	maaaats	8.572863	-6.5176563	comment	3.0	12.0	1488137584	12.9470005
13739602	You could probably omit the length, 	You could probably omit the length, because the length is probably already known implicitly. E.g. git knows the length of its hashes without having to read the hash. If the length < the full hash, it can be assumed to be truncated.	mtdewcmu	8.707448	-6.5160866	comment	3.0	16.0	1488140545	-5.542756
13742507	This argument still assumes that Git	This argument still assumes that Git uses SHA1 for security. Linus points that out and John doesn't attempt to refute it, simply ignoring it. Linus should have used Murmur, CityHash or something - a SHA1 collision was going to happen eventually. By using a content identification hash function we could have avoided this argument entirely.	zamalek	8.66171	-6.4984574	comment	3.0	31.0	1488180424	7.2016015
13742697	> SHA1 is not used for security in G	"> SHA1 is not used for security in Git       -S[<keyid>], --gpg-sign[=<keyid>]
           GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space.

Yes it is."	kpcyrd	8.659225	-6.511097	comment	3.0	11.0	1488182784	7.2072763
13743614	So wait, when is SHA-1 ever used for	So wait, when is SHA-1 ever used for signing tags and commits in git? that's new to me..My understanding was you're using a public key type of encryption such as PGP at that point. I feel I may be missing the point here. (apologies if so)	moonshinefe	8.659894	-6.5052576	comment	3.0	15.0	1488197130	7.202409
13787103	Wait, so people use git and they don	Wait, so people use git and they don't know this?How?	JustSomeNobody	8.550149	-6.453201	comment	3.0	11.0	1488578103	-11.875174
13820713	It's different from rebasing to squa	It's different from rebasing to squash many commits into one. The article has nothing to do with hashes. Foo is also easier to parse mentally than umpty digits of hexadecimal vomit.	BugsJustFindMe	8.595285	-6.5244803	comment	3.0	10.0	1488985808	-11.879154
13833848	Commit hashes seem to be the way to 	Commit hashes seem to be the way to go, for sure, at least to be safe. I really don't want to put our vendor content in the repos.It's just a tad absurd when you're used to mature package managers in other languages.	joaodlf	8.655724	-6.4487476	comment	3.0	23.0	1489094756	-9.546613
13897930	"The ""official"" git prompt[1] is safe"	"The ""official"" git prompt[1] is safe on Bash; the script doesn't run.[1]: https://github.com/git/git/blob/master/contrib/completion/gi..."	rahiel	8.581991	-6.4730415	comment	3.0	11.0	1489784203	-11.852805
13918118	> The recent attack uses special tec	> The recent attack uses special techniques to exploit weaknesses in the SHA-1 algorithm that find a collision in much less time. These techniques leave a pattern in the bytes which can be detected when computing the SHA-1 of either half of a colliding pair.> GitHub.com now performs this detection for each SHA-1 it computes, and aborts the operation if there is evidence that the object is half of a colliding pair.Isn't it possible for a valid non-colliding object or commit to contain that pattern as well? It sounds like eventually, though possibly in the far distant future, someone will be unable to push a commit to Github because it matches the pattern but doesn't contain colliding objects.Does anyone know what the pattern is they're looking for? I'm curious now.	click170	8.695247	-6.510941	comment	3.0	34.0	1490048100	7.129483
13918203	Per commit, or over the expected lif	Per commit, or over the expected lifetime of Git's utilization of sha-1? If it's the former it's not very useful unless we have an idea how many commits are made.	orblivion	8.687213	-6.5282893	comment	3.0	27.0	1490048855	7.243069
13925652	What helped me make Git click was le	"What helped me make Git click was learning how to use SourceTree. It has intuitive UI (compared to GitHub Desktop) accompanied by a pretty graph of commits. Can't recommend it enough for ""visual"" type of people like me."	gpetukhov	8.566812	-6.4629784	comment	3.0	11.0	1490126351	-11.883494
13932454	What convinced me to try out gitlab 	"What convinced me to try out gitlab today: ""Today with 9.0, we are excited to release Deploy Boards for environments running on Kubernetes. The Environments page of Pipelines now offers a single place to view the current health and deployment status of each environment, displaying the specific status of each pod in the deployment. Developers and other teammates can view the progress and status of a rollout, pod by pod, in the workflow they already use without any need to access Kubernetes."""	kozikow	8.467007	-6.5528784	comment	3.0	12.0	1490201120	-12.089159
13961473	"Yeah, this is clearly out of date. """	"Yeah, this is clearly out of date. ""Experimented with Git"" is the highest level in the version control row? Git is the standard now and has been for years.I think a bigger issue, though, is that some of these skills are very valuable, and some of these skills are the ones companies hire on, and those two sections are not always the same. Personally, I see myself as being somewhere around the n level on the algorithms stuff, but well into the log(n) level at the engineering/communication stuff. I've harped over and over on the weirdness of prioritizing theory knowledge over practical skill in day-to-day jobs where the practical is what matters - it's nice to see all the different dimensions so clearly laid out and given (roughly) equal attention."	ivraatiems	8.556998	-6.4815397	comment	3.0	29.0	1490545065	-11.871207
30738129	Is the main use case being splitting	Is the main use case being splitting large uncommitted change set into logical units in _one pass_ rather than few iterations of `git add -p && git commit`?	almog	8.575575	-6.5228715	comment	3.0	11.0	1647728982	-11.92263
30738866	This is the one P4 workflow feature 	"This is the one P4 workflow feature I wish git had from the beginning.  In Perforce, changes can be grouped into uncommitted ""change lists.""  Its really helpful if you're working on multiple things especially when they're unrelated features or projects.  Works very well for artists and such.Sadly P4 fumbles at the 10 because you can't split changes by hunk, file only.I hope something like this (or maybe just multiple named stages?) makes it into git."	jayd16	8.613918	-6.533372	comment	3.0	10.0	1647736523	-11.901477
30765715	Ask HN: I'm a researcher and I have 	Ask HN: I'm a researcher and I have to mantain code. Where do I start?	marcomanzoni	8.521193	-6.477925	story	3.0	1.0	1647955218	-11.891988
30816234	Fossil is an alternative to both git	Fossil is an alternative to both git (source control) and github (issues, etc).I think its brilliant having issues tracked in fossil. Part of the promise of github is that the user is in control, since your computer is a first-class citizen of a repository. You have all the code, and all the history on your computer. You can use github, but you don't need github, since its just another node in git's distributed network.But that promise falls apart with issues and pull requests. Issues and pull requests don't get replicated by git. If github goes down, you can't interact with issues. If github ever turns evil, or you decide you want to self host git over ssh or something, you lose the history of all your issues and conversations.Git is a distributed, replicated data format. Why are issues f	josephg	8.490799	-6.454204	comment	3.0	11.0	1648336779	-11.88562
30816242	I would love to see a better git com	I would love to see a better git compatible VCS. I'm not feeling good about self hosting my version control.	999900000999	8.568463	-6.4383726	comment	3.0	15.0	1648336870	-11.888632
30816782	When Fossil didn't have those featur	When Fossil didn't have those features, the frequent complaints were that Fossil doesn't have those features, and that's why they had to keep using $INERTIA_SOURCE. Now that it has those features, it's the reason not to move to it? I see. :)All of these features cooperate and serve the same goal: coordinate the work product of people on a project, in a distributed fashion. One path to that is the nearly fully centralized model of GitHub. Another is the VCS + mailing list + bug tracker + wiki path, which requires considerable admin resources to manage, and at the end of the day is a pile of barely-cooperating services. Fossil's path is to put them all into one place so they all work properly together.You can reference ticket IDs from a forum post.You can point to a section of the timeline f	wyoung2	8.508178	-6.52533	comment	3.0	11.0	1648342994	-11.960595
30840587	Generating code is a powerful tool t	Generating code is a powerful tool that I think everyone should have in their toolbox — use it wisely of course, but don’t avoid it on principle.This describes an interesting approach that I hadn’t seen. I personally wouldn’t have considered putting the result in the same file because I usually like to gitignore any and all generated code, mostly to reduce phantom merge conflicts. However, some colleagues have the opinion that those conflicts are trivially resolved by rebuilding and thus don’t matter, and having diffs of the generated code show up in pull requests adds value.What do others think, check in generated code or put it in gitignore?	codeflo	8.68356	-6.482943	comment	3.0	10.0	1648547070	-7.7089877
30857802	This seems interesting.But, I wish t	This seems interesting.But, I wish there was some code to show me what makes it so radically different. It seems like this is targeting developers (or is it devops team?) and I'm excited about the new language here, but I don't see any examples of code. Code engages both my head and heart.I am reusing a lot of code in my CI jobs. I have an upload script that I reuse. I have a DEB package script that I reuse across many projects. So, that assertion rings false to me, and seems to indicate there is an unhealthy wall between devops and the developers that prevents shared code. Maybe I misunderstand.The thing that always bites me is that I have trouble debugging a job that depends on the artifacts from a prior job. My e2e job is flakey, and I'm loathe to fix it, because I have to re-run the en	xrd	8.546832	-6.4499564	comment	3.0	15.0	1648659352	9.0472145
30881542	Oh hey, i think there was a post abo	Oh hey, i think there was a post about Fossil here on HN a few days ago: https://news.ycombinator.com/item?id=30815693It is most certainly a nice project and i'm all for alternatives to Git, but for many people having to give up their current tooling (e.g. IDE integrations, specific tools for graphical graphs, interactive staging of chunks, rebasing etc.) would probably be a non starter, since it's another source control system entirely, instead of a front-end/enhancement of what Git provides (e.g. ticketing, wikis, merge/pull request discussions, CI etc.).Here's hoping that Fossil has a nice future ahead of it, there is certainly a number of projects that would benefit from it's relative simplicity when compared to Git!Also their docs are pretty simple to understand: https://fossil-scm.or	KronisLV	8.50339	-6.5104685	comment	3.0	11.0	1648837178	-11.983472
30886193	I don't get why everyone wants git s	I don't get why everyone wants git status on every prompt. It feels more of a distraction than necessity just to make it look prettier for screenshot purposes.Most of the time I'm within a repo directory, I don't care in which branch or state it's in as I have other apps to take care of that and there are better info to be had like cwd, who you're, host name, exit code, time and time last command took for a prompt.	mekster	8.552003	-6.461266	comment	3.0	10.0	1648880093	-11.829464
30948225	I have a guy on me team that commits	I have a guy on me team that commits basically every 5 or so lines.  Hell have a 30 line bug fix spread across like 20 commits because he never goes back and cleans up those small commits that get changed afterwards, not to mention he’ll merge the development branch into it numerous times and never rebased.  It’s absolutely infuriating reading through git logs that involve his stuff.His commit messages are equally maddening - “change this variable to 5”, “fix broken spec”, “change variable to 7” ad nauseam…	rubyist5eva	8.587977	-6.5242796	comment	3.0	15.0	1649354944	-11.908843
30948657	I work in a way similar to the autho	"I work in a way similar to the author, treating my micro commits like a videogame quick save. But many videogames separate ""quick save"" and ""real save"" in the UI and so do I.I have a local branch, usually just called ""wip"" for work-in-progress and commit to it frequently. Then when I want to push to origin I pull all the contents from that branch into my ""real branch"" and commit it as one commit. Then delete the wip branch and repeat.If I'm working on multiple tasks at once as my distracted brain loves to do, I'll have several wip branches. wip-new-hook-events, wip-update-sdk-version, wip-refactor-button-state. Sometimes the branches conflict with eachother, but dealing with that is worth being able to drop a task for a few days while I'm stumped or blocked. I also don't tend to micro comm"	squeaky-clean	8.589915	-6.5326595	comment	3.0	16.0	1649356853	-11.91179
30951234	The author's reasoning behind not sq	The author's reasoning behind not squashing: https://blog.ploeh.dk/2020/10/05/fortunately-i-dont-squash-m...I can understand they don't want to oversquash - I rebase & squash so that each commit should be able to stand on its own.  I think the above link is a good argument for squashing (and rebasing) to the point that each commit should leave the system in a state where everything works, because otherwise you can't use `git bisect` and actually determine if it's good or bad.  I will often have more granular commits where I break something and then fix it in the next commit.	bentcorner	8.574657	-6.5650687	comment	3.0	10.0	1649371576	-11.955024
30979241	You're saying the presence of PGP-si	You're saying the presence of PGP-signed commits is correlated with programmer skill?I have never signed my commits because I see absolutely no reason to (my repositories are all small personal projects that nobody uses), and I haven't gotten around to setting up a proper key management workflow with my password manager. Maybe I need to start signing them!	arjvik	8.616553	-6.442688	comment	3.0	11.0	1649611037	-11.7142105
30988322	The only advantage Perforce has, and	"The only advantage Perforce has, and the reason why giants such as Ubisoft have committed to it, is that ""it handles large files better"". That's it."	pluc	8.670244	-6.510531	comment	3.0	14.0	1649683530	13.794374
31011536	This is really dismissive. Unexpecte	This is really dismissive. Unexpected execution is not a users fault, and can happen for a variety of reasons (you telling me you’ve never unzipped a full git path someone sent you?)	hsbauauvhabzb	8.557112	-6.476065	comment	3.0	19.0	1649828381	-11.875684
31011600	Don’t make tools use processes for “	Don’t make tools use processes for “plug-in behavior”. Do one thing and do it well doesn’t really appeal to me to begin with but “let the first thing do the next thing on its own” is definitely a bastardization of that idea as well. Git has that Unix disease where the go to method of getting anything user configurable done with one program is launching another program. I’d much rather use tools that use huge convoluted script languages or good plug-in apis than tools that duct tape together with exit codes.	alkonaut	8.55706	-6.4752088	comment	3.0	11.0	1649829175	-11.941798
31011686	fzf is a wonderful little tool. I us	fzf is a wonderful little tool. I use this script so much:git branch | fzf | xargs git checkout	AmpsterMan	8.593326	-6.534293	comment	3.0	11.0	1649830280	-11.874938
34587905	This is especially true of something	This is especially true of something like a git SHA, which is drilled into your head as THE stable hash of your code and git tree at a certain state. It should be expected that lots of tools use it as an identifier -- heck, I've done so myself to confirm which version of a piece of software is deployed on a particular machine, etc.	nilsbunger	8.620292	-6.5033216	comment	3.0	12.0	1675119756	-11.82079
34587565	Does anyone have the motivation for 	Does anyone have the motivation for why the git project wants to use their own implementation of gzip? Did this implementation already exist and was being used for something else?I understand wanting fewer dependencies, but gut-reaction is that it's a bad move in the unsafe world of C to rewrite something that already has a far more audited, ubiquitous implementation.	jzelinskie	8.569048	-6.465256	comment	3.0	13.0	1675118310	9.301127
34633424	Everybody who had to maintain an API	"Everybody who had to maintain an API knows this.1. You can't just rely on documentation (""we never said we would guarantee this or that"") to push back on your users' claims that you introduced a breaking change. If you care more about your documentation than your users, they will turn their back on you.2. However if you start guaranteeing too much stability, innovation and change will become too costly or even impossible. In this instance, if the git team has to guarantee their hashes (which seems impossible anyway because it depends on the external gzip program) then they can never improve on compression.Tough situation to be in."	skywal_l	8.585219	-6.463207	comment	3.0	19.0	1675373644	-11.895278
34633850	If it can't be made stable, `git arc	If it can't be made stable, `git archive` should specifically add random content (under a feature flag to be removed after a year or two) to so as to make the generated checksum completely unreliable and force users to adopt different workflows.	pcj-github	8.576137	-6.4654765	comment	3.0	17.0	1675375519	8.37354
34664362	While I love a standard for API docu	"While I love a standard for API documentation, these kinds of documentation is seldom of use for me when I read code, it is usually the same boiler plate you see in this cheat sheet: ""X a number"". Git commits are ment to be similarly short there  it is the what and why, in code I often feel you need the why and how, rather than what for function arguments."	emj	8.622031	-6.5188446	comment	3.0	14.0	1675600047	-11.8552265
34673340	There’s a common convention that sta	"There’s a common convention that starts commit message with ticket numbers. Why tickets are not mentioned in the spec? This context is more important.Regarding choice of types: why „feature“ is shortened to „feat“? If there’s a type for feature, why another type is „fix“, not a „bug“? Semantically naming should be consistent.Automatic relationship with semver is questionable. Fix can be a change in architecture that deserves major version. Implementation of non-functional requirements is not a fix, yet it does not introduce new features and thus not a minor version increment. These are just two examples where inferred version is not what it could be. Making possible explicit expression of intent would help, e.g. by adding some tag like [minor].
Example:   „APP-143:fix:major - migrated from"	ivan_gammel	8.569891	-6.505455	comment	3.0	10.0	1675657601	-11.95759
34689158	Make Atomic Git Commits	Make Atomic Git Commits	pabs3	8.57946	-6.5137205	story	3.0	11.0	1675748335	-11.914669
34734716	Trunk-based development reminds me o	Trunk-based development reminds me of Agile Development: the drawbacks mostly accrue to the developers while the benefits mostly accrue to the managers.	fwlr	8.612994	-6.543465	comment	3.0	33.0	1675994471	3.2093096
34738134	Question: For mobile apps, wouldn't 	Question: For mobile apps, wouldn't gitflow be more suitable, since the app is only released after app store validation? The release branches here seem to match well this purpose. Just to curious to know how trunk-based development is applied in practice for mobile apps.	bacro	8.572437	-6.5510397	comment	3.0	13.0	1676027027	3.2120972
34761786	> if you want to be sure of you get 	> if you want to be sure of you get the latest version, rename the file.This is a beyond ridiculous statement. It is a BUG that you do not get the latest version of the file when viewing raw, not an error you made that you should address by having a filename driven versioning system.If I'm using Git and GitHub, it's specifically to NOT have to deal with v1, v1.1, final, final_for_real, final_of_the_finalest, this_time_its_really_final.Your suggestion to work around this GitHub bug is to essentially not use Git. Ridiculous.	iLoveOncall	8.572231	-6.4480386	comment	3.0	16.0	1676198440	-11.869255
34874481	Oh man, if this could plug into git 	Oh man, if this could plug into git and be a LFS replacement, that would be awesome. I work in a field where folks run into situations where they think they need LFS, and rarely does it work out well. If someone can figure out an ergonomic and durable LFS-like blob versioning system that can align with git histories, that would be incredible.	Zee2	8.578301	-6.45629	comment	3.0	26.0	1676936947	-11.899649
34902056	We need models that can read long te	We need models that can read long texts like a bunch of scientific papers, a book, or the whole git repo of an app. And we need models that can do iterative changes - diff models, they can be trained of course on git commits.	visarga	8.603166	-6.4858394	comment	3.0	24.0	1677097341	9.054839
34907500	Training our next generation on prop	Training our next generation on proprietary tools like GitHub isn't the way though. Understanding a VCS (i.e. Git, Mercurial, darcs, Pijul, etc.) is great skill and almost certainly a job requirement, but a specific platform? Its classification as “industry standard” could and should be debated as well.	toastal	8.571172	-6.4598145	comment	3.0	32.0	1677134126	-11.861194
34945429	I liked magit on Linux, but on Windo	I liked magit on Linux, but on Windows it's so slow that it's unusable. Yes, I know it's because git is slower on Windows, but when using git CLI I don't feel the speed difference, while on magit I feel like constantly waiting for it to happen.In the end, I just stick to Git CLI. It's fast enough, ergonomic enough for the basic usage, and works everywhere. I still wonder people who use multiple IDEs for multiple languages and have to fight different git plugins.	miroljub	8.625827	-6.4552665	comment	3.0	22.0	1677418646	-11.696187
34958681	I wish people would stop insisting t	I wish people would stop insisting that Git branches are nothing but refs	pavel_lishin	8.559322	-6.5215797	story	3.0	4.0	1677516574	-11.910241
34965865	We do, at least to my mind.  It's ca	We do, at least to my mind.  It's called Mercurial.  It's great, extremely close to git, but is much easier to use IMO.  It's really a damn shame that git won - primarily, I think, due to the cachet of its author.	rjbwork	8.532482	-6.519154	comment	3.0	11.0	1677560966	-11.928879
34965922	Linus built an incredibly elegant an	Linus built an incredibly elegant and simple underlying model for git. For what it successfully does - distributed version control - it is remarkably simple and easy to grasp if you want to.However, this model was not mapped well to the high level concepts that the typical user of a VCS operates in. This is the biggest issue of git: it's hard to make sense of it by its UI if you do not understand how it works under the hood. I struggled until I read the pro git book.I wouldn't go as far as to compare this to knowing about filesystem data structures for saving a jpeg file. It's more like using an old school file dialog where you just see the bare file system and you need to know your way around your drive.	bad_username	8.594367	-6.4556317	comment	3.0	45.0	1677561544	-11.86915
34966036	I use the heck out of fossil and hav	"I use the heck out of fossil and have little idea how it works underneath. I consider fossil the gold standard for a good versioning system ui. I don't think git has any excuse for being as weird as it is.fossil init repo; make a new fossil repositoryfossil open repo; open a fossil repository somewherefossil add file; note: very different than git add. in fact I was very confused by git add, in fossil the repository knows what files are managed by it and there is no staging area. so you only use ""fossil add"" when adding a new file. If you move a file use ""fossil mv"" to let fossil know what you did. Along with ""rm"" when you remove a file. The staging area still feels like an unnecessary added bit of friction.fossil commitThere are others I use often ""merge"", ""sync"", ""revert"" but they tend d"	somat	8.511592	-6.545444	comment	3.0	16.0	1677562624	-11.945579
34966097	> When I understood the reflog and h	> When I understood the reflog and how nothing I do is really gone (just gotta find it!), that was when I realized how much I like git.The reflog won't help you recover things in the staging area that where accidentally `reset --hard` though … (you can still get the ones you added to the index with `git add` but not committed[1], but changes that weren't added are lost for good)I love git, but the UX is still terrible …[1]: https://stackoverflow.com/questions/7374069/undo-git-reset-h...	littlestymaar	8.570055	-6.5379395	comment	3.0	14.0	1677563326	-11.924228
34966098	So what's the underlying model that 	So what's the underlying model that makes the staging area make sense? Why does stash followed by unstash leave my checkout in a different state from what it was before?	lmm	8.624026	-6.5679083	comment	3.0	20.0	1677563328	-11.91554
34970265	"A ""branch"" is two things. In git, it"	"A ""branch"" is two things. In git, it's the ref. To humans, it's the ref or the chain of commits under it.Both of these have their place, I feel.When thinking about commits to a branch, humans (I speculate) tend to imagine the branch as a sequence of commits.But when operating on the branch ref itself, like when you delete it, you should be very clear that you're not deleting commits."	beej71	8.56414	-6.538524	comment	3.0	19.0	1677597683	-11.903137
34975339	It reads a bit like the author has a	It reads a bit like the author has a misconception of what commmits are. A commit is not a diff, it's a snapshot. All of the talk about branches containing changes etc, make sense in the context of it being a reference to the latest snapshot. And yes it might not make sense if you think of a branch as a reference to the latest difference, but this is a misconception.	expazl	8.607498	-6.531257	comment	3.0	15.0	1677620918	-11.880735
35007036	> stronger digest algorithm for repo	> stronger digest algorithm for repository signing: We now use SHA256 instead of SHA1 for the index signatureNeither SHA-1 nor SHA-256 are signing constructs, they are hash functions. They  provide integrity, not authenticity.For this kind of thing (a central authority signing and public clients verifying), you'd need a public key signature scheme, like ECDSA or EdDSA.	franky47	8.702541	-6.4734406	comment	3.0	14.0	1677830956	-9.501308
35013989	So basically, now we can do `git dif	So basically, now we can do `git diff master` in a GUI. Hooray, I guess.	nusaru	8.596404	-6.4896226	comment	3.0	20.0	1677872055	-11.827673
35014336	You can name a branch master on git 	"You can name a branch master on git to your hearts content. We still have branches named master. We still have stuff we refer to as ""whitelist"" even though that was never an accurate descriptor for it in the first place.This shit isn't banned. Nobody stops you from using them."	mrguyorama	8.507616	-6.5057383	comment	3.0	15.0	1677873919	-11.599889
35015096	For those who want a GUI around this	For those who want a GUI around this on Mac, https://rowanj.github.io/gitx/ is an incredible secret weapon. You can swipe over a bunch of lines or let the software identify a whole span of contiguous changed lines, click a button, and see just those changes move over from your unstaged to staged changes, then commit exactly what you want.A lot of times people don't even understand how powerful the staging area is; they're just used to saying git add && git commit without realizing that it can be an incredible way to take a day of chaotic fixes and turn it into a set of commits you can be proud of!It also provides an incredible tree view of commit parentage, perfect for when you need to instantly understand what happened with this weird merge/rebase that broke things, and to screenshare it 	btown	8.584187	-6.522934	comment	3.0	13.0	1677878133	-11.887624
35037591	I'm confused... What's wrong with me	I'm confused... What's wrong with merge?For all I know, I once joined a company where the policy was to only do squash-merges. I left from there at the brink of mental breakdown.	rsaarsoo	8.596719	-6.551569	comment	3.0	10.0	1678077762	-11.921694
35061505	Yes. I'm saying that due to this rel	Yes. I'm saying that due to this relying on an external service it would be inappropriate for a pre-commit hook as you could only commit while online.	eikenberry	8.620036	-6.5051165	comment	3.0	13.0	1678224460	-11.870873
25443334	This type of thing can happen easily	"This type of thing can happen easily with Git. We just submit a directory, and every damn file in that directory gets submitted.What I do, is have a file that aggregates my sensitive stuff (like server secrets and whatnot), and call that file something like ""DoNotCheckThisIntoSourceControl.swift"". I then add a git ignore line, on that name.I'll also sometimes store it outside of the repo root (I use Xcode, so I can drag files in from anywhere)."	ChrisMarshallNY	8.587291	-6.4696274	comment	3.0	14.0	1608130958	-11.832402
36889264	I find their git integration limited	I find their git integration limited as well. When using git I always find myself using IDE's integrated terminal, or OS's terminal. But, I've reported bugs on their tracker - it took a while, but they fixed it.	iamcreasy	8.577757	-6.454893	comment	3.0	10.0	1690435500	-11.840738
36903830	Goddamn do all the people who commen	Goddamn do all the people who comment here work on linux and only through the command line, and have never used a git GUI before? There's barely any proper advice from a windows-gitgui user here.On windows start with TortoiseGit, if he used TortoiseSVN before he'll get it. Right-clicking on a file/folder will bring up a context menu that windows users will be very familiar with, plus it has labels that even a command line git user would be familiar with. Then teach him commits, pushes and branches (git's underlying mechanics) from there on.	oreally	8.566217	-6.4720545	comment	3.0	10.0	1690527958	-11.889371
36953795	Nice to see this posted here. I swit	Nice to see this posted here. I switched over to it about 2-3 weeks ago, and I haven't looked back. It took a lot of mental rewiring, but I really enjoy the workflow `jj` provides. There's no longer a time to think about what's being committed, because all file changes automatically amend the working copy commit. Of course, sometimes you don't want this, so you have things like the ability to split a commit into two, moving commits, etc. But having _everything_ operate on commits is really nice! Other niceities that I like:- `jj log` is awesome for getting an overview of all your branches. If, like me, you have a lot of work in progress at once, this provides a great map- Conflict resolution is really cool, as you can partially resolve conflicts, and then switch branches. Conflicts are als	ocharles	8.578923	-6.5488944	comment	3.0	74.0	1690879274	-11.878829
36955390	"So in your workflow you never ""git c"	"So in your workflow you never ""git commit -a""? So you have to always manually mark what you stage. Which is probably more work than always manually removing the changes you don't want to commit.The ability to rewrite older commits easily in jj also looks like it would help with this usecase if you get it wrong once.Concretely I think you would do is: Instead of staging part of your changes and then committing as in git, you would call jj split and split the commit into the part you want to keep local and the part you want to push. This way the local changes always stay in your working copy commit.Even better, just commit the local changes once when you start. Work locally and before you push you call jj diffedit on your initial commit of the local changes and remove them. Now all the work "	Certhas	8.612454	-6.5541787	comment	3.0	14.0	1690894794	-11.921976
36956366	Because I have two types of people w	Because I have two types of people who understand git on my team. People who use the CLI and people who don't understand git and just start clicking buttons	calvinmorrison	8.554811	-6.481863	comment	3.0	12.0	1690900153	-11.89228
36958608	How about why not? The only reason i	How about why not? The only reason it's not done is because git doesn't support it.	theLiminator	8.561664	-6.4517865	comment	3.0	11.0	1690908531	-11.865191
37011087	I would have thought most discussion	"I would have thought most discussions around ""UI vs CLI"" are more about ""GUI vs CLI"".Keyboard-driven git UI's which aren't GUI are relatively niche. (I can think of magit, tig, and lazygit).Whereas, a git beginner may be more likely to start using git with a GUI, e.g. the git panel in VSCode, or something like GitKraken."	rgoulter	8.581814	-6.491774	comment	3.0	32.0	1691236091	-11.821647
37012155	That should be telling you that git 	That should be telling you that git is designed unintuitively, not that everyone else is wrong.	yCombLinks	8.554487	-6.4643617	comment	3.0	10.0	1691244544	-11.888922
37015835	> Multiple Git CheckoutsYou don’t ne	> Multiple Git CheckoutsYou don’t need to do a full clone to have multiple working copies of your repo checked out. You can use the git worktree command to create these working copies:https://git-scm.com/docs/git-worktree	MarkSweep	8.5614605	-6.4526553	comment	3.0	21.0	1691266042	-11.915013
37015594	Ask HN: What projects are trying to 	Ask HN: What projects are trying to reinvent core software infrastructure?	hariwb	8.690694	-6.4511633	story	3.0	16.0	1691264270	-11.749299
37038526	Did you go through the PR discussion	Did you go through the PR discussion though?In this particular case there was technical discovery on a non-trivial approach to patch an npm package (which didn't work out)But above aside, one can get a lot more milage out of GitStart if small fixes are bundled together. As that means all of them share the cost of QA (across devices), bundled code review and less context switch overhead.	hzia	8.563453	-6.4391212	comment	3.0	11.0	1691432783	-11.898709
37040467	I've been working a bit the past wee	"I've been working a bit the past week on a guide for a workshop I'll be running in a few months to get research mathematicians productive using just GitHub's UI. [0] So the purpose is not identical by any means. But I'm curious whether it's appropriate that this RedHat guide seems to go straight into ""what commands do I run"" rather than answering/illustrating ""how does Git model the history of a software project's files"".[0]: http://jmm2024.clontz.org/"	StevenXC	8.546978	-6.4519677	comment	3.0	20.0	1691439845	-11.848554
37041689	Honestly the picture shown in that t	Honestly the picture shown in that thread are fine and most people I have met grok those commands really quick.The issue is git's interface is terrible and very powerful. Which means when something goes awry and they land outside those 5 or 6 commands they often have no idea how to fix it. Which invariably leads to a copy paste of their changes and a delete and re-clone.Honestly I really like mercurial. I found its interface better but in this day and age all the tooling is built around git so ...	tempest_	8.52496	-6.5417595	comment	3.0	11.0	1691446499	-11.917768
37042566	Don’t even have to go that far back.	Don’t even have to go that far back. Mercurial is/was a way better ux over a very similar feature set.	TylerE	8.505053	-6.55604	comment	3.0	20.0	1691452423	-11.972017
37042635	Hard disagree.Perforce is idiot proo	Hard disagree.Perforce is idiot proof. I can teach a non-programmer who has never even heard of revision control how to use Perforce in literally 10 minutes. They will never shoot themselves in the foot. They will never lose work. They will never, ever need to nuke and reclone their repo.Perforce has other issues of course. But Git has both a bad CLI and a bad model. Maybe its particular model is strictly required for the Linux kernel. However for 99% of developers that are centralized on GitHub the model ranges from “mediocre fit” to “downright broken”.	forrestthewoods	8.611289	-6.49948	comment	3.0	21.0	1691452814	13.835847
37044232	I don’t recommend git pull to anyone	I don’t recommend git pull to anyone.  The magical ways that .git/config sets up tracked vs untracked branches are too opaque for me.It’s always been much easier to understand (and explain) what’s going on when you separate fetch from rebase/merge*, and I feel like all these “just re clone and start again” memes are all because people’s branch tracking broke and they wanted magical “git push # no further args” to work properly again.Once you know how to “git push remote myref:theirref” you become much less dependent on magic.  Knowing about / having to know about how it works internally is the fun / tedium of git.*Just kidding about doing git merge, btw.  Linear history for life!	gorgoiler	8.57193	-6.540045	comment	3.0	30.0	1691465888	-11.913866
37044655	Yep.  I've been using git for years 	Yep.  I've been using git for years and still don't really understand the difference between fetch, checkout, and pull.The official docs are dogshit so I just don't have time to figure out the minutiae.	nvy	8.55432	-6.5092406	comment	3.0	26.0	1691470423	-11.856587
37044745	Fetch means “safely fetch new data f	Fetch means “safely fetch new data from one of your remotes without affecting any of your local work”.Pull means “do what fetch does, but with the spicy bonus risk that your precious work will be modified in an unexpected way depending on when and how you checked out the branch you’re on, what version of git you are using, and what config options you have set.”	gorgoiler	8.565056	-6.4953456	comment	3.0	22.0	1691471422	-11.865041
37055475	Stop wasting time writing commit mes	Stop wasting time writing commit messages	kgellci	8.58743	-6.531539	story	3.0	3.0	1691528860	-11.916204
37075672	> That campaign seems to have ended,	> That campaign seems to have ended, and nobody cares if your project has either anymore.Has the movement to rename every master branch to main quietened down as well?	azangru	8.522768	-6.525331	comment	3.0	13.0	1691672900	-4.183026
37087423	Along the same lines: when I want to	"Along the same lines: when I want to locally review someone’s PR, I want to see their changes as “dirty” relative to main, so that the changes show up nicely highlighted in PyCharm in the “gutter” (left side).  This has to be such a common need, but I am surprised that I have to do convoluted things like: create a new branch, switch to it, and then:git merge --no-commit --no-ff pr-branchAm I missing an easier workflow/command to achieve the above?
(Granted this is not so bad, and was suggested by GPT4, but I wondered if there might be a more straightforward way)"	d4rkp4ttern	8.578954	-6.500883	comment	3.0	10.0	1691753117	1.9067286
37095303	See also: https://news.ycombinator.c	"See also: https://news.ycombinator.com/item?id=25032956Pijul is definitely a nice research project, and maybe some of the technology behind it could be integrated into better git tooling. But I doubt that exposing users to the raw ""everything is just a bucket of patches, you have no history of repo state"" idea is good. People want to be able to bisect, or check out some older version at a given time point. There are benefits of pijul's model, but I don't think they are worth as much as losing that."	est31	8.587064	-6.5532956	comment	3.0	13.0	1691796790	13.896687
37097059	The names given to the commits are..	The names given to the commits are... peculiar.	GaggiX	8.591769	-6.49348	comment	3.0	17.0	1691814491	-11.847273
37099858	org-mode tables are great. So is mag	org-mode tables are great. So is magit, I highly recommend it! I'm comfortable with command line git, use it quite a lot, but I also use magit a lot, and magit is especially great as a much better `git add -p`.	drunkpotato	8.606887	-6.4694123	comment	3.0	10.0	1691846225	-11.792097
37292563	Wouldn't Git LFS be the tool for thi	Wouldn't Git LFS be the tool for this job? Have the automated tool build a .zip file for example of the translations (possibly with compression level set to 0), then have your build toolchain unzip the archive before it runs. Then check that big .zip file into GitLFS, et voila you now have this large file versioned in Git.	PMunch	8.574583	-6.4623322	comment	3.0	10.0	1693222975	-11.891497
37325358	I don’t get your git strategy - don’	I don’t get your git strategy - don’t you work with other people and have code reviews? And it’s not like branching means more things in progress - you can work on one dev/feature branch at a time.	jstx1	8.5794735	-6.5251117	comment	3.0	10.0	1693415445	-11.904322
37395131	Even though you're being downvoted I	Even though you're being downvoted I do agree that this should've been squashed (I don't see any other problems here, if that's not it).I've made sure via repo config that only squash commits are enabled from now on, so this will not happen again. Thanks for the feedback!	cube2222	8.566905	-6.535516	comment	3.0	47.0	1693935350	-11.94203
37395285	> Branch protection doesn't allow me	> Branch protection doesn't allow merging without a passing test-suite.https://github.com/opentffoundation/opentf/pull/243EDIT: and just to point out. If you have 1 PR with 19 commits that break the test suite. The last commit fixing it doesn't matter as you will be hitting one of those 19 commits at some point during a bisect.>Could you expand? You choose a sensible commit message on squash, while the PR's commits become fairly irrelevant at that point.It's optional. Nothing prevents you from just adopting whatever the PR said initially. Turning it on doesn't automatically make it better.	Foxboron	8.56673	-6.585321	comment	3.0	20.0	1693936168	-11.953345
37395803	"I'm sorry, but making only ""squash c"	"I'm sorry, but making only ""squash commits"" is also a bad idea. You can have a MR with multiple independent, atomic, commits.The ""real"" solution is making the developers aware of the issue and cleanup up their history before doing an MR."	Faaak	8.560246	-6.583899	comment	3.0	28.0	1693938509	-11.910827
37399667	>It's work in progress. We're workin	>It's work in progress. We're working on getting it finished.So finish it and then I will merge your PR ;) What's the use of putting it in master if it's not finished?It's the author's responsibility to get it merged successfully. If they're taking too long and have to rebase and re-work their code to integrate, that's on them.  Pushing it into master is either wasting a reader's time (per the original comment) or, worse, inviting an uninitiated collaborator to use it and cause an incident.	rvrs	8.630193	-6.5427732	comment	3.0	12.0	1693959413	-11.882579
37400700	If a git commit hash was directly ti	If a git commit hash was directly tied to a data hash at that state (IPFS), that would be trivial.	chaxor	8.652605	-6.512189	comment	3.0	11.0	1693967109	-12.020334
37417079	I never used exa as a general `ls` r	"I never used exa as a general `ls` replacement, but I did use it as a `tree` replacement. Its tree view that gives you file stats from ls alongside a `tree`-like view I haven't found replicated in any other tool.Here are the aliases I use:    et() { exa -alT --git -I'.git|node_modules|.mypy_cache|.pytest_cache|.venv' --color=always ""$@"" | less -R; }
    alias et1='et -L1'
    alias et2='et -L2'
    alias et3='et -L3'

exa never handled git ignores correctly so I had to manually provide common ignores with -I. But the above alias provides a scrollable tree view, with files colorized according to LS_COLORS, with file stats like `ls -l`, that I haven't found provided by any other tool. Suggestions for replacements welcome."	kbd	8.727208	-6.505895	comment	3.0	13.0	1694083572	-11.750655
37428908	It seemed much beloved by teams who’	It seemed much beloved by teams who’d used SVN or other source controls that had incremental version numbers, switched to Git, and strongly wanted to implement their old workflow in Git.I worked at a shop that tried really hard to pretend that it was possible to strictly order commits (“What if dev A writes commit 1234, then dev B writes commit 5678 and pushes it, then dev A pushes 1234. Which came first?” “The earlier one!” “What does ‘earlier’ mean here?” “Why can’t you just do it!”) and they thought Git Flow was the greatest thing ever.Put another way, it was popular among the same people who write every language as though it were their favorite. Have Python but they only have Java experience? All their Python looks like Java! Well, they thought Git Flow was spiffy, too.	kstrauser	8.562658	-6.4748836	comment	3.0	10.0	1694143927	-11.900929
37430478	Personally, I simply don't want to s	"Personally, I simply don't want to see any merge-commits, ever. Merges are hard to follow and may include conflict resolutions which are hard to show (if they show up at all).Sure, ""merging"" is an amazing feature. But I am not working on projects with an organizational complexity like the Linux kernel. Short-lived & rebased branches so that code gets integrated into main fast. Conflict resolution is never postponed nor shared. Versioning/release/deploy/rollback is dealt with mostly outside of git, or with tags-on-main at most."	the_gipsy	8.579882	-6.5564713	comment	3.0	16.0	1694156998	-11.91189
37434296	I went down a bit of a rabbit hole t	I went down a bit of a rabbit hole the other day, and put together some quotes from Linus and some info on how and why Git was created.	rlnorthcutt	8.5929985	-6.493524	comment	3.0	13.0	1694184881	-11.881823
37434861	> And it's amazing that two of the b	> And it's amazing that two of the biggest contributions to the world of software came from the same person.That's not that amazing at all, because the fame and weight of being the creator of the former led to the adoption of the other as it became the official version control management system on which Linux was developed. — These are not two independent results.If someone completely unknown developed Git 0.01 in 10 days, it would probably have  stayed relatively obscure, and the reason for it's quality is because it became so famous due to being tied with Linux, attracting many developers.	Blikkentrekker	8.552025	-6.43937	comment	3.0	16.0	1694186968	-11.892982
37459288	Git Based SDLC	Git Based SDLC	kown7	8.558122	-6.4856877	story	3.0	20.0	1694375297	-11.879039
37461974	Version control isn’t bulletproof ei	Version control isn’t bulletproof either. All your code history is one git rebase away from being abolished forever.I hope most orgs have processes around their main branches so this does not occur, but I’ve also been in smaller orgs and accidentally screwed up prod database tables, so the accidental git rebase isn’t impossible to consider…	SamuelAdams	8.570173	-6.55215	comment	3.0	11.0	1694397522	-11.91418
37462711	> I've seen this same resistance to 	"> I've seen this same resistance to deleting code in programmers working in repos that are completely under VCS, and it's flabbergastingI think a lot of developers only know the basics of git. They can check in changes, they can look at history with git log, and maybe they know how to use git blame.They often don't know how to filter git history. They often don't know about the git pickaxe, or about exclude patterns, and don't even think to question if you can do something like ""git log -G'int.*foo\(' -- ':(exclude)directory'"" to search for 'foo' in the git log, excluding some directory.They know how to ""grep"" within the existing code tree though, so they know if it's not deleted they can find it again with the right grep. If it's deleted, they might not know how to find it in git history."	TheDong	8.607661	-6.4817247	comment	3.0	12.0	1694404875	-11.824946
37514676	You don't need to know this, by the 	You don't need to know this, by the way. You can totally just think of git as simply storing a copy of your entire repo every time you make a commit. This is one part of git that actually is a good abstraction.Of course it is fun to know this but it won't help you understand git really, and please don't tell people who are just learning git. Just say git makes a copy of the whole project every time you commit.	globular-toast	8.571257	-6.4473596	comment	3.0	27.0	1694724627	-11.859019
37561213	Was this article written by ChatGPT?	Was this article written by ChatGPT? It's the same wishy-washy style. Ignore the article, the actual answer is always trunk-based development. Long lived feature branches will always come back to bite you.	modeless	8.61271	-6.5304136	comment	3.0	24.0	1695067264	-11.8378315
37561303	Agreed. If you like pain, long lived	Agreed. If you like pain, long lived branches are key.	bastardoperator	8.614761	-6.5383706	comment	3.0	21.0	1695067675	-11.832651
29018462	seems like a lot of work to split up	seems like a lot of work to split up your commits like this.  PR means -- trust no one.  the truth is out there (in the code).	darepublic	8.583231	-6.4836497	comment	3.0	17.0	1635365288	-11.8963785
29063694	I'm not a native speaker. The articl	I'm not a native speaker. The article regularly mentions 'the Git porcelain', or just 'the porcelain', what is meant by this? Do they mean it's fragile or something?	bartvk	8.555768	-6.488559	comment	3.0	40.0	1635749049	-11.904803
29063967	The fact that all git operations are	The fact that all git operations are local (will except push, pull, fetch) and thus mistakes do not enter the (remote) repo so often, that’s really a great advantage.But what is the problem regarding merges?	hibbelig	8.590149	-6.549551	comment	3.0	15.0	1635752457	-11.891809
29068161	Ask HN: Alternatives to Git – what a	Ask HN: Alternatives to Git – what are you using?	vanilla-almond	8.584175	-6.458047	story	3.0	8.0	1635781104	-11.910119
29126078	"""How should I change to a different "	"""How should I change to a different branch?"" asked the programmer.""Use git checkout.""""And how should I create a branch?""""Use git checkout.""""And how should I update the contents of a single file in my working directory, without involving branches at all?""""Use git checkout.""https://stevelosh.com/blog/2013/04/git-koans/"	strictfp	8.560535	-6.524742	comment	3.0	23.0	1636157406	-11.915163
29126114	> Many new/inexperienced programmers	"> Many new/inexperienced programmers love complexity.Not sure if you're trying to argue that Linus was a ""new/inexperienced"" programmer when he first wrote git.I think the ""it's too complex"" argument against git is misplaced, or at least not complete. I don't find git ""complicated for complexity's"" sake (e.g. looking at Enterprise Java Beans back in the day), but it has a very specific workflow in mind for its conceptual model, and if you don't understand that conceptual model, you're just going to be confused.It took me a while to grok that model, but once I did it clicked and I understood it. Not saying it's optimal, but it also has a lot of benefits."	hn_throwaway_99	8.564444	-6.5051327	comment	3.0	10.0	1636157677	-11.92414
29126152	There are two solutions that come to	There are two solutions that come to my mind, both are more by convention:1. Always use merge commits (--no-ff) a la git flow, and leave the branch name in the merge commit. That doesn't get you the branch name on the commit, but it should help identify the branches.2. Use a pre-commit hook to put the branch name or bug tracker ID at the bottom of the commit message. There are some tools built around this, I've done it at $DAYJOB with a custom python script I manually copy around into `.git/hooks/pre-commit`.	ISO-morphism	8.547079	-6.5634046	comment	3.0	21.0	1636157964	-11.902937
29126205	Probably true. IMO the crime of chec	"Probably true. IMO the crime of checkout is that the command really is `git checkout <tree> -- <path>`, which updates that local path to match that git tree, but it implicitly fills `tree` with the current branch and `path` with all files.It actually makes sense if you learn the full command but makes zero sense when you google individual common operations and then they thought ""this command should also have a shorthand to create branches"" I suppose"	chrisfosterelli	8.573902	-6.532981	comment	3.0	11.0	1636158363	-11.851799
29126340	I completely agree. Git is a product	I completely agree. Git is a product of its requirements. It's not perfect, but it gets the job done, and obviously it does it pretty well.	loudthing	8.545646	-6.469485	comment	3.0	13.0	1636159381	-11.887239
29126353	I've used RCS, SCCS, CVS, Subversion	I've used RCS, SCCS, CVS, Subversion, SourceSafe, ClearCase, AccuRev, Perforce, and probably at least one more I've forgotten. ClearCase was a garbage fire for reasons of performance and stability, but none of them had an internal model that was as much of a hot mess as git's. It's not the OP who has forgotten what things used to be like. Maybe you-now understands git better than you-then understood CVS (for example), but that might have more to do with personal learning curves than with inherent complexity.	notacoward	8.592623	-6.4595785	comment	3.0	11.0	1636159512	-11.8636055
29126219	Basically, GitHub.GitHub would have 	Basically, GitHub.GitHub would have won even if it were MercurialHub. It had a better user model of the problem to be solved than any other SaaS code forge, and it supported both open-source bazaar-style development and private enterprise. The gamification and social network features are KILLER.Also, the Mercurial developers never had the built-in fan base of Linus Torvalds. Anyone who wanted to work on Linux had to use Git, so that was another major reason to learn (and stick with) Git.	krallja	8.519396	-6.5041504	comment	3.0	12.0	1636158461	-11.924796
29126267	If you always rebase, aren't you hid	If you always rebase, aren't you hiding even more of the history than if you have unlabeled branches?I have to admit I've never understood the point of keeping the history linear.	elsjaako	8.582914	-6.564463	comment	3.0	45.0	1636158797	-11.905623
29127829	I kinda hope you’re being sarcastic,	I kinda hope you’re being sarcastic, but it doesn’t sound like it, so I’ll respond with a straight face. Why would anyone ever want to capture typos, especially if they never got saved? I definitely don’t want that kind of pure noise when I review changes.The context & argument you’re repeating here but either missing the true essence of, or teasing about, is the view that since git rebase edits commit history it is bad. The Fossil devs have long been advocating this view using hyperbolic language like saying git is ‘lying’. This unfortunately incorrect framing stems from Fossil having different goals and assumptions than git, and the Fossil devs projecting their dogmatic views on their perceived competition.But… even the Fossil devs are not actually advocating capturing every single keyst	dahart	8.525332	-6.554564	comment	3.0	14.0	1636177420	9.560834
29128713	I’m so relieved to hear someone arti	I’m so relieved to hear someone articulate this sentiment that _git_ is user hostile. Sometimes it feels like TINA to git in the modern world.At a conceptual level, so much of the more esoteric parts of git makes little to no sense. E.g., rebasing. I don’t completely understand what it is supposed to achieve.Even vi, with its own idiosyncrasies, is eventually grokkable once you understand that vi key sequences are an expression of an action you want to take.Git? Nothing makes sense. There is no connection (that I can nail) between its many features and how we think about and articulate what we want to do with a repo.It’s success is so strange to me.	saimiam	8.54824	-6.498988	comment	3.0	13.0	1636190414	-11.969812
29188365	I have to disagree with this as it r	I have to disagree with this as it relies on the assumption that every commit on a branch is logical and descriptive. In my experience a lot of PRs will have small commits that have poor names as they go through a review process. If you merge this using a regular merge commit or by rebasing the commits on the target branch this creates a lot of noise for those who look at the commit history.In my opinion it is best to squash all commits into one before rebasing it on top of the target branch. During this process any information that is considered important for the history can be preserved by leaving it in the commit body.	jonkoops	8.581885	-6.5433354	comment	3.0	11.0	1636642099	-11.92672
29233543	Do you know what github does differe	Do you know what github does differently when performing a merge? I’ve noticed sometimes github says there’s a merge conflict yet when i do the merge locally using the default recursive strategy it often just merges without any conflicts. I know there are cases it can’t handle when there are conflicts, but it seems odd that it cannot merge when there are no merge conflicts.	beermonster	8.602828	-6.5070143	comment	3.0	12.0	1637014340	9.034399
29250525	Thank you for your comments, I appre	"Thank you for your comments, I appreciate it. I'm still not sold, however. I would like to understand the underlying principles, ""how this works"". I don't need implementation details (happy if they are shared, though) but more on the main principles of operation. Please see my further comments below:> Git is very bad at analyzing SQL diffs.Agreed, nothing against. So PS has built-in a nice SQL diff. Neat! But what this really brings? I mean, it's not that there aren't SQL diff tools, tools to manage DDL migrations. Besides this, why not layer it on top of Git? Many orgs and integration tools already have similar workflows (e.g. approval workflows, issue management tools, CI, etc) and if instead of coming up with a new system it would be a layer on top of the existing ones, it would probabl"	ahachete	8.601793	-6.50353	comment	3.0	14.0	1637139457	-11.873937
29255673	Usually when feature-branch-1 is sti	Usually when feature-branch-1 is still under review and feature 2 relies on feature 1, I just open a PR from feature-branch-2 onto feature-branch-1 to get the review process started, knowing that feature-branch-1 might still change which I can deal with by rebasing.	barbazoo	8.583844	-6.530885	comment	3.0	19.0	1637168738	1.6691977
29257812	Yeah one pain point is if you squash	"Yeah one pain point is if you squash your commits on PR merges, you'll have a situation where the branches look like:    master: 1, 2, 3
    feature-1: 1, 2, 3, 4, 5, 6,
    feature-2: 1, 2, 3, 4, 5, 6, 7, 8

Then we merge feature-1 into master (numbers in parentheses indicate squashing):   master: 1, 2, 3, (4, 5, 6)
   feature-2: 1, 2, 3, 4, 5, 6, 7, 8

Then say we have another commit to master:   master: 1, 2, 3, (4, 5, 6), 9
   feature-2: 1, 2, 3, 4, 5, 6, 7, 8

And now we need to rebase feature-2 onto master. We can't do a normal rebase because git will try to do:   feature-2: 1, 2, 3, (4, 5, 6), 9, 4, 5, 6, 7, 8

Instead we have to do a slightly tricky maneuver where we rebase just 7, 8 onto master, getting:   feature-2: 1, 2, 3, (4, 5, 6), 9, 7, 8

It's not impossible and you can mem"	hardwaregeek	8.618278	-6.5922832	comment	3.0	13.0	1637177700	-11.947612
29258807	>(At facebook people regularly stack	>(At facebook people regularly stack over 10).Meaning branch 1 depends on branch 2 which depends branch 3... all the way to 10?That just seems crazy to me.  What happens if branch 4 changes their implementation and borks everything depending on it?	treis	8.600871	-6.5145807	comment	3.0	11.0	1637183059	-11.835277
29321724	  > 1. Find and replace a pattern in	"  > 1. Find and replace a pattern in a codebase with capture groups
  > git grep -l pattern | xargs gsed -ri 's|pat(tern)|\1s are birds|g'

Or, in IDEA, Ctrl-Shift-r, put ""pat(tern)"" in the first box and ""$1s are birds"" in the second box, Alt-a, boom. Infinitely easier to remember, and no chance of having to deal with any double escaping."	l0b0	8.605833	-6.4925547	comment	3.0	15.0	1637693850	-11.65712
29329115	How does bisect help in a large proj	How does bisect help in a large project? Seems like it would be best to use personal expertise to find it	randomopining	8.579385	-6.531969	comment	3.0	10.0	1637755148	1.0591301
29377390	Have you ever run `rm -f important_d	Have you ever run `rm -f important_doc.txt` instead of intended `rm -f important_doc copy.txt`?It doesn't matter if it is GUI or terminal interface, software must be _humane_, forgive mistakes and provide a way out. As much as love Unix coreutils and have them in may fingertips, those are the least humane programs I have ever used.Surprisingly, git seems quite humane, even when you screw things up it gives you a lot of safety mechanisms to recover.	p2t2p	8.569393	-6.5091567	comment	3.0	12.0	1638172019	-11.867705
29377780	I can do that with Emacs. What other	I can do that with Emacs. What other tools make it easy to branch in history?	linspace	8.598992	-6.5271053	comment	3.0	10.0	1638177346	-11.865341
29389833	Maybe an apt comparison is git.It's 	Maybe an apt comparison is git.It's just as easy to make a mistake with git today as it was however many years ago; git hasn't fundamentally changed in ways that make it easier. Git still more/less requires you to have a good understanding of what's going on in order to be comfortable using it.But, since use of git is now widespread, it's less of an issue. And the git CLI has seen some UX improvements.Nix is very weird. I'm sure there are some ways its UX could be nicer; but to some extent, doing things in a strict/pure way is always going to have friction if the tools/environments don't easily support that.	rgoulter	8.576765	-6.489415	comment	3.0	20.0	1638257580	-11.888216
29396663	`git add -p` does that as well, it's	`git add -p` does that as well, it's effectively what the GUIs are using.  You can also [e]dit each thing and rewrite as desired, though it can be a bit fiddly.UIs can be nicer though for rewriting / making finer-grained splits than the hunks that -p decides on, definitely agreed there.  I have broken out a UI just to simplify staging some gnarly commits.  GUIs are also often nicer for understanding and resolving nasty three-way merge conflicts.	Groxx	8.614374	-6.528209	comment	3.0	12.0	1638302108	-11.917196
29438411	> Using commit log diffs as changelo	"> Using commit log diffs as changelogs is a bad idea: they're full of noise. Things like merge commits, commits with obscure titles, documentation changes, etc.I’d rather fix that. I’ve been following the suggestion from this website in the past. It is a nice take but tedious and boring.Better have commit messages. For example:
https://www.conventionalcommits.org"	bromuro	8.595121	-6.523876	comment	3.0	11.0	1638588315	-11.905089
29439843	I've shared this anecdote elsewhere 	"I've shared this anecdote elsewhere but it's my go-to example. We recently had a new engineer join our team, we gave them a small piece of work related to a bigger feature we had completed months before they arrived. They tracked the feature back to the squashed PR commit, which of course referenced the Github PR URL- in there they had the engineer's summary and implementation caveats, the review comments from the rest of the team and the discussion context. They could reference all the commits made throughout the process from there. The PR itself used ""Closes #X"" syntax, so they could jump back to the engineering task and up into the product backlog item that spawned it. They nailed the change the first time :-)> What is the size of the resulting commit (in terms of average modified files"	rezonant	8.594006	-6.545123	comment	3.0	10.0	1638611673	-11.920632
29516368	About two years ago, a change in wor	About two years ago, a change in work caused me to become a heavy git user. One of the most important changes I made to my bash setup was to change my prompt to multi line, detect whether I was in a git repo, include the branch in the prompt, and also include a summary of git status.Very handy! (The check also makes sure I am in the repo part of the repo, and not, say, in its .git folder or other non-working folders.)	PeterWhittaker	8.576445	-6.4572487	comment	3.0	10.0	1639176176	-11.842972
29565401	There are mentions in this thread ab	"There are mentions in this thread about false positives, risk of data loss, others.  This made me think of Star Trek's use of a self destruct phrase.  Obviously their method is too slow, but you could have a ""duress"" phrase and a ""all clear"" phrase.User-Defined Phrase: ""Please dont kill me"", activates ""duress"" mode.- A daemon listens in the background for a phrase of your choice.  When detected, your laptop makes a sound effect that is not out of the ordinary for others to hear, but not something you would expect it to play when self destruct is activated.  Git repos are committed/pushed with a duress demarcation code to an alternate branch.  Your encrypted volumes are dismounted, buffers and caches cleared, camera and microphone start sending small chunks of audio/video to a destination o"	LinuxBender	8.5568695	-6.490249	comment	3.0	53.0	1639573727	-11.890804
29586423	I have been doing this for years. I 	I have been doing this for years. I have my team push changes directly to master (they have the option to use a feature branch and code review if they feel it is necessary of course). Once per release cycle, we have meet, I put the diff off all changes since the last release and we review every change going out as a group, we talk about what is being changed, why, and people can explain their changes. Sometimes something needs to be fixed, and we can fix it right there.- The quality of these reviews is better than any code review I’ve seen on feature branch reviews- We review the whole collection of changes going out, on rare occasions when two changes conflict, you catch these- Everyone keeps up to date with what is changing in the code base and why- If for whatever reason there’s an issu	hatchnyc	8.605412	-6.469398	comment	3.0	11.0	1639703487	2.223529
29609232	I guess the one where the commits ar	I guess the one where the commits are signed by the author. If there are forks, good for the author since these then are backups.Disclaimer: I have only a vague idea about the whole underlying tech but I've also been wondering if there isn't a simpler approach.	blablabla123	8.581363	-6.452023	comment	3.0	11.0	1639866709	-11.868098
29672165	> I write my comments in commit mess	> I write my comments in commit messages because those are valid forever.Don’t they disappear when someone squash merges branch where a file is both renamed and changed (a lot)? Or, at least, when somebody decides to move to code to another repo, and doesn’t bother bringing the git history along.	janaagaard	8.579958	-6.528123	comment	3.0	21.0	1640339715	-11.91138
29673421	Probably one of the best videos abou	Probably one of the best videos about subversion: https://youtu.be/GwDdJsdYM3g	logronoide	8.605985	-6.460635	comment	3.0	20.0	1640352829	-11.842568
29677117	Rule 10. If you can - comment in com	Rule 10. If you can - comment in commit messages instead of statically in code.When you do git blame you get commit message for each line of code. You can see what ticket changed it (there will be reasons why it changed hopefully), what it was before, what other things changed with it. This is incredibly useful, much more useful than static comments in code. But you have to help yourself by writing good commit messages and making small commits that don't mix many changes into one. If you fix whitespace or some stylistic stuff - don't commit it in the same commit as your business logic changes.The best things about comments in commit messages is that they are automatically changed when you change a line of code in the next commit. They are never outdated and are never lying to you (regular 	ajuc	8.581031	-6.5182633	comment	3.0	10.0	1640375510	-11.91279
35936963	Merge branch 'x86-rep-insns': x86 us	Merge branch 'x86-rep-insns': x86 user copy clarifications	cyberhost	8.630244	-6.459105	story	3.0	39.0	1684060585	10.261896
35967184	Oh man ~180mb to build a _book_.  It	Oh man ~180mb to build a _book_.  It's 2023, why hasn't someone figured out a good way to check in photos and other binary objects into a git repo?  I'd expect someone in the latex or ML community to have build a pre-commit hook to, I don't know, link & upload to S3 or something, right?I think git (and vcs in general) could be revolutionary to the way experts in all fields including law, medicine, book editing & publishing, etc can collaborate and track changes on shared documents, but yeah, we really haven't figured out how to handle necessary accoutrements like images without blowing up the repo size.Otherwise, definitely enjoyed seeing a project layout using directories for chapters.  Might crib (with attribution!) the project layout next time I feel like writing something.	api_or_ipa	8.569246	-6.4384427	comment	3.0	12.0	1684268265	-11.872872
36029821	No. You and those replying to you ha	No. You and those replying to you have completely misunderstood what the author wrote. My emphasis and a clarifying adverb:> As a team member, you don’t wait until you have finished a feature or story to integrate your code to the mainline. Instead, you frequently - at least once a day - put your code into a healthy state that passes tests and [then] integrate it into the mainline with everyone else’s current work.You get your local copy into a healthy state - build passing, tidied up, refactored - and then you push it upstream. The idea is precisely that you only push healthy code, and so never break mainline.	twic	8.6483965	-6.534486	comment	3.0	14.0	1684753275	1.3352481
36046513	IMO, in small/solo development proje	"IMO, in small/solo development projects, you really don't need particularly descriptive git messages.I'll frequently commit 40 disparate changes under ""stuff"" in my personal projects. It's never been a problem. No real need to LARP a big software project with many developers."	marginalia_nu	8.5524235	-6.495811	comment	3.0	19.0	1684858868	-11.837302
36178945	It's easy to forget how unintuitive 	It's easy to forget how unintuitive the git model is after you have used it for a long time.  It is quite unintuitive.  Especially because many use it in conjunction with GitHub which centralizes the decentralized model (and causes impedance mismatches along the way).But, it does feel like a big upgrade over the past iterations of version control like svn.	throwaway_5753	8.576221	-6.4739223	comment	3.0	10.0	1685815430	-11.882915
36179029	I completely agree. Some commands ar	I completely agree. Some commands are not intuitive at all. I always wanted git stage [file], git unstage [file] instead of add and reset.I totally understand why those were chosen when the original code for git was written but I really think it's time to re-evaluate the CLI and do better.	hparadiz	8.572244	-6.4999056	comment	3.0	11.0	1685815831	-11.88441
36212160	Ask HN: Which is a better unified AP	Ask HN: Which is a better unified API platform?	harshithmulla	8.723378	-6.4719205	story	3.0	5.0	1686057239	9.154776
36236670	One question however: would Linus ac	One question however: would Linus accept merging the commits signed by a pseudonym?  Or Asahi patches would not be upstreamed due to this?	gaius_baltar	8.64884	-6.452419	comment	3.0	10.0	1686193472	-11.798983
36297415	Something I love about the experimen	Something I love about the experiment tooling I've used at a few places now (Thread, Google) is the fact that state has typically been stored in source control. i.e. not just the usage of flags in code, but the rollout/experiment definitions, the state of how much traffic is allocated to each branch, eligibility requirements, etc. This makes it easy to see what the current state is (without going to a UI), and also makes it much easier to build tooling around that state, as the API data sync problem disappears.Looking at DevCycle, it seems you've not taken this approach, is that right? Scanning your docs it seems there's an API to update state, but that fundamentally it's kept in your database, not in code. In my experience this isn't the best dev experience, so as dev experience is your U	danpalmer	8.642675	-6.479418	comment	3.0	18.0	1686590932	-11.895664
36307554	It's a pet peeve of mine when people	It's a pet peeve of mine when people put stuff like this in a project's `.gitignore`. The proper place is either your global gitignore (probably appropriate for stupid stuff like this) or in your clone in `.git/info/exclude`.`.gitignore` is for stuff that all developers need to ignore, like compiler output, and should be kept to the bare minimum.	globular-toast	8.637327	-6.462421	comment	3.0	14.0	1686647266	-11.814934
36327263	I wonder if bisect is the optimal al	I wonder if bisect is the optimal algorithm for this kind of case. Checking for the error still existing still takes an average of ≈500 iterations before a fail, checking for the error not existing takes 10,000 iterations, 20 times longer, so maybe biasing the bisect to only skip 1/20th of the remaining commits, rather than half of them would be more efficient.	rjmunro	8.599921	-6.5462856	comment	3.0	30.0	1686755820	-11.895793
36328088	There is actually a bayesian version	There is actually a bayesian version which I wrote: https://github.com/ealdwulf/bbchopBasically it calculates the commit to test at each step which gains the most information, under some trivial assumptions. The calculation is O(N) in the number of commits if you have a linear history, but it requires prefix-sum which is not O(N) on a DAG so it could be expensive if your history is complex.Never got round to integrating it into git though.	ajb	8.561675	-6.524798	comment	3.0	11.0	1686759053	-11.877661
36335032	I guess it depends on the context in	"I guess it depends on the context in which you are seeing the message.For me, the most likely context is through blame or similar - I am looking at some code, and trying to understand its history. I see who changed it, when - and their commit message. In which case, only the intent is useful - I already likely know what the change does.The ""what it does"" form is more useful if for some reason you're scanning commits trying to find the one that introduced some particular change. But that's not a use case I ever encounter."	stevage	8.583076	-6.525289	comment	3.0	11.0	1686790484	-11.90472
36359970	I've never seen so much bitterness. 	"I've never seen so much bitterness. Teachers in this thread are really, really salty. Just ask for his hall pass already and demand he call you ""MISTER dwater"".Imagine if we talked about people learning programming the same way?I have a general disdain for anyone who programs for 2 years and then thinks they have learned enough to teach anyone or improve the system in any way. 2 years is how long it takes just to learn git, let alone be comfortable teaching it. You better wait awhile, chief. Programming is the most important, most hardest, most critical thing in the world. Imagine thinking you could just stroll into MY world and make a possible difference in somebody's life with your abysmal and inexperienced self. The hubris! Y'know what? Go to the principle's office.  This will be on you"	goostavos	8.521533	-6.452498	comment	3.0	10.0	1686934743	-11.936215
36370984	I agree mostly but recommend avoidin	I agree mostly but recommend avoiding rebase at all costs at all times always and always prefer merge. Rebase is pure evil plain and simple.	kingdomforgit	8.594137	-6.5659957	comment	3.0	25.0	1687015267	9.299473
36371137	I don't think Git is easy at all.But	I don't think Git is easy at all.But 20 hours seems a worthwhile investment to me for something they will likely use for at least the next decade of any serious work with software? I'm assuming that this doesn't mean literally 20 hours of instruction.	quadrifoliate	8.529164	-6.471529	comment	3.0	42.0	1687016258	-11.894646
36372470	Done right and understood, it is as 	Done right and understood, it is as simple as merging, if conflicts arise no difference to conflicts via merge?But you get rid of those ugly merges back and forth and unviewable histories.. Not sure why not more people care, I guess it is a little OCD I do that for my stuff.. however the 20-50+ user projects where everyone, often multiple times merges develop or even other branches in.. really unusable history right away, lets not talk about any point later. Git has derailed to a mere backup system where you can jump back, but understanding changes later becomes impossible :(What people also rarely know: A linear history is without lies, but one can sneak additional changes into a merge commit that was in neither branch quite easy - I hate that!	throwbadubadu	8.581255	-6.534546	comment	3.0	13.0	1687023830	-11.909517
36373106	I've used git for the last 7 years a	I've used git for the last 7 years and I've had no problems with it. If a developer is not willing to invest their time into learning simple basic git commands and concepts then I think they're in the wrong business.	harha_	8.554463	-6.492855	comment	3.0	14.0	1687027125	-11.900214
36372071	You have to fix conflicts either way	You have to fix conflicts either way so what's the difference? I suppose when merging you only have to fix the cumulative conflicts, while when rebasing you have to incrementally fix the conflicts introduced by every commit which is annoying. I usually squash a branch (rebase on where it diverged) before rebasing to fix this.	ahelwer	8.602701	-6.553787	comment	3.0	13.0	1687021452	9.213676
36374882	"I have ""truly learned git"" (includin"	"I have ""truly learned git"" (including having written a clone for a school project) and still hate the CLI and conventional Git workflow. Why is checkout overloaded to mean ""restore a file from the index"" or ""move to a different branch"" or ""move to a different commit?"" Why can reset mean both ""un-add a file"" or ""delete a commit?""I am very happy that there are better frontends for git like Gitless or Facebook's Sapling. I also think their commands are more of a 1:1 mapping to ""raw"" git operations behind the scenes."	tylerhou	8.573431	-6.5393586	comment	3.0	15.0	1687037641	-11.890166
36375861	"""git checkout"" is a deprecated comma"	"""git checkout"" is a deprecated command, use ""git switch"" to switch to a commit, and ""git restore"" to restore a file"	Viliam1234	8.557193	-6.530605	comment	3.0	12.0	1687044983	-11.90874
36414856	Is that a problem?  A simple tool is	"Is that a problem?  A simple tool is good if it can solve complex problems, but a simple tool that can't is just an underdeveloped tool.  Sometimes you need a complex tool to solve a complex problem.I think a good mini language bridges the gap between interactive commands and programming.  Sometimes you need to spend an hour writing a program to do something complicated.  But because of various ""extraneous features"" built into UNIX commands, you rarely need to spend an hour manually poking at the filesystem.  The mini language gets you almost as productive as a full-fledged programming language, without feeling like you're programming.  (How do you know you're programming?  If you ""git init"" and start committing stuff, you're probably programming.  If your carefully-crafted thing scrolls i"	jrockway	8.588116	-6.5308766	comment	3.0	14.0	1687326579	-11.90554
36484849	I love magit and I use it basically 	I love magit and I use it basically every day. But lately, at my work's monorepo, I've been greatly pained by how synchronous it is (like much of Emacs). When I want to fix a unit test, I find suspicious commits by a grep for some keyword through diffs in the git log, and unlike the git CLI, magit will not show me any matching commits until it has searched through all of them (capped at 256 matches by default), which takes a very long time. I love so many creative Emacs tools, but the wait times from magit and consult get painful.	Conscat	8.600891	-6.4990187	comment	3.0	12.0	1687808939	13.842268
36486710	I'm surely in the minority here. I'v	I'm surely in the minority here. I've been using Emacs for almost a decade now, but I just can't get into the Magit workflow. I've tried several times, but always end up going back to Git on the command line. I have dozens of aliases, shell integrations, a nice diff viewer[1], etc., and interacting with Git has become muscle memory. I can commit, cherry-pick, rebase, bisect, fix conflicts, etc., in a fraction of the time it would take me to navigate Magit's UI. I'm sure with enough practice, a Magit user could do this more quickly and efficiently, but honestly, with some custom-built porcelain, Git's UI is not so bad. Though this could very well be Stockholm syndrome after using it for such a long time...For whatever reason, Magit's opinionated workflows never clicked with me. A part of it	imiric	8.605704	-6.491202	comment	3.0	11.0	1687818398	-11.796473
25813342	How do you selectively stage several	How do you selectively stage several hunks from command line in git? - Imagine you edited a large file, fixed two different things, now you‘d like to select the changes related to one thing first and commit them. And then the next changes.In Magit you visit the file you changed, hit `C-x g' and see all diffs. Now you can review and select hunks by hitting „s“ (stage), go to the next relevant hunk and hit „s“ again to mark for staging. And when you‘re done selecting all changes that are relevant for one ticket, you hit „c“ twice to write a commit message. And off to the modifications/ hunks regarding second ticket.So how‘d you do this in command line?	submeta	8.60745	-6.5284624	comment	3.0	11.0	1610908044	-11.898942
25813438	This is what sold me on magit:1. In 	"This is what sold me on magit:1. In the magit status buffer (equivalent of git status), you can selectively stage changes by highlighting the relevant lines and pressing ""a"".  Basically an interactive git add -p.  There's also line-specific unstage and discard.  This makes it easy to tidy up before committing.2. If the cursor is on a commit, commands (show, interactive rebase, push) will take that commit ID as a default argument.  It feels like you're interacting with the commits directly, which makes it easier to reason through an interactive rebase or partial push.  Simple rebases like reordering or squashing recent commits take only a few seconds.3. It seems to mostly rely on calling the core git commands and parsing their text output.  The core git commands are reliable.  Many git clie"	jpeloquin	8.613911	-6.50865	comment	3.0	13.0	1610908484	-11.881546
25898925	Subversion vs. Git: Myths and Facts	Subversion vs. Git: Myths and Facts	prepperdev	8.573629	-6.4523964	story	3.0	3.0	1611547280	-11.878554
26075435	Sorry. What year is it?Must be somew	Sorry. What year is it?Must be somewhere in the 1990s since you've mentioned perforce multiple times.	volta83	8.659414	-6.5007668	comment	3.0	12.0	1612862364	2.203032
26082974	Git didn't exist until Linus Torvald	"Git didn't exist until Linus Torvalds sat down and hacked it out in a few weeks during 2005.  I remember using SDL back in '99 to play with game development on Windows 98.  So the short answer is, git wasn't even an idea in its creators head when SDL was around and thriving.IMHO when you see a design decision that seems odd to you, it's a good opportunity to investigate the entire context around that design, rather than pepper the devs/issues/comment threads/etc. with pointed questions, ""Why did you do X when Y is now clearly better??""."	qbasic_forever	8.548077	-6.4740644	comment	3.0	10.0	1612908241	-11.889783
26190128	In Git you don’t have to actually co	In Git you don’t have to actually commit, you can use the staging area. It’s something I do rather often. I’m going to make a non-trivial change and I’m not sure if it’s the right approach, so I `git add -A` first, make my change, and then `git diff —-cached` to review it. This is especially useful when doing things like running formatting tools, so I can see what the tool just did. And it doesn’t require making any commits.Having said that, this approach only works if I know up front that I’m going to want to compare the code. Far more often is making a change and then realizing I want to see the old version. A history timeline would be extremely useful here.	lilyball	8.622111	-6.518356	comment	3.0	16.0	1613713001	-11.870862
26190142	Even commits are malleable until you	Even commits are malleable until you push them somewhere. I do this a lot - create commits of any meaningful checkpoint, then rearrange/squash/remove commits later that I don’t want , to create a well-formed commit that I push.Git stash can handle your use cases too, but commits are more powerful as they let you compose multiple pieces together	nilsbunger	8.577528	-6.5500574	comment	3.0	11.0	1613713170	-11.9025345
26193040	I do the same. Many people comment a	I do the same. Many people comment about commiting frequently but that doesn't work for me: delete code + commit => I don't see the code anymore and my brain magically forgets about it. I need the quick feedback loop: commented code + uncommented code (all in one screen) => new code is going to look like a mix of both. If I have to use git to see commented code then the feedback loop is broken.	sdevonoes	8.580826	-6.517555	comment	3.0	24.0	1613742308	-11.8931675
26217065	But what if I have software and imag	But what if I have software and images (e.g. as in game software)? Which version control system do I use?Honestly, I think the effort was better spent on an improved version of Git.	amelius	8.578655	-6.4605627	comment	3.0	13.0	1613940741	-11.881954
26239547	Yea... no.An overly clean git histor	Yea... no.An overly clean git history for me is a sign of too much perfectionism and greatly reduced productivity.When I code I usually have a general idea of the stuff I want to include in my branch, but then I stumble upon bugs or code couplings which I need to fix for my feature to work. And then I include the fix into my feature branch, because it's just tedious to switch all the time and create 5 interdependent branches that need to be merged together anyway. Also as long as the feature branch itself is fairly clean then I don't give a rats ass about atomic commits.And commits having to pass tests is just ludicrous. That's what the tests are for, so you can fix it before merging the branch. Don't go crazy on the commit level..It depends a bit on the project, and how public it is. But 	Droobfest	8.589122	-6.5467987	comment	3.0	11.0	1614099170	-11.926979
26239660	Yep, small disciplined commits take 	Yep, small disciplined commits take valuable time. If you rarely revert or get other benefits from them they might be a net loss for you. Especially in solo projects when you can keep a lot of what's going on in your head.It's a bit like testing - there's a lot of posts about where you need them and not many discussing where you don't.	seanwilson	8.582645	-6.515647	comment	3.0	10.0	1614099649	-11.900773
26241592	In fairness, you're only seeing 5% o	"In fairness, you're only seeing 5% of the typos. We caught the other 95% before committing. :)I love your question, ""why not a commit per keypress?"", because it raises an interesting follow-up: why not squash and rebase entire months or years of project work into single commits?  If squashing is so useful, why do we only apply it at low-grain scales? Could we read and understand massive projects quickly and easily, if they only had a few commits to them?I'm sure that we don't experiment with larger-scale rebases because of the limitations in the technology -- we all know that we're not supposed to 'git rebase' in public, and why that is.  But suppose those obstacles were lifted. Now that we can rebase and rewrite at any time scale, which scale(s) is the right one(s) to choose?"	gmfawcett	8.575471	-6.5586596	comment	3.0	11.0	1614107986	-11.916902
26242349	I figure it takes 3-4 weeks for a ty	I figure it takes 3-4 weeks for a typical newbie developer to learn git in depth. That's too much compared to the benefits. Git is way too complex and the CLI is badly designed, especially for a solo developer.The crux with git is that you really do have to learn it in depth, if you want to be self-sufficent in the end.	tpmx	8.542155	-6.4960856	comment	3.0	11.0	1614111503	-11.8953905
26280621	If one of your top commands is `clea	"If one of your top commands is `clear`, you may like my alias `c`:  $ alias c='clear &&'
  $ # Usage:
  $ c git status

[1]: https://github.com/grantzvolsky/skel/blob/ea43b1969463a97f96..."	GrantZvolsky	8.6154785	-6.5241213	comment	3.0	16.0	1614378600	-11.843071
26282574	Looks very interesting, congrats!A c	"Looks very interesting, congrats!A common mistake I have come across a few times (and seen others fall victim to as well) is forgetting to stage a file that's necessary for the new feature or fix they just committed.Do you think that identifying these cases and suggesting to stage them is something in line with the project? (e.g. while trying to commit: ""You imported file X in a file you staged, but it is currently being ignored, do you wish to stage it as well?"")"	gcarvalho	8.623152	-6.533274	comment	3.0	11.0	1614400165	-11.925197
26282981	I’m generally very skeptical  of any	I’m generally very skeptical  of anything that abstracts away git with UIs. This looks really cool though and I like that you embedded common git workflows into the CLI	vardaro	8.568221	-6.4879794	comment	3.0	13.0	1614405018	-11.894405
26284836	Bit needs just one single switch and	"Bit needs just one single switch and everyone will gladly use it for its killer feature.Undo with one single command, without strange additional arguments, weird naming, strange documentation[1] etc.[1]https://git-man-page-generator.lokaltog.netWhen anyone is doing the ""next best thing after bread and butter"" version control, please start with --undo switch.Sometimes you just need a hammer, without any will or need to learn how to make hammers."	stiray	8.574462	-6.515278	comment	3.0	12.0	1614434108	-11.836582
26320827	Do you have your commit history avai	Do you have your commit history available in a public repository? I don't. Honestly, i'm paid for being a professional fuck-up. I just fix things quickly and support my team enough for us to bear the mutual guilt in silence.	NotPavlovsDog	8.584747	-6.504786	comment	3.0	12.0	1614719554	-11.886697
26348183	Yes, but every hapless user shouldn'	Yes, but every hapless user shouldn't have to go searching through a bunch of commit messages to find the suggested replacement. Bad UX.	drfuchs	8.603572	-6.443003	comment	3.0	26.0	1614891393	-11.853181
26348628	> Why make it harderBecause there is	> Why make it harderBecause there is no way for a commit message to become outdated or detached from what it talks about, both of which are very much issues with comments.> why make it impossible to update if there are other suggested alternatives that are available since whenever the commit was made?Because that doesn't really matter.	masklinn	8.58176	-6.515913	comment	3.0	13.0	1614893357	-11.888617
26348756	> Why not check the git history?Beca	> Why not check the git history?Because that is effort every person who uses the file has to do over and over again, whereas maintaining the file is effort that has to be done once by one person.	adrianmonk	8.569176	-6.490751	comment	3.0	12.0	1614893911	-11.894037
26355869	Git does not have colaboration tools	"Git does not have colaboration tools. It's very much a ""work in a silo for a period of time and then evtually figure out how to mash these things together"" approach."	madeofpalk	8.488251	-6.5010405	comment	3.0	18.0	1614945681	-11.912368
26406721	What's an easy way to fix the defaul	What's an easy way to fix the default git installation on OSX?	toomim	8.562022	-6.4521956	comment	3.0	12.0	1615339713	-11.869434
26454881	The most unfortunate part of all thi	The most unfortunate part of all this churn is that git didn’t provide a way to ask it what a repository’s main branch is named.	kbd	8.525011	-6.511263	comment	3.0	16.0	1615725969	-11.8254795
26470720	At risk of sounding curmudgeonly, I 	"At risk of sounding curmudgeonly, I can't help but feel like `git maintenance` is a bit of unneeded feature creep. Does it sound useful? Sure. But should it part of git itself, when its functionality could be easily achieved instead by crontabbing a relatively simple shell script that runs existing git commands? I feel like the answer is ""No."". Of course, not everyone would go out of their way to write the aforementioned shell script; they even address this directly in the release:> You could manage these data-structures yourself, 
  but you might not want to invest the time figuring 
  out when and how to do that.On the other hand, not everyone will use `git maintenance`, so by the same token you could argue it's unnecessary bloat."	Svetlitski	8.541649	-6.476058	comment	3.0	10.0	1615850891	-11.898807
26471661	Are there any plans to add support f	Are there any plans to add support for large files to Git? (Not as an extension)	amelius	8.565138	-6.447145	comment	3.0	11.0	1615856967	-11.875827
31050748	Where I work, development is trunk b	Where I work, development is trunk based and without pull requests, and all code is reviewed. When I want to submit code, I push it to a staging area that tracks master. This causes the commits to appear in Gerrit where (conflict-free) rebasing can be performed with a single button and the code can be reviewed. During the staging I can change anything about the commits to my hearts content. Once everyone is satisfied, someone with the authority to approve the change approves it and I submit it, upon which the patches are applied as-is on the branch I staged it for.Creating a separate branch, pushing this to your public copy of the repository and then asking someone to pull from that branch into their master branch seems absurd to me, especially if it's just 1-2 commits, and the idea of rev	boomlinde	8.580088	-6.513973	comment	3.0	13.0	1650098371	-11.939236
31065085	Doesnt unity Just Work(tm) with git,	Doesnt unity Just Work(tm) with git, too?	leetrout	8.56194	-6.4413676	comment	3.0	11.0	1650234363	-11.880165
31079109	Not sure if I like this better.It se	Not sure if I like this better.It seems even more complicated to track 3 context points in time rather than 2.I'm open to changing my mind, but would need reasons.  Botched rebases aren't a common issue for me (though merge conflict resolution can be unpleasant).	metadat	8.584309	-6.569717	comment	3.0	12.0	1650334057	9.303885
31080901	We recently adopted it at my company	We recently adopted it at my company for managing local dev machines, project environments, and CI. It definitely has some warts, often the best documentation is “read the source code”, but man is it an awesome tool. I’ve switched all of my machines / servers over to it and I’ll never look back.Now I’m looking at my iPad and iPhone and wishing I could manage them through Nix too.I’d put it at a comparable difficulty to learn / powerful tool as git. Which given that they’re both based on hash trees makes sense.	BreakfastB0b	8.576424	-6.453129	comment	3.0	14.0	1650357983	-11.882952
31103426	Sure, diff3 is better than nothing. 	"Sure, diff3 is better than nothing. zdiff3 is even better. But there's so much scope for better diffs still. For starters we could have semantically aware diffs that take into account where blocks are (I think there are some efforts to do this).But even diff3 is missing information. Lets say the code started as A, you changed it to B. Then you rebase and `master` is C. You'll get basically ""It's C now! But you changed it from A to B.""That's not enough information. Why was it changed to C? I don't know how to update my diff without that information. Really you need to see the change that changed it to C too.There's so much scope for an advanced conflict resolution tool. Git gets it wrong in so many situations where you could do better."	IshKebab	8.716925	-6.4885902	comment	3.0	11.0	1650490939	-11.805998
31104742	If you're getting a lot of conflicts	"If you're getting a lot of conflicts then you have folks working on the same code and diverging it significantly. I honestly don't think that's a problem tooling will improve because it's really an organizational/communication problem. Engineers have to know when to rebase (or merge in changes from the target) if they're working on code with other engineers. If you merge in/rebase sooner, then things tend to be painless. If it's been weeks or months then let the Circus O' Pain begin. This should be fairly easy to recognize in stand up, eg: ""Oh, you're working on that module? I need to track your changes, so am I."""	kodah	8.673895	-6.509556	comment	3.0	10.0	1650500640	-11.823612
31131836	It is kind of true, though. From Mer	It is kind of true, though. From Mercurial docs:>The public phase holds changesets that have been exchanged publicly. Changesets in the public phase are expected to remain in your repository history and are said to be _immutable_Note that in Git all history is mutable, even if published.Regarding 'backout' (and 'revert'), to the best of my knowledge, it does not revert commit, it creates a new one (reverting changes), and I frankly do not know is that's possible at all to amend commit in Mercurial (when I worked with it, that was definitely not possilbe, but that was a long time ago)	Miiko	8.534013	-6.55869	comment	3.0	12.0	1650693915	-11.955858
31149545	> This was fun, but my gut reaction 	> This was fun, but my gut reaction to the title was “it doesn’t have to be easy, just possible” and that holds.It really depends why you’re hashing and what the consequences of a collision are. Using a hashing algorithm to protect sensitive data (should I hash passwords with SHA-1?) should weight the value of this answer significantly differently than using it as a convenient lookup optimization (should I use SHA-1 to identify git references?).  And there’s a spectrum between those, where that convenience might be an attack surface (can I impersonate someone’s git commit?) or might be worth the risk (does it matter if I can easily find a collision?).Unless I’ve missed some new proof, it should be assumed the answer to “is it possible?” will likely always be yes. The question then becomes 	eyelidlessness	8.6680355	-6.521184	comment	3.0	21.0	1650846085	7.2270064
31173878	GitHub (by default) uses the name of	"GitHub (by default) uses the name of the PR as the merge commit message and also includes the commit message of each commit in the log. Having whitespace-altering ""Dummy commit to trigger CI, ugh!"" commits in a git history isn't good but it still clutters the `git log` with stock squash+merge GitHub use.I can't speak for everybody, but if GitHub goes down completely and I only had access to my git logs, I'd struggle to recreate ~20% of the information scattered across issues and PRs. This issue is external to merging preferences, but it's definitely not solved by squash-merges and descriptive merge messages."	mwt	8.582051	-6.553673	comment	3.0	20.0	1651011582	-11.941237
31204370	What happens when the shortened vers	What happens when the shortened version becomes ambiguous?For instance that's commit 9e02977bfad006af328add9434c8bffa40e053bb.What happens when someone creates a commit and that happens to have 9e02977bfa-e-something?I'm not even sure what github does here. Does it just refuse to select a commit or give you a list of candidates and you have to check the date (given that your link presumably was unambiguous when you wrote it)?	faho	8.592679	-6.5384564	comment	3.0	18.0	1651236156	-11.889433
31231182	My CS minor program didn't cover GIT	My CS minor program didn't cover GIT.	formerkrogemp	8.543064	-6.4535418	comment	3.0	16.0	1651462485	-11.938648
31243177	I agree that the concept behind git 	I agree that the concept behind git is powerful and elegant. I very much disagree that the implementation of git is elegant. For example: how many things does `git checkout` do? And I still don't understand what the point is of having a staging area. Or why I need to edit files in order to provide Git with instructions on what to do when it rebases. Or why adding hunks is so much more difficult than adding complete files.Git is built upon a powerful and beautiful concept, but the Git CLI is just about the worst viable interface to that concept that you can build. There's a reason that there are so many other Git UIs, such as Magit, SourceTree, GitKracken, etc.	quanticle	8.555893	-6.507349	comment	3.0	10.0	1651540718	-11.889824
31402527	I've always been puzzled by 4-way me	I've always been puzzled by 4-way merge not being  more common.  Support is quite rare.KDiff3 is another tool that supports it.	WalterGR	8.720766	-6.491982	comment	3.0	13.0	1652731259	9.234746
31420446	Do you know about .git/info/exclude?	Do you know about .git/info/exclude? It only exists in your local git file so it isn’t shared with a remote repo and achieves this same purpose.	RupertWiser	8.612195	-6.4653597	comment	3.0	11.0	1652862637	-11.838807
31425210	If they did not commit all the impor	If they did not commit all the important files and your CI system didn't catch that, that's definitely the fault of your CI system, not global gitignore.	fishywang	8.571704	-6.4743414	comment	3.0	16.0	1652894016	-11.879912
31425146	That sounds... unnecessary.  There i	That sounds... unnecessary.  There is always stuff to refactor, and tests to add, folks showing up at the last minute with new requirements.  Or you can just wait a day to push commits, etc.  More honest, I think.	digisign	8.674818	-6.484296	comment	3.0	17.0	1652893624	-11.867957
31480969	The author suggest prepending v to a	The author suggest prepending v to a tag name for the sake of shell completion. This assumes that everyone will be interacting with git tags using a shell. I disagree that a v should be prepended for that reason.	CamelRocketFish	8.581372	-6.5017805	comment	3.0	11.0	1653322580	-11.848844
31482216	>Tag push permissionsAgreed entirely	">Tag push permissionsAgreed entirely on restricting tags (they tend to have meaning and expected semantics outside the repo, which makes them risky), but also!  Teach people more about git, or unix CLI patterns in general.  `git log test` is ambiguous about it being a tag (or branch) or file/folder, but `git log -- test` is not.  `--` as an ambiguity-preventer is a very common pattern, it works in many, many CLI tools.---One that hasn't been included here: don't rely on tags for any kind of business logic, if you have literally any way to avoid it.Tags are mutable, and do not have a history of when you changed them.  They're plenty handy for ""human, enter a thing to use"" purposes, but you should immediately turn that into a commit sha and then only use that commit sha."	Groxx	8.550789	-6.490309	comment	3.0	27.0	1653327473	-11.873643
31483856	Um okay.That is not what anyone mean	Um okay.That is not what anyone means when they talk about immutable objects or refs in Git. I can delete a commit from `.git` but they are still considered immutable.A branch is mutable since you can push it forward without `--force` as long as the current commit becomes an ancestor of the next tip. Can you change a remote tag without `--force`? I don't know off the top of my head. But I doubt it.	avgcorrection	8.5782795	-6.524936	comment	3.0	11.0	1653334297	1.1251138
31571496	Unrelated to fork itself, but I alwa	Unrelated to fork itself, but I always wonder how do people implement the vertical colored lines representing branches and merges. This is present in almost all git desktop clients, and of course very useful.	IMTDb	8.576301	-6.505041	comment	3.0	11.0	1654014432	-11.9029875
31630625	Fossil is better for small project	Fossil is better for small project	secwang	8.520216	-6.5535326	comment	3.0	13.0	1654434252	-11.96628
31635287	I wonder what the server feature giv	I wonder what the server feature gives you. I've been using fossil for a decade or so, always over ssh. Definitely don't need to do that setup part.Fossil doesn't do rewriting history. I think that rules it out for large team efforts. As an immutable distributed log of everything I write by myself it's essentially perfect.	JonChesterfield	8.510271	-6.546291	comment	3.0	40.0	1654467034	9.524484
31635474	I hear a lot of larger teams insist 	I hear a lot of larger teams insist on squash commits for PRs. Fossil isn't a fan of squashing.	spiffytech	8.570644	-6.5693946	comment	3.0	20.0	1654468537	-11.948355
31635927	There are significant pockets of non	There are significant pockets of non-git users in the developer community ;)I find hg much more pleasant to use than git, and can generally still work in git based teams while using hg.I find pijul's approach much more interesting than git's, and look forward to pijul (and others :) pushing forward how we do revision control.I don't believe git to be the end of the evolution of revision control systems (which for me has looked like cp -> rcs -> cvs -> svn -> git|hg), and find git lacking enough that I look forward to what the next generation does.Would I argue that you personally should branch outside of your git centric world? Of course not! Just as I've worked with many devs who live their lives gainfully employed only knowing Java, or sys admins who only know Microsoft, it is up to you 	srer	8.540415	-6.4979277	comment	3.0	31.0	1654473027	-11.912226
31682979	Nice landing page. I built git-rerer	"Nice landing page. I built git-rerere as a service for a company, they only use it internally. The most annoying part of rebase is resolving the same conflict again and again..git/rr-cache is the recorded resolutions that help auto resolve the same conflict by matching ""preimage"" and re-apply ""postimage"". You could add this feature, it's a killer even github doesn't have a way to feed in rr-cache."	Existenceblinks	8.5801735	-6.5639887	comment	3.0	11.0	1654790921	9.330618
31695776	You're just shifting work though. Th	You're just shifting work though. The commit will now contain 10000 non html structure changes to an html, phtml, whatever, instead styles to a CSS sheet. Might as well go back to doing inline styles. There's a reason we don't do that anymore.	calvinmorrison	8.5812025	-6.5134926	comment	3.0	11.0	1654876050	-11.8993635
31697916	Where did you hear Facebook is dumpi	Where did you hear Facebook is dumping Mercurial. Last I heard they were using Rust to optimize  Mercurial.	themerone	8.505419	-6.6310825	comment	3.0	11.0	1654886670	-11.939203
31698363	> I feel like an SCM would have to b	> I feel like an SCM would have to be WAY better than git to make it worth using.That's how Git overthrew SVN. Cheap branching, robust conflict management, and offline workflows were killer features. Throw in Github, which is more accessible and lower friction than emailing patches and lurking on mailing lists, and SVN's fate was sealed.	spiffytech	8.569318	-6.469929	comment	3.0	22.0	1654888923	-11.902117
31698592	A really critical sneaky trick that 	"A really critical sneaky trick that Linus pulled in the implementation of Git was to just pretend like Sha1 hashes never collide, which helped make ""cheap branching, robust conflict management, and offline workflows"" possible. This (false but convenient) assumption massively reduced the complexity of many algorithms, and allowed Git to efficiently do things that other source control systems couldn't do.   I personally switched from Darcs to Git about 15 years ago entirely due to performance issues."	williamstein	8.622576	-6.489651	comment	3.0	19.0	1654890314	-11.884336
31756182	"I don't think Git ""won"" principally "	"I don't think Git ""won"" principally on technical merits.I think it won because VCS transitions are very painful so people wanted to use the system that they expected to end up being most widely adopted. Certainly that's why I chose it in 2007.And of course when you're making this decision you should assume that many other people are making it on the same grounds.I believe the term for this situation is a ""Keynesian beauty contest""."	mjw1007	8.540131	-6.4589086	comment	3.0	12.0	1655313616	-11.8956785
31762659	They're using git as a cache. Having	They're using git as a cache. Having generated files stored there means they're available if they're needed (eg in CI) without needing further access controls, they're versioned, and it's a simple and understandable strategy. As the article states, most devs are set up to ignore those files so they're not much of a source of the slowness. It's a common pattern for apps that have to serve lots of different locales.	onion2k	8.584022	-6.445013	comment	3.0	24.0	1655356736	-11.887716
31762863	Remember back when people recommende	Remember back when people recommended commiting node_modules into git?	SenHeng	8.579586	-6.5231047	comment	3.0	25.0	1655359264	14.26537
31762922	> I'm not saying don't have the tran	> I'm not saying don't have the translations at all. I'm saying: 1) caching things in git in general is a bad idea (...)You're missing the point. Storing translated files is caching things in git, and it is not a bad idea. It's a standard practice that saves your neck.You either place faith on a build step working deterministically when it was not designed to work like that, or you track your generated files in your version control system.If you decide to put faith on your ability to run deterministic builds with a potentially non-deterministic system, you waste minutes with each build regenerating files that you could very well have checked out and in the process risk sneaking in hard to track bugs. Then you need to have internationalization test steps for each localization running as par	arinlen	8.620761	-6.456219	comment	3.0	11.0	1655359924	5.522707
31763079	> git status takes 10 seconds on ave	> git status takes 10 seconds on average> running these commands multiple times a day reduces the total productive time engineers have every dayI love the attention paid to this. Often opportunities to prioritise seemingly small efficiency gains are neglected.At 10 seconds per command, an engineer that uses git status 50 times per day spends ~10 minutes per day waiting; an entire work week per year!! Well above the threshold warranting optimisation, and that doesn't even factor in distractions and context switching.	nomilk	8.555345	-6.4511933	comment	3.0	12.0	1655361416	-11.853394
31763355	  > it takes 10 seconds to run git s	"  > it takes 10 seconds to run git status

People coming from the SVN world do not think that this is unusual or problematic. And unfortunately even recently I've seen SVN still in use at large legacy companies."	dotancohen	8.576867	-6.4613037	comment	3.0	16.0	1655364198	-11.881875
13998767	I'm sure this has been posted before	I'm sure this has been posted before, but regardless it's still extremely relevant.It's been almost 3 years now since this article was written, and I've still yet to see a git UI which is anywhere near as good as the one proposed here in terms of functionality and UX.If a GUI like this is ever implemented, I might finally be able to use something besides the CLI for my git client.	Ajedi32	8.566663	-6.452591	comment	3.0	11.0	1490907162	-11.875598
13998882	> Everything is a commit. Treat work	> Everything is a commit. Treat working copy and staging area as commits, allow regular commit operations to be applied to themThat… silly. No. That doesn't make any sense at all.	donatj	8.63939	-6.5624723	comment	3.0	15.0	1490908170	-11.931411
13999569	This is especially funny considering	"This is especially funny considering the huge discussion recently about rewriting curl and then the entire world in Rust, but imagine you lived in a world where the magical ""better tool"" already existed and all you had to do was discover it.Leaving fantasy-land aside for a moment, this morning you woke up in the real world. In the real world, that tool does already exist, and it's called Mercurial.If you try command-line Mercurial for long enough to get past the initial ""oh no Windows/macOS/Linux got updates and moved all my icons"" muscle-memory-refresh phase (and especially if you last long enough to get into revsets and templates), you'll find it extraordinarily difficult to go back to using command-line git. Your power grows with Mercurial as you learn more about it because you aren't c"	shabbyrobe	8.519194	-6.5430155	comment	3.0	14.0	1490913794	3.2630394
14013994	Writing detailed commit notes can be	Writing detailed commit notes can be useful in the same way.  I have backed out of a commit during the write up more times than I would like to admit because I realized that I hadn't covered some edge case or I completely forgot about something (like the effect of the change on a report or other sub-system).  Writing things out in a way that someone else can understand forces you to re-think through the task in different ways.	allannienhuis	8.592867	-6.5547857	comment	3.0	10.0	1491078331	-11.898783
14040635	I think the problem the movie crew f	"I think the problem the movie crew faced, was that GitS basically needs something like the Marvel Universe stretching to retell the story. Most of the episodes of GitS2 would have made for a Stand Alone movie.
So what to do?
The original is in particular running against the usual hollywood conventions. There is no visible villain, until late, then the villian turns out to be a grey area guy, hunted by other grey area guys.>the culture series is longing for a movieHonestly, i hate it when book SciFi gets put into movie shape. Its rarely looks like i imagined it."	Pica_soO	8.535929	-6.4417844	comment	3.0	30.0	1491381335	-11.853456
14048614	I'm a git noob. I realy mis an optio	"I'm a git noob. I realy mis an option to simply backup my current work situation to Git and work further on it on another machine, or simply later with the knowledge that everything is safe on the server. Currently I have a big list of commits called ""Backup"" which I always push immediately. It's ugly. Is there a way to save to the git server your current situation with bothering others working on the project with your commits?Maybe this is simply not what Git is made for and I should use Git from my NextCloud folder to have my data safe on a server?"	teekert	8.560101	-6.4385557	comment	3.0	14.0	1491463421	-11.858559
14134027	"alias gp=""git push"" has probably sav"	"alias gp=""git push"" has probably saved me hours of my life"	artursapek	8.57398	-6.4922886	comment	3.0	20.0	1492460101	9.551897
14134498	Would be nice to have some form of a	"Would be nice to have some form of autocorrect directly in the shell, especially if it was aware of common programs and so could also autocorrect options. Obviously we could think of a few cases with destructive outcomes--but that doesn't make it a bad feature.git stautsI mean, git knows enough to ask me ""Did you mean this? status""."	ryandrake	8.595667	-6.5132203	comment	3.0	14.0	1492463965	-11.874661
14285224	Or just clean up your local history 	Or just clean up your local history before you push. Frequent commits are handy for checkpointing a known state so you can experiment freely and easily revert failed attempts; then, when you know you've got something good, you can squash the relevant commits and rewrite the messages to provide solid detail, and push a clean result.Interactive rebase is an amazingly powerful tool - a little hard to use at first, but the investment of effort to learn its capabilities pays off manyfold. If you're looking for an easy way to level up, and you haven't investigated it before, I can't think of a better choice.	throwanem	8.579905	-6.5685673	comment	3.0	25.0	1494161788	-11.978992
14285236	One of the teams I work on is pretty	"One of the teams I work on is pretty religious about one commit per PR and mandatory rebasing, which is a nuisance at times, particularly when one feature is made up of multiple different stepse.g. refactor code to allow thing X to be pluggable, implement new alternative for thing X, load thing X if user has the right permissions all need to be squashed down to just ""implement thing X"""	Macha	8.576934	-6.554726	comment	3.0	11.0	1494161903	-11.897177
14338307	Ask HN: Using a version control syst	Ask HN: Using a version control system for your resume?	toexitthedonut	8.647049	-6.4400325	story	3.0	3.0	1494808345	-11.84861
14386488	For example, correctly merging a fin	For example, correctly merging a finished feature branch requires up to 15 individual Git commands!Am I missing something? Does `git merge` imply fourteen other commands?	btym	8.583729	-6.549075	comment	3.0	18.0	1495359800	-11.91822
14386496	Git Town looks thorough to me. It in	"Git Town looks thorough to me. It includes well-written source code in Go, plenty of edge-case error checking, good messages, and excellent feature tests. Kudos!If you're interested in branch aliases, here are some that may be helpful that I use at GitAlias.com.topic-start = ""!f(){ branch=$1; git checkout master; git fetch; git rebase; git checkout -b ""$branch"" master; };f""topic-pull = ""!f(){ branch=$(git branch-name); git checkout master; git pull; git checkout ""$branch""; git rebase master; };f""topic-push = ""!f(){ branch=$(git branch-name); git push --set-upstream origin ""$branch""; };f""topic-finish = ""!f(){ branch=$(git branch-name); git checkout master; git branch --delete ""$branch""; git push origin "":$branch""; };f""branch-name = rev-parse --abbrev-ref HEAD"	jph	8.566581	-6.5086536	comment	3.0	12.0	1495359928	-11.884674
14387626	> squash-merge the password-reset br	> squash-merge the password-reset branch into the master branch (this makes it look like a single, clean commit, without the convoluted merge history and the many intermediate commits on your branch)Is this what most people do? And is this something you can turn off with Git Town? I don't like to to squash-merge, I spend time making sure my commits are as much logical and self-contained units as they can be in my branches, and I want to preserve the ability to revert and/or bisect them later.	dahart	8.573025	-6.5669703	comment	3.0	11.0	1495379186	-11.931428
14401185	For the love of your chosen deity, p	For the love of your chosen deity, please do not take git as a good example to base your CLI UX on..	weavie	8.562674	-6.4843493	comment	3.0	13.0	1495547766	-11.852075
14403444	hey Linus, undo last 1 git command (	"hey Linus, undo last 1 git command (as though it had never been entered):  git undo 1

thanks."	logicallee	8.5688305	-6.523928	comment	3.0	21.0	1495562022	-11.777636
14403555	I'll bet between the reflog and alia	I'll bet between the reflog and aliases you could do that.	emodendroket	8.685471	-6.5873346	comment	3.0	18.0	1495562555	9.645946
14409723	My personal favourite:    git for-ea	"My personal favourite:    git for-each-ref --sort=-committerdate

.. shows progress for each branch .. this makes it surprisingly easy to see which of the developers in our group (with their own branches) is pushing the codebase further .."	mmjaa	8.565792	-6.4627066	comment	3.0	12.0	1495631469	-11.882011
14412057	Coming from the days of CVS and SVN,	Coming from the days of CVS and SVN, git was a freaking miracle in terms of performance, so I have to just put things into perspective here when the topmost issue of git is performance. It's just a testament how huge are the codebases we're dealing with (Windows over there, but also Android, and surely countless others), the staggering amount of code we're wrangling around these days and the level of collaboration is incredible and I'm quite sure we would not have been able to do that (or at least not that nimbly and with such confidence) were it not for tools like git (and hg). There's a sense of scale regarding that growth across multiple dimensions that just puts me in awe.	lloeki	8.567325	-6.4717493	comment	3.0	13.0	1495648693	-11.875626
14412769	They use mercurial (or were), which 	They use mercurial (or were), which is as good as git. In fact, I bet a lot of people at Google are happy to use mercurial instead of git, given git's bad reputation with its command line interface.	farresito	8.522895	-6.475034	comment	3.0	13.0	1495654171	-11.935051
14413127	Isn't this perhaps the greatest vali	Isn't this perhaps the greatest validation of Linus's design genius that what was initially a weekend project[0] has successfully scaled to this?They could no longer use their revision control system BitKeeper and no other Source Control Management (SCMs) met their needs for a distributed system. Linus Torvalds, the creator of Linux, took the challenge into his own hands and disappeared over the weekend to emerge the following week with Git.[0] https://www.linux.com/blog/10-years-git-interview-git-creato...	cubano	8.599643	-6.4436955	comment	3.0	12.0	1495657210	-11.892997
14417553	rebase : centralized repo :: merge :	"rebase : centralized repo :: merge : decentralized reporebase : linked-list :: merge : DAGIf the work/repo is truly distributed and there isn't a single permanently-authoritative repo, 
a ""clean, linear"" history is nonsensical to even try to reason about.In all cases it is a crutch: useful (and nice, and sufficient!) in simple settings, but restricting/misleading in more complex ones (to the point of causing many developers to not see the negative space).You can get very far thinking of a project as a linked list, but there is a lot to be gained from being able to work effectively with DAGs when a more complex model would better fit the reality being modeled.It's harder to grok the DAG world because the tooling is less mature, the abstractions are more complex (and powerful!), and almost a"	rdubz	8.577804	-6.5350027	comment	3.0	15.0	1495722882	9.234435
14431489	I would often rather use a decade-ol	I would often rather use a decade-old project that was developed solo by a world-class expert dumping code over the wall once every 6 months than a community project being hacked on by 100 amateurs.Without additional context I find recency of last commit and number of committers to be almost impossible to draw useful conclusions from.	jacobolus	8.570515	-6.4418635	comment	3.0	16.0	1495912599	-11.851326
14534886	Considering how many people are incr	Considering how many people are incredibly productive with Git, calling it junk might be unfair.	yock	8.544442	-6.4695964	comment	3.0	37.0	1497234189	-11.88503
14535008	You can become that expert too by re	You can become that expert too by reading this tutorial. https://www.sbf5.com/~cduan/technical/git/ It doesn't teach you commands at first because:> you can only really use Git if you understand how Git works. Merely memorizing which commands you should run at what times will work in the short run, but it’s only a matter of time before you get stuck or, worse, break something.	chx	8.550239	-6.4952164	comment	3.0	17.0	1497236869	-11.897578
14535094	Given that practically every non-beg	"Given that practically every non-beginner git tutorial starts off with ""back up your repository"", it's quite clear that git gets wedged a lot.Somehow, I rarely see a Mercurial tutorial give that same advice unless you are doing something really experimental."	bsder	8.53272	-6.549983	comment	3.0	19.0	1497238882	-11.958508
14535228	If you're writing a non-beginner git	"If you're writing a non-beginner git tutorial and you feel the need to include advice to ""back up your repository"" then you haven't done your job. It's incredibly hard to lose data with git - no matter what changes you make, the old commits are still around, because they're immutable. If you lose track of them, there's always ""git reflog"".I don't want to pounce on you just because you prefer Mercurial to git, so this isn't really directed at you, but in general this line of argument is always a bit frustrating to me. I've never lost data with git, but I've lost data with Mercurial several times because of the terrible UI of ""hg resolve"", which throws away your changes without warning unless you remember to type ""hg resolve -m"". None of git's questionable UI decisions (and there are many) h"	swift	8.547479	-6.549579	comment	3.0	15.0	1497242596	-11.9299965
14552746	Took me a while of reading here to r	Took me a while of reading here to realise, there's no git here. This is a seperate thing that cannot be integrated with your existing stuff, if you're already using Git.I'd like to have the option of Word documents in Git but I don't want a whole other system just for the special snowflake that is Word as I'm already using Git for managing LaTeX documents and doing that entirely on my own infra.	irl_	8.578232	-6.4383273	comment	3.0	13.0	1497448892	13.735795
14554436	This is interesting, but what's wron	"This is interesting, but what's wrong with ""Track Changes""? (a feature Word had for at least 10+ years now).
I believe for most people that is more than enough for version control purposes.
For tech people that actually know what Git is and how to use it, I bet they'd want real Git integration, or they'd choose to store the document in a different (more easily managed by Git) format such as .md or .html."	gigelu	8.592633	-6.4600716	comment	3.0	11.0	1497462017	-11.871752
14580431	Is there a valid reason to move to g	Is there a valid reason to move to git from any other VCS a person happy with, regarding time and resources one have to spend on it instead of productive work?	SergeAx	8.549991	-6.4580493	comment	3.0	11.0	1497790292	-11.876541
14634101	It is, and he's wrong, and he's usua	It is, and he's wrong, and he's usually wrong when security comes up.See also git using SHA-1: people warned him about this, and he argued passionately and incorrectly that git doesn't use SHA-1 as an integrity measure. He also argued passionately and incorrectly that SHA-1 was unlikely to be broken and worrying about it was a waste of effort. And now other people are doing a lot of slow work to dig ourselves out of literally every single git repo in the world relying on a broken crypto primitive.	geofft	8.675524	-6.523131	comment	3.0	14.0	1498451412	7.220052
14667475	+1, that's a pretty cool idea>> I wr	+1, that's a pretty cool idea>> I write the test after, then I reorder the commits once the test passes, and make sure it fails predictably in the way you were expecting it to fail.	charlieflowers	8.652806	-6.5315866	comment	3.0	10.0	1498776495	-11.901989
20370601	Are these not just mirrors though or	Are these not just mirrors though or do they actually use git? Woulda thought they used SVN primarily since they pull from Debian? Or do they just pull tarbals... And this all leads to me wondering how they do their process... Anybody got good docs on how Ubuntu or similar distros that base off a parent distro do their work?	giancarlostoro	8.5876255	-6.474393	comment	3.0	12.0	1562432797	-11.849612
20394734	`git merge`, `git rebase`, `git reba	`git merge`, `git rebase`, `git rebase -i`, `git revert`, `git checkout`, `git reset`, `git reset --hard`, `git log`, `git reflog`, `git stash`, `git cherry-pick`, `git add`, `git rm`, `git status`, `git commit`, `git push` and squash, reword, fixup, pick and f@ck knows what else. Who wants to really use all this bullshit just to do versioning?Especially if you are a beginner, this doesn't make any sense (and not even later in many cases)In my experience during the last two decades or so in the industry, there is always a special kind of person in the IT field who takes pride knowing all the nitty-gritty details of the latest shiny versioning tool. Should it be IBM Clearcase or SVN or CVS or Git or Mercurial. Even though that most of these softwares only slightly improve the user experienc	fogetti	8.576227	-6.542652	comment	3.0	10.0	1562695125	-11.917512
20395273	If I was to do it again, I would tea	If I was to do it again, I would teach Git with paper - have the class augment a paper tree with paper nodes or something else tangible. You can even have them write a collective story instead of code. The more abstract the topic, the simpler the analogs to get the largest subset of users to grasp it.	dzink	8.552274	-6.470511	comment	3.0	15.0	1562698090	-11.917271
20470391	> You’re describing merges, not comm	> You’re describing merges, not commits, or pushes to remotes.Both merges and commits can be pushed. I’m not exactly sure what distinction you’re trying to make.Also, btw, I’m using git terminology, but not everyone uses git. I’m including my experience on teams that use Perforce, for example.> One can commit and push to branches all day. Merging them to master without a heads up is a bad idea.Yeah, right, exactly. You agree with me. My policy is about putting anything new in the master branch during off hours, because breaking changes that evade the tests may not get fixed until work hours, and prevent other people from working at night or over the weekend.	dahart	8.613121	-6.550915	comment	3.0	27.0	1563461398	-11.908927
20470387	Many of us do a “squash merge” (use 	Many of us do a “squash merge” (use git rebase to compress to meaningful points in a CR and again before merging to master or feature branches). This creates a clean history at the expense of not being able to stalk others work at high granularity or get as large a score on github’s tracker.	inlined	8.5660095	-6.5695767	comment	3.0	13.0	1563461366	-11.942927
20470911	I would suggest making use of 'git c	I would suggest making use of 'git commit --fixup' or 'git commit --squash' which creates a commit that is specially-named such that you can later squash everything together with `git rebase --autosquash'. It's really transformed how I work on large patchsets.	cyphar	8.57229	-6.5594826	comment	3.0	10.0	1563464176	-11.925016
20471081	I stand by my top comment, avoiding 	I stand by my top comment, avoiding pushes Friday and waiting until Monday often leads to both code commit times on Monday and merge commit times on Monday. (Edit: and BTW I know this for a fact, because we monitored average commit times to make sure the policy was being adhered to.)If you look at the code from the article, you’ll see that the author did not filter out merge commits. The word merge doesn’t even appear in the article. The OPs data includes merge commits.You’re trying to draw a hard and idealized line that doesn’t exist in real companies. Squashes often happen right before push. Stashing for the weekend rather than committing is common. People unsafely leaving uncommitted changes in their workspace over the weekend is common. Most devs in my experience are not git experts, a	dahart	8.592892	-6.5382805	comment	3.0	22.0	1563465159	2.1393738
20485352	OP here. Apologies for not being cle	OP here. Apologies for not being clear. This is very similar to how Gerrit works. There's an additional stage before the commit lands on the trunk (where commits get reviewed). You rework your commit by amending/interactive rebasing and pushing again.When you get approval, you can submit your commits and Gerrit will try to merge them (even if the trunk has moved; you can say it's sort of cherry-picking on the trunk). If it can't merge the commit, you'll have to take a pull and push your commit again by resolving conflicts.Edit: Tweaked the post a little to make it more clear.	shubhamjain	8.577327	-6.51193	comment	3.0	10.0	1563625576	-11.910139
20499222	Good that git is a distributed VCS. 	Good that git is a distributed VCS. At least our master branch history is available on our local PCs, and we can freely work. Yupi.	mielecmichal	8.563659	-6.4428687	comment	3.0	14.0	1563810943	-11.865034
20512596	"Why do merge tools pretend that ""the"	"Why do merge tools pretend that ""their"" and ""our"" or ""remote"" and ""local"" are good labels? Can they not show the commit message and hash? Nowadays with history editing often both sides are local and mine."	pjtr	8.594043	-6.5726867	comment	3.0	10.0	1563946489	-11.927929
20611628	It is easier to track people being a	It is easier to track people being at their desks than diving into the git repository and looking at what got done.Also, for a programmer who did not code for 5 years because they got into management, it is a huge source of anxiety and forces them to contemplate the obsolescence of their skills. Having to ask a junior dev how to compile the project you are supposed to overwatch can be felt as humiliating.When I had a team to manage, I tried to keep involved enough so that I could do the whole build process. Most of my work was complaining about broken master branch and regressions, praising the correct person when a feature gets implemented, shout with the higher management to stop adding irrelevant features every time they meet a client and have a weekly discussion on how things are going	Iv	8.536949	-6.459764	comment	3.0	11.0	1564984788	-11.901204
20618427	Git-Revise	Git-Revise	jgraham	8.568525	-6.5116568	story	3.0	52.0	1565036209	-11.894388
20658732	>Don't waste your time with what is 	">Don't waste your time with what is hipWouldn't that apply to git? You can probably get 90-95% of the benefit of git using mercurial with a fraction of the effort in learning. Life is too short to spend learning the internals of one version control system.This idea of ""Don't waste time on X focus on more valuable Y"" has no real end. Don't waste your non-work time on learning computing related stuff and instead spend time on social connections and physical fitness first. Pays off way more than emacs, git, vim, lisp, or programming paradigms. See how easy it is to make such pronouncements?"	BeetleB	8.511922	-6.5479965	comment	3.0	19.0	1565389926	-11.93337
20731496	> I think a big problem is you grab 	> I think a big problem is you grab a library and you really have no idea what you've gotten. Maybe it has a label. It says it's 1.2, but you don't know which functions inside it have changed, or why. You don't actually know what you're running. And maybe the jar file or artifact tells you something about the source that was used to produce it, but the process that was used to produce it is often opaque. And any of that could be wrong because there's a lot of human steps involved in producing artifacts. And because so many people use Git, I'd like to get closer to leveraging some of the features there, in particular using SHA's and content-based addressing to talk about things.> I had worked on a library called Codeq, which we'll have a new version of soon, that sort of extends the Git mod	tosh	8.642044	-6.483093	comment	3.0	10.0	1566148729	4.575418
20746056	Is there any feature in mercurial th	Is there any feature in mercurial that git doesn't have? Is there some plugin to allow mercurial users keep using the client with a git remote repository (like the one for using git with svn)?	hiccuphippo	8.503837	-6.5421586	comment	3.0	20.0	1566303673	-11.9627285
20746168	> Git will let you blow away a month	"> Git will let you blow away a month's work if you mistype a command.It's sad to hear someone say that, presumably you've been bitten by it.What you describe is not true.  While it's easy to blow away work you haven't committed, every commit you've made in the past month is saved in the reflog.  Going back to any one of them is as easy as finding it and typing git reset --hard.Erasing something from the reflog is hard.  Possible, but it's not going to happen by mistyping a command or two.Makes me sad because of course I agree the git UI is terrible, and I don't blame any user for not being able to figure it out.  Although Googling ""how do I recover lost git commit"" does pull up useful results."	jlebar	8.560478	-6.528886	comment	3.0	32.0	1566304387	-11.917097
20746233	> It is superior to Git in every way	"> It is superior to Git in every way except performance and adoption.Performance is such an important advantage, though.I type git diff hundreds of times a day, and when I switched from hg to git at Mozilla, this made such a big difference in my life.These days I type hg histedit maybe fifty times a day at Google, and I cry every time because it is so. glacially. slow.  hg diff too.  And I'm working with a relatively small repository.Speed matters for tools we use all the time.I'd also posit that the process of writing ""plugins"" for git is much easier than writing hg plugins.  A git ""plugin"" is just a shell script that uses git.  If you can use git, you can write a shell script that uses it.  An hg plugin...whoaboy."	jlebar	8.530628	-6.507549	comment	3.0	13.0	1566304771	-11.938086
20746470	I started with CVS then moved to svn	I started with CVS then moved to svn. From there moved to bazaar (bzr), from there moved to git and at last used mercurial and settled on it. I still keep an active look at fossil SCM.In my earlier team at fortune 100 firm, most developers use Windows with svn. We tried git and it did not work well due to UI and windows support. They were able to pick up UI easily and were quickly productive in mercurial. It worked pretty good on all 3 platform Windows, Mac and Linux. I am talking of time when GitHub was not that popular in corporate world.Performance was never an issue.Also at that time mercurial followed philosophy of being explicit and every merge needs to be explicit and committed with immutable history. So can see the evolution of code along with the mistakes made.I believe the succes	dragonsh	8.56864	-6.5245976	comment	3.0	37.0	1566306229	-11.917977
20746829	Order of my exposure to SCM  Shared 	"Order of my exposure to SCM  Shared windows mount
  Visual Source Safe
  CVS
  SVN
  Perforce
  ClearCase
  Git
  Team Foundation Server

Of those I still use Git and SVN.  Aside from the shared network drive, VSS and ClearCase are in a dead heat for the worst SCM I have been exposed to."	mey	8.585833	-6.4788656	comment	3.0	19.0	1566308204	-11.882336
20747461	Sourcehut has Mercurial support. It'	Sourcehut has Mercurial support. It's open source and community maintained, and will remain supported for as long as the Hg community wants it to be. We recently took our Hg team out to Paris to meet the Mercurial community at the first Hg conference, and discussed how we can get involved in the future of Mercurial and committed to continuing to improve our offering into the foreseeable future.I've whipped together a script to help you migrate your repos to hg.sr.ht, for those interested:https://hg.sr.ht/~sircmpwn/invertbucketLet me know how it works out for you - I'd like to hear some test results before I post it to sr.ht-announce. Cheers :)	ddevault	8.493227	-6.537055	comment	3.0	14.0	1566311814	-11.987164
20747947	No clue.  I thought for sure Mercuri	No clue.  I thought for sure Mercurial would come out ahead, it had some proponents:* Bitbucket provided unlimited free private repositories and they were exclusively Mercurial.  Github had limits for private repos.* Google evaluated both and preferred Mercurial for code.google.com http://www.saturngod.net/articles/dvcsanalysis-support-analy....* Fogcreek (creators of Trello and Stackoverflow) picked Mercurial to power KilnEarly on, both tools had different advantages but they evolved toward each other making the choice more about flavor and popularity.  My guess is* git was strongly associated with Linus so it won that crowd handily* Github had a stronger association with open source than Bitbucket (dunno why though).  Maybe it all came down to marketing.  <-- there's a startup lesson	libria	8.504587	-6.528482	comment	3.0	10.0	1566314482	-11.946977
20751331	So you say Git has complicated inter	So you say Git has complicated interface? (rant)	ozim	8.546686	-6.487371	story	3.0	2.0	1566331006	-11.882482
20777365	I know you said GUI, but this single	"I know you said GUI, but this single-line git alias that goes in ~/.gitconfig changed my life and I don't look for a git GUI anymore:    [alias]
 l = log --date-order --date=iso --graph --full-history --all --pretty=format:'%x08%x09%C(red)%h %C(cyan)%ad%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08 %C(bold blue)%aN%C(reset)%C(bold yellow)%d %C(reset)%s'

Next, go to one of your git project directories and type ""git l""If you don't want to learn rebasing and other Git fun, I'm not sure how much this will help you, but for me it's invaluable when it comes to identifying the base of my branch and where I would like to transplant it to.Along with the basic ""git pull --rebase"" I also frequently use ""git rebase --onto"" and ""git pull --rebase=merges"" or ""git rebase --rebase-merges"" i"	yebyen	8.600631	-6.518994	comment	3.0	10.0	1566567144	-11.852883
20776914	People seem pretty interested in kee	"People seem pretty interested in keeping their pre-git source control system, even if it means switching repository hosts. I know the default attitude is ""they're just curmudgeons who don't want to change,"" but Hg could have some advantages."	whatshisface	8.538195	-6.4581275	comment	3.0	11.0	1566564365	-11.870186
20781376	In a nutshell: Know your goal, know 	In a nutshell: Know your goal, know what just happened, know what to do next. Maybe obvious, but I agree, critical, and a good thing to make explicit to oneself.The author presents a lot of seemingly complex tools for this. Mine are, I believe, simpler -- a TODO list in .org mode (goal and next), and git log (for what just happened, always with --name-status to show what files were affected how, and maybe with -p to show the diff).But you could use anything.	Jeff_Brown	8.569795	-6.487175	comment	3.0	18.0	1566587308	-11.883732
20814537	> Lesson #4: When you choose specifi	"> Lesson #4: When you choose specific non-default settings, leave a comment or link to documentation/issues as to why, future people will thank you.Put it in the commit message. There is no better place to put it. That is the exact point in time at which you have the most information about that exact change. Commit messages are cheap, be liberal with your words and links.It drives me nuts to read commit messages of the form ""fix"", ""fixed 2"", ""add test"", ""new var"" and on and on. You took an hour to make the change, take a damn minute to save some future colleague a day of frustration."	jacques_chester	8.589006	-6.524032	comment	3.0	30.0	1566941214	-11.868752
20814777	Git blame only shows you the last pe	Git blame only shows you the last person that touched the line, not the person who introduced a breaking change to that line (but it wasn't caught for weeks/months).Comments are just as cheap as commit messages. Why not both?	umvi	8.56903	-6.4975305	comment	3.0	19.0	1566942661	-11.905721
20861372	> So to relieve some of that tension	"> So to relieve some of that tension and ease up the final merge you’re heading towards, you decide to perform a control merge now and then: a merge of master into your own branch, so that without polluting master you can see what conflicts are lurking, and figure out whether they’re hard to fix.It is indeed useful, and just so you won’t have to fix these later, you would be tempted to leave that control merge in the tree once you’re done with it, instead of rolling it back with, say, a git reset --hard ORIG_HEAD and keep your graph pristine.if you use git ""linear history"" style and will do a rebase at the end anyway, why not do ""control rebases"" immediately, instead of control merges?At least from my experience, a rebasing on a branch that has substantially diverged can get painful quickl"	xg15	8.5831585	-6.5587287	comment	3.0	11.0	1567453464	-11.92828
20876941	I'm convinced that the obsession wit	I'm convinced that the obsession with rewriting history is solely due to inadequate tools. Git doesnt keep the name of a branch after it's merged, so people want to make merges look like a single commit on top so that they don't face this ambiguity. Github doesnt even display the branching structure in its commit log, which also shows a woefully small number of commits per page, further incentivising squashing/editing. Many tools (some are better than others) display commit history in a similarly non-dense way or in a way that implicitly discourages branching in some way, e.g. gitk doesn't even display commits from other branches by default. Large numbers of commits are also unwieldy when commits are hashes that cannot be ordered mentally just by looking at them.Over in mercurial land peop	doubleunplussed	8.575806	-6.552677	comment	3.0	17.0	1567603512	-11.922165
20890626	Last commit is from Oct 2018, is thi	Last commit is from Oct 2018, is this still maintained?	ecesena	8.610373	-6.452255	comment	3.0	13.0	1567717436	-11.894861
20995370	I want to say it's the freedom to se	I want to say it's the freedom to self-host, but really it's the CI.Throwing a .gitlab-ci.yml file into my repo is by far the easiest way to get CI/CD incorporated into a product. The configuration of test runners (or lack thereof) is both a breeze and extremely powerful.I'm not even talking about the auto-devops thing that I haven't tried; writing your own gitlab-ci file worked in frictionless ways that CircleCI, Travis, and (especially) Jenkins didn't.	Townley	8.520332	-6.4527664	comment	3.0	10.0	1568729922	8.969405
20997212	I'm being pedantic here, but the rea	"I'm being pedantic here, but the reason I prefer pull is because it feels more general than a ""merge,"" which to me precludes a fetch/rebase. I guess you could consider it a merge -ff-only, but in a mergeless-master workflow, ""merge request"" felt awkward."	banachtarski	8.587739	-6.49395	comment	3.0	11.0	1568738365	7.8004994
23739655	Where can one learn the art of excel	Where can one learn the art of excellent commit messages and when to rebase, etc?	technics256	8.586822	-6.55099	comment	3.0	11.0	1593964991	-11.871249
23740889	Spending time on commit messages tha	Spending time on commit messages that will be essentially removed when the PR is squashed seems... not very productive	dtech	8.577448	-6.540921	comment	3.0	25.0	1593974662	-11.928242
23740930	Commit messages are supposed to be s	"Commit messages are supposed to be short. ""Fixed stuff"" is totally wrong. I usually write ""Added ability to do foo with bar when baz is true.""Commit messages aren't mutually exclusive to the inline documentation.I am making the case that inline documentation is far more important than commit messages."	systemvoltage	8.589098	-6.531081	comment	3.0	20.0	1593975001	-11.933389
23740988	And that’s why PR squashing is count	And that’s why PR squashing is counter-productive. Good luck trying to track down an issue when bisect leads you to a 1500 line commit containing an entire feature.Repo commit history is an artifact the team produces, as much as the code it contains.	aeontech	8.584122	-6.560888	comment	3.0	17.0	1593975521	0.5809247
23751470	> almost nobody ever goes looking fo	> almost nobody ever goes looking for them thereI've seen this claim a number of times and it's always so odd to me. One of my most common activities each day - certainly more common than the activity of writing new code - is reading the commit history for different files. It's always surprising to me to hear that this is an uncommon thing to do.Edit to add: But I also think comments and documentation of all kinds are good. I don't advocate good commit messages instead of comments, but rather in addition to comments. The more documentation the better.	sanderjd	8.582101	-6.534808	comment	3.0	17.0	1594062128	-11.91169
23770090	For anything other than personal pro	For anything other than personal projects where messages don't matter much, -m is an anti-patern.Any good commit message should have at least a paragraph explaining the rationale, functional change and maybe links to design docs or bugs. All the time I come across commit descriptions from decades ago, that are useful because of this.	cameronbrown	8.586609	-6.5326185	comment	3.0	13.0	1594217952	-11.904644
23805897	"    git config pull.rebase true
    "	"    git config pull.rebase true
    git config rebase.autoStash true

I think these should have been the defaults but they weren't implemented until later and it's hard to change defaults."	modeless	8.570862	-6.552569	comment	3.0	14.0	1594501087	-11.866471
23806220	I use git a lot, and I like the spee	"I use git a lot, and I like the speed and decentralized nature. But I do think there's much to be improved.Named branches don't really exist in git: there's only a moving target name that refers to a leaf node. This means there's no ""history"" associated to a branch except for the parent commits. But in merge commits with several parents all parents are considered equal, and the system does not contain info about which commit belonged to the ""main branch"" and which was imported in. This information can be valuable in some cases. This leads to a lot of rebasing just to keep the commit log clean, but this actually rewrites history and destroys information.Also, there's no support for keeping two parallel views of the same repository (for example, an internal view with lots of subcommits, and "	y7	8.575717	-6.5468183	comment	3.0	18.0	1594503117	-11.910454
23806388	> Why would I ever want to make a br	"> Why would I ever want to make a branch without checking it out? It's literally never happened, yet it's the default.  git checkout -b new-branch

I fairly often make a branch as a sort of named undo point, and only check it out if need to undo to that point.  Tags could work for that purpose too, but the branch approach seems safer in my usual work situation."	bacon_waffle	8.565703	-6.5473223	comment	3.0	29.0	1594504206	-11.904017
23806440	What about a “git init-lite” option?	What about a “git init-lite” option?So many times I want to VC a directory but don’t care about commit messages, branching, or other jazz more suited to collaborative work.With init-lite, all the power of Git is still there - and you can use any commit or command you want, but it’s default would be to simply VC for every file save. In other words, a file save IS a message-less commit.	skeppy	8.592978	-6.5107036	comment	3.0	13.0	1594504579	-11.87654
23807006	It's actually an answer to a standar	It's actually an answer to a standard interview question. I've met it more than once.Funny thing, nowadays it's going to be deprecated in favor of:    git switch -c newbranch	kubanczyk	8.537906	-6.4703455	comment	3.0	21.0	1594509079	-11.908278
23806128	I’ve yet to find a good intro doc th	I’ve yet to find a good intro doc that explains how git works conceptually. There are too few visual examples with authors assuming that users already understand the basic concepts like commits. To people who are completely new to version control, git can appear nonsensical.Funnily enough I think Atlassian/Bitbucket comes close to a good intro doc to git on their site complete with a visual guide. I still found it inaccessible to people totally new to the basic concepts though.	vin047	8.542891	-6.495909	comment	3.0	11.0	1594502547	-11.899557
23807327	I couldn't agree more. The fundament	I couldn't agree more. The fundamental design it's absolutely brilliant.  The UI does take some getting used to.I frequently use Git as an interview question, but only when the candidate lists Git among the skill set.  Specifically, I ask how does Git figure out when you've renamed a file.  If you don't grok it, don't list it.	jerzyt	8.562532	-6.5020137	comment	3.0	13.0	1594512018	-11.902464
23808192	> I fairly often make a branch as a 	"> I fairly often make a branch as a sort of named undo pointCould you say more about this? I use  git checkout -b new-branch

all the time, but that checks it out. What does ""using an un-checked-out branch as an undo point"" mean? Don't you have to check it out to commit changes to it? I suppose I could read the docs but the git docs are awful."	dreamcompiler	8.570894	-6.5500684	comment	3.0	10.0	1594520639	-11.88701
23867274	"So ""main"" is also problematic now? I"	"So ""main"" is also problematic now? I thought that was the replacement for git's master branch?"	throwaway1997	8.518239	-6.5295477	comment	3.0	10.0	1594962934	-11.775302
23969024	I like that you can change `git init	I like that you can change `git init` to have a different default branch name.At work we've renamed all `master` branches to `main`	yboris	8.518964	-6.5377316	comment	3.0	16.0	1595881435	-11.77212
23971523	What does worktree provide that a fr	What does worktree provide that a fresh local clone doesn't?	jayd16	8.587786	-6.511344	comment	3.0	13.0	1595901218	-11.918646
24060946	> Each Tuesday I have been looking a	> Each Tuesday I have been looking at the performance results of all the PRs merged in the past weekI really appreciate the work described here, but it seems to me that the performance tests are in exactly the wrong place. The correct time to benchmark a PR is before it is merged; not after. It's the same for any other kind of test; your tests should pass before you merge, not after.Sure, there will be exceptions where a performance regression is appropriate. But that should be known and agreed on before merging it.I don't see a strong reason that the performance tests have to be done afterwards. I presume that it's okay to have a delay between creating the pull request and its merge, since humans will typically want to be able to review it!	dwheeler	8.656886	-6.479463	comment	3.0	12.0	1596636767	3.9521306
24104440	Commits aren't the valuable output o	Commits aren't the valuable output of the development process.	barrkel	8.573878	-6.498348	comment	3.0	11.0	1597021577	-11.883059
24103851	This is a condensed summary of merge	"This is a condensed summary of merges, not the commit messages.  The actual commit messages for those merges were:* A few little subsystems and a start of a lot of MM patches. Subsystems affected by this patch series: squashfs, ocfs2, parisc, vfs. With mm subsystems: slab-generic, slub, debug, pagecache, gup, swap, memcg, pagemap, memory-failure, vmalloc, kasan""* More mm/ work, plenty more to come. Subsystems affected by this patch series: slub, memcg, gup, kasan, pagealloc, hugetlb, vmscan, tools, mempolicy, memblock, hugetlbfs, thp, mmap, kconfig* More MM work. 100ish more to go. Mike Rapoport's ""mm: remove __ARCH_HAS_5LEVEL_HACK"" series should fix the current ppc issue. Various other little subsystems""* Various trees. Mainly those parts of MM whose linux-next dependents are now merged. "	bonzini	8.628871	-6.5087214	comment	3.0	27.0	1597015922	-11.897698
24104472	You wouldn't be offended, if you pos	You wouldn't be offended, if you possessed the requisite context for your opinions.Linux kernel commits are very detailed and high quality. The style can be a bit ad hoc, but the face of enforcement is Linus himself.What you're looking at here is a throwaway piece of unnecessary text. Git offers the opportunity to include it, but it is generally left blank, because it adds no value. All of the interesting bits are included by incorporation.In this case, Andrew Morton decided to have a bit of ironic fun with the throwaway text. Dismissals ensue!	quesera	8.596259	-6.447112	comment	3.0	10.0	1597021813	-11.851975
24137188	Not so fancy, but a one-liner  # Rem	"Not so fancy, but a one-liner  # Remove all local branches for which there is no remote
  git branch -r | awk '{print $1}' | egrep -v -f /dev/fd/0 <(git branch -vv | grep origin) | awk '{print $1}' | xargs git branch -D"	vikin9	8.58125	-6.5220647	comment	3.0	15.0	1597267543	-11.865321
24136592	>  Rule 5. Data dominates. If you've	>  Rule 5. Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.That one hits me in the feels because I think a lot of folks focus on algorithms (including myself), and code patterns, before their data and as a result a lot of things end up being harder than they need to be. I've always liked this quote from Torvalds on the subject speaking on git's design (first line is for some context):> … git actually has a simple design, with stable and reasonably well-documented data structures.then continues:> In fact, I'm a huge proponent of designing your code around the data, rather than the other way around, and I think it's one of the reasons git has be	rubyn00bie	8.537438	-6.4909124	comment	3.0	19.0	1597264403	-11.902151
24175161	I’ve almost been exclusively using t	I’ve almost been exclusively using the GitHub Desktop client as my primary Git Tool and I’m much more comfortable with git now and helping people out. Merge conflicts were super scary, but with VS code markers, it’s a breeze. The desktop tool also makes sure to fetch origin first. If my commit is incorrect, I just use the “revert” button and it lets me fix things. There are a few things like renames and branch deletes that I use the shell for, but I’m happy and more confident in using git since the desktop tool is effective. One thing I hate is the pesky .DS_Store on Mac. No matter how many times I ignore it, it just wants to be a part of my commit.	catchmeifyoucan	8.602253	-6.451896	comment	3.0	10.0	1597552540	-11.874197
24214966	The most interesting things about Co	The most interesting things about Conventional Commits are that they can be deterministically digested by a process to decide how to bump a SemVer and similarly to create a formatted CHANGELOG file.	thephyber	8.594247	-6.5188985	comment	3.0	10.0	1597864960	-11.894002
24288733	Mercurial may not be popular, but th	Mercurial may not be popular, but the people that love it really love it.  There was much sadness when Bitbucket discontinued support.  Maybe Heptapod is a place those people can go.	freedomben	8.491958	-6.5465503	comment	3.0	10.0	1598486609	-11.964157
24303976	As someone who is at the intersectio	As someone who is at the intersection of tech and arts one of the things I like about using git in projects is that it is very clear what is the latest official defintive final variant of a piece of data and you don't have to ask anybody to get it.When I worked as a VFX freelancer I was amazed at the number of hours (=money) burned by marketing agencies who didn't manage to give me the definitive variant for a simple list of things they wanted. In one instance they gave me everything they had, including crude and unrecognisable filenames, hints about things that I should ignore via telephone etc. I had to make sense of it and compile a list which I sent them to approve. They ended up approving another list (!) which they themselves sent me two weeks prior and they only managed to correct t	atoav	8.553408	-6.4863772	comment	3.0	11.0	1598617221	-11.893287
24329824	Sounds like you are not taking the t	Sounds like you are not taking the time it takes to get to know the concepts in git or are not given the time. One does not become proficient in a DVCS in a day. It takes time and practice. It is important to note, that git is distributed. It is a big leap from SVN. What you perceived as simple before might have been a serious risk everyone took.I've once tried to use SVN before I learned about git. I was terrified to do something wrong. I did not understand the concepts well. I just did not get it. Fortunately I did not stick around with it, but learned a little bit of git shortly after. Then simply Used what little I knew. Then at some point tagging. Then feature branches. Submodules. Pull requests. You learn step by step and don't get overwhelmed by git's complexity.	zelphirkalt	8.557993	-6.487466	comment	3.0	12.0	1598867266	-11.908535
24377016	The concept of the git staging area 	"The concept of the git staging area is utterly superfluous. All local changes that are propagated to the version control system should go directly into a durable commit object, and not to a pseudo-commit object that isn't a commit, and that can be casually trashed.That commit object could be pointed at by a separate COMMIT_HEAD pointer. If you have a COMMIT_HEAD different from HEAD, then you have a commit brewing. Finalizing the commit means moving HEAD to be the same as COMMIT_HEAD. (At that time, there is a prompt for the log message, if one hasn't been already prepared.)Your ""staged"" changes are then ""git diff HEAD..COMMIT_HEAD"", and not ""git diff --cached"".Speaking of which, why the hell is ""cached"" a synonym for ""in the index""? Oh, because the index holds a full snapshot of everything"	kazinator	8.59446	-6.544574	comment	3.0	19.0	1599240588	-11.890981
24377573	I like the staging area, though–at a	I like the staging area, though–at any given time I always have code that I do not want to put in a commit object (perhaps I changed some build flags, or my IDE touched some files I don't care for, or…) However, I do agree 100% that all the terminology is pretty bad.	saagarjha	8.696716	-6.578426	comment	3.0	14.0	1599244007	-11.931024
33086479	Anyone who thinks they can mansplain	"Anyone who thinks they can mansplain git to me should read first understand my StackOverflow answer, where I give detailed instructions on how to ""git stash"" only the staged changes, in a git that doesn't have the recent --staged option in git stash. This is done by manipulating raw tree objects to create commits in the way stash wants them.https://stackoverflow.com/questions/14759748/how-can-i-stash...I've been using this thing daily since around 2008.I think the behavior that is described by my post is suprising and poor. A command which throws away uncommitted changes removed a file whose only connection to the version control system was that its existence was announced to it. (I don't require to be informed about the mechanics of how that came about, due to what procedures being applie"	kazinator	8.575966	-6.5351124	comment	4.0	14.0	1664916036	-11.907005
33108498	Been using git for 10 years now, nev	Been using git for 10 years now, never rebased, never had an issue.	secondcoming	8.571312	-6.4864492	comment	4.0	16.0	1665066052	-11.85204
33140905	I have been using git for almost a d	I have been using git for almost a decade, I don’t see any issues and I enjoy it quite a lot. Is there something I am not aware of?	lawgimenez	8.553836	-6.4575286	comment	4.0	13.0	1665322945	-11.871233
33141179	Ive been using git for 5 years now a	Ive been using git for 5 years now and i feel ive been using like the same 5 6 commands all the time. I dont understand these debates.Why would you need more ? Even when merge and rebase are getting out of hands, just take a good breath and use a bunch of manual cherrypicks.	davidguetta	8.575467	-6.544822	comment	4.0	15.0	1665324388	-11.909674
33141212	The problem I've seen is that there'	The problem I've seen is that there's two groups of people that are generally involved in a conversation like this1. The group of people that think git is powerful, but the CLI makes it difficult to do anything that is even slightly outside the box (which, for example, makes fixing a mistake difficult).2. The group of people that think git is powerful, and the CLI is easy to use, and refuse to acknowledge that it's difficult for some people; rather, they blame the people for being wrong.I've been using git for 10+ years and I fall into the second group. Every time I get into a situation the isn't the normal workflow, I have to google how to fix it. And I need to check and double check what I'm doing because, if I do it wrong, I need to reclone the entire repo to undo my mistake (and heaven	RHSeeger	8.558164	-6.4917803	comment	4.0	16.0	1665324570	-11.901797
33210437	> Using the git CLI is much better f	> Using the git CLI is much better for version control than the Jetbrains GUI wrapperFor some things. But for reviewing activity in git, and tracking changes across time, doing it in the terminal is unproductive and sucks. (e.g.: 10 levels deep of git blame)> That's sort of the point of *nix systems: multiple processes running simultaneously. Using the shell is of course going to allow that, especially with something like tmux!I meant getting a consolidated list of from them, and also having the ability to run corrective actions.> Most of the editor questions were also answered by my original post (and the answer was yes).Sure, but how much crap do you have to memorize? It's not a unified experience. It's a duct-taped Frankenstein where every subsystem works differently.	29athrowaway	8.579612	-6.5032415	comment	4.0	13.0	1665794467	-11.851563
33238351	> it defaults to parsing a git tree'	> it defaults to parsing a git tree's gitignore file and skipping over files listed in itIs that true?  How could anybody think that this non-orthogonal monstrosity would make any sense?	enriquto	8.642884	-6.467638	comment	4.0	15.0	1666034683	-11.804868
33239869	I wonder if there even is public mer	"I wonder if there even is public mercurial hosting available anymore.
This git monoculture is starting to be a bit annoying."	NexRebular	8.500569	-6.476444	comment	4.0	15.0	1666042832	-11.9405775
33387964	My perfect commits have message „WIP	My perfect commits have message „WIP on stuff”, include changes to code coupled with formatting changes, have zero tests, nada documentation, and no links to issues.But they are perfect nevertheless, because I judge them so. And because the code works.Also, because I get to get out more.	WesolyKubeczek	8.613114	-6.528848	comment	4.0	18.0	1667077738	-11.924718
33388231	Perfect commits are a bulwark agains	Perfect commits are a bulwark against technical debt:https://www.infoq.com/articles/business-impact-code-quality/https://news.ycombinator.com/item?id=33372016The extra time spent crafting a perfect commit today will save 10x that time in the future. Your future self will thank you, and if not your future self, then I will, when I inherit your code.	js2	8.590959	-6.509754	comment	4.0	18.0	1667079832	-11.905661
33388556	I very rarely check the repository h	"I very rarely check the repository history, even less to find an answer in how some buggy behavior was introduced.At most I'll git blame, search the issue repository and see if I can chat with the concerned people.Understanding the current relevant code and what need to be done is basically always sufficient to do the job. Digging into history, while potentially very interesting, never helped to reduce the time to resolve anything in my experience. If the code is a mess,  the history will be exponentially so.  If the code base is clean and well documented,  you might more likely have a great set of ""perfect commits"" that you will never need."	psychoslave	8.573548	-6.489206	comment	4.0	12.0	1667082273	-11.895295
33399824	With no attribution nevertheless :) 	With no attribution nevertheless :) (/s)I love how, without the 'hello, world' message itself, 25% of your entire HELLO.ASM codebase is from a random HN commentEdit: I saw the new commit, HN is lovely	ithinkso	8.598881	-6.5128846	comment	4.0	12.0	1667170203	8.803343
33504221	Git stack ranking via a script coded	Git stack ranking via a script coded by SpaceX and Tesla sofware engineers over a weekend and bringing Jason Calcanis and your personal lawyer onboard to give you advice.What possible other outcome could there be other than a shit show ???.	tibbydudeza	8.542654	-6.4556227	comment	4.0	13.0	1667818265	-11.888199
33509474	Oh My Git – An open source game abou	Oh My Git – An open source game about learning Git	modinfo	8.56	-6.48391	story	4.0	81.0	1667843892	7.195345
33515221	What gui do y'all use? I'm quite pro	What gui do y'all use? I'm quite proficient with git on the command line, but some tasks seem overly tedious, so I was looking at some other options, but haven't found anything that'd impress me yet.	izoow	8.592141	-6.478145	comment	4.0	12.0	1667874046	-11.851641
33525754	Ask HN: Are you still using conventi	Ask HN: Are you still using conventional commits? If not why not?	muratsu	8.584898	-6.513103	story	4.0	5.0	1667950726	-11.905906
33532671	Couldn't you rewrite history locally	Couldn't you rewrite history locally on your own branch and nobody would know?	peteradio	8.584155	-6.5529246	comment	4.0	21.0	1668006641	-11.899282
33532998	I guess this will come off kinda... 	I guess this will come off kinda... douchey? But I just don't find Git to be that hard. I know there's a lot of complexity there, but I find that 95% of the time I'm just git add -p or git add . and then committing. Every once in a while I'll do a rebase, and that's the most complex part of Git that I use with any frequency.I remember when I first was introduced to Git I found it confusing, so I'm sympathetic to newbies who have to cross over the learning curve, but I think the main day-to-day Git operations just aren't that much to learn. What is it about Git that people find so difficult, even after using it for a while?	agentwiggles	8.545691	-6.5153365	comment	4.0	19.0	1668007903	-11.874198
33533607	I know HN will absolutely tear me ap	I know HN will absolutely tear me apart for recommending this, but I use GitHub desktop. It has all the bells and whistles of the CLI, but you can actually see and understand what's going on.As a Junior Engineer, a Senior Engineer recommended it to me. I thought he was joking at first, but he kindly reminded me that using a GUI app is completely fine and okay. We shouldn't stigmatise tools that make it easier to use and understand your workflow. GitHub desktop allows me to see what i'm committing, commit history and much more. I'd definitely recommend it.PS. Using it is not an excuse not to learn how to use the CLI. Others will accuse me of being lazy and not learning best practice. Learn both. Use the easier one.	ccity88	8.586214	-6.4891787	comment	4.0	23.0	1668010066	-11.844752
33534767	This is basically solved by squashin	This is basically solved by squashing each PR on merge and having a good PR title + description.	cube2222	8.629525	-6.470162	comment	4.0	14.0	1668014419	-11.851306
33534995	    git add .; and git commit --amen	"    git add .; and git commit --amend --no-edit; git push origin --force

Rarely, I have to do pipeline work on repositories. You'd normally see twenty ""Fix Jankins Issue"" commits on the main branch because of some nonsense that only happens when you deploy UAT or whatever.  Once I learned this little gem, this is also how I manage my feature branches mostly.  But also my employer's fleet of laptops has been aging and I've had to do 3 swap outs this year, so I like to keep my in progress work pushed up just in case."	krinchan	8.574479	-6.5158033	comment	4.0	17.0	1668015301	-11.9333935
33533465	"When I say ""the evolution of the pro"	"When I say ""the evolution of the product"" I really mean ""the ""evolution of the code"". When a small feature branch with 5 commits - four of which say ""wip"" and the last one says ""added color support"" - gets merged as is, and all relevant information is held hostage by whatever Git platform the company is using this week and not inside the repository itself, the log is not useful to me regardless of any strategy.Yes, it can be annoying if your developers are committing nonsense, but then just tell them to not do that, or to rebase locally before pushing.If you find yourself troubleshooting a  bunch of nonsense commits, you can just do a diff to the merge commit, and it will show you all the changes.  But you also have the option of figuring out exactly which commit caused the problem, and se"	dec0dedab0de	8.577288	-6.541907	comment	4.0	27.0	1668009569	-11.917244
33534435	Yeah if you just use commits as they	Yeah if you just use commits as they are intended then the complexity of git drops off massively. I’ve used got for a decade and want to know how many times I’ve rebased? Zero	willio58	8.573217	-6.530989	comment	4.0	12.0	1668013163	9.057341
33615500	I was going to say that they already	I was going to say that they already had started their own successor to Mercurial called Eden, but it seems like Sapling is just a renaming of Eden. Maybe anyway. It's a bit unclear.	IshKebab	8.513142	-6.5563154	comment	4.0	15.0	1668548902	12.830173
33615940	I certainly recognized several Mercu	I certainly recognized several Mercurial features and concepts in Sapling.For example, I use Mercurial’s absorb command [1] and was pleased to see it in Sapling.Overall this looks promising.[1]: https://gregoryszorc.com/blog/2018/11/05/absorbing-commit-ch...	alwillis	8.518638	-6.5985026	comment	4.0	23.0	1668550958	-11.989621
33626886	Disagree that git is hard to use. It	"Disagree that git is hard to use. It's fairly complex, I'll admit, however it's pretty much all ""necessary complexity"".Occasionally, I'll see articles talk about ""fixing"" git by eg. removing the staging area, or something like that... but the staging area is great! It's literally a feature I was dreaming about when I used Mercurial.I definitely think there's room for a more intuitive solution. I would rate the git learning curve as ""medium-easy"""	P_I_Staker	8.574376	-6.527004	comment	4.0	21.0	1668619582	-11.877867
33646977	there’s so many low hanging fruits f	there’s so many low hanging fruits for improving the quality of diff viewing. The worst code reviews are often the ones where code get refactored, leading to piles of delete / create lines that are just code being moved or slightly renamed.One very simple approach would be better git integration with the IDE, helping build commit that make sense, where a set of changes could easily be commented by the author as they’re performing the edits, then keep improving from there.	bsaul	8.682508	-6.450974	comment	4.0	15.0	1668724861	-11.832861
33705158	Basically, not to put too fine a poi	"Basically, not to put too fine a point on it, I believe that distributed version control is a problem no one ever truly had, and no one intends to ever have in the future.I mean: Imagine going back in time 20 years to when git, hg, and bzr were created and telling the creators of those tools: ""Hey, while designing your technology, you should be aware that it'll end up being used as a worldwide centralized monorepo run by Microsoft, and no one will ever use any of that distributed stuff.""They'll either laugh you out of the room or you'll be in trouble with the Department of Temporal Investigations for polluting the time line, because what we currently understand as git sure as hell won't be the design they'll come up with.So for me: I prefer centralized.  And SVN is just a reasonable one to"	gyulai	8.593343	-6.4398007	comment	4.0	20.0	1669121164	-11.868105
33706349	I don't know how stupid this is on a	"I don't know how stupid this is on a scale from 1 to 10. I've created a wrapper [1] for git (called ""shit"", for ""short git"") that converts non-padded revisions to their padded counterpart.Examples:""shit show 14"" gets converted to ""git show 00000140""""shit log 10..14"" translates to ""git log 00000100..00000140""[1]: https://github.com/zegl/extremely-linear/blob/main/shit"	zegl	8.611933	-6.4963617	comment	4.0	12.0	1669128427	5.7809157
33746563	So, should we just add .gitignore to	So, should we just add .gitignore to .gitignore and problem solved ?	revskill	8.616127	-6.45765	comment	4.0	22.0	1669409132	-11.828469
33947450	What I have always been told for wri	What I have always been told for writing good commit messages is that the message should tell you what the commit does when applied to the code. The place for these what/why messages would appear to be in a ticketing system of some kind, referenced by ID in the commit message.What you're asking for would result in extremely bloated messages.	Karunamon	8.583262	-6.5348043	comment	4.0	15.0	1670792512	-11.919084
33948676	Design decisions should really go in	Design decisions should really go into docs rather than commits.Out of three (commits, comments, docs), the commits are least approachable, just few changes in the code will erase original commit in the blame.By all means write good commit messages, but crystallize the info in them into changelog or other docs every bigger release	ilyt	8.586875	-6.527804	comment	4.0	15.0	1670800392	-11.922116
33970738	Sounds like `git annex` is file-leve	Sounds like `git annex` is file-level deduplication, whereas this tool is block-level, but with some intelligent, context-specific way of defining how to split up the data (i.e. Content-Defined Chunking). For data management/versioning, that's usually a big difference.	kspacewalk2	8.598281	-6.4538984	comment	4.0	32.0	1670947722	8.516677
33972570	There are a couple of other contende	"There are a couple of other contenders in this space.  DVC (https://dvc.org/) seems most similar.If you're interested in something you can self-host... I work on Pachyderm (https://github.com/pachyderm/pachyderm), which doesn't have a Git-like interface, but also implements data versioning.  Our approach de-duplicates between files (even very small files), and our storage algorithm doesn't create objects proportional to O(n) directory nesting depth as Xet appears to.  (Xet is very much like Git in that respect.)The data versioning system enables us to run pipelines based on changes to your data; the pipelines declare what files they read, and that allows us to schedule processing jobs that only reprocess new or changed data, while still giving you a full view of what ""would"" have happened "	jrockway	8.614062	-6.4635715	comment	4.0	23.0	1670953416	-11.881729
33999734	Ask HN: What major technical feat ar	Ask HN: What major technical feat are you going to take a shot at this break?	breck	8.560078	-6.450723	story	4.0	2.0	1671113520	-11.876532
34002287	Git no longer uses SHA-1. It instead	Git no longer uses SHA-1. It instead uses a variant called SHA-1DC that detects some known problems, and in those cases returns a different answer. More info: <https://github.com/cr-marcstevens/sha1collisiondetection>. Git switched to SHA-1DC in its version 2.13 release in 2017. It's a decent stopgap but not a grrat long term solution.There is also work to support SHA-256, though that seems to have stalled: https://lwn.net/Articles/898522/The fundamental problem is that get developers assumed that hash algorithms would never be changed, and that was a ridiculous assumption.  It's much wiser to implement crypto agility.	dwheeler	8.6792	-6.5180464	comment	4.0	28.0	1671123160	7.166796
26488154	I'm a bit late to the game, but I do	"I'm a bit late to the game, but I don't understand what this fuss is all about, from a technical point of view.  I just created a git repo this morning and the default branch was named ""master"" (using the git command line).  Then I pushed it to github to make it visible, as I have done several times before.  The command line instructions at the ""new repository"" interface on github suggest changing the branch name to main, but I did not do that (just for trying) and now I have a brand new github repository whose branch is named ""master"".  Basically github allows to name your branches however you like.  The example instructions suggest that you rename your master branch to ""main"", by running this code on your command line:    git branch -M main

But that is all.  You can name it ""trunk"" if y"	enriquto	8.509659	-6.5110717	comment	4.0	24.0	1615971123	-11.715099
26490252	Disclaimer: I work for Microsoft.I’v	Disclaimer: I work for Microsoft.I’ve seen many Microsoft employees internally comment on how they don’t like the term “master branch”. I believe Microsoft’s renaming (this is my personal belief) was somewhat influenced by that internal push.It may not mean much to you, but if it made some people feel more comfortable it’s a good change and has very few downsides.	PretzelPirate	8.527528	-6.5308433	comment	4.0	15.0	1615985017	-4.1970496
26705006	I'm a little confused about what git	I'm a little confused about what git annex is - I think it's perhaps a basic file sync utility that uses git behind the scenes?	GordonS	8.563001	-6.481695	comment	4.0	16.0	1617658504	-11.886115
26710558	If you just want to use for personal	If you just want to use for personal single-person projects fossil [1] and mercurial [2] may be a better choice, given both come with in-built web interface. Just run hg serve or fossil server or fossil ui. No need any external platform or program.[1] https://fossil-scm.org/home/doc/trunk/www/index.wiki[2] https://www.mercurial-scm.org/	dragonsh	8.544251	-6.54137	comment	4.0	18.0	1617708320	-11.955725
26735628	A look how branches work in Git	A look how branches work in Git	nsoonhui	8.5678625	-6.512751	story	4.0	41.0	1617862410	-11.901582
26742569	I've learnt something new today, tha	"I've learnt something new today, thanks for sharing. Looks like I had a naive understanding of how snapshotting actually works.I still think that it's more intuitive to describe commits as diffs, in the context of things like cherry-picking a commit or rebasing/reordering a series of commits.But given that you can also ""check out"" a commit, in order to get a specific snapshot of the repo, I can see the parallels between commits and snapshots. Maybe both analogies are equally useful in describing the different features that git provides."	whack	8.595508	-6.542465	comment	4.0	14.0	1617909306	10.284534
26742775	> I believe that Git becomes underst	> I believe that Git becomes understandable if we peel back the curtain and look at how Git stores your repository data.I agree, and like many, I have been saying that for years (nay, for more than a decade): and that's exactly the problem!You don't need to understand how an internal combustion engine works to drive a car... You don't need to understand how your graphics card renders stuff to develop a web page... You don't need to know how a brushless motor works to use a drill...There is a pattern there, and it's the one that makes sense.I've read up on the internals of git a dozen times by now. But I only occasionally need to do something weird that makes me go back to it, so I usually forget the relevant bits.The trouble is that I've used a distributed VCS that did not ask me to unders	necovek	8.553478	-6.499302	comment	4.0	14.0	1617910476	-11.908586
26742864	> With that in mind, things like reb	"> With that in mind, things like rebase become obvious: Take the same diff and attempt to apply it to a different parent.You can think of it that way if you want.  But it's not what Git actually does.Personally I much prefer to have my mental model match the actual reality of things.You may not use ""git cat"" very often, but what about ""git checkout <SHA>""?  If commits were stored as diffs, then Git would have to rebuild a tree of the very first commit, then replay every single diff up to the SHA you asked for.What it does in actuality is find the snapshot of that SHA and change the working tree to match it."	haberman	8.612424	-6.5362086	comment	4.0	18.0	1617910975	9.57871
26743495	People are disagreeing with the auth	People are disagreeing with the author, not because they didn't necessarily read the article, but because they don't agree about how things should be defined.At the root, this is a disagreement about semantics and philosophy, not about git itself. I'm going to refer to Aristotle here: we think we have knowledge of a thing only when we have grasped its cause, and there are four general 'causes' [1]:- The material cause: 'What is it made of?'- The formal cause: 'What is the ideal of this thing?' , e.g. what's its abstract nature?- The efficient cause: 'How did this thing come to be?'- The final cause: 'What is its purpose?' How is it actually used? What role does it play in the world?Here we can see that commits are used (at least in the git internals) as 'snapshots' — they refer to bytes, n	smallnamespace	8.553759	-6.524916	comment	4.0	13.0	1617914415	10.30582
26870183	For a little additional context, a f	For a little additional context, a few days ago, Pan removed himself (using his IBM email address) from the maintainers list in the same file and added himself (using the gmail address) to the reviewers list.  The linked commit removes Pan entirely.There’s more going on here than is visible from the out-of-context quote in the commit message.	JonathonW	8.588037	-6.4518056	comment	4.0	40.0	1618886726	-11.878233
26921030	Does anyone have a really good (mayb	"Does anyone have a really good (maybe illustrated?) guide/short reference to the world of GIS? Every time I see GIS stuff mentioned the problem space itself, solution jargon, and various movements in the ecosystem (projects being unsupported, stewards/companies changing etc) always throws me for a loop.It's certainly the case that I just haven't built enough mapping-related software to be comfortable but if there's a resource out there that's like ""baby's first GIS application"" I'd love to read through it and try to ram the concepts into my gray matter again for the day when I do work on one."	hardwaresofton	8.530102	-6.461278	comment	4.0	16.0	1619225111	-11.896511
26921383	I don't like this workflow, I see it	I don't like this workflow, I see it as needlessly complicated. If you really can't cherry pick your big PR into simple branches to merge directly into master (which I rarely have seen over the years), create a longer lived branch and make small PRs to that. Then merge longer lived branch into master. You should never be going off and work on huge changes without keeping in sync with the base branch. Stacked PRs make all this more difficult.	aledalgrande	8.606473	-6.5374193	comment	4.0	16.0	1619227812	-11.897611
26923469	Hmm, I don't get it:> If you want to	Hmm, I don't get it:> If you want to have your code reviewed, you first have to branch master, then commit to that branch, then push it remotely, then create a PR.When I want to create a PR, I always create a feature/WIP branch locally and push that. Branches are cheap in Git.I find when the unit of scrutiny is an individual commit, like when you contribute to the Linux kernel, I spend way to much time fabricating nice atomic commits. Like maybe 50%, with 30% actual development time and 20% normal cleanup.The only thing I miss with PRs is the ability to rewrite my branch after showing it. I think it is not supported to do `rebase -i` and then `push --force` to a PR, is it? It would be really useful, especially for the cases where you have multiple commits that cancel each other out (e.g. a	captainmuon	8.575239	-6.5329785	comment	4.0	28.0	1619255098	-11.924212
26957499	I wonder if git had a part in it. Th	I wonder if git had a part in it. That UML doesn't have a good textual format, or really any standard file format, means it really doesn't play well with git. I remember IBM/Rational had some kind of diff & merge tool for UML, but it was horrible.	TorKlingberg	8.637523	-6.512174	comment	4.0	14.0	1619538244	-11.81453
26961484	Ah, OK.  And this is why I think lot	"Ah, OK.  And this is why I think lots of criticism like this is a little off the rails.  It's too dependent on what to my eyes is just a broken mental model.  I mean... branches are commits.  If you want your uncommitted work to be on a branch you... commit it.  There's a command for that.  It's called ""commit"".I mean, literally ""git commit -a -m WIP; git checkout $OTHER_BRANCH"" is all that's required.  It's even ""orthogonal"" per the requirements in the article."	ajross	8.56704	-6.551669	comment	4.0	38.0	1619557205	9.121747
26962171	I use magit and everything seems a l	I use magit and everything seems a lot less wrong :).I personally found Mercurials a lot more palatable but at this stage git is pretty much ubiquitous.	Guthur	8.573069	-6.4857826	comment	4.0	15.0	1619560290	-11.862856
26962564	> The only two alternatives I can im	> The only two alternatives I can imagine are worse: disallowing partial commits (I use this feature all the time; I guess I could replace it by a temp commit on a branch and then so long as cherry-pick -p still exists, use that) or specifying it to git-commit (that would be one gnarly set of flags…)Are you aware that git commit --amend exists? That replaces anything I might ever be tempted to use the staging area for.	jcranmer	8.619977	-6.5534463	comment	4.0	18.0	1619561905	-11.919261
26962766	Have you looked at using a good gui 	Have you looked at using a good gui for the repository? I find that helps a lot with the mess.I used to use Git Extensions and lately I've been using the one built into IntelliJ's products. It's not as good, but it's available on mac, so my options are limited.	t-writescode	8.579122	-6.4426584	comment	4.0	15.0	1619562799	-11.824646
26964339	Yep. There are reasons Perforce is s	Yep. There are reasons Perforce is so prevalent in game development, even if we gripe about it:- Large binary asset support.- Exclusive locks for binary assets.- Speed. When configured properly, it's very fast, particularly for large repositories.- Tooling support. It's nearly ubiquitous in gaming.I'm working on repositories that are 100+ GB and need to support both programmers and artists. Git just isn't the right tool.We do use git for backend server-side projects. Having to support two different version control systems is a pain, but, again, it's useful to have the right tool for the job.	jaaron	8.606202	-6.5000734	comment	4.0	13.0	1619573704	13.837798
26987826	You can just have a CI job generate 	You can just have a CI job generate a CI config file and have GitLab CI load that into a child pipeline. Look up dynamic pipelines.	StavrosK	8.462126	-6.4441514	comment	4.0	14.0	1619736869	9.017387
26998035	> Otherwise, if you amend/force-push	> Otherwise, if you amend/force-push or open an entirely new PR, 99% of the diff are things that your team has already seen and reviewed.gerrit has solved this issue for years by showing the diffs between each successive revision of a patch.e.g. look here the files at different origin patchsets : https://codereview.qt-project.org/c/qt/qtwayland/+/321246/3....	jcelerier	8.652577	-6.4629574	comment	4.0	13.0	1619810417	-11.743013
26998276	I think I'm missing something here. 	"I think I'm missing something here. How valuable is to have 20 commits of ""fix this error"" , ""fix the fix of the error"", ""revert all fixes"", ""real fix"".... etc? 
I'd argue a PR with many commits such as these, conveys little no no useful information, when the actual change is 1-3 LOC.what about cleaning and filtering out useless commits, by soft reseting the branch and commiting just the actual changes to merge. Sure, it can take a lot of time, but it's done once, by you, after all you're supplying the changes. And if it takes a really long time, you're doing it wrong in the first place by submitting PRs with many LOC.Have you tried rebasing branches with dozens of short useless commits? That's a real waste of time, and everyone needs to do this if you want to update your main branch. So y"	sebastialonso	8.595167	-6.557725	comment	4.0	18.0	1619811584	-11.921403
27018447	Solution works really well to databa	Solution works really well to databases which will not be updated frequently, like a standalone site.Although one should be aware of one very important git behavior - git does not diff binary files (like SQLite dbs). That means 2 things:1. Each db update will generate a new file in git, maintaining the whole old file in history, instead of the diff in bytes. This will accumulate a lot of clutter in the repo2. As git does not diff binaries, there is a very small risk of corruption (especially if you work in multiple OSs, because of CRLF)Ref - https://robinwinslow.uk/dont-ever-commit-binary-files-to-git	drtournier	8.593479	-6.489792	comment	4.0	13.0	1619985322	9.671167
27044071	Can anyone explain the “why does thi	Can anyone explain the “why does this matter” paragraph where the author seems to suggest that using branches in our program is a security risk?I know that branch speculation can be used as an attack vector if our program is the aggressor - but does simply using branches in some way make us more likely to be the victim?	mwint	8.669049	-6.546139	comment	4.0	14.0	1620170459	-11.829752
27135175	I've been using this bare repository	I've been using this bare repository approach for a while. I forget where I first saw it, I'm pretty sure it was on HN but it was not this project. I do like it, but I have a few minor issues.The first is that I have a habit of running `git add .` when I'm working on source code, and as a result I have accidentally added my entire home directory to the bare repo more than once... Easy enough to undo but a bit inconvenient. `dotfiles add -u` is the safe option, or just be explicit about which files you are staging.The second issue is the 'branch per machine' approach, which I do use. I have two machines I use regularly, and a third occasionally. There are some bits of config (e.g. for vim) that are shared across all the machines, while other bits are not. If I use one machine for a while, t	tdfirth	8.695482	-6.4615083	comment	4.0	14.0	1620853773	-11.904164
27143155	I am coming to think that it's preci	"I am coming to think that it's precisely the ""distributed"" bit that nobody really wants.For example, distributed version control systems are often held up as an example of some form of precedent for blockchain-type technologies. But I've never actually seen a truly distributed (in the blockchain sense) deployment of Git. It's technically possible, but it just doesn't seem to happen.Similarly, I'm not sure people actually want immutability. They want the ability to edit history, they just want it to not be an everyday thing. In a discussion about the relative merits of different distributed version control systems, someone invariably points out that the thing Git has that makes it more usable in practice than any of the others is that it allows you to rewrite history. In the repositories I "	mumblemumble	8.570112	-6.468751	comment	4.0	39.0	1620919456	-11.882201
27161340	I've long wished for a tool that (fo	"I've long wished for a tool that (for git) what fossil has built in: issues stored in the repository, where developers can use their full range of tools to work on them locally.A few additional things would be required to make this work for less-technical team members, and you end up building some of your own workflow, but it means that E.G. you have options like ""update the description of a ticket as part of the pull request that implements it""."	danielheath	8.50613	-6.520643	comment	4.0	15.0	1621041030	-11.940406
27198449	Before GitHub launched, I built some	Before GitHub launched, I built some large eCommerce sites, and for a vcs we used CVS, and then Subversion. We had a person on our team with the title of release manager, because branching in Subversion, and merging back to make releases, was a specialist effort that took time, patience, and managing a tremendous amount of fighting between teams of what features and fixes could even be merged together in order to ship this release.When I started using git, it broke my brain. I wasn't really sure I understood it, but the idea of cheap local branches soon became the most important thing to me in a vcs, and everything became easier and so much faster. You could just work on code the way real life happens, not in some methodical pre-planned release schedule that always rubbed harshly against t	briandoll	8.570994	-6.4633083	comment	4.0	21.0	1621360429	-11.8480015
27276497	I heard lots of praise to Magit. Is 	I heard lots of praise to Magit. Is there a way to use it like a standalone git client? Like tig, lazygit, etc.	jhvkjhk	8.623282	-6.4742217	comment	4.0	15.0	1621949218	-11.781611
27306097	Why would I use Stacked Git rather t	"Why would I use Stacked Git rather than Git’s fixup/interactive rebase dance?For example:    git commit -m ""one thing""
    # commit hash: deadbeef

    git commit -m ""other thing""
    # commit hash: badf00d

(working on one thing)
then:    git commit --fixup deadbeef

(working on the other thing again)
then:    git commit --fixup badf00d

And in the end, when I’m ready to roll each patch into one commit, respectively:    git rebase -i --autosquash


I do realize that Stacked Git allows me to switch between patches. Which is nice because regular Git wants me to type in SHAs for --fixup.But I’m not sure I’d take on a new tool dependency just for that. What are other benefits of Stacked Git? Just wondering if I’m missing something."	Hackbraten	8.573841	-6.5191784	comment	4.0	19.0	1622138493	-11.894811
27434013	The lack of ability to squash PRs in	"The lack of ability to squash PRs into single commits is a deal breaker for many, myself included.No, having a commit ""fix typo"" in the main branch's history is not at all useful and won't ever be. It's noise.In a work setting it's much better to reduce noise."	pdimitar	8.583869	-6.542243	comment	4.0	80.0	1623154004	-11.892329
27434957	Having commits that do not build rep	Having commits that do not build represents the history more accurately. It could very well be a “fix” to some build error that silently introduces an issue, that context is lost when you squash.	jiofih	8.607881	-6.6003475	comment	4.0	52.0	1623159268	-11.993331
27492908	I have never got all these jokes. Wh	I have never got all these jokes. When my job switched from Subversion to git it took me about one week plus reading a couple of articles to become more productive in git than I ever was in Subversion. Yes, version control is a bit tricky but git is not that hard to understand and was much easier than contemporary Subversion versions.	jeltz	8.57412	-6.460491	comment	4.0	32.0	1623594537	-11.877979
37613041	I don't see how you love something t	I don't see how you love something that makes you jump through these hoops:> In this particular case, it took me 4 separate commits (and 4 failed releases) to debug the various small errors I made: not using ${{ ... }}5 where I needed to, forgetting a needs: relationship, &c	darepublic	8.584839	-6.5361013	comment	4.0	22.0	1695395239	-11.8841505
37622747	A large number of Fossil positives a	A large number of Fossil positives are related to not having rebase. It feels like this is a huge concern for functionality that many people, do not use that often. The last time I used rebase at a job was maybe 5 years ago?Other than that my bigger gripe is when I read something like this:>  Git strives to record what the development of a project should have looked like had there been no mistakesGit does not strive to do this. It allows it, to some degree. This is not the same thing at all and is basically FUD. I would say the debate is ongoing as to the value of history rewriting. It's probably a tradeoff that some orgs are willing to leverage and Fossil is masking that they allow less flexibility in workflows as an obvious advantage, feels slimy.	Supermancho	8.545148	-6.5658007	comment	4.0	37.0	1695472985	9.573103
37623054	I tend to agree. I haven't used Git 	I tend to agree. I haven't used Git in a large project, but...why would I want to rewrite history? The project is what it is. What happened, happened. If there are a couple of weird commits, who cares? At most, maybe edit the commit messages to explain.	bradley13	8.573194	-6.5445256	comment	4.0	16.0	1695475862	-11.914183
37622804	That's also why perforce is slow as 	That's also why perforce is slow as heck unless you throw massive resources at it. I also work in the chip industry BTW.	nightfader	8.643959	-6.4988494	comment	4.0	12.0	1695473454	13.818751
37645568	> we find that whitespace changes ar	> we find that whitespace changes are not just part of the commits that Apache Open Office has been receiving, whitespace changes make up a substantial amount of the commits added to the repository.wat.	KirillPanov	8.659212	-6.508838	comment	4.0	23.0	1695656196	-11.845184
37646067	All these commits are so strange. Th	"All these commits are so strange. They are all useless ""clean up"" commits yet they are not done by a bot, there's someone manually making these changes every few days, almost every day actually.Don't know if he's really trying to make the project seem active, or trying to score a certain number of commits, or if he's just really passionate about cleaning up that codebase all by himself."	laurent123456	8.580112	-6.4692736	comment	4.0	18.0	1695657714	-11.878604
37722456	Changesets seem like a UX nightmare.	"Changesets seem like a UX nightmare. While I understand the motivation, the complexity of version control today is mind boggling.We have a working copy, index, commits, branches, remotes, pull requests - all of these come into play when proposing even the simplest change to an open source repo today. The idea that adding yet another concept to the pile will make things better is something I can't agree with.Will it enable more capabilities? Yes. Adding features generally does that.Aside from the ""it's already complex enough"" argument, there's also the fact that 90% of changes I've seen in my daily use of git don't require this feature. This means the feature will be misunderstood, misused and often not used when actually needed."	parentheses	8.586843	-6.472929	comment	4.0	14.0	1696133387	-11.884549
12582417	Well this is a great addition! I've 	Well this is a great addition! I've worked in places where `squash and merge` was standard procedure and others (including currently) where `rebase and merge` was the standard.It's nice to see the later finally getting some love so I don't have to keep going back to my own terminal after my PR is approved.	bnchrch	8.582962	-6.5730467	comment	4.0	18.0	1474902368	-11.890252
12612752	Warning: not actually git commands, 	Warning: not actually git commands, rather TFAA's aliases for possibly useful combinations of switches and/or commands.	masklinn	8.568363	-6.4892025	comment	4.0	16.0	1475246936	-11.87708
12613047	> so it’s good practice to create an	> so it’s good practice to create an empty commit as your repository rootWhile I'm aware of issues with rebasing the root commit, I've never heard this advice before and it seems unnecessary.	michaelmior	8.578465	-6.520534	comment	4.0	12.0	1475249490	-11.905671
12613167	My #1 use of stash is as the quickes	"My #1 use of stash is as the quickest way to express ""get rid of all this crap"". I rarely intend to ever retrieve it."	ashark	8.575739	-6.535578	comment	4.0	13.0	1475250534	-11.932808
12614879	Aside from selective commits (which 	Aside from selective commits (which they provide a different interface for), what do you use the staging area for?	rspeer	8.679469	-6.5653105	comment	4.0	54.0	1475265495	-11.982173
12615768	The paper doesn't discuss much how t	"The paper doesn't discuss much how their implementation does better on their listed issues. One particularly interesting issue git has is referred to at one point as ""Incoherent Commit"":""The problem with commit is that it constitutes a violation of the coherence criterion: the same concept (commit) has more than one, unrelated, purpose: make a set of changes persistent (P1) and group logically related changes (P2).""These two purposes are not only unrelated, but in tension with each other. On the one hand, you would like to save your changes as often as possible, so that if something bad happens you lose as little data as possible (thus encouraging early committing). On the other hand, a logically related group of changes usually involves multiple individual changes, which means that you mi"	c3RlcGhlbnI_	8.571609	-6.523552	comment	4.0	15.0	1475276821	-11.940963
12622389	And it hits the most important point	And it hits the most important point of: Gitless tries to do away with the staging area, thus completely misunderstands Git.	Mithaldu	8.576995	-6.50408	comment	4.0	22.0	1475417565	-11.851848
12623653	    git checkout <file> // throw awa	"    git checkout <file> // throw away all changes since the last commit (one file)

    git reset --hard    // throw away all changes since the last commit (all files)

This is a perfect illustration of why git needs a better UI.  Two different commands to do exactly the same thing, with the only difference being that one is for one file and the other is for many files?  If you tried to design a hard-to-use UI you could hardly do better than that.[NOTE: these two commands actually don't do quite the same thing, which is part of the problem.]"	lisper	8.564843	-6.5344076	comment	4.0	29.0	1475434213	-11.906814
12623989	I'm surprised at how many people are	I'm surprised at how many people are responding negatively to software that improves user experience.Suppose we had started out with the command UI that gitless has and someone came along and tried to sell us the current git cli UI. It would be completely ridiculed.The only thing possibly questionable about the gitless interface is that it does away with staging. However, you can always fall back to git for staging functionality if you like, and use gitless for most other commands. I think it is a win.	maker1138	8.561233	-6.495305	comment	4.0	16.0	1475439044	-11.869255
12674612	Original author of Fossil here, with	"Original author of Fossil here, with two comments:(1) Fossil was created for the single purpose of supporting SQLite development, a mission at which it has succeeded spectacularly. Fossil is therefore a success story, irregardless of its mind-share relative to Git.  That thousands of other developers also find Fossil useful on their own project is just gravy. I am not concerned that Fossil has not (yet) become the ""one true and great DVCS"". My intent is to continue personally supporting and maintaining Fossil for at least three more decades.(2) Git people: Please steal ideas and code from Fossil. This is not about winning and losing; it is about providing the best possible tools. Fossil has a number features which are missing from Git but which could be easily added to Git and would enhanc"	SQLite	8.501337	-6.551192	comment	4.0	39.0	1476065494	-11.965748
12674939	The fact that you created both an SC	The fact that you created both an SCM, and a RDBMS, kind of forces the question:Does Fossil have something like 'rollback'?If not, would it not be good to have your standard SQL COMMIT/ROLLBACK semantics in an SCM?I mean, sometimes you do something with your SCM that you immediately regret. Like, you do a 'pull' expecting that perhaps a couple files will be changed, and instead you get a screenful of statuses, errors and whatnots.Ooops! So you look at what you typed, and turns out you were in a wrong branch, or you should have used 'pull x y' or whatever.In any case, what you want to do now, is to 'roll back' ('undo') the last command.Now, in SQL, when you make a mistake, you say 'rollback' and everything is good.But in a typical SCM, either you cannot do it at all, or it is nontrivial. E.	carterehsmith	8.542226	-6.5586443	comment	4.0	19.0	1476071753	9.460155
12677707	TortoiseGit is by far the best Git G	TortoiseGit is by far the best Git GUI on Windows or anywhere else. The UI is light, fast and it stays out of your way. It's very tightly integrated with the file browser, which is really the only app I want to be using to look at my files...SourceTree OTOH is slow and clunky on every platform. But even if it had a light and fast UI - it's not integrated with my file browser, which sucks. With TortoiseGit, every Git command that I need is a single click away when I'm viewing my files.	WayneBro	8.581942	-6.4383717	comment	4.0	13.0	1476114023	-11.894999
12680734	As a full time developer, you are co	As a full time developer, you are correct that the relnotes don't capture all the great stuff.  It is difficult to keep track of all that is going on.  The only way I know how is to continuously read the commit logs.  But distilling that down into a useful document for end users is quite hard, especially retroactively.I will say that the release has non-trivial improvements in TCP performance (Mike Karels, Matt Macy, Netflix crew).VNET jails also should be safe to tear down, and SysV SHM can be jailed/virtualized which should be interesting to many users.	kev009	8.626831	-6.553001	comment	4.0	18.0	1476143179	9.293637
12716294	Very interesting, I think we need a 	Very interesting, I think we need a git for data. What is the performance of diffs and merges? What data size does it become too slow?	rpedela	8.649179	-6.497224	comment	4.0	25.0	1476578685	9.5123625
12776937	Many companies in the games industry	Many companies in the games industry have settled on using Perforce or SVN (or more recently Plastic DVCS) internally as, out of the box, it can handle both code and non-code assets (i.e. large binary files) well in tandem. Git has problems with the latter - people have tried to correct this with solutions like git-annex and git-LFS but these have failed to catch on thus far.	unsignedqword	8.584657	-6.4726887	comment	4.0	20.0	1477288258	-11.878384
12786394	The latests iteration of hg crecord 	"The latests iteration of hg crecord which is an interactive selection tool for chunks (see it in action here: http://g.recordit.co/BfbSa7cMXn.gif)
Is far far better than git staging area. Intuitive to use, i can submit hours of code in few nice selective chunks really easy.This sole function built in is a game-changer in mercurial for me."	marcinkuzminski	8.554941	-6.546374	comment	4.0	15.0	1477386517	-11.934922
12803356	"Am I the only one who read the ""offi"	"Am I the only one who read the ""official"" Git ebook and found that perfectly understandable?https://git-scm.com/book/en/v2"	josteink	8.549323	-6.4618664	comment	4.0	12.0	1477551597	-11.949689
12881111	I dislike the idea of using 'origin'	"I dislike the idea of using 'origin' for my own remote name.I keep 'origin' as the canonical remote and my local master branch tracks origin/master.  I use people's usernames for their remotes (including for my own).If I'm pushing a feature branch to my own remote:    git push -u myusername mybranchname

If I need to checkout someone's PR, it's:    git remote add theirusername git@github.com:theirusername/repo.git
    git fetch theirusername
    git checkout -t theirusername/repo

I've seen people at work who are new to git/Github struggle a lot with the 'origin'/'upstream' differentiation recently, especially when they're learning branching, and they don't seem to have any problems once I switch them over to using 'origin' + usernames."	brobinson	8.5348625	-6.50591	comment	4.0	13.0	1478370424	9.165338
12920583	Ask HN: Why am I underperforming?	Ask HN: Why am I underperforming?	dublinclontarf	8.622627	-6.540296	story	4.0	2.0	1478788108	-11.927394
13021426	Right now, I would take a button to 	Right now, I would take a button to go to the previous revision of a file, showing the full file with the diff underneath. That way I could very easily 'browse' through the history of a file to find out things like when a particular change got introduced or just get a feel for its history. Why on earth don't github/bitbucket provide this? Surely it's a reasonable and common requirement? Or is there something inherent to git that makes it too awkward?	oneeyedpigeon	8.590045	-6.48719	comment	4.0	15.0	1479895147	-11.872792
13126839	Kind of interesting. What I'd really	Kind of interesting. What I'd really like to be able to do is require specific people to review before merging, for example require a review by at least one of our senior developers.Right now the greenest guy on the team can approve a PR and it can be merged.The real dream would be to be able to set the requirements on a per-directory basis, but I doubt that would ever happen.	donatj	8.6481	-6.4453697	comment	4.0	13.0	1481149553	13.610603
13228698	Why not just revert the offending co	Why not just revert the offending commit? It would be a valid blip in history as mistake made and corrected.	soft_dev_person	8.589898	-6.530207	comment	4.0	16.0	1482324951	-11.913098
13228782	Two fun things about git: It is dete	Two fun things about git: It is deterministic, and it doesn't delete anything (readily).This means you can't really have a catastrophe.Just git reflog your way out.	guard-of-terra	8.554013	-6.491139	comment	4.0	26.0	1482325859	-11.898195
13228864	Allow me to disagree with your disag	"Allow me to disagree with your disagreement.Git fails often for the ""basic"" use cases. I won't lie. The number of options is intimidating for a beginner and one can easily get themselves into trouble. This is why there are Git guides and tutorials and UIs and they are all ultimately unsatisfying when you're a beginner.However the use case discussed in this article is NOT a beginner use case. It is an advanced case and the fact that Git is an advanced tool that supports it (both natively with git-filter-branch, as the author found out, and ad-hoc-ly as was their original plan is a testament to the power of the system.Tell me how you would better achieve the requirements that were the premise for this article in a different VCS?"	deanCommie	8.54234	-6.491382	comment	4.0	29.0	1482326743	-11.915762
13229353	> The set of different options (norm	"> The set of different options (normal merge, rebase, filter-branch, etc) is complex and not cleanly orthogonalAll of those commands you just listed are clearly defined and serve different purposes. In other cases, most commands or command flags simply help the user do something in an automated fashion that you could do by typing each specific command out (i.e., git pull --rebase). Git's core tooling is mainly centered around graph manipulation, everything else has been added due to convenience. And quite frankly I've never really understood the criticism people levy at git for being ""complicated.""It's stupidly simple at the end of the day, especially compared to the hodgepodge of features that other VC's provide, all of which don't really work together and are designed to cover some gap i"	justinlaster	8.567387	-6.572279	comment	4.0	75.0	1482330699	-11.896153
13229782	A tool like git could make operation	"A tool like git could make operations such as branching and merging easier, and allowing developers to collaborate more. It also has a global revision identifier (instead of file based revisions) and signed commits which may increase security.Also, git on the server seems to use less resources (which is one of the reasons git ""won"")"	pawadu	8.566079	-6.4841905	comment	4.0	26.0	1482333936	-11.868078
13229996	I disagree.  Github arrived in 2008,	I disagree.  Github arrived in 2008, soon after many DVCS options arrived.  Mercurial and git were developed at very near the same time in 2005, Bazaar was developed around then too.  I don't believe that git had anywhere near the market share back in 2008 that it enjoys now.When github arrived, git's biggest win was the kernel.  But that was kinda a given if you consider its genesis.  Granted, it's a noteworthy project that helps prove git's scaling capability.  But IMO git didn't win until years later when folks who had adopted the other DVCS engines started switching to git.	wyldfire	8.547342	-6.4876695	comment	4.0	12.0	1482335408	-11.892011
13229535	I like Perforce. It may not be perfe	"I like Perforce. It may not be perfect. But it's idiot proof.""Days since gitastrophe"" is a common phrase. There is no Perforce equivalent. You can't blow your leg off. There aren't thousands of ""Perforce made easy"" blog posts because it's actually easy. There are no ""fixing my p4 repo"" tales because it never breaks.Thanks Perforce."	forrestthewoods	8.606484	-6.478797	comment	4.0	14.0	1482331978	3.168616
13240206	People have been asking for gibs sin	People have been asking for gibs since the dawn of mankind.	Senji	8.487549	-6.445538	comment	4.0	23.0	1482439294	-11.894969
13371364	And what about .git? And roots compa	And what about .git? And roots compatible with what other Devs expect?	bluejekyll	8.529084	-6.4476447	comment	4.0	14.0	1484103127	-11.907037
13492573	        The body of the commit messa	"        The body of the commit message can be several paragraphs, and
	please do proper word-wrap and keep columns shorter than about
	74 characters or so. That way ""git log"" will show things
	nicely even when it's indented.

Software should help me, I shouldn't have to help it. Why doesn't git handle this formatting automatically? I shouldn't need to manually break lines for typographical (not paragraph) reasons."	chris_7	8.59873	-6.524961	comment	4.0	51.0	1485447407	5.8037863
13514495	Trunk based development works well o	Trunk based development works well on any scm that sucks at branching. Perforce, subversion etc.But, on git, using GitHub-Flow is far superior.The two poster children for TBD do not use git. Don't cargo cult their process without understanding the unique problems they have that you don't.Edit: downvotes on HN? This isn't Reddit, and I'm advocating github flow, not git flow.GitHub flow is trunk based development but with all work in feature branches that live for less than s day or two, instead of branch by abstraction in the core code. That's it!	joneholland	8.604191	-6.524541	comment	4.0	26.0	1485703789	-11.867456
13514959	This workflow, like all others, is j	This workflow, like all others, is just a formalization of some reality. The reality is that many organizations and teams run on nothing but trunk - and it more-or-less works on them. Some teams work by building blocks separately and then joining them together; other prefer to hammer away on a problem all together. Both approaches work. What worries me are emotional claims that the other approach is fundamentally flawed, or that some git workflow is The One True Way.I've seen feature branches get stuck in review for weeks. I've seen trunk-only developers not knowing how to merge a branch back to trunk. I've seen trunks brought into a state of disarray and never fixed again. I've seen svn-only devs get completely bogged down and confused by a git wofkflow.Trunk-only is a reality. Not a real	kosma	8.610029	-6.521042	comment	4.0	31.0	1485708313	-11.877839
13515803	How do you support a 3 year LTS bran	How do you support a 3 year LTS branch for enterprise customers without long lived branches?	brianwawok	8.644655	-6.525904	comment	4.0	16.0	1485715407	-11.860963
13516768	Trunk-only is a reality. Not a reali	Trunk-only is a reality. Not a reality some of us would want to live it - but one that nevertheless exists.My background in Smalltalk made me accustomed to a style where everyone would continuously merge everyone else's changes as they worked. This style makes you aware of what your team mates are doing. In fact, it facilitates communication pretty much when communication is most called for.As always: context. The above approach is only going to work well, when there is convenient high bandwidth communications between teammates. (Not only for your version control, but also for communication between people.)I've seen trunk-only developers not knowing how to merge a branch back to trunk.Well of course. If they never had constant practice at merging, they wouldn't be very good at it. Merging 	stcredzero	8.616965	-6.532477	comment	4.0	15.0	1485724982	-11.916041
13546599	You code differently using  Git vs S	"You code differently using  Git vs SVN? That's an interesting concept.
It doesn't change the way you code it just changes the way we share code."	Thaxll	8.575268	-6.4890175	comment	4.0	12.0	1485992634	-11.853245
13560188	Also don't think that this is a good	"Also don't think that this is a good idea.
Git is a Distributed Version Control https://en.wikipedia.org/wiki/Distributed_version_control, the main benefit of which is ""allows many software developers to work on a given project without requiring them to share a common network"". Seems like with GVFS they are making DVC to be a CVS (https://en.wikipedia.org/wiki/Concurrent_Versions_System) again. What is the point? There are a lot of good CVS systems around. They just to give cool kids access to cool tools? I believe there are plenty bridges between CVS and git already implemented, which also allows you to checkout only part of the CVS tree.At Splunk we had the same problem, our source code was stored in CVS (perforce), but we wanted to switch to git. And not only because we really wanted to"	outcoldman	8.588629	-6.437515	comment	4.0	18.0	1486134185	-11.844216
13610533	> You don’t need elaborate Git relea	> You don’t need elaborate Git release rituals. Ceremony such as tagging releases gets to feel like a waste of time once you are releasing many times per day.What happens when you ship bugged code and need to roll back?	pavel_lishin	8.607024	-6.4611697	comment	4.0	21.0	1486671665	-11.877096
27518161	I'm a mechanical engineer.The versio	I'm a mechanical engineer.The version control software that we use (I'm most familiar with Windchill, and just a wee bit familiar with SolidWorks PDM) is dumb. It's a B2B market with fat margins that is ripe to be disrupted.Typically in Windchill, a part has a part number, and can be checked out and checked in, iterated, and revised, in operations that are non-intuitive and difficult to reverse. If you ever wanted to build an assembly using older versions of current parts, the process to figure it out might take 100 clicks, or might not be possible depending on how your system administrator set things up.Merging (in the style of git) is generally a completely foreign concept, and engineers generally avoid collaborating on a single part or assembly file for that reason. Dividing up the inte	someguy321	8.555611	-6.57919	comment	4.0	15.0	1623776231	-11.908691
27521813	I love having commentary like that a	I love having commentary like that around, but I prefer to keep it in either the commit message or (more frequently) in the issue thread linked to from the commit. That way I can use as much space as I like for it and the timestamps make it clear that it's historical commentary, not a description of how the code works right now.	simonw	8.582341	-6.5240664	comment	4.0	29.0	1623792906	-11.910354
27578158	I have this rails app that behaves r	"I have this rails app that behaves really weird on Heroku, where every build fails the first time.So I have a comment ""Commit comment"" in my html that I adjust a capitalization on then push again.Works 100% of the timeI expect to end up in the 500k commits club"	bgroat	8.572218	-6.500343	comment	4.0	13.0	1624274941	-11.894693
27580232	git reflog is hard enough so that I 	git reflog is hard enough so that I (a software engineer for 12 years and a git user for 10+ years) have to look up its syntax every time I need it.	leifg	8.574765	-6.527083	comment	4.0	14.0	1624289992	-11.900127
27580273	This seems like putting a training w	This seems like putting a training wheel on a training wheel. git is already the easiest to understand of any VCS that I've used, and it's somewhat hard to do something in git that can't be reversed. As the articles states, it's unlikely you'll ever lose your changes. Further, this doesn't seem to be that different of a concept from git reset, so why not learn reset instead of yet another command?	zach_garwood	8.572519	-6.52967	comment	4.0	21.0	1624290208	-11.9032545
27580488	Any other recommendations for CLI to	"Any other recommendations for CLI tools?I've gotten kind of familiar with the Git CLI. But it took a lot of wasted hours and headaches to do so, and even now it takes headaches and extra time / effort to do certain things like rewrite history and ""good"" commits. I still prefer CLI to GUI but I wish it was more intuitive."	Jakobeha	8.607102	-6.482908	comment	4.0	13.0	1624291483	-11.846094
27580793	definitely agree, and I'm in the sam	definitely agree, and I'm in the same boat. I don't even think the data model of git is that hard to grok at all, it's mostly that commands are very unclear on what they operate on and in particular people get really tripped up about how many levels of state there are (stage, working tree, local branches, remote refs) that they have to interact with.Like, I've had to explain a lot of times why you `git pull origin master` but when you want to interact with that remote branch otherwise it's `origin/master` instead. The lack of clarity is in what commands operate on what levels, with many of them operating on several at once.There have been some efforts to reform the command set to be more clear, like `git switch`, but the old commands will persist forever along with a lot of other footguns 	stormbrew	8.5630665	-6.508766	comment	4.0	44.0	1624293125	-11.8948145
27581166	The problem is just that collaborati	The problem is just that collaborative text editing between multiple users simultaneously is hard. It's a human problem and git attempts to be a technical solution but the abstraction fails at the edge cases.Regardless, what's so bad about deleting the repo and pulling from remote if you can't figure out why you hosed it? It's not like it costs you anything to do `rm ... && git clone ...`. And it's not like this happens daily either.In the rare case that someone hoses remote, yes you'll have to do some weird git-fu to get everyone working again, but it's really hard to hose remote if you stick to the pull -> commit -> push -> merge pattern, which is what 99% of users are doing anyways. I've used git for 9 years and I've never had to spend longer than an hour troubleshooting git based BS. A	nexuist	8.573986	-6.4909797	comment	4.0	17.0	1624295407	-11.88847
27581117	I disagree.First of all, a well-desi	I disagree.First of all, a well-designed Git GUI (examples below) exposes the git's underlying data model to you; in contrast, the CLI obscures it until something breaks and you're forced into it without context. Git operates on a graph and there is simply no way around it. The more you're exposed to the graph, the better you can mentally model it and ask it to do the right things.While there are many half-baked Electron-based UIs that only unnecessarily complicates things, there are good ones too:On Windows (and Linux thru Mono), I use GitExtensions. The visualizations are sane and discover-friendly. It will tell you what to expect.When I work on C++ projects, the one built into CLion (JetBrains family; as mentioned by a sibling comment) is very good on its own. What impresses me the most	smilekzs	8.5816555	-6.510159	comment	4.0	12.0	1624295172	-11.869449
27587438	1. Network effects2. TimingThe world	"1. Network effects2. TimingThe world was ready for a replacement for SVN just at the moment when git hit the scene, and it was just good enough to take over. Mercurial dates to the same era and was just about as good (arguably better), and could easily have won out instead, but tiny difference in initial adoption snowballed, and so git won and mercurial lost (as did Bazaar, Fossil, etc.)And while git is hardly perfect, a git killer needs to not just be 15% better, but hugely better; a big enough gap to trigger another industry wide shift. ""It's like git, but we made the UI 15% nicer"" seems like a good sales pitch, but it's not going to motivate people into becoming evangelists for their teams to adopt it, and that's what you need. (Git, for all its flaws, was enough better than SVN that pe"	Lazare	8.549523	-6.519601	comment	4.0	13.0	1624330529	-11.916619
27615936	We use a combination of Markdown + P	We use a combination of Markdown + PlantUML, CSV, YAML, Structurizr DSL, and Gherkin feature files under Git version control next to the code to structure the requirements and examples. A GitHub Actions continuous integration workflow does validations and compiles reader-friendly documentation with Mkdocs. We are experimenting with consolidating more and more of this into feature files.We structure the project and its related projects hierarchically along service design packages, similar to the “class-responsibility-collaboration” breakdown in object-oriented design.All of our stream-aligned team collaborates continuously on this data as part of sprints, including analysts, managers, software and QA engineers. We recently started to collaborate with the enabling Risk & Compliance team on t	sandij	8.61739	-6.4759803	comment	4.0	16.0	1624531888	-1.5110855
27637856	Pro Git(https://git-scm.com/book/en/	Pro Git(https://git-scm.com/book/en/v2). You'd be surprised how many people in our professional community try to get by in life having never just sat down and read the documentation on their tooling. Obviously the git man-pages are terrible enough that we have goofy parody generators, but its okay because this book exists.	jldugger	8.555426	-6.4629345	comment	4.0	12.0	1624667029	-11.887992
27723388	I’m one of the people who strongly a	I’m one of the people who strongly advocates the squash merge. My PRs are also single commits most of the times with the PR body as the commit message. That is a hidden gem of GitHub, if you open a PR with a single commit then GitHub will use the commit message as the description.The reason why I prefer squash commits is not only the linear history but also the fact that I’m simply not interested in the sausage making process. If a PR becomes so big that it would need multiple commits than I request smaller patches. But I also see that this heavily depends on the team size and general setup. But I use squash PR ever since it was introduced in GitHub. Before I manually rebased the feature branches to have a clean merge.	larusso	8.570522	-6.558691	comment	4.0	19.0	1625334349	-11.939279
27723628	I've often thought this too, you sho	I've often thought this too, you shouldn't have to rewrite  i.e. lie about what happened. Git history ideally should be completely immutable but there should be a view that tidies up what happened for those that like to see individual features/bugs/hotfixes all listed in history in a nice way.I don't like the name thought, commit groups seems odd, I prefer feature view or something else. The reason is commit groups sounds to me like groups of people who are allowed to commit.	andy_ppp	8.57098	-6.5499163	comment	4.0	37.0	1625336394	-11.903171
27724132	You can do this today in standard gi	You can do this today in standard git with https://www.davidchudzicki.com/posts/first-parentSummary: every feature is merged with 'main' as the first parent.  Then, whenever interacting with history, you tell git you only want it to consider --first-parent	jefftk	8.545922	-6.5310044	comment	4.0	26.0	1625340817	-11.8776655
27728556	> I really want to put the 'enough i	"> I really want to put the 'enough is enough' point before worrying about a good looking commit history.I see where you're coming from, but I'd like to add a counter-argument to that. I'm currently working on a (mono-) repository with 40-something devs working on it, and we've recently switched from a ""everything goes""-commit-history-approach to enforced linear history (while only a handful of people are allowed to directly commit on main-lines without a pull request).The main reasoning was this: It became almost impossible to understand why a build broke on the mainline by just looking at the commit-history itself. It was always needed to go through build-logs and such to get the picture of the how and why, and often even to get to the 'who', because the commit-history itself was just rid"	Shacklz	8.576261	-6.55442	comment	4.0	12.0	1625393788	-11.925778
27769211	To ease the pain in conventional dif	To ease the pain in conventional differs, we use a pre-commit hook to format the source code (prettier). This way we only see differences if something _actually_ changed.	davidkunz	8.652963	-6.5001726	comment	4.0	18.0	1625729405	-11.797309
27850696	I think Subversion is fine for a cen	"I think Subversion is fine for a centralized solution.  True evil is spelled ""C"",""V"",""S"", but we do not speak its name."	gmfawcett	8.616092	-6.448319	comment	4.0	12.0	1626386920	-11.888144
27851068	I make a point never to commit broke	I make a point never to commit broken code anyway. If a series of changes have to be together to not break, I put them all in one commit. And for organization’s sake, commits could still be tagged by ticketThat doesn't mean an entire feature has to go in one commit (usually). Often a feature is made up of a series of non-breaking changes that can be layered one at a time, if appropriate.	brundolf	8.608726	-6.5553355	comment	4.0	16.0	1626389729	5.9134355
27904071	  > It's particularly easy to see th	"  > It's particularly easy to see that the ""atomic changes
  > across the whole repo"" story is rubbish when you move
  > away from libraries, and also consider code that has 
  > any kind of more complicated deployment lifecycle, 
  > for example the interactions between services and 
  > client binaries that communicate over an RPC interface.

This seems exactly wrong to me. Getting rid of complicated deployment lifecycles is exactly the job that people use monorepos to solve. Wasn't that one of the reasons they are used at Google, Facebook, etc? As well as being able to do large-scale refactors in one place, of course.You should be able to merge a PR to cause a whole system to deploy: clients, backend services, database schemas, libraries, etc. This doesn't preclude wanting to break up c"	lhnz	8.70478	-6.4931817	comment	4.0	28.0	1626859369	-11.864622
27964921	Stop using git blame to look up who 	Stop using git blame to look up who authored code, it's not a useful tool. Use git log -S <string> to search for changes to that line (then repeat with the previous version of that line, until you find the original author), and/or git log -L to track changes to a code block. Don't waste your time with git blame.	stevebmark	8.560388	-6.4848676	comment	4.0	18.0	1627330881	-11.920758
27965737	Curious how do you get away with it 	Curious how do you get away with it without anyone noticing. Doesn’t this imply rewriting the master branch? Wouldn’t that cause noticeable issues for everyone else? Or maybe you’re the only active contributor on that codebase (but then who else can you blame?)	ornornor	8.540648	-6.532123	comment	4.0	16.0	1627334924	-11.803682
12310683	Git bisect (2006)	Git bisect (2006)	99_00	8.572453	-6.5175986	story	4.0	45.0	1471500592	0.9419947
12329099	Git has done a terrific job of it. I	Git has done a terrific job of it. It just doesn't do a great job at communicating what it does, how it does it, why it does it that way and how to achieve those results.In other word, git's great internally... externally it just has a poor UI. But what's new there.	scrollaway	8.5403	-6.478374	comment	4.0	19.0	1471744292	-11.903716
12358303	One important reason is to avoid was	One important reason is to avoid wasting time on gilding lilies.Another reason is that the git information (e.g. from git blame) tells us when the code was written and in what order, rather than some post-hoc rearrangement.For example, we might notice that code X is doing some tricky work which elsewhere is done by a helper function Y. We look at the git info and see that X was added after Y, so we try to figure out what special edge-cases X is trying to deal with that Y wasn't suitable for. Little do we realise that X was actually written before Y existed, but the commits got rearranged.That kind of archeology is difficult to predict in advance (mostly because, if we realised all of the issues with our code beforehand, we'd fix them immediately!).Future devs are just as capable at travers	chriswarbo	8.571268	-6.501143	comment	4.0	19.0	1472126033	-11.904043
12358309	One can argue semantics whether you 	One can argue semantics whether you call it a UI or a CLI, but hey. There's a number of GUI clients out there that depending on your criteria could be considered better. They're usually not as powerful as the CLI client though, and if they are, features like accessing the reflog are hard to find and use. There's also a few alternative CLIs out there, I've just done a quick googling and came across http://www.saintsjd.com/2012/01/a-better-ui-for-git/ and http://www.kennethreitz.org/essays/legit-the-sexy-git-cli.Personally I prefer the CLI, it's the only tool that I can rely on to do what I tell it to do and to know what's happening. But it takes time and effort to get used to it.	Cthulhu_	8.586631	-6.5024796	comment	4.0	14.0	1472126082	-11.861552
12358771	One clarification: amend, reset, reb	One clarification: amend, reset, rebase and their ilk don't 'manipulate the commit tree' other than adding commits. The manipulation is with the branch names associated with the commits.I've always hated the common description of 'rebase' as 'rewriting history'.  None of the existing commits are modified by rebase, new commits are added and the branch names are shuffled around.	gwright	8.577694	-6.5592537	comment	4.0	20.0	1472131395	-11.899908
12383851	i have been using GitBox (http://git	"i have been using GitBox (http://gitboxapp.com) for quite awhile now, but it seems like it doesn't get much in the way of updates, so i tried this.Very first thing it does is write a file called ""gitclient.log"" to my home directory. i deleted it, and it came back the next time i started the app. I see nothing in the prefs that allows you to move the file somewhere else.call me picky, but this is is a deal-breaker for me. nothing gets to write files to the root of my home directory. Right into the trash."	allenbrunson	8.557399	-6.481339	comment	4.0	19.0	1472494220	-11.8847475
12425632	Show HN: Git–fiddle – Edit commit me	Show HN: Git–fiddle – Edit commit messages, author and timestamps during rebase	felixschl	8.564287	-6.4434137	story	4.0	60.0	1473010789	-11.822791
12460294	If you're concerned about not knowin	"If you're concerned about not knowing how to do certain things with git, and understanding at a deeper level how git works, I highly recommend reading Scott Chacon's ""Pro Git"" book:https://progit.org/"	wyclif	8.54651	-6.4958024	comment	4.0	13.0	1473407144	-11.897207
12460420	Any points on how to continue from t	"Any points on how to continue from there? Been in a few ""I give up"" conditions during rebases that I completely stopped trusting git it any way.The thing is, some repositories on github require you to commit only after proper rebasing. But I can never in my life remember how and need to google it..."	zubspace	8.587179	-6.5853844	comment	4.0	12.0	1473409448	9.392704
12460431	What are the superior foes in your o	What are the superior foes in your opinion ?I don't know any of the other distributed version control systems. The only other version control system I have much (too much) experience with is Subversion and it can't hold a candle against Git.In my opinion Git is the C language of version control systems. If you are careless it's not the tool for you. Otherwise you have a really great tool with lots of power.	brusch64	8.587669	-6.451196	comment	4.0	17.0	1473409538	-11.8791065
12462316	I would not expect a university to t	I would not expect a university to teach git. Maybe the theory of version control systems, their history, or a comparison of different version control systems.But not how to use the tool.	swehner	8.550041	-6.480817	comment	4.0	12.0	1473430105	-11.868239
12462824	"Have you ever tried ""man git""?git is"	"Have you ever tried ""man git""?git is bloated, and certainly anything but simple.  It's also arguably stupid in a lot of ways.git is fast, though, and that's one of the main reasons it won over other version control systems which were a lot more elegant and easy to use."	pmoriarty	8.552832	-6.4653864	comment	4.0	16.0	1473433214	-11.875449
12462952	God, it's probably billions. I love 	God, it's probably billions. I love git but its user interface is borderline criminal. The sad thing is mercurial has like 95% of git's power and is waaay easier to understand, but it never took off in a big way.	overgard	8.522713	-6.536333	comment	4.0	34.0	1473434060	-11.936769
35193615	I want to point out two additional o	I want to point out two additional observations.1. There are a decent amount of software engineers or programmers whom literally aged at the perfect time to organically learn these tools that later became fundamental. If you even touched a computer from the 60s to the late nineties in a engineering aspect at all, you were bound to have worked in a terminal, worked on computers with a single core, worked on computers with very little memory, had to either get comfortable with some lower level tooling or build your own, at some point had to mess with networking or at least understand how packets were being sent and received, seen and gone through iterations of version control and saving your work, automated task using shell scripts.2. While there is a plethora of knowledge, videos, tutorials	flamebreath447	8.557151	-6.475589	comment	4.0	18.0	1679031947	-11.890898
35325746	"Yup. Tried pushing and got ""remote: "	"Yup. Tried pushing and got ""remote: fatal error in commit_refs"". Was trying to understand what I was doing wrong."	can16358p	8.567757	-6.448699	comment	4.0	16.0	1679919761	-11.867306
35384848	This _is_ Silverblue and other ostre	"This _is_ Silverblue and other ostree-based repos.This article is focused on containers because when the root OS is immutable, then mutable developer workflows/etc necessarily happen in containers (distrobox, toolbox, whatever). OSTree is/was commonly described as ""git for filesystems"". Every update is an entirely new system image which applies a 3-way diff. It's possibly to state in a single command ""show me the drift in my config files/data versus the ref I'm running"" and/or ""show me the diff between my running system and an update I may apply""."	evol262	8.687995	-6.47774	comment	4.0	17.0	1680257926	-11.787211
35452673	As a developer, I would get pretty u	"As a developer, I would get pretty upset and demoralized if someone came and periodically reverted all my commits. Imagine if I actually had to risk my life to make those ""commits""?It's not hard to see why they stay in the car and keep driving if the arrests don't even lead to prosections."	paisawalla	8.586465	-6.487124	comment	4.0	21.0	1680696323	-11.876871
28030534	> with git checkout you can create a	"> with git checkout you can create and switch to the new branch in one command using the -b flag:
git checkout -b new_branch> You can do the same with the new one, but the flag is -c:
git switch -c new_branchIt's like they had a design meeting where they discussed this and said ""so  I propose switch -b newbranch to create and switch to a new branch"" and the objection was ""nah that would make it consistent with checkout, which is against the project policy"""	alkonaut	8.560023	-6.5414166	comment	4.0	32.0	1627855391	-11.910373
28033918	"I've tried the ""rebase into a featur"	"I've tried the ""rebase into a feature branch"" workflow, which I think you are alluding to.  Unfortunately, it always results in scary conflicts.  So I go back to merging the main branch into my feature branch workflow, which works every time.  I then hit squash in gitlab for my merge request, and no one is the wiser.Should I be doing something different?  As I said, rebase in that situation is disastrous.  Many folks recommend it vigorously but are not around when things inevitably go wrong."	mixmastamyk	8.597174	-6.582257	comment	4.0	25.0	1627890135	9.305592
28069161	Result: git committing, excessively.	Result: git committing, excessively.	hncurious	8.567289	-6.4782877	comment	4.0	27.0	1628131146	-11.882993
28110032	Every commit should build is a reaso	Every commit should build is a reasonable principle.However, it's in contradiction to TDD. If you have a bug (in master) the first thing you are supposed to do is to create a test that fails because of the bug. This is a self-contained commit, but it will not build (assuming your test are run during the build as they should). The next commit is fixing the bug and now it builds again.So the commit with the new test should be marked as unsuitable for bisecting. How to do that easily in away that bisecting remains easy I have yet to work out.	usr1106	8.637045	-6.5418644	comment	4.0	16.0	1628456163	-11.896807
28153530	We also found that bug-fixing commit	We also found that bug-fixing commits by authors tended to be larger in size and scope, and address multiple issuesToo bad I cannot see examples of what this actually entails - for us one commit which fixes several issues is a complete no-go: that should be separate commits. So now I wonder whether the paper really means single commits which address multiple things, or groups of commits?	stinos	8.583649	-6.537415	comment	4.0	21.0	1628756197	9.894483
28154685	I agree, but I've also been told off	I agree, but I've also been told off for making many, small commits. I don't know why the complainers don't squash them together if that's the way they feel and leave the moaning out of it.	brigandish	8.578169	-6.5371876	comment	4.0	12.0	1628765958	-11.917871
28156772	With normal review cycle times, this	With normal review cycle times, this would slow things very much.Optimizing your development practices for being able to revert single commits seems very wrong to me. If you produce so many bugs that this is important, I'd focus on making fewer bugs.At my current job I can't remember us reverting a commit in the three years I've been here.We probably work in very different environments, and your views may be the pragmatic ones in your environment.	BurningFrog	8.586293	-6.538375	comment	4.0	13.0	1628778475	-11.894148
28162034	Teaching git & Github to someone tha	Teaching git & Github to someone that doesn't know how to use a terminal is like teaching calculus to someone that doesn't know how to add.Of course you won't be able to do it in a couple of hours. Most people spend years learning the things that are required  to understand how git works, or at least many months if you want to learn in a fast, intensive manner.	young_unixer	8.544031	-6.4727335	comment	4.0	16.0	1628805198	-11.896907
28164396	"If ""git pull --rebase"" succeeds with"	"If ""git pull --rebase"" succeeds without reporting a merge conflict, then it's tantamount to having executed the command with ""--ff-only"".I believe you are incorrect however. ""git pulll --rebase"" will not ever rewrite history from the origin repository. It will only ever modify your local unpublished commits to account for new commits from the origin branch. If your change and the new commits from origin aren't touching the same lines or files, then the update is seamless [1].If there is a conflict because your change and a new commit from origin both changed the same line in the same file, this can result in a merge commit that you need to resolve. But you resolve this locally, by updating your (unpushed, local) commit(s) to account for the new history. When you complete the merge, it will"	jcrites	8.573322	-6.558153	comment	4.0	13.0	1628819734	-11.882112
28196353	I personally find Ruby's built-in sh	"I personally find Ruby's built-in shell features more ergonomic:    `cat package.json | grep name`

    branch = `git branch --show-current`
    `dep deploy --branch=#{branch}` if $?.success?

    [
      ""sleep 1; echo 1"",
      ""sleep 2; echo 2"",
      ""sleep 3; echo 3"",
    ].map { |cmd| Thread.new { %x(cmd) } }.each(&:join)

    name = 'foo bar'
    `mkdir /tmp/#{name}` if $?.success?"	satyanash	8.678043	-6.530459	comment	4.0	17.0	1629106328	-11.816008
28209697	What I really want from Git, is to b	What I really want from Git, is to be able to have just a single executable for distribution, like `/bin/git` or `git.exe`. Currently Git is a mishmash of C, Shell (yes really), Python, Perl and who knows what else. I found from my own testing that you can actually make a static native build of the core with a few tweaks, but some big chunks of the project are still in other random languages.	svnpenn	8.5944605	-6.468663	comment	4.0	17.0	1629207509	-11.89
28393294	It is just a tool to help you do you	It is just a tool to help you do your real work and famously gets in the way. You use SVN and it covers 99% of use cases much more simply than Git manages.	jimbob45	8.578371	-6.4842043	comment	4.0	23.0	1630596607	-11.8534355
28437968	Merges done from a GitHub Pull Reque	"Merges done from a GitHub Pull Request (PR) contain a reference to that PR. The reference is not even a full URL, but just a number (e.g. ""#42""). You need to use the GitHub web UI to turn this number into a URL (or deduct it if you know the repo URL). If you have that, then you can go to the Pull Request web page when you can read the whole story about the merge.What Linus rightfully wants is the whole story right in the commit message of the merge.I think GitHub purposely makes condensed commit messages for merges as a way to hook users to their web UI."	warpech	8.629614	-6.446394	comment	4.0	20.0	1630961459	-11.87513
28577528	If only we could instead have an int	If only we could instead have an intuitive version control system which didn’t need crazy explanations or for each team to have a ‘git expert’ who has memorised a few more commands for unbreaking the repo than anyone else. But for now, it seems git is here to stay and many collective hours will be wasted cursing the git who designed it.	dan-robertson	8.569921	-6.4796915	comment	4.0	18.0	1631983610	-11.86574
28632712	Git-Xargs	Git-Xargs	sciurus	8.627661	-6.489105	story	4.0	14.0	1632419929	-11.624418
22304513	You'll use git a hundred times a day	You'll use git a hundred times a day, every day, for the rest of your career. It's easily worth the hour it'll take to learn it properly.	ddevault	8.542953	-6.489117	comment	4.0	48.0	1581467268	-11.852876
22304782	A typical mouse has 2-3 buttons, a w	A typical mouse has 2-3 buttons, a wheel, and an X/Y axis.Git is 100x more complex, if not more.Give me a break. I'm sick of people glamorizing the idea that you should have your hand held through each step of every tool you use and never expend any effort on becoming an expert in the tools of your trade. Git is an engineering tool, designed by and for professionals. Imagine this kind of obscene complatency in other fields.	ddevault	8.541291	-6.478036	comment	4.0	23.0	1581470079	-11.891535
22307280	> If it's so hard to learn about thi	"> If it's so hard to learn about this tool and so easy to learn about it the wrong way, that's a pretty obvious hint that there's something wrong with the tool.Not necessarily. This may mean (and I think in this case, it does) that people are too afraid to learn about those ""internals"" - or should I say, the mental model behind the tool (and then some of those people write tutorials for others, perpetuating the problem). And with a ""monkey see, monkey do"" approach, people can fail at anything, up to and including tying their own shoelaces.There is no such thing as a perfect encapsulation. Not in programming, and especially not in the physical world. ""Internals"" are ever-present and leak into view all the time. A good abstraction is just one that you can use day-to-day without constantly mi"	TeMPOraL	8.570497	-6.4917626	comment	4.0	19.0	1581499386	-11.922153
22310549	I'd say not wholly unmaintained.  It	I'd say not wholly unmaintained.  It hasn't seen any commits since 2017.	bashinator	8.6815	-6.51852	comment	4.0	12.0	1581527327	-11.897526
22434389	The interesting thing is that Git is	The interesting thing is that Git is entirely non-centralized, so in theory they could simply redirect to servers onto which the data has been mirrored.	amelius	8.551752	-6.4476433	comment	4.0	16.0	1582819348	-11.88947
22488239	I agree 100%. I too tried Gitflow on	"I agree 100%. I too tried Gitflow on many different projects, with different skill levels of teams and we ended up pulling the plug on it and going back to ""master is always deployable/production"". Developers work in feature branches that are small and atomic, with frequent merges into master with corresponding deployments. Breaking master is a critical blocker issue. There's no need for tags, complicated release schedules or processes following this model and it scales from a team of 1 to a team of 1000, I've seen it done.Gitflow doesn't work in a CI environment on a modern software application that has good testing culture and systems that are resilient to failure.Tools and processes work a lot better when they work for you, not the other way around. KISS."	iamleppert	8.534473	-6.4864664	comment	4.0	15.0	1583356653	-11.913443
22488779	I don't understand the argument here	"I don't understand the argument here at all. Git flow seems pretty orthogonal to concept of branching lifespan. We did the ""merge early, merge often"" approach with SVN 15 years ago and it was fine. We do git flow now and it's fine. It meshes perfectly with agile development where you work on the smallest feature set that adds incremental value. That means your branch only ever lives long enough to do one tiny thing and it gets merged as soon as it's working and no sooner. I've been following this approach for years with dozens of teams and it's very successful. And I've never run a rebase on purpose in my entire life."	tootie	8.586338	-6.5485005	comment	4.0	30.0	1583360432	-11.900616
22489853	The author says:> While I hesitate t	The author says:> While I hesitate to say “Worrying about merge conflicts” is a valid reason not to pursue a branching strategy like gitflowI do not hesitate! This is _very good_ reason to avoid gitflow.Merge conflicts by definition require human intervention. And human intervention means an opportunity for human error. Resolving merge conflicts properly ranges from trivial to nearly impossible, depending on the specific changes you're trying to merge.Often none of the authors involved in the conflict are in a good position to understand why it happened. One person makes a small bug fix change to a few lines of code. But that fix required hours of research and a solid understanding of the problem. Meanwhile, someone else is doing a refactoring of that same code in another branch, unaware o	autarch	8.622203	-6.531071	comment	4.0	22.0	1583369295	9.024115
22489939	I don't just worry about merge confl	I don't just worry about merge conflicts. I worry about merges that generate no merge conflicts, but still create bugs because of the way changes on two different branches end up interacting with each other at run time.In general, I feel a lot more confident with using feature flags and the like to keep work in progress from prematurely going live than I do using branches to do the job.Or, if I could take a stab at saying it pithily: Having your code be continuously integrated is a prerequisite of doing continuous integration.	mumblemumble	8.646816	-6.532006	comment	4.0	16.0	1583370212	-11.857239
22491588	I'm curious how your commit history 	"I'm curious how your commit history looks. Doesn't it have tons of useless commits like ""removing comments"", ""forgot semicolon"" etc?Here's Linus Torvalds' thoughts on rebasing.
https://yarchive.net/comp/linux/git_rebase.html"	jsnk	8.575649	-6.5700293	comment	4.0	15.0	1583392730	-11.908473
22491039	The fact is that this doesn't work f	"The fact is that this doesn't work for everyone. What we found to be most workable is master is always ""stable"", then we have a production branch that is cut from master.This gives you a few things:1. More predictable deployments (let's deploy every week with X items)2. Better rollbacks (rollback to last production deploy instead of guessing SHA1 of last acceptable state)"	westoque	8.71531	-6.5152235	comment	4.0	15.0	1583383425	-11.876336
22498460	> A year after you release v1.0.0 (w	"> A year after you release v1.0.0 (which you say is a tag), a customer reports a bug in it. They don't want a breaking upgrade to v9.13.0. They want to pay for v1.0.1 (aka ""hotfix"").> But you can't open a PR against a tag v1.0.0. Hence you discover that v1.0 should be a branch, and both v1.0.0 and v1.0.1 tags. This way you can open a PR against v1.0 and easily create v1.0.1, v1.0.2, etc.So you could just `git checkout v1.0.0; git checkout -b v1.0`, commit your hotfix and deploy v1.0.1.> Another problem. You are at ""master"" and approach v13.0.0. But there are numerous bugs to fix before you release. Testing takes >24 hours. You choose to work on bugs on a branch (v13.0) this way master can proceed with new features and not be feature-frozen for days or weeks.Or you could use topic branches "	deepersprout	8.61277	-6.515655	comment	4.0	14.0	1583443492	-11.928909
22516972	> they haven't transitioned from SVN	> they haven't transitioned from SVN to git solely because of the logistical challenge of migrating 30 years of commitslol, I don't think that's the reason. At the only place I worked that used SVN the real reason was that the old guys didn't want to learn something new.	JesseAldridge	8.566674	-6.4657984	comment	4.0	17.0	1583655961	-11.862552
22516979	Our codebase is around 20 years old 	Our codebase is around 20 years old and was in CVS, then SVN, then git. Then several years after git, a new git repo without any history due to poor use of the first git repo (someone added binaries, bloated the repo to GBs instead of maybe 200-300MB, which made git export horridly slow).In all the steps we preserved the commit history, except for the final git->git. However also when we moved from SVN to git we kept the old svn server running as a historical archive for several years, as we didn’t carry across all projects (some were already EOL’d years ago).During that time I looked at it maybe twice, and ultimately we decommissioned it.Likewise with the new/old git repos, we still have the old git repo if we need the history.One final thought: git blame was nice, until someone reformatt	yardstick	8.575884	-6.473143	comment	4.0	14.0	1583656134	3.4003153
22606534	> Adding the --vcs git flag also has	> Adding the --vcs git flag also has cargo create a gitignore file so that the target folder isn’t tracked by git.Doesn’t cargo make a git repository by default, anyways? Why doesn’t it add a sensible gitignore in the process?	saagarjha	8.592731	-6.464926	comment	4.0	12.0	1584462127	-11.8791685
22628421	Is anyone here using gitlab with a r	Is anyone here using gitlab with a runner to build QT applications upon commit? I've got a friend who needs this and he is only using QTCreator but it seems like building inside a docker container should be possible. I guess I'm asking: can all the things discussed here be done from command line instead of inside the editor and if so, how do you determine those commands?	xrd	8.453089	-6.456663	comment	4.0	20.0	1584632091	9.030602
22659305	Part of the calculus for the cost is	Part of the calculus for the cost is losing the immediate utility of git blame once every file has been reformatted.	afshin	8.545193	-6.4704375	comment	4.0	17.0	1584915770	-11.883848
22698529	TL;DR Use the Histogram diff algorit	TL;DR Use the Histogram diff algorithm in Git	hervature	8.648802	-6.495883	comment	4.0	17.0	1585260933	-11.79533
22735510	Git branching is not intuitive, beca	Git branching is not intuitive, because they are not branches but pointers/labels. When you talk about the master branch, you actually talk about the master pointer.The other VCSes have an intuitive concept of branches, because they are in fact branches.I liked Mercurial more than Git, but when BitBucked dropped Mercurial I also switched to Git.	koonsolo	8.552204	-6.5462747	comment	4.0	14.0	1585638907	-11.956065
22750838	I like a good April Fool's joke as m	I like a good April Fool's joke as much as the next guy, but it seems like a git commit is more difficult to roll back. You'd have to make another commit on April 2nd reversing the April 1 commit, right?	AdmiralAsshat	8.570634	-6.5120316	comment	4.0	17.0	1585760143	-11.880472
19006663	How often dou you actually look at t	How often dou you actually look at this historic detail you seek to maintain? Daily, weekly, monthly? Is it more for to satisfy a feeling than an actual need? I mean if some junior dev wallows on some branch for 40 commits, I don’t want to see any of that, I just want to see what was finally merged.	marktangotango	8.583541	-6.540116	comment	4.0	25.0	1548516658	-11.921118
19008716	Ideally it should be this way, but i	Ideally it should be this way, but it's impractical in reality.It requires that you either stop your development workflow to commit as you go along, or that you untangle all the pieces after they're already entangled.If you commit as you go, it's an expensive mental switch to fire up git and also run all the tests (since surely part of this workflow is to apply the principle that no commit should ever break the build). You also take an extra productivity hit every time you change your mind about something a little later (e.g. you added the function getFoo() but realize it should have been called findFoo()).If you work for a while and then try to bundle up small, atomic changes, that can also be very difficult. Tools like git group together contiguous chunks of changes when committing, and 	atombender	8.581233	-6.5374813	comment	4.0	13.0	1548539217	-11.924675
19081108	Feature branch, review, squash, merg	Feature branch, review, squash, merge - only way to roll imho.	jtms	8.580925	-6.5593963	comment	4.0	13.0	1549317993	2.0775926
19103088	It's also dying [1]. Git's the only 	It's also dying [1]. Git's the only version control system that's got legs [2].[1] https://trends.google.com/trends/explore?date=all&q=%2Fm%2F0...[2] https://trends.google.com/trends/explore?date=all&q=%2Fm%2F0...	taspeotis	8.579924	-6.442593	comment	4.0	13.0	1549515200	-11.869482
19164711	Is there actually a way to do this, 	Is there actually a way to do this, if there is no code difference between your new branch and the base?	darkerside	8.572691	-6.5471478	comment	4.0	16.0	1550170589	-11.869643
19247830	Great pointers. However, I have foun	"Great pointers. However, I have found that even though quite a few people know this, it takes special effort to enforce it. For example, the single-purpose commits. My commits often tend to get a bit large, and include more than one ""unit"" of work, even though I know the best practices. Any pointers on how to avoid that?"	Sourya	8.582969	-6.535722	comment	4.0	14.0	1551118186	5.0271454
19263375	Someone already opened an issue to m	Someone already opened an issue to make it ignore files specified in `.gitignore`. A `fd` is doing it, `rg` is doing it, now someone wants this to behave the same. I don't know. Maybe I have some really strange expectations but when I want to find a file and nothing comes up as a result, I want to be sure nothing is there. And I want to be sure without remembering bunch of command line options or setting up aliases everywhere I log in because, guess what, maybe they invented some other file with patterns to ignore. Is it only me?	wst_	8.641945	-6.4705462	comment	4.0	12.0	1551277512	-11.803941
19374656	Under no circumstances would I be ha	Under no circumstances would I be happy if my degree program taught me how to use git.I can’t think of a single skill more stupid to learn in university.My degree came a lot cheaper than the modern ones but if I got a similar experience now as then I wouldn’t feel cheated.My undergraduate provided opportunities to program lisps & assembly & write published articles on data structures & I literally went to the local state school.	kasey_junk	8.530938	-6.4972615	comment	4.0	20.0	1552438111	-11.92219
19376988	MasterMing the merciless? a funny ty	MasterMing the merciless? a funny typo.	bryanrasmussen	8.502963	-6.570398	comment	4.0	15.0	1552468424	-3.3412623
19384945	“git show-me-the-code-as-of-last-Wed	“git show-me-the-code-as-of-last-Wednesday” is not a command that git understands. Of course, you can _do_ this in git, by memorising arcane commands, and you still only get the output on your terminal. The other option is basically using a GUI interface for git.On the other hand, finding the folder for last Wednesday and opening it up is easy.	joppy	8.545622	-6.449551	comment	4.0	16.0	1552518928	-11.817943
19384833	How the heck is that simpler than-- 	"How the heck is that simpler than-- git add .-- git commit -m ""I did something""-- git pushHow???"	leadingthenet	8.566471	-6.513499	comment	4.0	21.0	1552517942	-11.897286
19562232	Aw, well i'm glad you wanted to try 	Aw, well i'm glad you wanted to try it :)Too answer your question though. I've been working on Gimli for the last 18 months now. Using up my own savings, and the reality is that I can't afford to keep working on it for much longer.I would have loved to be able to present a finished and polished product but i'm just not there yet.	gimliapp	8.5020485	-6.441821	comment	4.0	16.0	1554287654	-11.923011
19569356	> The most obvious difference is tha	"> The most obvious difference is that Git's index is a bit boneheaded, so I'm ignoring it.> In fact, the entire concept of the staging area has been dropped, as it's both confusing and clunky.  There are now only three states that files can be in: 'untracked', 'dirty', and 'committed'.> Some usage examples:    git/add foo.c

So… what does `git/add` do?> Tells the repository to add a file to the next commit.And wherever that information is stored, so that between running `git/add` and `git/commit`, we can remember what things are going to be part of the commit… that sounds an awful lot like something one might call a ""staging"" area. How have we not reinvented it here?"	deathanatos	8.587371	-6.5349836	comment	4.0	15.0	1554352565	-11.903361
19704861	I prefer conventional commits, I hav	I prefer conventional commits, I have created a tool that prompts some info to make it easier to remember, I can also bump automatically the version  using the commits. I've been using it with friends with no issues. I really like how the commit log lookshttps://github.com/Woile/commitizen	woile	8.578178	-6.490451	comment	4.0	18.0	1555735718	-11.890616
19705115	I don’t completely agree. By taking 	"I don’t completely agree. By taking the time to write commit messages you are documenting your code at a fine-grained level. Think of it like a short email that explains to your (future) colleagues and future self what you changed and especially why you did it.A good git log prevents unnecessary headaches and saves a lot of time. Typical situation: you just found a couple of lines whose purpose is not completely obvious. If the author is still there, you both waste time discussing. If she/he left the company and you have to figure it out by yourself.
Now imagine using git log to identify when these lines where introduced/changed and getting an explanation as to why.So yeah, writing good commit messages can feel like a waste of time. Like writing good code can feel like a waste of time. You"	remilouf	8.568263	-6.5248904	comment	4.0	42.0	1555741743	-11.897692
19705810	I don’t understand why the history o	I don’t understand why the history of the code matters so much to some people. Give me well designed and commented (!) code, with tests, designed to be understood by humans. Thats a bar few code bases clear, if I need to look at the git history its a sign the code is crap and I have to use all the information that I can get, with history being my least favorite because it has shitty UX (discoverability, navigation).	MrBuddyCasino	8.5966215	-6.546437	comment	4.0	18.0	1555757154	-11.898639
19705225	Nobody questions it is important to 	Nobody questions it is important to write clear commit messages. The issue is being nitpicky about what exact form is being used like whether to capitalize first letter or not.When I look at the repository I am happy if I can understand the messages at all. It's challenging to get people to group changes in a logical way so that the commit makes sense. I am not going to pick on somebody because he used wrong tense or did not capitalize first word of the message if the changes are grouped logically and the commit mentions the correct ticket and purpose of the commit.	lmilcin	8.58718	-6.5310965	comment	4.0	15.0	1555744153	-11.902387
19739491	> Git is the best source control sys	"> Git is the best source control system ever.To be clear, I'm not disagreeing. But it is simply not good enough. Any new generation of source control needs to be able to do things that are difficult with Git, and Git simply isn't extensible enough. Microsoft has a Git VFS, and there's Git LFS, but this just doesn't go far enough.There are good technical reasons why you would use Perforce or even Subversion these days.The people who made Git made it for working on large, but not huge, open-source code repositories with a traditional model. It doesn't work so well for vendoring, it doesn't work well for artists, it doesn't have locking, it doesn't have access controls (and there's only so much you can add). You can argue that these features don't make sense or we're using Git ""wrong"" or I ca"	klodolph	8.551612	-6.4405437	comment	4.0	26.0	1556120428	-11.874367
19739521	> There are good technical reasons w	> There are good technical reasons why you would use Perforce or even Subversion  days.Can you say more?  What are some of those reasons?  Or link to some data or examples?	hashkb	8.614023	-6.4908915	comment	4.0	17.0	1556120598	13.822627
19878038	Weird they don't talk of the `git co	Weird they don't talk of the `git commit --fixup=` command. And then `--autosquash` when rebasing.	sktrdie	8.573592	-6.549513	comment	4.0	13.0	1557498584	-11.865751
19878318	FWIW i've never really needed rebase	FWIW i've never really needed rebase. i am pretty happy with seeing all the commits that ever happened.	jaequery	8.577416	-6.5723557	comment	4.0	29.0	1557499961	9.319557
19878482	What do you use your git history for	What do you use your git history for? History is either worth keeping, in which case you should maintain it like any other artifact, or it's not, in which case you should squash down master to a single commit every time you merge.But maybe you use your history for something else that I haven't considered.	rich-tea	8.569116	-6.5505905	comment	4.0	15.0	1557500894	-11.908427
19878841	This really should be the top commen	This really should be the top comment here. Learning about the non-destructive nature of Git really helped me overcome the unease around using some of Git's more advanced features (especially in a team environment).	Chazprime	8.549214	-6.4930124	comment	4.0	28.0	1557503104	-11.884745
19878973	I really don't understand why git do	"I really don't understand why git doesn't create a tag when you rebase in case things go wrong, or more generally when doing potentially gc-able actions.
Pretending the average user will know how to get things back to how they are is silly."	Dayshine	8.5615425	-6.5100865	comment	4.0	29.0	1557503754	-11.849942
19880411	So what are the chances that a versi	So what are the chances that a version of Git, or something like Git, will be developed that is suitable for the average user? Someone above made a comment about how easy it is to do X in Git, and then preceded to write lines of Git commands that are as arcane as anything an alchemist could come up with. If that is easy Git, I'd hate to see what hard Git looks like.	irrational	8.553318	-6.4811463	comment	4.0	17.0	1557510898	-11.86574
19882174	Yes, it is lying.You can mitigate mo	Yes, it is lying.You can mitigate most of the damage if it is convincing enough (for example, go through B' and C' and make sure everything still makes sense at each point), but realistically nobody is going to do that, because it's pretty inefficient way to spend your time. And even then, you're still removing context (unless you're just fixing a typo).> I'm advocating that you use rebase to improve the quality of your changes that will be reviewed before merging or even before being reviewed at all.That was clear from the start. But the fact that X breaks Y doesn't imply that Y is a good idea when X doesn't apply.	Nullabillity	8.57117	-6.5701575	comment	4.0	25.0	1557521971	9.151797
19903281	Honestly I still find a lot of engin	Honestly I still find a lot of engineers don't know git properly. Like they know enough to commit and push but that's about it. It really helps to understand everything git has to offer.	augbog	8.547765	-6.4870424	comment	4.0	30.0	1557777453	-11.916731
19907153	Reading this article, I realize that	Reading this article, I realize that I'm old now. I still remember wrestling with cvs, svn. Merge, branch were slow and even more challenging. It was much easier to mess up and so difficult to rewind.When I first learned git, I thought it's pretty neat. It solves merge, branch, rewind problems. Git is one of the things in life that doesn't work like the way we think. But it turns out to be a better way.	dnprock	8.58789	-6.4966865	comment	4.0	97.0	1557814082	-11.893184
19907418	Git is ugly and daunting when you st	Git is ugly and daunting when you start with it, but as you get to know it you start to appreciate it's beauty and elegance and it will work for you. Actually I find this with many programming concepts.	teekert	8.547616	-6.484839	comment	4.0	36.0	1557817656	-11.894471
19907511	"> I don't get this ""afraid of losing"	"> I don't get this ""afraid of losing something"" mindset at all. In fifteen years, I've ""lost"" some minor changes maybe 3 or 4 times, and this was mostly with SVN, which does not have the safeguards that Git has. The only thing that I am moderately afraid of is pushing to the wrong remote branch.I can lose something for you in 2 seconds in git. Have fun e.g. recovering from this:  $ git init
  $ mkdir -p widget && echo Introduction > widget/readme.txt
  $ git add widget
  $ git commit -m ""Initial commit""
  $ echo Conclusion > widget/readme.txt
  $ git checkout widget
  $ cat widget/readme.txt  # No ""Conclusion""??"	mehrdadn	8.5631	-6.5183396	comment	4.0	25.0	1557818891	-11.879088
19907717	> Git is pretty nice, but I'm sure t	> Git is pretty nice, but I'm sure there is something much better waiting to he invented.It is indeed being invented. It’s called Pijul: http://pijul.org/This tool is based on strong mathematical theory of patches, instead of snapshot/commit-based. It seems simpler to reason with, but we’d have to unlearn a lot from Git.It’s not suitable for big projects yet, but it’s already used by Pijul itself and other Rust components. And it already have its own „Github” called the Nest (because pijul is a bird). Pretty promising imho.	batisteo	8.592662	-6.4904723	comment	4.0	22.0	1557822205	10.138349
19909568	> This tool is based on strong mathe	> This tool is based on strong mathematical theory of patchesIs this a good thing? What practical problems does a strong mathematical theory of patches solve that git doesn’t? And what’s the difference between a commit and a patch? Aren’t git commits stored as patches?I’m a math lover, but my gut reaction to that idea is that it sounds off-putting. I don’t mean that as a judgement or insult; I’m admitting my own assumption and bias here, jumping to unwarranted conclusion, not saying anything is wrong with pijul. But when the elevator sales pitch is “strong math”, it immediately makes me assume it’s too technical for a normal programmer and focused on academic ideals rather than getting practical work done as easily as possible.The FAQ even says, “Pijul is trivial for whoever knows category	dahart	8.59174	-6.5695896	comment	4.0	16.0	1557842857	13.9163065
15757195	> https://www.fossil-scm.org/index.h	"> https://www.fossil-scm.org/index.html/timeline?y=ci ... That is just a mess of unimportant info.That screen contains all and only the information I want to see.  (No surprise, since I wrote that screen.)  I would very much like to read more details from Xwattt about what he (or she) finds messy, unimportant, and inadequate about the timeline view of Fossil and to perhaps see examples of better presentations of development history.I wonder if Xwattt has tried clicking on two of the check-in circles in the graph from the link above, in order to get a diff between the two selected check-ins?  Is that information not useful?What of the filtering options in the sub-menu?  Is clicking on ""Files"" to see all the individual files changes in each check-in not helpful?Is clicking on a branch-name t"	SQLite	8.47524	-6.5778346	comment	4.0	12.0	1511362789	9.522434
15820865	He makes excellent points on tags; t	"He makes excellent points on tags; the one I hadn't considered before is that tags indeed can be separated from the tree, which makes them a unique asset in a git tree.The problem with that however is how we use tags today. Creating a tag in the modern lingua franca of git means creating a new version. If you push that tag to Github or Gitlab or what have you, a handy ""release"" will be created for you. If you're signing all your commits for some security reason, you don't want that, aye?So you'd want tags that are tracked separately and that's not easy to do. `git commit --sign` is going to include the signature in the commit, not create a separately-tracked tag with an appropriate name or whatever. It certainly sounds interesting, albeit unintuitive, and that summarizes git perfectly :)"	scrollaway	8.577894	-6.482975	comment	4.0	19.0	1512087113	-11.889952
15845619	I was wondering how serious this was	I was wondering how serious this was. I don't know a lot about how mercurial is developed, but https://twitter.com/indygreg/status/937527180292014080https://gregoryszorc.com/work.html> I am a significant contributor to the Mecurial open source version control system.> I serve on the Mercurial Steering Committee, which is the governance group for the Mercurial Project. I also have reviewing privileges, allowing me to accept incoming patches for incorporation in the project.So not sure, but it seems like at least one person on the team is into it?	steveklabnik	8.511055	-6.5487337	comment	4.0	18.0	1512408689	-11.974258
15847513	I am not sure if I wasn't clear.I ha	I am not sure if I wasn't clear.I have never worked for FB, so I don't know how internally FB handles this. But my understanding is, FB uses Hg for its main repository. However, FB has developed open source projects which most of them are published on Github, so for those development teams they work with Git. The question is, how do they reconcile some dev teams are context switching between hg and git? How common is that?Personally, I would allow one DVCS only, so my internal development platform doesn't have to support both Git and Hg (who knows, maybe FB also have teams using SVN for good reasons).	yeukhon	8.532321	-6.4729953	comment	4.0	19.0	1512421574	-11.92031
15848409	Such a petty and childish thing to b	Such a petty and childish thing to be upset by. If Mercurial is soo great, then surely nobody would switch to git. Mercurial's extensibility has served some people, but in large part people prefer to work with git today. If that's what constitutes a betrayal, I don't see how there was much of a relationship to betray.Mercurial, Bazaar, Darcs, CVS, and even Subversion are all now barriers to entry for a project. Git has won the vast majority of mindshare and good will by being straightforward, ubiquitous, and well supported.	microcolonel	8.504641	-6.5533805	comment	4.0	43.0	1512428650	-11.950737
15886155	"Perhaps for those familiar with ""fun"	"Perhaps for those familiar with ""functional data structures"" such an analogy is helpful but I find it easier to simply explain git for what it is without adding more exotic nomenclature to it.Git lets you do version control via full snapshots as opposed to just tracking diffs (even though it does actually do this too behind the scene).You can think of a full snapshot as saving a copy of your project structure every time you do a commit. The key trick is that git doesn't actually create new copies of the content for each commit but simply maintains a tree structure whose nodes are pointers (via hashing) to the content they represent.The complication from git is not in understanding the core concept but knowing how best to apply them. There are all sorts of crazy workflows you could implemen"	Edmond	8.589303	-6.5253167	comment	4.0	19.0	1512833044	10.276897
15886282	Git rebase alters the structures tha	Git rebase alters the structures that are relevant for me, like heads of named branches. In Haskell let bindings are immutable. To reference to the results one has to put them into new bindings. I.e. if Git was purely functional, the rebase would create new names for branches.	_0w8t	8.574333	-6.5875163	comment	4.0	14.0	1512834579	-11.919578
15889806	Could you please elaborate? I've onl	Could you please elaborate? I've only used svn and git, and the largest codebases I've worked on have only been about 150k lines of code.What are the other ones and the main differences, really curious	malux85	8.590864	-6.486903	comment	4.0	12.0	1512878400	-11.882023
15903721	wow.> I'm incredibly hesitant to try	"wow.> I'm incredibly hesitant to try any sort of complex git operation because of the risk that I might lose my in-progress commits.correct way of learning git is every time you want to use a ""complex""/dangerous commands in git, you `cd /tmp` and create a git repository there. then create some commits, branches and experiment. you will NOT lose anything, but you will learn a lot.I did and do this every time I have doubts. and with time you will understand how non-dangerous git commands are.""dangerous"" part comes from the user, not the software, and it is okay. when you accidentally kick a corner of a furniture, that does not make that furniture ""dangerous""."	popopopo	8.542675	-6.5061603	comment	4.0	23.0	1513064644	-11.978179
15903841	Here are the commands I use:git init	Here are the commands I use:git initgit clonegit checkoutgit commitgit commit -mgit commit —amendgit rebasegit add/rm/diff [—cached]git pushgit branchand a few more I can’t remember exactly.I try to keep my git workflow simple. The most complex is probably checkout abd rebase with several different branches.	yeukhon	8.570766	-6.547068	comment	4.0	23.0	1513066385	-11.902532
15919159	> People have even made up rationali	"> People have even made up rationalizations about fictional concepts such as ""historical purity"".The idea behind not rewriting history is not to gain some kind of academic pleasure from purity. It's to make sure that the commits being committed are actually the same ones that you actually wrote and (hopefully) found to be working, so that when a bug makes you refer to the commit later, you (a) don't start scratching your head as to why it didn't do what you thought you saw it do yesterday, and (b) can actually refer to it to figure out what the correct code should've looked like.If you don't see what I mean, here's an example. Say you have  foo():
      foo1()
      foo2()
      foo4()
      foo5()

and you turned it into this:  foo():
      foo1()
      foo2()
      foo4()
      foo5()
  "	mehrdadn	8.590995	-6.5452557	comment	4.0	19.0	1513213405	9.31612
15952066	If this is a guide for beginners, th	If this is a guide for beginners, there should be (more?) warnings not to do history rewriting operations on commits that have already pushed.	stygiansonic	8.581952	-6.553805	comment	4.0	14.0	1513609405	8.811908
15952121	> Oh shit, I accidentally committed 	> Oh shit, I accidentally committed to the wrong branch!I find cherry-picking to be easier in this case. Just checkout the branch and cherry pick commits from 'wrong' branch.https://git-scm.com/docs/git-cherry-pick	dkns	8.553233	-6.5439487	comment	4.0	18.0	1513609838	-11.893001
15952228	The very existence of such guides te	The very existence of such guides tells us a lot about how easy to use Git is :)	mamon	8.543403	-6.4775867	comment	4.0	17.0	1513610856	-11.87972
15952238	I've said this before, but the busin	I've said this before, but the business leadership, and tech leadership, need to think carefully about whether or not they need all of the power of Git. This sums up my concerns:-----------------------Here are some minor failure modes I’ve seen with Git:1. a branch that stays open for many months, perhaps even a year (for instance, at Maternity Neighborhood)2. data is erased for good because someone makes a mistake while using rebase3. a developer introduces a new bug while trying to resolve a merge conflict4. widespread but fine-grained cherry picking leaves the team unclear about what’s been merged and what has not been merged5. a developer makes a change in the wrong branch because they forgot what branch they were in6. a developer is unable to recover a stash because they forgot where 	lkrubner	8.571477	-6.5585046	comment	4.0	38.0	1513610958	-11.927917
15952498	My biggest issue with a GUI is that 	"My biggest issue with a GUI is that most that I've seen introduce new terms for various stuff, e.g. ""sync"" in VS Code, or ""revert commit"" (in Source Tree maybe?) — there's no Git command called ""sync"" or ""revert"", so I'm not immediately sure what they do.In a CLI I know exactly what's happening.That's just my opinion though. If people feel comfortable working in a GUI all the more power to them."	lillesvin	8.584547	-6.486642	comment	4.0	16.0	1513612795	-11.834048
15952322	My last git mistake was pretty terri	My last git mistake was pretty terrifying. I decided to try and go back to an old commit on a project on my local machine after about a days work. Somehow I ended up making the commit I wanted to revert to a new branch, then somehow tagged that branch with the name of the commit making git get angry and decide that branch wasn't valid. Then continuing in my ignorance I reset to that branch and tried to checkout only to watch my source and resource files vanish one by one. Deciding the commandline had caused enough trouble I returned to a qgit window I had open, all the source files were still there and I could at least save them one by one. Better refresh the qgit window. Oh shit now qgit's mad at me too. Well there goes thousands of lines of code and about 3 months worth of work. Eventual	grawprog	8.56394	-6.527142	comment	4.0	17.0	1513611713	-11.9137
15954308	You might want to try Sourcetree if 	You might want to try Sourcetree if you haven't already. I felt the same way about Git GUIs for a long time, but Sourcetree actually does a good job of getting out of my way, and has a very nice commit history tree viewer to boot.	nerdponx	8.572994	-6.4856205	comment	4.0	14.0	1513623724	-11.860037
16057214	The diff/merge tools shipped with Pe	The diff/merge tools shipped with Perforce are good.They can be used with git as well.	partycoder	8.734444	-6.476274	comment	4.0	16.0	1514938785	-11.741941
16107981	Git Exercises	Git Exercises	Aga	8.550579	-6.4822497	story	4.0	125.0	1515519549	-11.874614
16109332	This is actually pretty well done, b	"This is actually pretty well done, but I can't help but feel like the number of articles and documents trying to explain or teach git is a sign that the tool just has usability problems.Maybe I'm misremembering, but I don't remember people having so much trouble with svn.  With rcs and cvs, sure, and it was mainly stuff with breaking locks, moving files, and other BS that were part of the bad design.  With svn I remember the problems being: setting up the daemon (https vs svnserve+ssh), fixing a wedged Berkeley DB when that was still a thing, and getting hook scripts working right cross-platform.  With git, the common problem seems to be: ""what command am I even supposed to use here?"" and ""I broke it somehow and I don't know how to fix it.""  If the number of articles about it ever seemed t"	da_chicken	8.568593	-6.472341	comment	4.0	24.0	1515527733	-11.902273
17972014	Is there any good way to keep track 	Is there any good way to keep track of stashes? I keep stashing stuff that I forget about and end up rewriting 2 weeks later.	captn3m0	8.583883	-6.584287	comment	4.0	13.0	1536779211	-11.926303
18029877	"Having a local ""bare"" copy (to use G"	"Having a local ""bare"" copy (to use Git's term; `hg clone -U`) of the Mozilla repo, I'd like to create a checkout of it (`hg clone`), and build Firefox from it.This results in 90 minutes of waiting with hg pegging one CPU core (CPU-bound, not disk-bound!), then a few minutes of hg actually writing files, then the actual build taking 60 minutes.In the git community, it was always taken as a sign that they were doing something right that `git clone` was faster than `cp -r`.  I'm having a hard time not taking it as a sign that Mercurial is doing something wrong that `hg clone` is so much slower.edit: The saying was that `git checkout` is faster than `cp -r`, not that `git clone` is.  The sentiment stands."	LukeShu	8.550767	-6.475019	comment	4.0	20.0	1537419204	-11.8757105
18029941	Mercurial is much easier to understa	Mercurial is much easier to understand and use than git, and for the most part has feature parity with it. The only drawback was the decision to implement it in Python, which makes it very slow for large codebases with gigabytes in binary files. However, I'm given to understand that core performance parts are being re-implemented in C.	Annatar	8.516457	-6.5519705	comment	4.0	32.0	1537420430	-11.942851
18030168	The battle seemed to be between Baza	The battle seemed to be between Bazaar and Mercurial for so long. Both were easy-ish to use and both were written in Python.Mercurial usually had the speed advantage but then git came along and wasn’t written in Python. Speed wise it blew Bazaar and Mercurial out of the water.It was harder to learn for someone used to svn, perhaps, but the sheer weight of both Linus and Linux made it hard to ignore.I think GitHub deserve a lot of the credit for git’s omnipresence, though. With Launchpad our aim was to create something bigger than “just” a code sharing site and fairly or unfairly both Launchpad and Bazaar were seen as too close to Canonical. Whereas GitHub picked up the mantle that Sourceforge had dropped and made something way more collaborative than Sourceforge but held onto the idea of b	mprev	8.539553	-6.4653316	comment	4.0	17.0	1537424329	-11.885068
18032843	$99 for this?When there's git cli, m	$99 for this?When there's git cli, magit, fugitive (which you should be using if you're really really in need of a GUI (and which is also better than whatever the demo is showing))?I'm all for paying for your tooling if you can afford it but overcharging much?	isatty2	8.568813	-6.459084	comment	4.0	13.0	1537455183	-11.889844
18097377	Test && (commit || revert)?Or (test 	Test && (commit || revert)?Or (test && commit) || revert?	boffinism	8.618722	-6.543479	comment	4.0	14.0	1538171710	-11.943562
18126956	I think I agree with what the author	"I think I agree with what the author is saying, by and large, but it doesn't matter: if it's a mental model that works for you, you can live in the ""stacked diffs"" world right up until you need to ""curate"" all your commits into something that can be considered for incorporation into the parent project.Then you still need to make a branch, put all the related commits into it in order, and adequately test that branch before sumbitting it.At that point, if changes are requested, you can make a choice about whether to work by rebasing that branch, or work on your ""master"" branch and then re-curate those commits.  Now, working in the stacked diffs world seems like more work, but you do you.A place I disagree with the author is about rebasing frequently onto master.  Assume you are working in a "	jepler	8.583964	-6.5361094	comment	4.0	19.0	1538529309	-11.90722
18169091	Notes on using git-replace to get ri	Notes on using git-replace to get rid of giant objects	lainon	8.566027	-6.4958925	story	4.0	59.0	1539017849	-11.893723
18226951	Merges is the stupidest thing there 	Merges is the stupidest thing there ever is in the land of source control. Contrary to the author I struggle to find even a single use that would make merge merited.My main point is that merges are not easily computable. comm3 = merge(comm1, comm2) is not a kind of function you can run and see for yourself.  Instead it is a kind of hand wavy magic in which we declare that those two apples plus a lemon equals three mangoes. You throw the beauty of hash tree out of the window like an overdue christmas tree.	doombolt	8.738515	-6.4870014	comment	4.0	35.0	1539669535	9.218311
18230085	Mercurial doesn't have branches, rig	Mercurial doesn't have branches, right? That drove me bonkers when I was doing a bit of contract work after having used git for awhile.edit: They must have been using a different SCM; ignore me!	pavel_lishin	8.519733	-6.559971	comment	4.0	23.0	1539703291	-11.9620905
18230255	This only briefly touches on revert 	This only briefly touches on revert commits, and instead shows a lot of (in my opinion) dangerous history-destroying commands.Why aren't reverts more widely used? It seems a lot of devs I've worked with don't understand them, and to me they seem so simple and are so much safer than destroying/rewriting history.	Klathmon	8.581276	-6.55132	comment	4.0	16.0	1539704563	-11.903785
18230993	>It could very usefully try harder t	>It could very usefully try harder to avoid getting into that state in the first place.Am I missing something here? How do you get into a detached HEAD state without explicitly taking an obviously weird action, like finding and checkout out a commit hash instead of a branch, and why would it make sense for git to not be in a detached HEAD state should you do that?	annabellish	8.551868	-6.529849	comment	4.0	12.0	1539709105	8.972012
18230454	It’s basically a manifestation of pr	It’s basically a manifestation of programmer arrogance that they’re just too damn smart to encounter a software learning curve again.Ever sat through user training on microsoft office? How to use email?  The weird one-off enterprise apps that nobody else has ever heard of?They’re unbearably tedious to users that can get by in a new tool with a 5 minute crash course, intuition and light googling.Then git shows up and has the audacity to ask professionals to learn its mental model.Once you do the interface isn’t great, but not particularly esoteric. The problem isn’t that users see dense-sounding things like “directed acyclic graph of revisions”, it’s that they assume they can competently manipulate one without knowing what that means.I do think the interface could use cleanup, but can any a	finnthehuman	8.547558	-6.5004044	comment	4.0	20.0	1539705833	-11.91095
18250513	Just hopping on this thread post for	"Just hopping on this thread post for a shameless plug:https://github.com/Detry322/git-psuhWhy make errors do the thing you want, when you can make them do things you don't want? ¯\_(ツ)_/¯Carpenters have ""measure twice, cut once"", since there's risk involved with a mistake. Let's make mistakes risky."	Detry322	8.563091	-6.4934554	comment	4.0	16.0	1539885441	-11.8521805
18268760	This is a really great explanation, 	This is a really great explanation, and I appreciate you taking time to share in such depth.One question I have is on version control. I understand the value of reference images and release images and debugging images (with a rare bug front and center) and so on. Would this play well with diffing as I am familiar with it from a carpentry perspective, e.g git diff?Would you serialize and dump a set of source code from an image? Would you build the reference image from a source code project and manually handle the consistency between source files and images?I know it's a vague multi-question, but I hope you understand what I'm getting at, and I would really appreciate learning more about this style of development.	greggyb	8.692917	-6.4654274	comment	4.0	13.0	1540139433	9.453463
18552417	Subversion vs. Git: Myths and Facts	Subversion vs. Git: Myths and Facts	rusk	8.571989	-6.452404	story	4.0	2.0	1543420087	-11.878302
18617653	This is based on a false premise, th	This is based on a false premise, that the Govt will ask developers, and that they would care if it is difficult/infeasible/impossible to actually complete.In reality, they issue a notice to the company, give them a timeframe, and expect it to be done. They don’t care about the intricacies of git.	vermilingua	8.54466	-6.4926534	comment	4.0	30.0	1544101432	-11.907297
18620787	amenpeople look at me like I'm an ol	amenpeople look at me like I'm an old crazy dude because I don't use a git UI or eclipse, or intellij, or from sublime. Git already has plenty of quirks, adding another layer of unknown on top of it is a no-go	bassman9000	8.55005	-6.5012035	comment	4.0	21.0	1544121716	-11.876297
18624956	> > Avoid trailing whitespace.> This	> > Avoid trailing whitespace.> This is one of the stupidest things to automate. Unlike indenting, removing trailing whitespace simply produces diffs where it doesn’t matter. And does nothing more.I suppose formatting is a weak point for version control systems, but I think that is all the more reason to get rid of trailing whitespace. The more your code is clean of ambiguous formatting, the less it will change between commits.	thomastjeffery	8.617104	-6.531636	comment	4.0	12.0	1544153959	-11.884857
18641684	Git v2.20.0	Git v2.20.0	jjuhl	8.53908	-6.4388375	story	4.0	93.0	1544373380	-11.900429
18649416	Git v2.20.0	Git v2.20.0	conductor	8.537626	-6.437493	story	4.0	71.0	1544462311	-11.884676
18920274	Here is my personal recommendation f	"Here is my personal recommendation for getting more comfortable with git. Use ""git status"" a lot. Everytime you do something in git, and before you do something, do a ""git status"" and see what you change with your commands. And what you didn't change.Also ""git log""."	cyborgx7	8.561605	-6.4888477	comment	4.0	43.0	1547642305	-11.877271
18920312	So I have a solid mental of git, and	So I have a solid mental of git, and I understand the theoretical  need for the staging area.However, I find the occasions for using the staging area in practice are few and far between, for the simple reason that I can't test and execute the code that's in the staging area without also having the code from the working directory also be there. It feels like after having partially staged some of my working directory, it would be a blind commit with no guarantee that things are working.Very rare is the situation that I can break out a list of files over here that are for feature A and some over there for feature B, and never the two shall interact.I think this is probably what most struggle with regarding the staging area, without being able to articulate it.	JediWing	8.700949	-6.578482	comment	4.0	33.0	1547642640	-11.922047
18921633	You never amend commits or rebase lo	You never amend commits or rebase locally before pushing? I rebase before pushing almost every time.Git’s workflow wouldn’t even be sane without the staging area. This is what allows you to fix mistakes and make your work presentable for remotes.	dahart	8.569108	-6.5675097	comment	4.0	16.0	1547652683	-11.906498
18921649	This has never made sense to me. I'v	This has never made sense to me. I've seen others say that they commit only parts of a file. How does this scenario start? Are you working on solving one problem, but then notice some other unrelated issue and fix that too, before committing the first change?	url00	8.603397	-6.5294805	comment	4.0	16.0	1547652813	-11.897696
29767380	Well there must be 20 years worth of	Well there must be 20 years worth of backups. I wonder whether there is a way to turn 20 years of zip files storing different versions into a git repository, using the dates of the zip files, the dates of the files inside and perhaps the name of the zip files. Bonus points for detecting branches.	ant6n	8.570365	-6.443892	comment	4.0	12.0	1641117909	-11.85817
29775764	Kudos to getting this out. I can't i	Kudos to getting this out. I can't imagine working on a series of patches for 2 years for build cleanups/speedups on a separate branch, having to periodically rebase against master and throwing away my work 3 times in order to figure out how to do it correctly. At any company I have worked for, I would have been fired for being unproductive/afraid of making changes.	yrral	8.626013	-6.5069385	comment	4.0	32.0	1641169496	-11.867066
29840385	Fixing up merge conflicts multiple t	Fixing up merge conflicts multiple times when rebasing is indeed a huge pain (has anyone actually used git rerere? If I ever find myself in this situation I always just squash first instead.)However I typically squash by just doing a soft `git reset` to the merge-base (the last commit in common with my branch and the one I'm building my work from) and making a new commit.  It avoids touching the working tree at all, which avoids breaking my build cache and confusing my IDE.If I instead want to do a squash-rebase onto the _latest_ of the upstream branch, I do the same as the above, except I `git merge` first (to resolve any merge conflicts in one shot.)  Then the merge-base is just the upstream head.  This is way easier than doing `rebase -i` and squashing, because you don't have to fix the	ninkendo	8.560474	-6.5912366	comment	4.0	14.0	1641570117	-11.928314
29841010	10+ years and I still don’t understa	10+ years and I still don’t understand why developers and orgs think it’s necessary to squash and rebase.	unicornmama	8.582828	-6.537099	comment	4.0	19.0	1641572663	9.334467
29871106	Autosaved: A Go utility for autosavi	Autosaved: A Go utility for autosaving progress in Git projects	nikochiko	8.572156	-6.47968	story	4.0	44.0	1641793681	-11.895922
29876138	I also had that moment; ask “Who wro	I also had that moment; ask “Who wrote that shit?”, run ‘git blame’ and find yourself. This happened 1 year into my second job.	sshine	8.547081	-6.4776826	comment	4.0	17.0	1641827977	-11.900681
29883197	Eh, I'm not sure I agree.What has go	Eh, I'm not sure I agree.What has gotten me the most value is having either the branch or the commit message tie back to a ticket somewhere. -That- has the original bug, the comment thread that led to the decision around why this particular fix, any additional comments around tradeoffs we were aware of, and what other options we dispensed with, etc.A well written commit message might explain what the issue was, but it won't have anywhere near the context the ticket and resulting comment thread should have.	lostcolony	8.621795	-6.523248	comment	4.0	19.0	1641851537	-11.92723
29979097	Understanding what git is doing unde	"Understanding what git is doing under the hood did more for my ability to use it effectively than it did for most tools.That said, this document in particular does not seem to be a very good way to get that understanding, it's a very ""IBM documentation"" way of presenting git. I wish I remembered what I read, because it's was a much easier read."	delecti	8.537478	-6.4796014	comment	4.0	13.0	1642514148	-11.898662
29979954	Quick tip: Git branches are cheap. L	Quick tip: Git branches are cheap. Like super-cheap. IF you want to create a safe point just before doing a tricky merge, just spin off a new branch pointing at the current commit:git branch blah_branch_backupLater, if your merge gets completely messed up, you can do:git merge --abortgit reset --hard blah_branch_backupThat final command will restore the current branch's HEAD to point to the same commit as blah_branch_backup.This same pattern is useful for other dangerous commands, like rebases or filter-branch.When you're done, just delete blah_branch_backup.	balefrost	8.584933	-6.551306	comment	4.0	18.0	1642517419	-11.908616
29992480	I am not saying git is flawless but 	"I am not saying git is flawless but most complaints seem to be about the ""porcelain"" and not its inherent design. I think Git tremendously outgrow the original audience so a larger proportion of people complain.Complaining about the porcelain is like complaining about vim's complexity: It takes some time to master but ultimately it is rewarding."	jhoechtl	8.540654	-6.4961324	comment	4.0	15.0	1642593127	-11.923173
30009667	Another lesson I learned from almost	Another lesson I learned from almost 2+ decades of using Emacs:Track your customizations in a version control. Using customize package and reading the diff in dot Emacs file has taught me quite a bit about certain aspects of the package.Side note: It would be awesome if Emacs could do the versioning as part of saving the customizations - build Emacs with libgit2 and make it a native git client.	0xdky	8.622752	-6.4620843	comment	4.0	14.0	1642690744	-11.798433
30069822	For anyone not using `merge.conflict	For anyone not using `merge.conflictStyle = diff3` I highly recommend trying it. It removes a lot of ambiguity when dealing with conflicting changes.And now they introduced `zdiff3` which looks even better, will be trying it once I update.	tomthecreator	8.705485	-6.498858	comment	4.0	22.0	1643101821	9.158996
30113043	If I was in the position of having t	"If I was in the position of having to review that PR, I would probably flat-out reject it and ask for just the minimal changes required.I don't see how adding an additional capture framework backend would require meaningful changes to the build system.With some likelihood, in this case, Apple probably won't have the resources to rework their PR and thus the PR will stay un-merged until somebody of the project has time to merge/reimplement the relevant parts.Which of course is a total shame and I wonder why Apple didn't have ""mergeability"" in mind when they decided to create their PR. They must have known that ""rework the build system"" can't be part of a PR adding a capture backend if they wanted any chance of this being merged."	pilif	8.626156	-6.462888	comment	4.0	14.0	1643367039	-11.867645
30163324	Ask HN: GitHub Download Hash Change?	Ask HN: GitHub Download Hash Change?	j1elo	8.731361	-6.498319	story	4.0	13.0	1643727676	-5.527496
30193276	Branch off of main	Branch off of main	roncohen	8.55251	-6.5377207	story	4.0	41.0	1643900573	-11.789865
30254471	It's a dreadfully common story: some	It's a dreadfully common story: some ugly hack which was necessary at the time persists for decades (or centuries, in the case of legal/social systems), because nobody can really be bothered to change it.The extra file size is not much of an issue, but it does mean we still require stupid workarounds with Git and anything else that needs to handle cross-platform plaintext.	TillE	8.575692	-6.4439344	comment	4.0	21.0	1644289399	-11.870196
30257885	I've wondered about this many times 	"I've wondered about this many times -- your conversion is a one-way street, right?Let's say you have your source material in MD stored in Git, convert it to docx and send it to your client. They use Word to make annotations and revisions and send it back to you. Now what? How do you get this back into MD and your Git repo? Of course you can do this by hand, but that's terrible work. It certainly is worse than staying in the Word ecosystem and flying with it. Not that I'm advocating this, but I don't see how ""backporting"" their proposed changes into some local Git branch in MD scales.So, I'm curious about your solution to this."	wildmanx	8.628156	-6.4748516	comment	4.0	13.0	1644325609	-11.770681
30275295	I just created a new repo with just 	I just created a new repo with just a master branch. Where does Github force anything?They're sure suggesting it - their suggested commands to initialize a new repo will create a main branch. But you can just ignore that suggestion?	Grollicus	8.510002	-6.490688	comment	4.0	17.0	1644427541	-11.777109
30313942	Lots of confused beginners in this t	Lots of confused beginners in this thread. IMO diagrams, and tutorials, that take this approach to teaching git are the reason people have such a hard time. After learning the very basic commands, the next step is to learn the internal data structure of git at a conceptual level. This may seem like a bad design to some, and that is a reasonable thing to debate. It doesn’t change the reality that knowing basic git internals makes git much easier to use.	Skunkleton	8.529324	-6.4814415	comment	4.0	14.0	1644683135	3.7985244
30336228	My biggest bugbear with these tools 	My biggest bugbear with these tools is poor git support. If someone dragged and dropped their way through the UI, I want to be able to reliably commit that to a branch and recover to it using standard git workflows.Most don't do this, or do it in such a brain-dead way that I am forced to use a branching model that is all wrong (eg a branch for each environment)	bradwood	8.569822	-6.5194025	comment	4.0	13.0	1644864133	-11.909711
30336441	While I have learned to be mostly co	While I have learned to be mostly competent when it comes to git day-to-day tasks, I still miss hg for it's clean interface design and simplified workflow.	btreecat	8.527431	-6.511241	comment	4.0	25.0	1644864828	-11.92401
30399587	Wow, this scratches a lot of my itch	Wow, this scratches a lot of my itches about Git. I teach a Git course at my alma mater, and the things that confuses people the most (the index, how to undo mistakes etc etc) all seem addressed head-on. At first glance, this seems substantially easier to teach than Git.The Git compat seems like a great idea for this to really take off. My team is totally PR based though so if/when doing (Git compatible) feature branches lands in JJ I'm excited to switch.	skrebbel	8.543437	-6.4981318	comment	4.0	26.0	1645297640	-11.8929
30400076	What is the advantage of using workt	What is the advantage of using worktrees over another checkout in another folder?	CorrectHorseBat	8.611161	-6.553951	comment	4.0	19.0	1645301432	-11.907903
30400835	Surprise limitation: you cannot have	Surprise limitation: you cannot have two worktrees set to the same branch, or at least that confronted me when I tried it.	pjc50	8.590006	-6.5235243	comment	4.0	15.0	1645307178	-11.878602
30400776	In git you can reorder any sequence 	"In git you can reorder any sequence of commits without any conflicts. Howwever, there is no nice ""porcelain"" for it.The basis for it is the read-tree command.In git, every commit is a snapshot and not a delta. (Repeat that three times.)Any arbitrary snapshots of files can be arranged into a git history. They don't even have to be related. We could take a tarball of GCC, and make that the first commit. Then a tarball of Clang and make that the second commit.The read-tree command will read any commit's state into the index, and from there you can make a commit out of it.To reorder some N commits you're looking at, save all of their hashes somewhere, and then rewind the branch: git reset --hard HEAD~N.  Then use git read-tree to read those hashes in whatever order you want, committing them on"	kazinator	8.579787	-6.5278826	comment	4.0	20.0	1645306725	7.3461304
30462096	What does git or Perforce have to do	What does git or Perforce have to do with refactoring? Why would whatever version control you're using matter?> tools for mass renaming that try to guarantee that there are no regressionsbeyond sed or whatever a fancy IDE already does? What kind of voodoo magic are we talking about here? Did Google solve the halting problem and I just haven't noticed yet...	deckard1	8.578441	-6.513629	comment	4.0	19.0	1645747374	-11.853431
30464074	When there are hundreds of branches,	"When there are hundreds of branches, not just feature branches but real long-lived development branches, and pull requests are managed the way they are in the Linux kernel (chain of trust all the way up to Linus).. ""Do the mass replace"" becomes quite non-trivial I imagine."	slimsag	8.58817	-6.5334377	comment	4.0	14.0	1645768106	-11.895293
30500583	Surprised no one mentioned git. Made	Surprised no one mentioned git. Made over the course of a single week by Linus Torvalds,	nafey	8.572081	-6.451726	comment	4.0	41.0	1646060828	-11.873179
30523914	I once thought git for humans would 	I once thought git for humans would be a great idea but never got around to speccing it out. Later on, a lawyer friend showed me the software they used 'for backup' (that they paid thousands per month for) and it turned out everything about it was just exactly like SVN. The terminology was different, the UX was laser focused to the intended users, but at the end of the day it was commits, syncs, merging, pretty much everything but branches, just laid out with domain specific language instead, professional office UI and simple UX.So, uh, yeah I agree absolutely with you.	phreack	8.569636	-6.462916	comment	4.0	20.0	1646197048	-11.864907
30566698	Sometimes, yes.But I never worked in	Sometimes, yes.But I never worked in a big professional team before, where git's features shine.And git != code formatter.	wheelerof4te	8.566634	-6.4731402	comment	4.0	12.0	1646481331	-11.909588
30583317	git. Even if I understand the codeba	git. Even if I understand the codebase well, I always manage to get my working branch into a merge conflict.	perrygeo	8.584843	-6.507441	comment	4.0	13.0	1646617870	-11.884162
30588341	I might have sounded harsh but I thi	I might have sounded harsh but I think shit happens is not the way to look at this. Don't claim I'm a better developer, but I always try to shy away from making things look nicer.Experience have thought me, deal with problems when it is a problem. Dealing with could be problems can be a deep, very deep rabbit hole.The commit message gave me the feeling that we should have just trust the author.https://github.com/torvalds/linux/commit/f6dd975583bd8ce0884...	dncornholio	8.580208	-6.4500694	comment	4.0	18.0	1646664032	-11.889815
30712569	Everyone absolutely should configure	Everyone absolutely should configure that. (Git config pull.rebase true.)Such an annoying mess it leaves otherwise. And CI is building 'merge branch master', on the master branch, great.	OJFord	8.615333	-6.550706	comment	4.0	16.0	1647532638	-11.879001
16266704	Why Beginning Programmers Should Use	Why Beginning Programmers Should Use “Git”	javascriptworks	8.543148	-6.4775414	story	4.0	17.0	1517330554	-11.896741
16309703	> If the state was concurrently chan	> If the state was concurrently changed on different devices, Automerge automatically merges the changes together cleanly, so that everybody ends up in the same state, and no changes are lost.> Different from git: no merge conflicts to resolve!This is impossible unless there are significant restrictions on what kind of operations are possible.If I have a bag of 15 apples, and I take 10 of those apples at the same time as somebody else takes more than five apples then we have a merge conflict right there because we can't end up with a negative amount of apples in the bag.	bringtheaction	8.694988	-6.5051723	comment	4.0	44.0	1517847360	-11.853295
16515656	I don't know man, but look at @pixiu	I don't know man, but look at @pixiuPL's commits https://github.com/ariya/phantomjs/commits?author=pixiuPLEspecially his own commits (non-merge commits)	rilut	8.573531	-6.453678	comment	4.0	18.0	1520186669	4.3988605
16532001	The Linux kernel has been developed 	The Linux kernel has been developed over 25 years by thousands of contributors, so it is not at all alarming that it has grown to 1.5 GB. But if your weekend class assignment is already 1.5 GB, that’s probably a strong hint that you could be using Git more effectively!Git is only 12 years old, how does Linux have 25 years of history there? As far as I know Linux used patches on mailing lists before git, are those also somehow transferred to the repo?	pandem	8.572157	-6.4407372	comment	4.0	17.0	1520369457	-11.851571
16572614	We were introduced to version contro	We were introduced to version control in our first year. The only problem was that till we started managing large code bases, most people found it very difficult to understand why we used Git in the first place.	arjo129	8.570646	-6.475927	comment	4.0	18.0	1520897153	-11.881203
16587325	Git comes down to knowing 6 commands	"Git comes down to knowing 6 commands... and you don't need to even need to be an expert with all 6. If can grasp the following 6 commands, you will know about 99% of every day uses of git:git add .git commit -m ""my commit message""git merge my_feature_branch | or my personal favorite: git merge --squash my_feature_branchgit rebase my_feature_branchgit loggit checkout -b my_feature_branch"	thrownaway954	8.571155	-6.5477743	comment	4.0	15.0	1521053932	-11.904855
16587448	"git commit -a -m ""Commit"" && git pus"	"git commit -a -m ""Commit"" && git push90% of the time, all you need :)"	friedButter	8.570125	-6.4946594	comment	4.0	14.0	1521054767	-11.915963
16587584	I think the problem is the arcane in	I think the problem is the arcane interface and documentations. The verbiage in the documentation is unnecessarily difficult if not a computer science major.I agree The Git Book is by far the best way I have found to learn it but the commands remain . I imagine they are some kind of balance between what operations are useful day-to-day and what is possible in respect to the program design but they fail so often because they have almost no consideration for interface design.I just wrote a script for determining which files are ignored by .gitignore in a repository and the solution I arrived at is nothing short of painful to think about. It is ugly, anything but intuitive and impossible to build a test for. What is the excuse for this?	gt_	8.57658	-6.4844737	comment	4.0	13.0	1521055882	-11.862641
16588053	why isn't `git log --oneline --decor	why isn't `git log --oneline --decorate --all --graph` the default behavior of `git log`? It makes things so much easier to understand IMHO.	bowmessage	8.57435	-6.5015335	comment	4.0	17.0	1521059600	-11.89496
16613142	How to avoid merge conflicts	How to avoid merge conflicts	dudzik	8.734657	-6.480916	story	4.0	15.0	1521395118	9.234282
16650440	Gitlab's CI/CD is amazing. Of all th	Gitlab's CI/CD is amazing. Of all the systems I've seen, it's the easiest to (a) deploy your own runners easily, and (b) mix private and public runners (i.e. the equivalent of using a free plan on Travis, with the benefit that for heavy-duty jobs you can run your own machines). That and first-class support for docker (no more being at the whims of what Travis chooses to deploy in their images), make it a really great system.But we had been on Github, and that turned into something of a pain.First we tried mirroring Github to Gitlab. This worked, but (a) it added a minute or two of latency to starting jobs in the CI, (b) since it went through one account, all the build emails went to a single person, and (c) the mirroring happened on our own infrastructure, which turned out not to be so rel	eslaught	8.494404	-6.440256	comment	4.0	23.0	1521737901	9.011962
16650664	This is great, although I'll probabl	This is great, although I'll probably stick with Travis & Appveyor for my open source project since Gitlab.com currently only has Linux runners.All three currently have two big flaws IMO though:1. They all use YAML which is an awful, unintuitive format.2. The only way to test a configuration is to commit it and push it. Why is there no way to paste a config file in their website and run that?Hopefully one day we'll get a CI system that supports Windows, Linux and OSX and has a sane config format, and free minutes for open source projects. A man can dream!	IshKebab	8.696182	-6.4373207	comment	4.0	15.0	1521739153	9.009611
16662221	I think the next step from here is g	I think the next step from here is giving the ability to assign maintainers for certain sets of files (in this directory or matching a particular regex) and then when a pull request comes in, GH can looked at the changes, match the maintainers, and require all of them to sign off prior to allowing merging.	haneefmubarak	8.635981	-6.4921083	comment	4.0	13.0	1521835842	-11.900947
16698143	At GitLab we're making the applicati	At GitLab we're making the application ready for Kubernetes, we have not switched yet. It required us to untangle many parts. For example we used to store uploads on disk before moving them to object storage, now it goes directly to object storage. There where many interactions between our applications https://docs.gitlab.com/ee/development/architecture.html#com... over disk or sockets that we need to clean up.When its done we expect to be able to scale the different parts of our application independently. This also makes it easier to detect problems (why did Gitaly suddenly autoscale to twice the number of containers).	sytse	8.538419	-6.5381784	comment	4.0	18.0	1522249020	-12.189131
16705226	"""Every branch of every repo gets its"	"""Every branch of every repo gets its own sandboxed directory. Your revision history in each branch, including uncommitted stuff, is persisted, as are build artifacts. When you switch contexts, each project is just as you left it.""Isn't that just svn? Why force a git-shaped peg into an svn-shaped hole?"	Finster	8.553256	-6.487078	comment	4.0	15.0	1522308785	-11.877144
16711303	"""Sir, we have reviewed your git comm"	"""Sir, we have reviewed your git commit history of the last 5 years and come to the conclusion that you would be gravely endangering the code quality of this country."""	elcapitan	8.553339	-6.461214	comment	4.0	14.0	1522359551	-11.87454
16768454	If possible, you should use your VCS	"If possible, you should use your VCS's native tool for applying patches, not patch(1). Otherwise, you risk that the patch will mess with the repository internals.For example, this patch compromises git repositories when applied with patch(1):  --- a/.git/config
  +++ b/.git/config
  @@ -0,0 +1,2 @@
  +[core]
  +	pager = cowsay"	jwilk	8.6058	-6.500555	comment	4.0	15.0	1522959186	-11.872414
16806268	Good list, but I feel like they bury	"Good list, but I feel like they bury the lede: integrated wiki, issues, and notes. That doesn't scale to every project (linux kernel for example), but for a lot of projects it's really cool.Other selling points from the Fossil site:* Integrated Bug Tracking, Wiki, and Technotes* Built-in Web Interface _and_ Self-Contained (I combined these)* Simple Networking (no git://, just HTTP and SSH)* CGI/SCGI Enabled* Autosync - ""Fossil supports ""autosync"" mode which helps to keep projects moving forward by reducing the amount of needless forking and merging often associated with distributed projects.""* Robust & Reliable - ""Fossil stores content using an enduring file format in an SQLite database so that transactions are atomic even if interrupted by a power loss or system crash. Automatic self-chec"	wiremine	8.503897	-6.5145597	comment	4.0	15.0	1523400139	-11.943351
16806524	As branch names are not recorded in 	As branch names are not recorded in commits, it is pretty much impossible to say what commit was next in a branch.	chx	8.567912	-6.5373964	comment	4.0	15.0	1523402137	-11.90602
16806781	>and bitkeeper, now open source at b	>and bitkeeper, now open source at bitkeeper.orgAnd no one cares about it. For a reason.>Git has no file object, it versions the repo, not files.Which is the correct thing to do.>if you have a graph per file (like BitKeeper does).Which is insane to do because you're basically making things more complex than they need to be, which is why merging in git is not only SUBSTANTIALLY faster than nearly every SCM out there, it also works a good deal of the time without issue.>No file object means no create event record, no rename event recorded, no delete event recorded.Most people do not need these. If you're going to choose to use file GCA's for the reasons listed above then you better have a damn fucking good idea of how much these features are actually used, because the trade offs are ENORMOUS	kadenshep	8.580681	-6.496771	comment	4.0	28.0	1523404087	-11.896344
16806485	Nope. A branch in git is just a poin	"Nope. A branch in git is just a pointer to the tip of the branch:   $ cat .git/refs/heads/master
   170ec1365f9fc0ca281e72e6789d1df281d168ae

From it, you can infer the commit history which gitk shows, but if you delete the branch (and discard the reflog), it's gone.In Fossil, each check-in (commit) actually records the name of the branch it belongs to: http://fossil-scm.org/index.html/doc/trunk/www/fileformat.wi..."	dchest	8.538145	-6.556179	comment	4.0	31.0	1523401840	-11.890368
16807039	"> The ""index"" is a silly dongle in G"	"> The ""index"" is a silly dongle in Git.Everyone thinks that until they need to use it for something.  If all you do is a bunch of linear small changes with obvious implications and two-line commit messages, then the index is nothing but an extra step.But at some point you're going to want to drop a thousand-line change (from some crazy source like a contractor or whatnot) on top of a giant source tree and split it up into cleanly separable and bisectable patches that your own team can live with.  And then you'll realize what the index is for."	ajross	8.565546	-6.5260615	comment	4.0	41.0	1523406865	-11.911141
16807171	You're talking to the guy that creat	"You're talking to the guy that created that concept [1].  I get that changesets are cool :)  You're right, you do want to see all that info together.But lots of times you want to look at the file view, find the line of code that looks like the problem, and then zoom out to the changeset.  BK makes that trivial, Git makes that miserable to impossible.[1] Actually there was a little known system, Aide-de-camp, that one of my people told me about that had changesets so I didn't invent it, but I reinvented it.  And made the world aware of the concept.  Back when you could search Usenet via dejanews you could search for ""changeset"" and date limit it to before me talking about it.  There were maybe 5 hits.  A few years after BK came along there were 100's of thousands of hits.  So I wasn't first"	luckydude	8.5918045	-6.4660034	comment	4.0	19.0	1523408421	3.8775115
16807427	"At what point do you test these ""cle"	"At what point do you test these ""cleanly separable"" and ""bisectable"" patches?  Do you do a second pass where you check out and build/test each of these commits?"	sigjuice	8.642903	-6.5429225	comment	4.0	26.0	1523411696	-11.892968
16807530	The whole point about abstractions i	"The whole point about abstractions is you shouldn't need to understand the internals to use them. If the best defense of git is ""once you understand the inner workings, it's so clear"" then it is by definition a poor abstraction."	johnfn	8.562412	-6.5021544	comment	4.0	37.0	1523412952	-11.919768
16808704	Why would you call branches ref's? T	Why would you call branches ref's? They don't point to specific files or commits.I know you can target commits through them - which utilizes the ref syntax... But they're still not really referencing anything directly.They're completely arbitrary and are just a feature to improve gits workflow.	y4mi	8.565541	-6.526471	comment	4.0	21.0	1523429943	-11.9323225
16839592	I wish there was some post in the sa	"I wish there was some post in the same vein as ""Repository Formats Matter"" comparing Git and Fossil. I.e. not one that describes differences in incidental UI features and how they happen to be exposed to the user now, but what the intrinsic differences are that make certain things intrinsically hard or impossible in one of the two systems.That old post, by Keith Packard: https://keithp.com/blogs/Repository_Formats_Matter/I've read through the documentation on the Fossil file format: https://www.fossil-scm.org/index.html/doc/trunk/www/fileform...Maybe I'm just being dense, but e.g. in the case of the wiki which Fossil advertises as a core feature over Git, it's not clear to me how it wouldn't be implementable in a similar way in Git by some convention of creating commit objects & having som"	avar	8.498372	-6.557299	comment	4.0	19.0	1523740990	-11.938076
16979311	Mercurial's startup time is the reas	Mercurial's startup time is the reason why, for fish, I've implemented code to figure out if something might be a hg repo myself.Just calling `hg root` takes 200ms with hot cache. The equivalent code in fish-script takes about 3. Which enables us to turn on hg integration in the prompt by default.The equivalent `git rev-parse` call takes about 8ms.	faho	8.513656	-6.5561805	comment	4.0	17.0	1525282735	-11.928469
17085805	It's really strange to me that nowad	"It's really strange to me that nowadays source control seems to be, largely, a monoculture. Back in the day I either used, or knew plenty of people using any of CVS, Subversion, Sourcesafe, Sourcegear Vault, Perforce, AccuRev, ClearCase, along with a few others.Whilst distributed version control is a huge leap forward over many of those older systems, it's odd that nowadays it seems to be git or, well, nothing. I'm surprised Mercurial hasn't made more headway than it has.But maybe git is just ""good enough"" for most people? I suppose that's where I land on it. It has it's frustrations, like anything else, but I can live with them."	bartread	8.57632	-6.461045	comment	4.0	20.0	1526499943	-11.880969
17103353	"For all the ""big"" Google projects th"	"For all the ""big"" Google projects they use a proprietary system called piper.I think all their open-source stuff (Angular, GoLang, Android) uses git (and sometimes Gerrit).Although given Google's scale, I'm sure there's some teams/projects that use Mercurial."	seabrookmx	8.501689	-6.465957	comment	4.0	26.0	1526665196	-11.920306
17132484	"I prefer having the ""why"" in commit "	"I prefer having the ""why"" in commit messages than in comments, unless it's something really screwy and needs a big warning right there.""How"" though, very much e.g. reference to the algorithm being implemented or the like if the code is unclear."	masklinn	8.58221	-6.5129476	comment	4.0	28.0	1527066490	-11.897443
17246947	"    We prefer patch-based workflow.
"	"    We prefer patch-based workflow.
    It makes Git history pretty.

What is wrong with the feature branch approach? Before you merge a feature branch, you can squeeze all its commits into one. That leads to a pretty history too."	TekMol	8.593701	-6.5403104	comment	4.0	16.0	1528291614	-11.919208
17246221	Pointing out flaws without detailing	Pointing out flaws without detailing them isn't very useful.Arcanist is not a Git wrapper - you can (and should) use Git normally. All Arcanist does is automate the process of creating and uploading patches, and applying remote patches.	lima	8.561626	-6.479863	comment	4.0	12.0	1528286132	-11.896516
17271345	Is using mercurial+bitbucket instead	Is using mercurial+bitbucket instead of git+GitHub limiting my contributors?	doubleunplussed	8.516367	-6.545472	story	4.0	4.0	1528514578	-11.921616
22833203	Just don't forget that Fossil does n	"Just don't forget that Fossil does not support rebase/amend, on principle. 
So if you want both ""commit very often"" and ""have nice, readable commits with clear descriptions"", it is not for you."	theamk	8.5057125	-6.563967	comment	4.0	39.0	1586528053	9.53454
22833392	You can't change history.In a versio	You can't change history.In a version control system, this is axiom 0.	thunderbong	8.635968	-6.4957843	comment	4.0	18.0	1586529239	-11.784516
22854088	https://fishshell.com/ for sureJust 	"https://fishshell.com/ for sureJust having sensible defaults on a shell works wonders on my day-to-day productivity.Add a couple of aliases for productivity and off you go.  abbr --add s ""git status""
  abbr --add gap ""git add --patch""
  abbr --add gco ""git checkout""
  abbr --add gd ""git diff""

  alias recent=""git for-each-ref --sort=-committerdate refs/heads/ --format='%(color:yellow)%(refname:short)|%(color:bold green)%(committerdate:relative)|%(color:blue)%(subject)%(color:reset)' | column -ts'|' | tac""
  alias r=""recent"""	macobo	8.593391	-6.5230184	comment	4.0	12.0	1586766688	-11.860455
22924786	Patterns for Managing Source Code Br	Patterns for Managing Source Code Branches	caution	8.591098	-6.5139084	story	4.0	98.0	1587396871	-11.892557
22938186	> ignores files matching .gitignoreM	"> ignores files matching .gitignoreMaybe it's just me, but that sounds like a bad default.  I can
definitely imagine people being confused by that."	ainar-g	8.626995	-6.468905	comment	4.0	12.0	1587495594	-11.805217
22984290	git rebase is akin to being a wizard	git rebase is akin to being a wizard but forbidden to use magic. I know it's there. I know it could solve a ton of my problems. But I can't use it because it would break everything from the feature-branch promotion model to my teammate's repos. It's basically useless to me, despite all the power it grants me.	TheCraiggers	8.572993	-6.56873	comment	4.0	18.0	1587873600	9.348921
23038520	The refs tab is not called branches 	The refs tab is not called branches because it is for references. We use git terminology deliberately, because it is a tool for git, and you should not be afraid of understanding your tools. On hg.sr.ht, for example, it's named differently, because Mercurial is designed differently and has different terminology.SourceHut is not GitHub/GitLab/Gitea, and you would be ill-advised to treat it as such. I have no intention of building yet another GitHub clone. If you insist on everything having the same workflow, then what utility is there in different tools? Be prepared to challenge your preconceptions when learning how to use SourceHut. The documentation is thorough and has lots of tutorials to help you along the way:https://man.sr.ht/There are no pull requests or merge requests. We use email,	ddevault	8.528737	-6.519992	comment	4.0	46.0	1588300028	-11.920828
23038818	But your suggestion relies on them k	"But your suggestion relies on them knowing what ""branches"" are - an equally tenuous proposition for a new programmer, I think. Recall that at one point, you didn't know how to use GitHub, either. Pull requests? Cloning? What do these words mean, out of context? New users on GitHub struggle a lot, too, something I know from firsthand experience dealing with new programmers on my GitHub projects all the time.I would prefer to solve these problems by fostering a culture of mentorship, and being responsive to questions. This is what I do on GitHub, too."	ddevault	8.547552	-6.469152	comment	4.0	15.0	1588303788	-11.900806
23108030	I've encountered similar difficultie	I've encountered similar difficulties around codebases with a lack of file hierarchy structure. But one major difficulty in fixing the issue is that moving a lot of files around tends to trash `git blame`, which is often more valuable than knowing what folder to put a new file in. Is that something you've encountered?	rudi-c	8.583568	-6.4723306	comment	4.0	19.0	1588884033	-11.901634
23124656	They explain it here: https://engine	"They explain it here: https://engineering.fb.com/core-data/scaling-mercurial-at-fa...The official reason is that the ""internals of Git"" weren't conduce to the kinds of invasive changes they needed/wanted. But I think the truth is closer to being that it was going to be too hard/slow to get those invasive changes past the Git mailing list.Here's an example of a FB eng reaching out to the mailing list: http://git.661346.n2.nabble.com/Git-performance-results-on-a..."	wincent	8.510441	-6.5349846	comment	4.0	16.0	1589032054	-11.981909
23135765	Curious why Jenkins over GitLab's CI	Curious why Jenkins over GitLab's CI/CD?	AsyncAwait	8.656097	-6.509358	comment	4.0	19.0	1589141688	11.992873
23214111	"I have been interested in ""git for b"	"I have been interested in ""git for binary data"" for a while, mostly for ML/computer vision purposes.I've tried quite a few systems. Of course, there's git-lfs (which keeps ""pointer"" files and blobs in a cache), which I do use sometimes - but it has a quite few things I don't like. It doesn't give you a lot of control on where the files are stored and how the storage is managed on the remote side. The way it works means there'll be two copies of your data, which is not great for huge datasets.Git-annex (https://git-annex.branchable.com/) is pretty great, and ticks almost every checkbox I want. Unlike git-lfs, it uses symlinks instead of pointer files (by default) and gives you a lot of control in managing multiple remote repositories. On the other hand, using it outside of Linux (e.g., MacO"	dimatura	8.5863905	-6.4463553	comment	4.0	14.0	1589740464	-11.887663
37798819	Thanks! Yeah I plan to get to the bo	Thanks! Yeah I plan to get to the bottom of it. I will probably propose to just keep a branch with full history somewhere (we need to keep history for auditability) and reset the main branch from a recent state.	charles_f	8.584716	-6.546891	comment	4.0	13.0	1696649746	-11.895937
37799707	> It’s the alien mental modelsHm.I l	> It’s the alien mental modelsHm.I love Git because its core is so simple it fits on a napkin [1]. From such a simple mental model, everything else flows. It's an extremely simple mental model because it compresses so well: from only the first principles, I can derive the rest.Any other computer system, I try to dig and find its first principles, but nothing is quite so clean, so I have to keep in mind a bunch of exceptions and add-on warts to understand them, a larger mental load.That said, I seem to often be the one around my teams most comfortable around Git. I can't explain it. Perhaps I've erased my initial struggle to understand it. Perhaps others don't conceive of Git as a datastructure...[1] files=blobs (named after the SHA1 hash of its content), dirs=trees=collections of blobs+tre	AceJohnny2	8.549995	-6.5071335	comment	4.0	38.0	1696663108	-11.8778
37799890	>It’s not the bad CLINah, really, it	">It’s not the bad CLINah, really, it is terrible.Git is one of the best examples of ""great tool with terrible API"".Funniest thing is that people always argue ""learn git internals and it'll click""Yea, git is the only tool that people argue with straight face that you should know internals of software and act as if it wasnt sign of terrible API design.Imagine if people acted as if you needed to know Visual Studio's or Firefox's internals in order to use those tools even in ""far from very advanced scenarios"", rofl."	tester756	8.565042	-6.4893765	comment	4.0	22.0	1696665335	-11.877814
37799922	"I think the disconnect is that the """	"I think the disconnect is that the ""first principles"" that you can derive from are implementation details; in other words, git makes the most sense if you embrace the inherent leakiness of the abstraction.> Perhaps others don't conceive of Git as a datastructureThe problem is that git doesn't really look much like a datastructure at first glance; it's ostensibly a shell command that you invoke, which makes people look at it in terms of inputs and outputs rather than spending time learning the details of all of the parts that aren't obviously in plain sight.> A branch is a reference is a pointer to the latest commit in a series. Creating a new commit adds to the top and updates the pointer.I think this is a pretty good demonstration of the issue I'm talking about; I've talked to engineers w"	saghm	8.5671	-6.517388	comment	4.0	24.0	1696665610	-11.904891
37799989	It's so frustrating when people join	It's so frustrating when people joining my team often scoff at the idea of using a git GUI.They're hired to write software, not fumble with ancillary tools that they've been using incorrectly for over 10 years.Either use the cli effectively, without messing up simple tasks, or use a gui that will teach you how.There's surprisingly a lot of resistance even though we provide Gitkraken licenses for free.To be clear, we have a few people using only the cli, we don't bring this topic up unless it's a problem.	korm	8.578483	-6.4965444	comment	4.0	15.0	1696666773	-11.863585
37812111	Comes up in every conversation I hav	Comes up in every conversation I have about Emacs, Git, CSS, etc: Just because a tool is the best at what it does, that doesn't necessarily mean it's good at what it does. Those are two different metrics.There's no danger of me dropping Git, the best alternative I've seen is Fossil and (opinion me) I think Fossil makes more mistakes than Git does. But Git definitely still has flaws; a lot of this post rings true to me.I do think that Git gets a lot better the more that you understand how it works. Not perfect, a lot of the flaws being pointed out here are core flaws with Git's internals and have nothing to do with the UI. But it does get significantly better; some of the failure modes are much easier to avoid if you've spent time digging into how Git works, and the whole thing starts to fe	danShumway	8.553234	-6.4940705	comment	4.0	33.0	1696783764	-11.923027
37812793	> I just personally think that can b	> I just personally think that can be in many situations an unhelpful way to think about what a VC is at a fundamental level;The Devil's Advocate in me feels compelled to point out that git is (to the very best of my fallible knowledge) the _only_ SCM in history to permit rewriting of history. Certainly SVN, CVS, and their predecessors did not get it all wrong by not enabling editing of history?Admittedly, rebase/squashing/etc. is _necessary_ for a Linux-kernel-scale project, but 99.99+% of software projects are, in terms of the number of contributors/contributions, so far removed from that scale as to not even register on that scale.	sgbeal	8.573563	-6.4926066	comment	4.0	12.0	1696787684	-11.9037895
37812519	Yeah - I'm very much about maintaini	"Yeah - I'm very much about maintaining an immutable record.  That is why, back in 2006, I started designing Fossil to control SQLite, instead of just switching to Git.I think that proper version control should be immutable.  If history is changeable, what's the point in having history at all?  It ceases to be ""history"" and becomes just a fable or hagiography.Mistakes happen, and it is important to be able to correct them, which Fossil does do.  In many ways Fossil's mistake-correction logic is far better than Git's.  If you make a check-in to the wrong branch, you can move it after the fact in Fossil.  If you check-in with the wrong user-id, or a with a goofy check-in comment, you can edit those too.  Was your system clock wonky when you did the commit, resulting in a bad timestamp on the "	SQLite	8.522374	-6.5609765	comment	4.0	18.0	1696786030	9.517539
37828816	Is this a commit?If so - is it norma	Is this a commit?If so - is it normal to do indention changes and actual code changes in the same commit?Personally, I would first have committed the indention changes and then did a second commit with the coded changes.	TekMol	8.590463	-6.5289707	comment	4.0	14.0	1696915894	-11.893511
37857047	> not only drive away a significant 	> not only drive away a significant number of potential contributors,It drives away the kind of people who have little patience for technology problems and little patience for learning new things.I don't want those kind of people working on e.g. Git. Git needs people who have lots of patience for technology problems and lots of patience for learning new things.	djha-skin	8.533396	-6.479681	comment	4.0	17.0	1697118421	-11.904731
37958217	In case it's useful to anyone, I've 	In case it's useful to anyone, I've been running the cheapest possible implementation of Git-based revision history for my blog's PostgreSQL database for a few years now.I run a GitHub Actions workflow every two hours which grabs the latest snapshot of the database, writes the key tables out as newline-delimited JSON and commits them to a Git repository.https://github.com/simonw/simonwillisonblog-backupThis gives me a full revision history (1,500+ commits at this point) for all of my content and I didn't have to do anything extra in my PostgreSQL or Django app to get it.If you need version tracking for audit purposes or to give you the ability to manually revert a mistake, and you're dealing with tens-of-thousands of rows, I think this is actually a pretty solid simple way to get that.	simonw	8.623248	-6.4641914	comment	4.0	13.0	1697819220	-11.897436
37972392	Interesting that Tcl uses Fossil for	Interesting that Tcl uses Fossil for their development, I wonder how many projects out there are using it instead of Git/GitHub.	pabs3	8.498307	-6.502461	comment	4.0	15.0	1697942782	-11.942811
38094089	> If you squash on merge, you’re doi	> If you squash on merge, you’re doing it wrong. If you’ve never used git blame, you’re doing it wrong. If your repo’s history is useless, you’re doing it wrong. If you didn’t add a typo fix or white line change as a separate commit, you’re doing it wrong.I agree Git Blame is useful, but squash on merge is great, and having atomic commits for whiteline changes is overkill.Looking forward to that fleshed out blog post on git	abledon	8.577798	-6.561984	comment	4.0	24.0	1698807216	-11.9414625
25458943	I have never understood cherry-pick 	I have never understood cherry-pick for this very reason.  This helps, but I'm still confused.> The git cherry-pick <oid> command creates a new commit with an identical diff to <oid> whose parent is the current commit.How can two diffs ever be considered equivalent when they include a changed file that had different starting contents?  Can they?	recursive	8.608427	-6.543896	comment	4.0	27.0	1608231582	-11.889394
25459165	This is why I'm really excited about	This is why I'm really excited about the potential of Pijul. In pijul, commits are diffs, and you avoid all of the rebase/cherry-picking craziness of Git.Still alpha software, so tons of roughs edges, but the potential is incredible. I think it'll be similar to the centralized -> distributed revolution that git ushered in.	dilap	8.583497	-6.5343523	comment	4.0	27.0	1608232607	13.895712
25461197	> Mercurial is so much simpler and e	> Mercurial is so much simpler and easier to understand than GitI think it must just be a mindset thing. The way git works makes perfect sense to me and I don't know why you would do it any other way.But git was already gaining significant traction when I started using version control.I can see how having built your mental models around previous version control systems and then trying to superimpose that on git would cause dissonance.But my entire concept of version control is based on how git does it, so it seems perfectly natural.	war1025	8.518099	-6.5477386	comment	4.0	15.0	1608243136	-11.938685
25467408	Thanks for the comprehensive explana	Thanks for the comprehensive explanation!I also find it quite interesting that you mentioned git specifically, because I’ve been going back and forth for the last few days with myself about whether I should spend the rest of Winter Break and next semester (I’m an undergrad with one semester left) learning git internals deeply. So, this felt somewhat validating of the perspective that I should learn about git more deeply so I can have enhanced practical knowledge, which could translate into more economic value for the company I’m working with after graduation.Once a decision is made in this regard, I then have to figure out the best way to actually learn it. I’ve considered trying to follow the mailing list[0] and contribute code to the git project, thinking that would force me to learn it 	didizaja	8.54292	-6.471958	comment	4.0	28.0	1608301882	-11.915305
25467703	The above explanation is great but I	The above explanation is great but I think the example you selected (git) is rarely the right thing to choose as for most companies git isn't where the money comes from (notable exceptions are companies like GitHub or GitLab). Sorta like the difference between working in the IT department vs Development (for a software company).Maybe a better choice is something like CSS: there's actually a lot to know about it and a lot of companies need people who are good at it for their core product (even though it's not as deep a topic as say being very knowledgeable/skilled in functional programming).	ido	8.549337	-6.483663	comment	4.0	12.0	1608303667	-11.896968
25471339	I just want them to make a stand-alo	I just want them to make a stand-alone git client - their 3 way merge for merge conflicts is second to none.	alpo20	8.597204	-6.5096126	comment	4.0	12.0	1608322358	-11.87929
25536673	So why disallow merging unrelated hi	So why disallow merging unrelated histories? Does it cause any actual problems? In many ways it seems like a neater model than what git now does.	lmm	8.57921	-6.5603075	comment	4.0	18.0	1608906769	-11.946989
25538145	Anyone who's ever used Darcs [1] kno	"Anyone who's ever used Darcs [1] knows that you can do a lot better than Git! So does anyone who's ever used Mercurial, for that matter.Darcs failed to reach mass adoption, and lost against Git back in the mid-2000s, which for me, at the time, felt like a big step backwards (and in other ways a step forward, since Darcs had some icky bugs and performance issues). Some 15 years later it's amazing that we are still stuck with Git.What makes Darcs different is that it does not need to organize history sequentially. It knows what commits depend on other commits, and a branch is simply a ""sea of patches"" whose order is inferred. This means that you can share commits across branches without conflicts (unless the branches actually conflict, of course). Darcs' equivalent to ""git cherry-pick"" simpl"	atombender	8.565146	-6.540738	comment	4.0	22.0	1608921433	13.8766575
25539221	This was really really educational. 	This was really really educational.  Git internals seem rather simple.Does anyone have a really good visual explanation of what's being done to the tree and such when commits and merges and rebases are done? I still don't quite grok it intimately enough.	Waterluvian	8.56407	-6.529835	comment	4.0	13.0	1608932098	9.749515
25560740	I wish there was a way to maintain g	"I wish there was a way to maintain git version control while still being able to send and receive files from attachments from people who struggle with the idea of reading or reviewing something in any way other than by getting an email attachment.I used to work at a bank where we had to collaborate on Word documents stored in SharePoint. It was a nightmare. In SharePoint you are supposed to ""check out"" documents, edit them, and ""check in"" the document afterward. The problem was that SharePoint was slow, so it was more convenient to work from local copies. And many people couldn't resist the urge to send documents as attachments when requesting feedback from someone else, thus breaking the version control system. And if someone already had ""checked out"" the document, there was nothing stopp"	cluse	8.601408	-6.461132	comment	4.0	12.0	1609174474	-11.83003
25645072	There's definitely an argument that 	There's definitely an argument that GitHub is one of the primary reasons that Git beat Mercurial.	richardwhiuk	8.500521	-6.5425215	comment	4.0	13.0	1609852029	-11.941941
25792197	Ned Batchelder: Experimenting with G	Ned Batchelder: Experimenting with Git storage	rbanffy	8.56641	-6.441879	story	4.0	1.0	1610725805	-11.890882
25887893	"I used to be an ""insane weirdo"", but"	"I used to be an ""insane weirdo"", but at some point I gave up.Now, I just focus on code correctness, merge and fix the code style myself, avoiding a lot of useless back and forth.My hope is that people like to see their name when they ""git blame"" (what's the PC version of ""blame"" again?)So they will over time learn to follow the code style in order to keep their name there."	alain_gilbert	8.600017	-6.5524254	comment	4.0	15.0	1611451222	-11.899597
25909595	This is generally a good flow, but s	This is generally a good flow, but something that absolutely baffles me is that GitHub changes the commit SHAs when branches are rebase-merged from PRs[0]. This totally breaks a fundamental notion in Git that the same work, based on the same commits, has the same hash. It also makes it incredibly difficult to determine which PR branches have been merged into master.[0] https://docs.github.com/en/github/collaborating-with-issues-...	hoprocker	8.583153	-6.4947824	comment	4.0	12.0	1611612445	9.004264
25967889	Fast Commits for Ext4	Fast Commits for Ext4	joseluisq	8.59002	-6.5438466	story	4.0	93.0	1612002142	-11.914187
26033720	My favorite ~/.gitconfig  [alias] th	"My favorite ~/.gitconfig  [alias] that uses fzf:  # Allows you to easily pick what to rebase
  frbi = ""!f() { git rebase -i $(git log --pretty=oneline --color=always | fzf --ansi | cut -d ' ' -f1)^ ; }; f""

Then just do:  git frbi"	graton	8.58306	-6.5252333	comment	4.0	12.0	1612506933	-11.85381
26049214	what they suggest is very similar to	"what they suggest is very similar to Architecture Decision Records (ADR's). https://adr.github.io/TL;DR: ADR's are a design choice for a lightweight process to store and manage the history over what architecture decisions have been made in the past and why. They should be tracked within git so that the history of decisions and how these evolved is provided for free. Just track all this within an `adr/` subdirectory at the root of each project.""Communicating and documenting architectural decisions"" - David Ayers LeadDevNewYork(2019): https://www.youtube.com/watch?v=rwfXkSjFhzc"	DyslexicAtheist	8.610033	-6.4614844	comment	4.0	15.0	1612640334	-11.814209
26083813	This sounds like an indictment of gi	This sounds like an indictment of git. It was supposed to make it easier for OSS developers to collaborate, but it turns out that you become bound to a monopoly like Microsoft. Why can't git users develop an easy to maintain server, like svn and fossil did, for example?	coliveira	8.5783	-6.4373226	comment	4.0	13.0	1612912498	-11.864013
26188633	"I am one of those ""not willing"" peop"	"I am one of those ""not willing"" people. I encounter the same issue discussed here without even thinking about it, and solve it as such:1. Realize I need to check how my new code looked like 5 min back.
2. Copy full file into clipboard, undo by a few steps
3. Do a temp commit on GitHub desktop
4. Paste the new code back and look at the diff on GitHub desktop, and if needed undo the temp commit from above.Is this more clicks than the vin shortcut? Sure. But I don't have to go learn the internal tree structure representation of my text editor and spend my time in that universe. I have found a way to do what I need to with the tools I have in hand.This is the same way how the majority of finance runs on excel when they could do better with better programing. In the end whether you get the job "	ramraj07	8.606908	-6.4548903	comment	4.0	12.0	1613700315	-11.828809
26193231	For me #1 would be to add a version 	"For me #1 would be to add a version to any data format or communication 
 protocol. If you want to know how hard not doing so can bite, don't look further than Git and it's tourcherous migration from sha1."	boris	8.683625	-6.5144863	comment	4.0	14.0	1613743449	7.204695
26207037	Actually I was part of an SCM confer	Actually I was part of an SCM conference put together by Facebook and Google recently.  People are starting to think about what happens after Git.Unfortunately, even now, it seems that there is a lot catching up to BK still to be done. To be fair, we had kernel level programmers working on it, we don't think anyone will pick up our code, you pretty much have to be a top 1-2% programmer to work on it, it's all in very disciplined C, people don't seem to like that any more.So far as I know, BK is the only system that gets files right, we have a graph per file, everyone else has a single graph per repository.  The problem with that is the repository GCA may be miles away from the file GCA; BK gets that 100% right, other systems guess at the GCA.   Graph per file means each file has a unique i	luckydude	8.576697	-6.537686	comment	4.0	25.0	1613849403	-11.905313
26228069	Ohmygit – An open source game about 	Ohmygit – An open source game about learning Git	mtmail	8.522904	-6.4580092	story	4.0	63.0	1614017871	-11.886172
26239951	"Exactly.  I want to ""tell a story"" w"	"Exactly.  I want to ""tell a story"" with my commits, and that story is really more of an idealized retelling of what I actually did.Five years from now, no one needs to know that I forgot to add that one line to a prior commit and had to add it separately, or that my first attempt didn't quite pan out as expected.What that future person _will_ care about is:- What final changes actually got made?- What task was I working on?- What was the reason for any of these changes in the first place?- Why did I make some of these changes specifically to implement that task?- What additional side info is important context for understanding the diffs?"	acemarke	8.590758	-6.5286083	comment	4.0	16.0	1614100875	-11.903619
26241226	> it makes me feel saferThis for me 	"> it makes me feel saferThis for me is one of the biggest things I like about working under version control, even solo. It gives me the freedom to explore some crazy idea or refactor without having to think about the way back if it doesn't pan out. If it turns out to be more complex than I am willing to do now, I can stash or branch.If I think back to my pre-source control days, I used to leave commented code everywhere, or just make a full copy of the folder. It doesn't take long before this becomes an absolute mess.  Copying in particular was a barrier: you had to realize it was necessary then interrupt your flow to do something that would take a several seconds. (By contrast, if you commit as you go - especially everytime you get to a working ""checkpoint"" - there's zero extra effort nee"	gregmac	8.651634	-6.4417195	comment	4.0	32.0	1614106449	-11.866975
26241511	Modern IDEs often ave basic source c	Modern IDEs often ave basic source control baked in. You don't even need to commit anything. I wonder whether there is any point in using Git for basic version control if those features are already available.	colllectorof	8.584372	-6.4620566	comment	4.0	15.0	1614107584	-11.861907
26283097	On the flip side, I'm a strong propo	On the flip side, I'm a strong proponent of using a GUI for many Git tasks:https://blog.isquaredsoftware.com/2021/01/coding-career-git-...but I also use the CLI for other tasks as well.For example, it's _way_ easier to add specific file chunks or individual lines to the staging area via a GUI, or do interactive rebasing.	acemarke	8.591653	-6.498779	comment	4.0	12.0	1614406702	-11.901952
26454830	I think the default branch name chan	I think the default branch name change has been good for the ecosystem; “master” didn’t always make sense for whatever workflow was used, and it was hardcoded all over a bunch of tooling. I think “main” makes more sense, regardless of politics, and this encouraged a lot of software to make the default branch configurable.	cmckn	8.514221	-6.529707	comment	4.0	15.0	1615725579	-11.725246
26470561	Whoa, `git maintenance` looks amazin	Whoa, `git maintenance` looks amazing.It's a background server that you launch with `git maintenance start`.> This cross-platform feature allows Git to keep your repository healthy while not blocking any of your interactions. In particular, this will improve your git fetch times by pre-fetching the latest objects from your remotes once an hour.	dfabulich	8.525627	-6.4448714	comment	4.0	13.0	1615850032	-11.863387
36572964	I once spent 8 months merging a code	"I once spent 8 months merging a codebase with almost every single function duplicated three times, and all that was required for each (most of the time) was another parameter, one conditional in function, and all 3 could be merged.So I did that!  And at the same time cleaned up the code, fixed bugs, and adding required new functionality, and all while merging in constant change from the main codebase.After reducing a 1M line codebase to 280k lines, when almost done, after that 8 months, I was asked ""how much longer"".My response of ""a month for testing"" was apparently too long for the new manager, who turfed all those fixes, including the new functionality.And I wasn't even behind schedule, I was ahead.Once abandoned, everyone just copy and pasted my changes... in triplicate, into the old c"	bbarnett	8.678979	-6.5332503	comment	4.0	21.0	1688392781	-11.817413
36594055	as a solo developer, you are free to	as a solo developer, you are free to commit however you wantI use commits as rollback points. If something works and I want to try something risky, I commit first. I don't care about the commit message. I basically never look at any commit older than one month	hsn915	8.585745	-6.5129557	comment	4.0	13.0	1688515386	-11.932307
36707541	I would love to use this at $daywork	I would love to use this at $daywork, but it has the unfortunate limitation that the merge group needs to pass the same checks as the branch itself, making it doubly expensive (esp. with something like Chromatic that is susceptible to flakiness and might need manual approval).I would love to be able to set different sets of checks that need to pass to add a PR to a merge group, and to the merge group itself to be merged, so we can better manage speed and cost.	cprecioso	8.615039	-6.505925	comment	4.0	14.0	1689247517	13.653467
36778437	I presume merge queues are useless i	I presume merge queues are useless if you have flaky tests?	dave4420	8.7288065	-6.50654	comment	4.0	17.0	1689711081	-11.797517
36783720	I use IntelliJ IDEA and often rely o	I use IntelliJ IDEA and often rely on their own Git functionality. But it cannot stage specific lines, only whole chunks [1]. For that, I've been using lazygit for a couple of months now. I like its simple UI and that it makes staging specific lines very easy and quick. If you like lazygit, you might also be interested in similar Git CLI clients that I collected here [2].[1] https://youtrack.jetbrains.com/issue/IDEA-186988/Allow-commi...[2] https://github.com/frontaid/git-cli-tools#clients	FrontAid	8.600617	-6.4935293	comment	4.0	20.0	1689757505	-11.871013
36783797	I'd like to know what happened to Sq	I'd like to know what happened to Squash. Up until the mid 90s or so it was really popular. Then it seemed like everyone stopped playing and courts closed left right and centre	stormdennis	8.563021	-6.568749	comment	4.0	13.0	1689758147	-11.953072
36787220	I don't know if this is maintained a	I don't know if this is maintained anymore. Last commits are from 3 years ago	no_wizard	8.609263	-6.459185	comment	4.0	13.0	1689777771	-11.8684225
36831791	I've used Fossil for a private local	I've used Fossil for a private local project. It's quite a capable revision control system with a very decent web UI. Just a word of warning - make frequent backups of the backing sqlite repository database. I had upgraded fossil to make a few commits and then I inadvertently made a commit using an older version of fossil and it corrupted the fossil repo database irreparably and a few days' of work was lost. I've never had GIT corrupt a repo in ten years of daily use - regardless of version.	avgjo	8.542412	-6.4859457	comment	4.0	16.0	1690076425	-11.88935
36833642	In fairness, the rate of change of a	In fairness, the rate of change of any type of tool slows down over time as the problem domain becomes well understood.It's like the Joel on Software article (which annoyingly I can't find at the moment) about how software is always pretty much done by about version 4. His example was office software, especially Excel, and sure enough if you loaded Excel 4 today you'd see it does fundamentally all the main things.I suspect we'll see git last at least double the length of time as those other VCS tools.	quietbritishjim	8.55941	-6.485389	comment	4.0	26.0	1690102325	-11.900112
36832400	git...is difficult to install? What'	git...is difficult to install? What's difficult about apt-get install git?	backendanon	8.546157	-6.4753337	comment	4.0	33.0	1690084268	-11.886637
36834159	git gets bad rep because its cli is 	git gets bad rep because its cli is a terrible messif apple designed git's cli it'd be bilion times better from ux perspective while only 10% less powerful I guess	tester756	8.56484	-6.483422	comment	4.0	19.0	1690109093	-11.825548
36922883	Is This a Branch? (2021)	Is This a Branch? (2021)	segfaultbuserr	8.626149	-6.5423536	story	4.0	33.0	1690654087	-11.810764
36954533	Isn’t this just .gitignore? I feel l	Isn’t this just .gitignore? I feel like I’m missing something.	vxNsr	8.628259	-6.48301	comment	4.0	21.0	1690887314	-11.809456
36954772	I'm of the same opinion as you, here	"I'm of the same opinion as you, here. I generally have 10+ ""extra"" files in my project directory (output files, notes, one-off scripts for certain things, etc). When I add files to a commit, I do it by filename, never ""everything that's new/changed"". I don't have a use case for ""everything I've created/changed goes into the commit, always"".> switch to another branch, the files will still be in your working copy but not listed in your .gitignore fileThis is a failing of git, imo. There should be a .local.gitignore to somesuch, that is ""added to"" .gitignore. It's VERY common for me to have files that I want ignore, but are specific to me; they don't belong in the project's .gitignore. I know there are ways to do this, but all of them are clunky. There should be a simple, out of the box way t"	RHSeeger	8.653804	-6.5270987	comment	4.0	17.0	1690889760	-11.850007
37040718	Resolving rebase conflicts is techni	"Resolving rebase conflicts is technically and conceptually much more difficult than resolving merge conflicts, with the added bonus that rebasing can sometimes force you to resolve conflicts for each commit in your branch.Here's how I think everyone should use git:1. Create a new branch for your changes
2. Make commits and merge from main with wild abandon
3. One final merge from main
4. Squash everything into a single commit, push a PRIf you keep your branch focused on only a single change, the end result is a tight, focused, single commit PR that merges cleanly into main and didn't involve any complex or error-prone shenanigans."	jkubicek	8.584018	-6.56013	comment	4.0	13.0	1691441173	9.131998
37041148	Definitely a mistake, though you can	Definitely a mistake, though you can explain Git's data model in about 2 minutes.I would say a bigger mistake is starting with the command line. A good GUI is absolutely instrumental to understanding Git, and it lets you avoid Git's terrible CLI for as long as possible.	IshKebab	8.564414	-6.494664	comment	4.0	15.0	1691443417	-11.874365
37043956	Simple question: why is there no git	Simple question: why is there no git undo command shipped in box? There is absolutely no technical barrier to shipping such a command.	howinteresting	8.558557	-6.5217113	comment	4.0	30.0	1691463480	-11.903122
37086347	I'd say the biggest drawback of that	"I'd say the biggest drawback of that approach is churn; loads of extra commits and code changes for code review comments.Of course, that becomes a non-issue if you use a squash merge approach, instead of retain all commits (which in this approach have a lot more of a ""WIP"" feel to it).Do code review comments have value after merging? I would also posit they're easier to find if they're in an external location (like github/lab, gerrit, etc), unless you also wrote tools that can figure out which commits and comments belong to a certain feature."	Cthulhu_	8.580542	-6.545668	comment	4.0	25.0	1691742238	-11.975202
37097356	Tbh I’m (loosely) following commit m	Tbh I’m (loosely) following commit message best practices in all of my projects out of irrational fear of being viewed as unprofessional. But never needed that effing prose in my workflow. Maybe a keyword from time to time. I’m using code, not messages to navigate history, and in a rare occasion. If all my messages turned into “i” I’d lose nothing, because all rationales and essentials are in code comments. I’d better seen dates (and related grouping) in a log by default and looked for a commit by some grepping patch contents rather than messages.	wruza	8.5812235	-6.545472	comment	4.0	16.0	1691818864	-11.864168
37154904	There are countless tools that write	There are countless tools that write to the bash files though, which is not true for most programs. Bash changing its locations would break all of these.Heck, git adopted ~/.config/git years ago, and yet just last week I ran across a tool that created and wrote to ~/.gitconfig instead of my ~/.config/git/config. If Bash tried to change then we'd be dealing with the fallout probably forever.	lilyball	8.602023	-6.4871597	comment	4.0	18.0	1692226069	-11.892283
37291432	> GitOps is a philosophy which makes	"> GitOps is a philosophy which makes sense even on small projects.Er, does it? Root cause of this catastrophic dataloss incident is that in ""GitOps"" none of the traditional safety checks can be implemented. In normal sysadmin workflows, attempting to delete all your data will yield an ""Are you sure?!"" type message and you'll probably have to take explicit steps to confirm that this is really what you intended. There will also be dry run modes and other helpers.Because git is intended for source code and not as a way to make stateful changes to servers, there are no features for that. If you push a commit that didn't do what you mean, it will just blindly do it.It seems like this is a pretty major flaw in the whole ""philosophy"". The whole point of hacking a VCS into a server admin UI is bec"	nvm0n2	8.554157	-6.489064	comment	4.0	12.0	1693212532	-11.877
37295459	> Are there some fundamental aspects	> Are there some fundamental aspects of git that would make it either very difficult to improve that, or that would sacrifice some important benefits if they were made?It’s hard to look at a million files on disk and figure out which ones have changed. Git, by default, examines the filesystem metadata. It takes a long time to examine the metadata for a million files.The main alternative approaches are:- Locking: Git makes all the files read-only, so you have to unlock them first before editing. This way, you only have to look at the unlocked files.- Watching: Keep a process running in the background and listen to notifications that the files have changed.- Virtual filesystem: Present a virtual filesystem to the user, so all file modifications go through some kind of Git daemon running in t	klodolph	8.573035	-6.4894514	comment	4.0	16.0	1693235811	-11.909689
37434704	Does anyone have the code from the f	Does anyone have the code from the first commit?	arey_abhishek	8.581207	-6.460089	comment	4.0	16.0	1694186385	-11.881173
37514727	I have a local clone of a git repo w	"I have a local clone of a git repo with many local branches.  I lost an object file (and I'm not certain how).  Now git gc always fails, complaining about the object:Counting objects: 100% (11785289/11785289), done.Delta compression using up to 64 threadsCompressing objects: 100% (4116944/4116944), done.fatal: unable to read 
1cae71a9d5b24991c0d632b45186ca8a250e5d52fatal: failed to run repackI've cloned the repo again, and that object does not appear in the new clone, so I assume it must be from a commit to a local branch.The odd thing is that I think I locally cloned this repo, and saw no complaints about the missing object.Is there any way to tell what branch and/or file(s) were referred to by the object?  And, assuming its from a stale branch, just delete the branch and thereby fix my r"	drewg123	8.597261	-6.5275807	comment	4.0	20.0	1694724898	-11.910748
37553989	Yes it should replicate the function	Yes it should replicate the functionality user expects - save everything into temporary file and overwrite the original file only on explicit save action.As for Git, it would benefit from using text format specifically aimed for easy diffing/merging. No idea how easy the sqlite dump is in this regard.	rini17	8.6167	-6.496097	comment	4.0	16.0	1695028938	9.872947
37561332	You can have both. Some bigger featu	You can have both. Some bigger features can take a while to complete and you can keep the pain to a minimum be rebasing your feature branch on the latest mainline branch often.	tsak	8.619197	-6.523821	comment	4.0	13.0	1695067815	-11.84826
24440452	I also love:- magit-blame: show the 	"I also love:- magit-blame: show the commits for each line
- magit-find-file: allows you to open a file from any branch. So you can easily have the same file from two different branches opened side by side.
- magit-log-buffer-file: shows the git tree with all commits that modified the file in the current buffer (which you can then navigate just like you would when doing M-x magit-status l l)And this package is pretty sweet as well: https://melpa.org/#/git-timemachine , it allows you to navigate the git tree for a given file easily."	globuous	8.587593	-6.5059047	comment	4.0	13.0	1599814031	-11.875547
24532168	"Political correctness aside, ""main"" "	"Political correctness aside, ""main"" does sound like a more natural name for the main branch.The term ""master"" for a branch name always felt a little strange to me. One might ask, ""What is master?"" The answer usually is, ""It is the main branch.""The same thing held true for ""trunk"" in the SVN world, although it made more sense. One might ask, ""What is trunk?"" It requires a lengthy explanation, ""It is the main development branch. We will create other release branches from it. Imagine a tree with a trunk from which other branches grow.""One is less likely to ask, ""What is the main branch?"" The branch name is self-explanatory."	susam	8.519927	-6.5266595	comment	4.0	17.0	1600581489	-11.720635
24586861	I'm hopefully waiting for a new and 	I'm hopefully waiting for a new and easier alternative way of version controlling. I don't have any idea how it should be, but git's approaches are so complicated, possibly because of it is designed for so complicated projects.	swadizand	8.60044	-6.483856	comment	4.0	17.0	1601012128	-11.877209
24586934	An introduction such as this, should	An introduction such as this, should also explain about ways of working with git and not just explain the commands. I still remember the first time when I started working with git, that I was warned never to use rebase, because it could be dangerous. It was only when I moved to another working environment, that I learned how to use it, and only about five months ago that you can add --rebase with the default pull button. But still I find myself using Git Bash shell often.It took me also a long time to learn that origin was the default remote and that you can add more remotes and that you can also push to a repository on a USB drive.I have been working with git for about four years now and it is only in the past year that I feel a little comfortable with it. But still when I look up a git c	fjfaase	8.5639715	-6.5405073	comment	4.0	22.0	1601012872	-11.929462
24587875	I understand there's a whole lot of 	I understand there's a whole lot of FUD behind rebase, but I still don't like it. To me, a project's branch structure provides a history of how it all went down, and when I'm trying to hunt down a mysterious change in the code, it's all information I can use to figure out exactly why a certain decision was made, and whether it was made on purpose or by accident.I think rebase and squash go together in terms of what you want to get out of the VCS. If you want a clean history, where every commit represents a complete feature, with the knowledge that you can check any commit out and expect it to work, then squash and rebase are your friends. If like me, you want to understand the history of the code, warts and all, then merge is the way to go.Also, I find I can achieve most of the benefits of	sirmarksalot	8.57337	-6.5673084	comment	4.0	15.0	1601023418	-11.930639
24593535	In the sense that git was noticeably	"In the sense that git was noticeably ""better"" than the centralized systems that came before it, is enough wrong with git to not use it these days? Although there are pain points with git, a large majority of git activities are fairly cookie-cutter"	mhh__	8.545624	-6.4728594	comment	4.0	24.0	1601063923	-11.9041815
24593960	i'm not sure if this project is diff	"i'm not sure if this project is different, but patches can suck really bad. an example of this are mercurial queues (mq). with no history/ancestry, the merge behaviour can be horrible. for even medium-size teams, it goes downhill quickly. IMO, it's fucking broken and a huge waste of time. of course, it's possible i don't get mq. but i'll take git any day of the week over mercurial + mq, at least git works and doesn't loose my work as often. (believe it or not, this is easier to do with mq than git (!).)maybe pijul is different, but their ""conflict"" doco doesn't fill me with confidence: https://pijul.org/manual/conflicts.html"	guitarbill	8.588628	-6.564132	comment	4.0	21.0	1601067039	13.899593
24615978	Wouldn’t git with signed commits wor	Wouldn’t git with signed commits work just as well? You’d have to find a good app that saved stuff as text (not Word, but probably not LaTeX either since that takes time to get the formatting right), but once you figured that out, you’d have a full history of all changes made.	easton	8.590824	-6.4864964	comment	4.0	18.0	1601296746	-11.908262
24619103	A question I always have is if CDRTs	A question I always have is if CDRTs solve some problem with collaborative editing, then can git's merge algorithm be rewritten to use CDRTs and benefit from it somehow?Somehow I think the answer is no. There is a reason we still have to manually drop down to a diff editor to resolve certain kinds of conflicts after many decades.	nonbirithm	8.6528845	-6.52093	comment	4.0	13.0	1601314134	-11.796473
24646310	Would like to see a SCM that:- handl	"Would like to see a SCM that:- handles large files effectively (build artifacts, 10-40GiBs each, and other binary dependencies)- partial checkout of the repo/view- git style operations (have stage area, can stage parts of a file, can stash changes and reapply later, cherry pick)- can view the history of an individual file (support file relocation)- access control on individual files, and partial review of the repository (views are ""granted"" to developers)- good tooling- immutable when it makes sense (e.g. you cannot changed a published commit)- works offline (if possible)- large mono repoI evaluated git annex and git lfs, and finally chosen Perforce, mainly for its large file handling, view for each developer and ACL, but the lack of flexibility makes me don't want to commit, and every tim"	7kmph	8.584422	-6.491145	comment	4.0	12.0	1601516315	-11.89516
24686700	I never understood the need to squas	"I never understood the need to squash commits (or rebase). If you do merge requests and use merge commits (like GitHub or gitlab do). A ""nice"" history is a small script away. It should even be a part of the GitHub/gitlab gui. Do not loose information about the development history!"	aurelianito	8.574603	-6.556968	comment	4.0	19.0	1601897872	-11.940457
24686726	If you use Pull Requests with squash	If you use Pull Requests with squashed commits, you can do exactly the same process as described here by isolating the issue to a PR then restoring the branch and bisecting from there.It seems like a small price to pay for a clean history, given the rarity of occurrences like this.	ZephyrBlu	8.580033	-6.557905	comment	4.0	21.0	1601898137	-11.926596
24730608	Ask HN: Can't the GitHub switch from	Ask HN: Can't the GitHub switch from “master” to “main” be opt in?	joshxyz	8.534273	-6.4807286	story	4.0	8.0	1602256239	-11.754149
24734987	An excellent tool that can be used i	An excellent tool that can be used in conjunction with this approach is the word-level diff option for git diffs: `git diff --color-words`Rather than processing entire lines (useful for code), it shows individual word changes, so it's great for tracking data as in the screenshots in the article and even better for text (output produced is similar to latexdiff for those familiar).I highly recommend... I have a git alias setup for this, and use it almost every day.	ivan_ah	8.684876	-6.4887505	comment	4.0	14.0	1602281891	-11.78699
24751227	Git is an awesome tool – so awesome 	Git is an awesome tool – so awesome that it has a vast plethora of options and commands to do just about anything. Bit attempts to alleviate some of that pain.	chriswalz	8.55634	-6.470218	comment	4.0	28.0	1602474746	-11.879814
24752841	The save command also accepts the co	The save command also accepts the commit message on command line only instead of opening an editor.I do not understand how people can live with only a single line for the commit message. For a new feature, I need to provide some details what is added and how it can be used. For a bugfix, a single line is rarely enough to describe the problem, what you changed, and why this change solves the problem.Writing good commit messages is an essential part of using a version control system with a team. When trying to make the git interface easier, this should not be dumbed down. I would rather expect the tool to provide assistance with the usual format of a short subject and a body for a longer explanation.	raimue	8.599669	-6.529778	comment	4.0	16.0	1602495967	-11.892658
24815433	Git GC won't do anything here unless	Git GC won't do anything here unless you're deleting commits or resetting the repo constantly.  Every commit will keep piling up, and you will never prune anything like you would a traditional backup tool.  The day you do decide to start pruning things, expect your computer to burst into flames as it struggles to rewrite the commit history!Using a real database backup solution isn't a premature optimization, it's basic system administration.	candiddevmike	8.580418	-6.49256	comment	4.0	12.0	1602993435	13.054698
24848841	> 5. Squash Those CommitsThat's very	> 5. Squash Those CommitsThat's very odd advice, as the reverse actually should apply.Since (in GitHub) merging with squash costs just one click more to the maintainer, and one can't separate squashed commits, having separate commits should be the default behavior.I'd say that it's preferrable to squash a disorderly branch history, but then, it's about being orderly rather than squashing for its own sake.	pizza234	8.585811	-6.566971	comment	4.0	17.0	1603294504	-11.939714
24908708	I've personally only seen git lfs us	I've personally only seen git lfs used as a bad-habit enabler (e.g. storing .dll, .so, and .exe files within a repo).IMHO those artifacts should be stored elsewhere. Anyone have some better examples of how it's used?	actionowl	8.5716305	-6.4594917	comment	4.0	19.0	1603814415	-11.862805
24972626	We regularly¹ have unclean merges at	"We regularly¹ have unclean merges at my company, and I consider my coworkers competent, and well above ""the bar"". The biggest problem we have with clean merges is that nearly every CI system & code review tool out there doesn't test the final product — the merge commit — until after it is merged. GitHub follows this flow by default, and usually even with more CI tooling on the side. Something like bors-ng is what one has to adopt. (And we're struggling to do this for our monorepo due to other points the article touches on.)While it is possible (if difficult) in git, some VCS systems struggle even harder with this: Perforce and derivatives, for example, simply can't, by design, perform atomic test & commit.¹like once a month, or so, over the whole company"	deathanatos	8.643899	-6.4911437	comment	4.0	14.0	1604347939	-11.868214
25007348	Lemme give you one example of one wo	Lemme give you one example of one workflow I've encountered a bunch of times that's super annoying with git.I port/test a project to a new OS. I run into a bunch of issues, like linkers, environments, etc. that are broken that I need to fix. I try and make clean commits tackling one issue at a time, so we get 1 commit for the linker issues, 1 for the docs, 1 for the environment, etc. eventually I have 5 commits of fixes.These fixes are all orthogonal, so ideally I want to make separate PRs and separate reviews for them. But locally they're all tied together (in chronological order), since I need all of them there to continue development.In git I can either open 1 big PR including all fixes at once (annoying) or I can make a PR for one commit, wait until it's merged, then PR the next, etc. 	merijnv	8.581837	-6.5513024	comment	4.0	13.0	1604668379	-11.923058
25027972	Here are the alternatives:FileMerge 	Here are the alternatives:FileMerge - part of Xcode. Free. use opendiff to launch from CLIBBEdit - My go to editor for the Mac. Freemium. Available both on the Mac app store and their website as a download.VS Code - Also free.SourceTree - Acquired by Atlassian. Also free. Good for git context to diff branches, commits and modified but uncommitted files in current branch.	putlake	8.659063	-6.4864516	comment	4.0	14.0	1604861857	-11.774497
25044149	> Seems pretty standard to me. Anyth	> Seems pretty standard to me. Anything notable here?I agree, it's pretty vanilla git usage. I was curious to see any insightful take of whimsical twist, but it boils down to a basic take of good old git flow, which is git 101 for a long time.https://nvie.com/posts/a-successful-git-branching-model/The only surprising thing in the article was the refusal to use git stash, which can't really be explained on a rational level.	barumi	8.553024	-6.496468	comment	4.0	25.0	1605000838	-11.88671
25044921	The most important bit in my opinion	The most important bit in my opinion:> When merging fixes and features into master, we avoid merge commits and use rebases and fast-forward as much as possible.Rebasing feature branches, and avoiding non-ff merges has been the best change I've ever made to my workflow. Makes it very easy to keep a clean, readable history that is actually useful when doing code archeology months later. Resolving conflicts is far easier than via merging too.	ricardobeat	8.615105	-6.549594	comment	4.0	25.0	1605008975	-11.918498
25121659	Git is hard because it precisely mod	Git is hard because it precisely models the complexities of concurrently modifying source code on multiple computers. It explicitly models all of the concepts and operations that are relevant in that domain - branching, merging, my local changes, the server that my local branch is kept in sync with, rewriting local history, rewriting public history. Can you shoot yourself in the foot? Absolutely, because this stuff really is non-trivial. Could it be made easier? Yes, by limiting what operations you're even allowed to make, and streamlining those (c.f. git flow).	m12k	8.554561	-6.4790673	comment	4.0	19.0	1605605056	-11.902866
25121782	I've definitely been the victim of m	"I've definitely been the victim of my own git hubris.Once, when leaving a job, I decided to copy all of my local WIP branches to the server.I whipped out this fancy --mirror option I had just heard of:  git push --mirror $remote

Surprise! All branches on the remote repo got wiped. My local refs replaced the refs on the remote.Somehow I found the right commits floating around in the git ether. I was able to recreate the branches, but I had to recreate their names by reading the commit log.Did I mention this happened on my way out the door from a job? In retrospect, I shouldn't have panicked so much -- there were daily backups -- but the sheer terror I felt has made me read the man pages really closely to this day."	zingermc	8.560717	-6.5062594	comment	4.0	20.0	1605605935	-11.895268
25124813	"I rarely use ""git pull"".  Why would "	"I rarely use ""git pull"".  Why would you?More typically, I will ""git fetch origin"" to fetch the current integration branches, then ""git checkout -b <feature branch> origin/master"" to start a new feature branch from a given integration branch, then push that once the change is completed.If I need to update a local copy of an integration branch, then I might well use ""git pull"".  But I would never have any local changes made there which would require stashing, since all changes are done on feature branches."	rleigh	8.5664015	-6.5110703	comment	4.0	16.0	1605626794	-11.906683
25138591	"The branch name ""master"" does not ha"	"The branch name ""master"" does not have ""golden master"" or ""master copy"" roots: https://mail.gnome.org/archives/desktop-devel-list/2019-May/..."	zacwest	8.456209	-6.570577	comment	4.0	15.0	1605716535	-1.0435296
25185213	Git is at a vastly different level o	"Git is at a vastly different level of abstraction than most of the population are used to (or capable of). When Linus made git, concepts like references, pointers, indirection, graphs, hashing, indexing etc. were already as obvious to him as the sky being above the ground. Even some programmers struggle to operate at this level. It does hurt to see non-technical people inventing their own terrible VCSs, though (""Copy of Important Document 2020-11-21 (2) (Updated PB).docx"")"	globular-toast	8.5681925	-6.460137	comment	4.0	17.0	1606126223	-11.894541
25246903	I really want to use Pijul, but prog	"I really want to use Pijul, but programming is a team sport.
And especially open source.The Pijul equivelent of GitHub is Nest.
It's just not there yet.
Firstly, there are basically no potential colaborators for the areas i work on.
Secondly, it is much less mature ass a platform. In 5 minutes i couldn't find any way to ""browse repositories"" inn any sense, to discover what is out there.
Discussions are not fleshed out as a issue tracker (no tags for a start), though that could be dealt with by using a 3rd party issue tracker.Pijul's whole setup seems like it would solve a bunch of problems I have with git.
1. that a commit maintains its own identity when cherrypicked onto another branch, and its intrinstically linked. Vs in Git where it is a unrelated (but identical) set of changed.
2. the"	oxinabox	8.598437	-6.555656	comment	4.0	16.0	1606674482	13.896037
25400554	On top of that, his opening example 	On top of that, his opening example is so easy if you use a GUI for Git it's mind-boggling.It'd literally be click status column to sort, click top entry, shift-click bottom deleted file, right-click, restore. Done, a couple of seconds without even thinking about it.And somehow this simple task in a GUI inspired a blog post about how useful the shell is.I'm not going to deny a shell is extremely useful, and knowing far more than I do makes you a better programmer, but there's also using the right tool for the job.	mattmanser	8.579051	-6.5122886	comment	4.0	16.0	1607799687	-11.8749485
25443971	text-mode interface for GitBased on 	text-mode interface for GitBased on the comments here saying they love Tig, I know I'm missing something, but: doesn't Git provide a text interface (the `git` command) to Git?I'm not trying to be obtuse; I genuinely don't know what Tig provides that Git doesn't already do, but would love to know!	tnorthcutt	8.579193	-6.5016956	comment	4.0	19.0	1608133779	-11.859933
38638140	Git has something similar if you tur	"Git has something similar if you turn on the ""diff3"" conflict style, and I can't for the life of me understand why it's not on by default, because there are many situations where you just don't have enough information to properly resolve a merge without it."	teraflop	8.633738	-6.5186415	comment	4.0	13.0	1702531821	-11.861634
38665658	I manage a highly complex AI service	"I manage a highly complex AI service, and from time to time make config changes, and part of that duty is config cleanup -- removal and simplification. This is a necessary job in the past I have found copy-pasta where settings overrides for one environment are incorrectly copied to a similar one, leading to bad customer experience. As a personal policy, before submitting the cleanup PR, I go back in git history to when the config was introduced to understand why it was done the way it was, in case I am missing something. I call this ""paying the Chesterton Tax.""Usually its fine, though once in a while the original author gets annoyed at second guessing their work long after it was considered settled. One recent curious example was when I found a specific setting was applied for one out of a"	jldugger	8.567859	-6.502711	comment	4.0	20.0	1702745496	-11.9401455
38770793	The commit messages are terrible. In	The commit messages are terrible. In my opinion, conventional commit messages [0] should be used for a clean commit history.[0] https://www.conventionalcommits.org/en/v1.0.0/	sighansen	8.583396	-6.528485	comment	4.0	35.0	1703589660	-11.925411
38809977	If you want to preserve separate com	If you want to preserve separate commits you can just make them separate PRs?Small PRs are better since they're easier to review.	klipt	8.603124	-6.5077066	comment	4.0	22.0	1703882587	-11.840655
38809978	How do people with workflows that do	How do people with workflows that don't do any squashing do code review? To me it always seems the main consideration deciding on commit size is about being considerate of the reviewer. Don't want to harass them with huge commits but also don't want to send barrages of tiny uncontextualized changes.	phreeza	8.578581	-6.482123	comment	4.0	13.0	1703882599	-11.938992
38809997	Rebasing would be so much better if 	Rebasing would be so much better if Git just had better defaults.Having to fix the same merge conflict for each of your commits is one of the leading causes of developer burnout :D	aeternum	8.580589	-6.566993	comment	4.0	12.0	1703882699	-11.91995
38816748	I'd never heard of the :cq command i	I'd never heard of the :cq command in vim before. Seems useful, but in practice it's so unknown that things like editing the git commit message cannot rely on it and instead check whether the file has been changed. Also, reading its documentation, it probably would be better named :cqall .	gpvos	8.713222	-6.5377064	comment	4.0	16.0	1703956045	-11.749185
38821181	"Can I check a ""low-code"" implementat"	"Can I check a ""low-code"" implementation into version control, using standard free tooling? Can I, when something inevitably goes wrong, do a `git log` equivalent to spot the source of the problem? Can I then roll back to a specific commit, using off-the-shelf free tooling?I find that generally the answer is most often ""no,"" which is kinda a nail in the coffin for serious usage of ""low-code."""	ubertaco	8.591118	-6.4901357	comment	4.0	21.0	1703989131	-11.8645115
38832441	I look at commit messages every day.	"I look at commit messages every day. I actually don't love a message that just describes the code change (I can figure that out on my own if I look at it long enough). That's fine for bigger or more misleading changes, but when I'm looking at blame/history I'm usually very aware of what the code is doing already. My question at those times is less about ""what"" and more about ""why"". Why was this change made? Sometimes that can be found by looking at accompanying tests (if the original author was so gracious), but if it's not in the commit (or only obtusely so, as many developers I know tend to commit in what I'll call ""stream-of-consciousness"" style) then I've got to go outside the codebase to research by interviewing people (assuming they're still around and remember) or trawling through o"	twodave	8.566015	-6.52935	comment	4.0	22.0	1704123080	-11.917223
38835211	I've been using git happily for many	I've been using git happily for many years. Strangely enough the provenance of a commit i.e. which branch did a commit originally come has not really mattered to me very much. Mercurial provides this and they are using `git notes` to add this provenance meta-data to each commit during migration to git.I would have thought I'd need this much more, but I have not. In plain git I'll just `git log` and grep for the commit in case I want to make sure a commit is available in a certain branch.	sidkshatriya	8.553246	-6.5436387	comment	4.0	12.0	1704142245	-11.942262
38844255	I wonder if this might be an educati	"I wonder if this might be an educational issue? Maybe people are learning ""convenient lies"" about how Git works so they can get started, and don't move forward to learning the real truth of the matter?Just speaking from the perspective of someone that's used git since nearly the very beginning (and CVS and Subversion before that), Git's strong adherence to the Unix philosophy (""give enough rope to hang yourself"") was definitely a breath of fresh air compared to the restrictive systems."	chungy	8.552539	-6.4773426	comment	4.0	23.0	1704216646	-11.90289
38844343	One interesting, slightly related th	"One interesting, slightly related thing about git branching I run into every once in a while:   $ git checkout -b test
   Switched to a new branch 'test'
   $ git checkout -b test/1
   fatal: cannot lock ref 'refs/heads/test/1': 'refs/heads/test' exists; cannot create 'refs/heads/test/1'

Forward slashes are special in branch names; I'd guess because there's a filesystem representation of the branch name happening in there."	015a	8.563464	-6.5322404	comment	4.0	16.0	1704216925	-11.907583
38845189	Merging is a process that I like ove	"Merging is a process that I like over rebasing exactly because it conserves the history.With a repository server that supports merge requests and feedback from CI/CD tooling on commits/push you can motivate people to use merges rather cleanly.If you add to that very simple rules like- create branches for every feature- commit often- push often- merge only via merge/pull requeststhen even people new to Git can handle it just fine.Merge conflicts happen when multiple people work on the same file and try to merge their different status.
Imho, code bases where multiple people work on the same file at the same time have a more fundamental problem than Git.Honestly, I still struggle to see the value 
in rebasing. Maybe because I haven't used it extensively. Superficially, to me at least, it does"	riperoni	8.582328	-6.5550447	comment	4.0	19.0	1704220780	-11.909819
38878129	Name clash with an already popular o	Name clash with an already popular open-source project: https://fossil-scm.org/home/doc/trunk/www/index.wiki	self_awareness	8.493248	-6.5710506	comment	4.0	13.0	1704455120	-11.950219
38905289	"""Unfortunately popular git GUIs all "	"""Unfortunately popular git GUIs all fail on giant repositories or become unresponsive and unusable.""  I have only witnessed that in magit (or pyright) when I have super deep directory trees (say a wide dataset collection) not yet in .gitignore and then git status takes forever in cmdline or in magit. But I don't think that there is a difference between a GUI or TUI or cmdline use of git in that case.  Do other interfaces to git fail in more spectacular ways than git itself?"	pama	8.576905	-6.5137377	comment	4.0	17.0	1704662718	-11.883973
38907557	What's the main benefit of using a G	What's the main benefit of using a GUI with git for people? For me it's usually just the ease of not needing to know a commit hash to perform a rebase against after a merge, but I generally just do these ops from within an IDEs builtin git support and everything else is command line.  Do others find a huge benefit from GUIs?	Sleaker	8.571391	-6.4838834	comment	4.0	17.0	1704680553	-11.884404
38965045	Isn't It Obvious That C Programmers 	Isn't It Obvious That C Programmers Wrote Git?	medo-bear	8.564583	-6.4650126	story	4.0	3.0	1705043835	-11.878757
39057417	I've been using Sourcehut for a coup	I've been using Sourcehut for a couple years now.  One thing this outage taught me about the service that I didn't know is that Mercurial (hg) is community maintained:> We also did our best with hg.sr.ht, but it is community maintainedIt looks like git.sr.ht is hosted on OVH in France, while hg.sr.ht is hosted on High5! in the Netherlands.It's not entirely clear to me how this affects their product roadmap or support, but definitely good to know.	kyrra	8.507474	-6.5309877	comment	4.0	19.0	1705682334	-11.949911
32639096	In my mental model of git internals:	"In my mental model of git internals: I envision the initial commit stores a full copy in object store - and thereafter the states are captured as diffs. If a new file is added at a later commit stage, of course the ""blob"" will be stored, but subsequent commits will add the deltas to it - not a full copy."	srvmshr	8.628443	-6.5087256	comment	4.0	36.0	1661785084	10.316446
32668066	"""zero-tolerance performance regressi"	"""zero-tolerance performance regression policy""... no patch can land if it regresses benchmarked performance.I'm guessing the tooling around this used subversion's increasing commit numbers and it was easier to add a shim to git, than to rewrite or rethink the tooling."	tln	8.569446	-6.458506	comment	4.0	17.0	1661978442	6.3197756
32709919	Point 2, even with CI/CD multiple ti	Point 2, even with CI/CD multiple times a day, with zero flaky tests and a sweet build time and automated test time, it sounds like you still need almost zero time between the final git push and merge to $BRANCH causing a deployment.What about review? Code review? QA? Showing off to stakeholders? These things add a delay, and there is a 'crunch' around the end of sprints where things are artificially urgent. I am not sure that is optimal. I have not heard a reasonable solution to this, other than abandon sprints maybe?I think this stuff works wonders when at MVP stage and number of users < 10 maybe. For mature and complex products, the type I typically have worked on it is not ideal.	quickthrower2	8.654073	-6.5238996	comment	4.0	17.0	1662266639	5.562436
32747637	Is this something you can turn on be	Is this something you can turn on be default for Git when working with others that don’t use Difftastic, or could that lead to some weird behaviors?(I don’t know enough about the internals of Git to answer this myself.)	janaagaard	8.565912	-6.477929	comment	4.0	12.0	1662536096	-11.83462
38110918	Are people really adding their datab	Are people really adding their database dumps to git? Does that scale? Without this trick, what was the point?	6LLvveMx2koXfwn	8.586602	-6.479487	comment	4.0	12.0	1698917029	-11.892087
38116793	Nice. But technically its true. orig	Nice. But technically its true. origin/master is not master on origin. It just refers to the last known commit pointed to by origin/master, which gets updated when you fetch (pull automatically fetches).ls -l  .git/refs/remotes/origin/masterorigin/master is just a file on your system, you can see when it has been changed. It doesn't magically get updated. Do `git fetch origin` and if there are any changes, you'll see the timestamp change, and the contents:cat .git/refs/remotes/origin/masterThe basics of git are so simple, you can implement the core data structures and some operations in a day. It is really worth it to get to know these.Somehow git has managed to create a very complex user interface on top of quite a simple core.	Lutger	8.552657	-6.5095344	comment	4.0	38.0	1698945215	-11.858853
38117988	>the single command that can take yo	>the single command that can take you out of any weird situation is `git reflog` which shows you all the commits that HEAD has pointed to.Can you elaborate on why that's helpful?  I rarely get into a weird state with git but when I do it's almost always faster/easier to just delete the repository, re-clone, and re-apply my changes manually.	nvy	8.574362	-6.5269876	comment	4.0	19.0	1698949915	-11.908624
38119697	My constant git commandline annoyanc	My constant git commandline annoyance is that some commands take remote branches as `origin mybranch` and some take `origin/mybranch` .. maybe there is an arcane reason for this, but I've never seen it.	sleepybrett	8.566378	-6.5132127	comment	4.0	15.0	1698957082	-11.907678
38130074	Seems to assume that people are acti	Seems to assume that people are actively/idly waiting for CI to pass and then start the review? Or they've done the review, wait for CI to pass then hit merge?Most projects I've worked on with multiple contributors on have had a merge queue where you simply tell it to merge if/when the CI passes, then you can move on with your day.	capableweb	8.678694	-6.5036383	comment	4.0	23.0	1699024606	5.7671328
38160279	The two came out at roughly the same	The two came out at roughly the same time and for the first few years it wasn't really obvious which was better.Personally, I chose Mercurial to start with, because I liked the Windows tooling available and it felt a lot more like Subversion, which is what I used previously.However, Git won the mindshare war in the end, so I moved over to that.	gtsteve	8.53769	-6.520292	comment	4.0	19.0	1699261589	-11.927219
38160361	Yeah. From a technical standpoint Gi	Yeah. From a technical standpoint Git is a lot worse in a lot of ways. From an ease-of-use standpoint it's about as much worse as it's possible to be.Still, with Linux behind it, Git won the DVCS wars. Mercurial became an also-ran and now almost nobody uses it.Too bad.We'll need something new and innovative to come out and rid us of constant blogs explaining how Git works because it's too hard to understand how to make it do the things you want it to do.I've been using Git for about 7 years now (5 exclusively) and I know how to use it, but I still have to look things up occasionally because its UI is trash and non-obvious. I didn't have that problem with Mercurial. There, I knew the verb and the built-in help was sufficient to get me where I wanted to go.Worse is better wins again.	Espressosaurus	8.546822	-6.5368037	comment	4.0	16.0	1699262330	-11.930393
38160925	I never understood how people can ha	I never understood how people can happily figure out a gigantic, complicated code base like Firefox and are taken aback by learning a little bit about some tool. In your case, was it a thing where working with an unfamiliar tool was simply demotivating? Cause I think if you can write a Firefox patch, you should be able to learn Mercurial during breakfast.	fhd2	8.491778	-6.5589004	comment	4.0	12.0	1699267340	-11.977869
38161900	Last time I checked every alternativ	Last time I checked every alternative to Git was lacking some major feature that would immediately make it a non-alternative to me. (And I wouldn't even remotely call myself a Git power user.)For Mercurial, that was shallow clones. I haven't looked at it in a while, but a quick googling shows me a wiki page where they discuss how an implementation could look like, and it hasn't been updated since 2015.Network effects are certainly a reason git is popular. But also: If you want to challenge git, you should be able to compete with its basic features.	hannob	8.514625	-6.515437	comment	4.0	14.0	1699275141	-11.887391
38165848	> destroying Commit information just	"> destroying Commit information just to keep the graph tidy is a bad idea in my opinionThe commit information I see when telling teams to squash their branches on merge is not valuable.* ""fixing whitespace""
* ""incorporate review comments""
* ""fix broken test""
* ""fix other broken test""(note, the broken tests were broken by the changes in the PR)As soon as that PR is merged those commits are worthless.  And there are branches with dozens of those ""fixing X"" commits that would otherwise pollute the commit graph."	diek	8.580957	-6.547068	comment	4.0	19.0	1699292572	-11.991128
38166356	No, because git bisect operates off 	No, because git bisect operates off of the information in the history. And thanks to the bad rebase, the history no longer existed in the branch.	btilly	8.563091	-6.5338902	comment	4.0	16.0	1699294441	-11.885723
38167657	> why spend time on a ‘nice’ commit 	"> why spend time on a ‘nice’ commit history in a (smallish) feature branch when you can squash merge later.Several reasons:    * facilitates much better code review discussions
    * enables use of git bisect to locate bugs
    * allows for informative commit messages associated with the changes
    * communicates clearly to future self about why changes were made"	gwright	8.590404	-6.540512	comment	4.0	56.0	1699299247	-11.916498
38223373	The only git tutorial that worked fo	The only git tutorial that worked for me is the exact opposite. It even warns you> you can only really use Git if you understand how Git works. Merely memorizing which commands you should run at what times will work in the short run, but it’s only a matter of time before you get stuck or, worse, break something.https://www.cduan.com/technical/git/this tutorial was an absolute revelation for me. I can't recommend it strongly enough.Ps: I also found git destroying my work via git reset to be really annoying so I built a safety net. https://gist.github.com/chx/85db0ebed1e02ab14b1a65b6024dea29	chx	8.54729	-6.5271163	comment	4.0	14.0	1699644588	-11.8713045
38223454	Also I've always found that cp worki	Also I've always found that cp working-tree broken-tree, then git clone <new-tree> then <manually fix up files I was working on> almost always beats trying to detailed the 10 suggested SO solutions.	dboreham	8.576286	-6.467936	comment	4.0	12.0	1699644912	-11.878651
38223631	> The number of times I got stuck fi	"> The number of times I got stuck fixing (mine and other people's) git issues is way more than seems necessary.I almost never have any issues with git, I wonder if you're working differently than I do?> I have not used a merge at a workplace for so long that I forget how it works, because rebases make so much more sense.Oh, that's the reason.I've been using git almost as long as github.com has been a thing and I'm convinced that if you find yourself rebasing, _especially_ if rebasing is a normal part of your workflow, you're using git wrong.Here's how I work:    1. All development is on a features branch
    2. Feature branches are tight and focused
    3. Frequent merges from `main` to stay up-to-date
    4. Squash your branch into a single commit before merging

This gets you everything "	jkubicek	8.581223	-6.5302076	comment	4.0	33.0	1699645803	-11.920199
38350917	> should be triggered iff the transa	> should be triggered iff the transaction commitsAgreed. Which is why the design doesn't make any sense. Because in the scenario presented they're starting a job during a transaction.	hipadev23	8.703427	-6.572558	comment	4.0	12.0	1700500847	-11.860618
38368241	I didn't start my tech journey til l	I didn't start my tech journey til late 00's, so it's constantly surprising to me that something as ubiquitous as git only came out in 2005.Is it possible at all this story helped spur the widespread adoption of git (the early implementation of this tool)?	JohnMakin	8.512212	-6.446003	comment	4.0	31.0	1700592778	-11.905712
38371300	My only experience with Mercurial wa	My only experience with Mercurial was in game development. What’s used these days in arenas where large file versioning is needed?I think the ultimate answer is maintaining an asset stack containing files that allow for inherit diff chunks or however that might be described.	oktwtf	8.5156355	-6.5546317	comment	4.0	12.0	1700605533	-11.909232
38371495	Author here.> my goodness did they b	"Author here.> my goodness did they beat around the bush w/regard to their actual contribution to this process (per the title).Fair point. I came up with the title first. Then as the content grew large and diluted the essence of the title, I reconsidered, but ended up sticking to it as a shameless clickbait.> Originally, separate clones was the recommended way to do ""topic branches"" in Mercurial (not to be confused with ""named branches"").That still leaves the question ""why topic branches rather than named branches?"". For the needs of the rapid release process, named branches could have been used, but weren't. I haven't tried to contact the people involved at the time to have a definite answer. It's not /that/ important, and I'm not /that/ curious."	glandium	8.517072	-6.557283	comment	4.0	14.0	1700606392	-11.899582
38373715	Where I work it takes several hours 	"Where I work it takes several hours to get a PR past all the merge gates. If I have 5 small PRs that all build one on top of the other, it can take me the better part of 2 weeks to get them all merged, counting all the context-switching, tweaking based on comments and relaunching of the merge checks, etc.The only way developers are able to make any kind of velocity in their work is to babysit their PRs morning, evening, and night. ""Time for bed. Let me crack open my laptop and check to see if my PR made it past the merge checks. Oops, $RANDOM_CHECK failed because the server that runs it was borked. Let me kick that off again and hope it works overnight so first thing in the morning before I leave for the office I can check again to see if there's some other random failure I can fix and the"	steelframe	8.622961	-6.493225	comment	4.0	17.0	1700618900	-11.852294
38376714	GIT is a tool. Like a swiss army kni	"GIT is a tool. Like a swiss army knife, it looks tricky and you need some experience to master all what it provides. But you never actually need everything and, surely, you should also shy away from features if you do not really need them. In this respect GIT is a bit like Perl or C++. You have to apply some discipline to avoid unnecessary complexity. Personally, I have never used GIT's ""octopus"" merge support but I am sure in some situation it may well be a useful feature to have. So I respect that while scratching my head. ;)Those are basically all commands I am really ever using:git statusgit addgit rmgit commitgit branchgit checkout -t -b ...git mergeLearn those and you'll mostly good to go.Sure, I could to rebase my branches all day and make sure my version history looks ""pretty"" but "	G3rn0ti	8.571981	-6.540031	comment	4.0	15.0	1700642958	-11.916407
38393694	For me, git becomes unintelligible w	For me, git becomes unintelligible when there's a crazy train-track map of branching and merging.So I usually do whatever I can to keep a single straight-line master history.I branch off for a task, then after a while my branch isn't joined at the tip of master.  So I rebase locally until it is.  Then when the PR happens, master gets my changes added to the top, with no extra noise from merge commits.Even if the local-rebase workflow is slightly more complicated, the payoff is a really clean history, making future reasoning about branches much easier.  Not to mention merge conflicts are easier to solve when you rebase early & often.	mrkeen	8.575978	-6.5612273	comment	4.0	12.0	1700752980	-11.890357
38395165	When the entire structure of commits	"When the entire structure of commits is called a tree, I find the name ""branch"" fitting. The branch is identified by its head commit, so the path from head to root is uniquely defined and that's the branch. (Disregarding merges for now.)"	mr_mitm	8.584804	-6.5777955	comment	4.0	22.0	1700760630	-11.929121
38396747	git checkout will also happily throw	"git checkout will also happily throw away local unstaged modifications, and I would argue that it is even more dangerous because I did not have to type ""--hard"" to shoot myself in the foot."	alex_smart	8.563231	-6.4764	comment	4.0	25.0	1700768932	-11.884299
38416390	> Everything is possible with git bu	"> Everything is possible with git but nothing is easy or easy to remember.These are the commands the overwhelming majority of git users will use the overwhelming majority of the time:   clone / checkout (or switch) / commit / merge / rebase / diff / stash

Time to stop the ""nothing is easy"" fairy tale.Yes, hacking around with the reflog and fixing up weird situations with git is ... tricky and hard to remember.But the vast bulk of git usage is easy and easy to remember."	PaulDavisThe1st	8.5687	-6.517653	comment	4.0	17.0	1700943869	-11.8944845
38466596	Some people prefer CLI over GUI, me 	"Some people prefer CLI over GUI, me included. For a lot of us, GUI is really inefficient compared to keyboard-centric interfaces. You have to move your hand away from the keyboard for every little thing you want to do. I see it as analogous to the difference between spinning disks and solid state drives; one is better in almost every way, the other only has like one advantage for a subset of people.I also recommend against using git GUI for beginners just because it hides so much of what's going on, making it easy for people to stop learning after they figure out how to do exactly 2 things with it: commit and push.But honestly if we're going for ""best"" I think magit is the winner."	MountainMan1312	8.596853	-6.4834213	comment	4.0	13.0	1701299129	-11.840523
38519848	It is a merge block in some code bas	It is a merge block in some code bases. You need to know the code the person said they were going to commit is the code they actually commit. Especially when there is financial incentive and state actors that want code inserted.In my project we used to be allowed to approve with nits but recently they changed it that the code needs a re-review for almost any edits. The system has some criteria for which it will allow minor edits but it's strict enough that I've rarely seen it pass an edit. I assume there must have been some incident that triggered this.	nox100	8.596017	-6.4828477	comment	4.0	13.0	1701709563	-11.898977
38528165	"For those who resonate with ""why mig"	"For those who resonate with ""why might this be useful"", here are ""plain git"" alternatives to this tool:> searching for a function I deleted    git log -G someFunc

> quickly looking at a file on another branch to copy a line from itI use `git worktree` to ""mount"" long-running branches much to the same effect as Julias tool. To quickly look at a file from a non-mounted branch/commit, I use:    git show $REF:$FILENAME

> searching every branch for a function    git log --all -G someFunc

Note that -G can be replaced with -F for a speedup if the pattern you are searching for is a fixed string."	mbakke	8.731516	-6.4620457	comment	4.0	34.0	1701763056	-11.134517
38529367	Is there a project that does the rev	Is there a project that does the reverse of this, namely mounting a filesystem where every write to a file in the repository becomes a Git commit?	franky47	8.571519	-6.4765487	comment	4.0	14.0	1701774022	9.09671
38590291	Of course there is a room for improv	Of course there is a room for improvement... One of the biggest issues is usability/user experience: pull, fetch, checkout, commit, push, rebase - what is all this and what is the exact meaning? I need simple English terms for my work - like update and save - nothing more. Why do I need to worry about implementation details and terms? If I can not explain it to my wife, then I can not use it for binary documents which she needs to store in a repo... in this case Subversion is a better version-control-system for her documents... Just SVN Update/SVN Commit - nothing more to learn in Subversion...	pulse7	8.589986	-6.518201	comment	4.0	31.0	1702199658	-11.908124
38593116	While I feel like this is generally 	While I feel like this is generally true for most programmers and knowledge workers, Git is absolutely not suited to the workflow of several industries, including the one I work in: games.Working with an engine like Unreal Engine for a project of any reasonable size requires working with both hundreds of thousands of active files (my current project's repo's HEAD has ~400k) and hundreds of gigabytes of active files, many of which are many GB on their own.  Our repository (in perforce) is currently in the order of 10TB.Git, even with LFS and partial clone and shallow copies and fsnotify just falls apart at this scale.  Add to that the necessity for less-technical people (artists, designers, VFX, audio, etc) to use it, and it is really just a non starter.I absolutely loathe Perforce (having 	dafelst	8.579841	-6.473149	comment	4.0	26.0	1702228807	-11.878592
38593134	> doesn't capture some metadata chan	"> doesn't capture some metadata changes like renamesIf you rename the file using git and that is the only change in your file, then it works:  git mv oldfile newfile

Commit that change and the rename is in your history."	rendall	8.626181	-6.524392	comment	4.0	20.0	1702229038	7.9558115
38595049	This is a solved problem with git. I	This is a solved problem with git. I’ve worked on bigger projects than yours with histories that are so big you can’t clone them if you wanted to. I’ll make a note to drop what to google for tomorrow, but basically the history is fully available but git knows how to query it over the network. When you open a file, it loads it over the network. Remote build systems do your builds.Most of this was built by Microsoft to work on Windows with git.We moved from SVN in the late 2010’s, and holy crap man, did it change our workflows. No longer were we passing around patch files in a team for code reviews, but actually reviewing code somewhat like on GitHub. It was magical.	withinboredom	8.58274	-6.4893155	comment	4.0	20.0	1702242363	-11.832996
14712505	>Today, Git has a reputation for bei	>Today, Git has a reputation for being a tool that erases your working tree without warning if you use the wrong command.This is news to me.	hprotagonist	8.562616	-6.5024686	comment	4.0	19.0	1499364760	-11.85264
14894600	> I keep meaning to dig into Fossil,	"> I keep meaning to dig into Fossil, but I have no faith I could convince a team to use it.Developer or Fossil and SQLite here:  I agree.  In my experience, you'd have better luck convincing the team to switch from vi to emacs.  For all its many and well-documented faults, the Git/GitHub paradigm is what people want to use because it is what they are familiar with.All the same, I intend to keep right on using Fossil, thank you very much!So here is the idea I've been thinking of lately:  What if Fossil were ported or enhanced to use Git's low-level file-formats so that unmodified git clients could seamlessly push and pull against the (enhanced) Fossil server.  Call the new system ""Fit"" (Fossil+Git).  Using Fit, you could stand up a GitHub replacement for an individual project in 5 minutes u"	SQLite	8.514016	-6.498134	comment	4.0	12.0	1501525236	-11.953304
14967860	How is it rewarding? No one ever see	How is it rewarding? No one ever sees the history, honestly. Writing good code results in working code the people build off of. Maintaining clean, linear git histories does.. what exactly?	kobeya	8.561014	-6.5113873	comment	4.0	15.0	1502281427	-11.897318
14980768	What's allowing the terminal to disp	"What's allowing the terminal to display the current git branch  on the input line?What's allowing the pretty path view instead of my ugly ascii ""~/blah1/blah2$ ?"	CupOfJava	8.575096	-6.509504	comment	4.0	12.0	1502379649	-11.880261
14989303	This practice is seriously bad.It me	This practice is seriously bad.It means that one group of developers is busy improving and fixing packages, and another different group is cherry-picking commits in order to maintain the illusion of stability (as mentioned above).That second group has to duplicate all the testing work done by the first group, and additionally ensure that there are no new problems introduced.It's very vulnerable to human error and adds a lot of unnecessary work.	lotsoflumens	8.700418	-6.502783	comment	4.0	22.0	1502457380	9.403238
15078938	What I really want is Subversion, bu	What I really want is Subversion, but then without all the bugs and the weird file locking. And with easy release branches and a way to make commits locally and then share a bunch of them at once with my colleagues.Of course no such thing exists, so I use Git which has these features but combines them with 10x worse UX and 10x more condescension from the community. But I put up with that, only because it's the lesser of two evils.I can't imagine I'm alone in this.	skrebbel	8.620732	-6.452794	comment	4.0	12.0	1503468627	-11.870121
15208080	What was distinctively git-like abou	"What was distinctively git-like about it that makes that connection more meaningful than ""it was a version control system""?That is, what made it Smalltalk's git, and not, say, Smalltalk's CVS or ClearCase? The linked-to page suggests that ENVY used a centralized system. (Eg, ""The Git model is better for distributed development"" and ""it had a small process that ran on a server to manage record locking"".)Consider also some of the limitations in ENVY. ""You would bring your changes to the machine in the form of (IIRC) a list of RCS-like versions of individual methods, then review and merge them with latest."" and ""What wasn’t available, was automatic merging""."	eesmith	8.599416	-6.4434633	comment	4.0	15.0	1504978261	-11.861192
15216359	Gmaster – git client with semantic d	Gmaster – git client with semantic diff	fmavituna	8.665633	-6.513365	story	4.0	11.0	1505110373	-11.805821
15263863	> Graphs of non-linear history, “tra	"> Graphs of non-linear history, “train tracks”, can be intimidating. They certainly felt that way to me to begin with, but there’s no reason to be scared of them. There are many magnificent tools that can analyse and visualise complex Git history, both GUI- and CLI-based.It's a pity the author doesn't mention some of those magnificent tools. Some tools I know/use:  CLI: tig
  GUI: gitg, qgit (Linux)

Any others?"	shock	8.560875	-6.4774575	comment	4.0	13.0	1505555853	-11.864242
15263869	Magit (fantastic Git mode for emacs)	Magit (fantastic Git mode for emacs) is running a crowdfunding campaign	altschuler	8.62127	-6.464467	story	4.0	27.0	1505555992	-11.757689
15264041	There's a more nuanced approach to g	There's a more nuanced approach to git rebase. You should use it the other way around - switch to your feature branch and `git rebase master` to update your branch and resolve conflicts. Then test it and `git merge`. I also use git rebase to tidy up the branch's history - generally not entirely squashing it, though.	ddevault	8.580927	-6.5685887	comment	4.0	17.0	1505559285	-11.921889
15286504	I still think git-cola is one of my 	I still think git-cola is one of my favourite Git Ui's. Anyone know any other good ones?	timlyo	8.582891	-6.4664073	comment	4.0	19.0	1505840885	-11.861461
15293581	How is it that git still doesn't hav	How is it that git still doesn't have machine readable output built in?	stephenr	8.557005	-6.456013	comment	4.0	15.0	1505914885	-11.862834
15336200	As a former mercurial user, it absol	As a former mercurial user, it absolutely drives me nuts when people rebase already-pushed commits. I get that this is the norm in a lot of git workflows, but it still makes me twitch!I prefer to rebase liberally before pushing commits, and then merge once commits have landed in a shared repo or been pulled by others. No git --force necessary.	echlebek	8.579798	-6.559623	comment	4.0	13.0	1506400461	-11.939069
15371617	Git Log in HTML: A Harder Problem an	Git Log in HTML: A Harder Problem and a Safe Solution	chubot	8.5422	-6.4409556	story	4.0	25.0	1506754257	-11.854941
15377036	The advice here given to avoid using	"The advice here given to avoid using ""master"" branch for development, and advice to create non-default branch named ""develop"" (or variations thereof) is quite harmful.If you must have a ""release"" branch or ""stable"" branch, ok, go for it, but leave the ""master"" for developing. Why? Strive to have sane defaults.Frankly, the idea that somebody must check out some extra special branch after cloning repo in order to start properly developing, is not sane."	watt	8.515067	-6.534703	comment	4.0	32.0	1506850305	-11.756802
15377203	I always advocate workflows where me	"I always advocate workflows where merges never happen.To me, the 'git log' of a master branch is like a history  book about the repository. When you read through it, it should give you answers to the questions ""what was changed, why, and when"" in  as clear format as possible.Now, I've read most of the arguments trying to show that merges are the way  to do just this, instead of rewriting history with interactive rebasing. I won't repeat them all here, but just want to ask this: when one reads a real book about real world history, does it look more like git log history of a repo which has been using rebase, or merge?"	shandor	8.581028	-6.5575404	comment	4.0	15.0	1506854046	-11.918392
15413368	This only seems to work in practise 	This only seems to work in practise for tools that are very small, otherwise exceptional writing is required (which, by definition, will rarely occur). I can't imagine (to pick a particularly extreme example) that anyone has ever learned to use git by reading the man pages.In contrast, even features in pretty poor GUI apps are by default generally discoverable.	crispinb	8.551199	-6.498491	comment	4.0	19.0	1507246334	-11.873524
15418646	Nicely explained.On a side note, I n	Nicely explained.On a side note, I noticed with deep satisfaction that “git” is used as some kind of curse in the land of Lisp.	tempodox	8.556892	-6.4708586	comment	4.0	12.0	1507311540	-11.864594
15459450	Odd. It's surprising to me that this	Odd. It's surprising to me that this example runs out of memory. What would be a possible solution?Admittedly I don't know that much about the inner-workings of git, but off the top of my head, perhaps something with traversing the tree depth-first and releasing resources as you hit the bottom?	warent	8.570287	-6.50631	comment	4.0	17.0	1507827871	-11.905482
15566143	Why does everyone rethink a working 	"Why does everyone rethink a working strategy. Write lots of unit tests that are fast. Write a good amount of integration tests that are relatively fast. Write fewer system integration tests that are slower. The testing pyramid works. He even talks about it in this post, and then ignores the point of it.You write lots of unit tests because you can run them inline pre-commit or in a component build. If you integration tests are numerous and interesting enough, that won't work. They are better suited to gating feature branch merges. System integration (the actual name for ""end to end"") take longer and usually gate progressively more stable branches upstream, or nightlies depending on where you are."	throwaway5752	8.654819	-6.535191	comment	4.0	22.0	1509085321	-11.900693
15703573	I bought this up on HN  in the past[	"I bought this up on HN  in the past[1], but it gets instantly downvoted( by gitlab employees?) , my comment was a response to CEO claiming how their marketing is honest[2].They also declared Gitlab CI as number one CI by excluding Jenkins because of their made up defintion of ""modern"" .1. https://news.ycombinator.com/item?id=15590240
2. https://news.ycombinator.com/item?id=15589654"	dominotw	8.558868	-6.4716625	comment	4.0	20.0	1510752685	12.014291
15751233	Why is this a single commit? I would	Why is this a single commit? I would expect renaming like that to be done in completely separate commits and then subsequent commits to do any fixups.Is it just a merge commit? I imagine it's probably unfair to blame Linus for this (assuming it's a huge merge), but it would also weird for you to point to a merge commit as evidence of the opposite.Color me confused.	lomnakkus	8.614794	-6.5010414	comment	4.0	31.0	1511295988	-11.875549
15753788	I am a cranky old contrarian. I do n	I am a cranky old contrarian. I do not like huge monopolies or monoliths. Github in itself is fine, but it rubs me the wrong way how huge and all-pervading it has become - a sort of Facebook for coders.Fossil avoids all that, and is, of course, orders of magnitude more manageable than Git. For years, I have been using it for all sorts of personal record-keeping. All sorts - code, yes, but also notes and manuscripts and sketches and what have you. Super-handy tool, with baked-in wiki and ticketing, and everything neatly packed in a single SQLite-file.Mind you, the new encrypted Git-service in Keybase is sitting there, calling my name.	interfixus	8.528871	-6.4493794	comment	4.0	40.0	1511318586	-11.866378
17307650	This is scary. Are there any orgs we	This is scary. Are there any orgs we can support that are against big merges like these?	simplify	8.688353	-6.4841833	comment	4.0	20.0	1528929877	9.265533
17318587	I see a lot of people complaining th	I see a lot of people complaining this doesn't support Git. To me this is an advantage.Source control is essential for managing code but for handling a few text files on a blog it's probably unnecessary overhead.Also most people aren't programmers, there is a large audience who could edit a markdown file but have no idea what Git is. I'm sure I could teach my mum markdown in an hour or so but there is no way she could ever grasp Git.	tonyedgecombe	8.617991	-6.469156	comment	4.0	17.0	1529056059	-11.873072
17324095	Hey there. I'm the developer who mad	Hey there. I'm the developer who made the POC. My original idea came after watching non-technical people try to make changes to the readme. They would have to ask for a lot of help to get the terminal open or use a GUI. When really all they wanted to do was make a quick change.The idea is that there's a lot of different users using git and I want to make it accessible for everyone.	jakecodes	8.567445	-6.483633	comment	4.0	13.0	1529101046	-11.879229
17327053	I wasn't even aware that Git is capa	I wasn't even aware that Git is capable of merging from more than N=2 parents (technically a three-way merge) ...Is this a relatively new feature? And what is the use-case for N>2?	amelius	8.594896	-6.540061	comment	4.0	19.0	1529149946	-11.897017
17355013	(front end js)My new favorite tool i	(front end js)My new favorite tool is the ridiculously named husky package, which allows for configurable git hooks inside of package.json.  Specifically what I'm doing now is precommit eslint and prettier, and prepush test:all i.e. people on my team will be unable to commit if they fail lint and unable to push if they fail unit tests.  There's of course positives and negatives to this approach but the former significantly outweigh the later in my experience.	cozuya	8.611021	-6.481391	comment	4.0	13.0	1529500420	9.43663
17415275	Yet another file in the .git directo	"Yet another file in the .git directory. The work is impressive and certainly helpful, but I can already hear Fossil proponents say ""just use SQLite"", which is getting more and more true."	rakoo	8.480402	-6.5734115	comment	4.0	33.0	1530177338	-11.971118
17459515	Forcing any commit to be a PR merged	Forcing any commit to be a PR merged by another dev would have solved it	Buetol	8.595394	-6.461333	comment	4.0	23.0	1530739560	-11.885811
17487637	Can someone who has more context aro	Can someone who has more context around this commit explain what is going on here?What does this commit do?Why did this commit get accepted in the commit history tree published at android.googlesource.com?	foo101	8.582583	-6.4673033	comment	4.0	14.0	1531104821	-11.877466
17519886	The commit messages across the entir	The commit messages across the entire project are... alarmingly insightful. There's some detailed stream of consciousness stuff in there.	kgbier	8.589551	-6.550681	comment	4.0	31.0	1531444950	-11.915643
17580584	Git's UX is horrible for people who 	"Git's UX is horrible for people who don't know git, i.e. git beginners.  All the documentation and error messages are written as if the user is already intricately familiar with the inner workings of git.  As a result, it's very hard to learn because you don't know what you're about to do without hours of googling cryptic error messages.Perfect example that happened to me today:    $ git push
    fatal: The current branch insert_branchname_here has no upstream branch.
    To push the current branch and set the remote as upstream, use

    git push --set-upstream origin insert_branchname_here

What does it mean to ""set the remote as upstream""?  That phrase makes no sense to me.  Is that going to overwrite master on origin?  I have no idea, but I'll be damned if I am going to hit enter and r"	na85	8.555269	-6.514889	comment	4.0	21.0	1532144497	-11.895503
17631657	"Seeing this my first thought was ""Oh"	"Seeing this my first thought was ""Oh cool, so you format your git commit messages in a certain way, and then this tool will automatically generate changelogs for you.""... but it wasn't that (rather, just good arguments and suggestions).And now I'm wondering if my first thought is a thing?  And if so, how it has worked out for users."	fpgaminer	8.585536	-6.5132008	comment	4.0	14.0	1532754568	-11.888917
17632862	Don't use push --force, use push --f	Don't use push --force, use push --force-with-lease. Then you avoid accidentally undoing unexpected new commits on the remote.	0x0	8.572467	-6.535786	comment	4.0	15.0	1532780895	-11.876833
17689537	Seeing a former coworker use Magit i	Seeing a former coworker use Magit in Emacs is what got me to look into the Vim version: https://github.com/jreybert/vimagitFrom what I gather it's nowhere near as feature-complete, but it lets me create commits with immense ease and precision.	nkantar	8.737818	-6.4413204	comment	4.0	12.0	1533440257	-11.619068
17695839	Is there a similar tool that can run	Is there a similar tool that can run as a pre-commit hook and prevent it from happening in the first place / after this scan?	Cthulhu_	8.649991	-6.535983	comment	4.0	12.0	1533541789	-11.872328
21025964	This might have a serious use. I hav	This might have a serious use. I have a private repo that I worked on with my daughter. If I open source it, ideally I'd keep the chronological history but scrub her email address out of it. It's OK that all the commit hashes would change. Would I want to adapt this joke tool to that purpose, or is there an exiting tool for rewriting history that way?	brlewis	8.57229	-6.491505	comment	4.0	14.0	1568982891	-11.874791
21191983	You need to add `git stash` to move 	You need to add `git stash` to move to a different branch while having changes wide open.You also need `git log` with all sorts of arcane options if you actually want to use the history.	simiones	8.554489	-6.568694	comment	4.0	16.0	1570541014	-11.91706
21192822	I'm personally a huge fan of https:/	I'm personally a huge fan of https://www.gitkraken.com/ (I also used to work there.) Don't have to memorize git cli commands and get beautiful visuals on top of that.	JamesQuigley	8.563818	-6.4511533	comment	4.0	15.0	1570545688	-11.865957
21265271	Hey guys, looking for feedback on th	Hey guys, looking for feedback on the essential concept of the idea. I'd like to hear from real programmers whether they understand what DitaBase is and whether they think they would use, either now or in the future.It's been difficult to explain DitaBase, and I still don't know if that's because its actually a terrible idea, and much too complicated. If it is a good idea, then I think sometimes good ideas look complicated like this until people figure out how best to explain them. You wouldn't have expected the internet, or say, object orientation, to be instantly and clearly obvious what it is when they were first being talked about, and that is how I see DitaBase.Its basically that DitaBase is 4 essential concepts: schemas, validation scripts, conversion scripts, and public version cont	IsaiahShiner	8.666289	-6.504086	comment	4.0	20.0	1571182329	10.144086
21288994	`git commit -m “added factoryboy to 	`git commit -m “added factoryboy to generate random target coordinates to test the launch sequence.”``git commit -m “Fuck fuck fuck, forgot to replace the launch API endpoint with a mock one.”`Scrum master: “Let’s implement the stuff with the highest customer value first.”Developer A: “I guess that means being able to launch the nukes.”Developer B: “Yeah. Auth can come later.”Developer C: “Nobody answered us about how they want the abort sequence to work. I guess we’ll defer it to the next sprint.”	k_sze	8.570554	-6.4918694	comment	4.0	14.0	1571377679	-11.876165
21289995	Should have been in a doc or wiki in	Should have been in a doc or wiki instead of commit message.I have never seen any dev searching for error messages in commit messages.For the rest of the points (makes smarter, builds trust and compassion), if it's so worthy put it on the blog (like this blog post itself) so it can has a potential to reach some reach some audiance.	codegladiator	8.589678	-6.535687	comment	4.0	18.0	1571392831	-11.903508
21290084	In the same vein, I wish there would	"In the same vein, I wish there would be a standard workflow for putting code inside commit logs.The typical use case would be database migration scripts : IMO they are always a pain to version properly because fundamentally Git and all the other software versioning tools let you describe the  ""nodes"" (in the graph theory sense of the word) of a codebase (""at commit A the code was in this state, at commit B it was in the other state""), but severely lack when it comes to describe the edges between nodes (""in order to go from state A to state B, you need to execute this code"")I think the temporal dimension of software engineering is still poorly understood, and severely undertooled."	Darkstryder	8.588216	-6.52999	comment	4.0	14.0	1571393876	-11.902296
21290256	To me they are red flags because it 	To me they are red flags because it means that very likely who writes this kind of commit messages doesn’t use a proper issue tracking system.	tigershark	8.590044	-6.511152	comment	4.0	15.0	1571396239	-11.906258
21290416	> I don't want your entire life stor	> I don't want your entire life story in my commit log.Then I never want to work with you ever (or any code base you ever touched) because of your laziness and lack of experience working with huge code bases where long commit messages are life-saving. Also you don't care about your colleagues and long-term maintainability.Debugging bugs for months and weeks because of lack of proper commit messages is the most frustrating experience.	kissgyorgy	8.582307	-6.512047	comment	4.0	17.0	1571398557	-11.911913
21290529	>> I don't want your entire life sto	">> I don't want your entire life story in my commit log.
>Then I never want to work with you ever (or any code base you ever touched) because of your laziness...What an incredibly aggressive response."	kyberias	8.573771	-6.5010557	comment	4.0	12.0	1571399741	-11.903253
21312138	Conversely, this is a massive indict	"Conversely, this is a massive indictment of the git user interface.People used to talk about ""CASE tools"": Computer Aided Software Engineering, by analogy with the CAD tools that replaced physical drawing tables once the technology got good enough. I joke that certain tools are ""computer impaired software engineering"", and git can certainly belong in that category at times.What we have built is a tool with a good internal model but  a user interface that it's easier for you to not use a computer, to step away to the whiteboard, in order to work out what to do.We don't tolerate this for, say, word processors; people don't go to a piece of paper to lay out their headings and only then work out the incantations necessary to achieve that result.(Has anyone attempted to make a ""transparent porc"	pjc50	8.556027	-6.493092	comment	4.0	19.0	1571665449	-11.901113
21312471	I don't think it's an indictment sin	I don't think it's an indictment since it's a clear tradeoff. Yes git isn't intuitive or self explanatory for newcomers, but that's only because it's optimised to be maximally efficient for experienced users.To me, this is a sensible decision. The target users of git will use it day in and day out for decades, in this case it makes sense to prioritise experienced usage. For onboarding new users there are plenty of good tutorials, and I think in the long run it makes sense to put the legwork in with those, rather than switch to a more intuitive but less efficient porcelain.	intarga	8.546918	-6.4964194	comment	4.0	13.0	1571667275	-11.935624
21338538	"This is great.
Is there a tool to do"	"This is great.
Is there a tool to do this?I mean, can I edit the times and the authors and create a history that I need with some software? Or did the author painstakingly go in and manually look up all the dates and make the commits? And then roll back for an error and just keep going?The issue is how would you change a single commit from 8 commits ago if there was an error there?And then how would you visualize the whole thing just to keep it straight in your head?"	omarhaneef	8.594737	-6.520084	comment	4.0	14.0	1571861959	-11.885271
21370700	Git can already do that with subtree	Git can already do that with subtree, no other tools needed.	minxomat	8.561405	-6.469052	comment	4.0	15.0	1572193708	-11.929405
21392858	Hm, I was hoping there would be high	Hm, I was hoping there would be higher-level differences than that. Like maybe the notion of having an index and staging area would be fundamentally different (or absent), or the notion of committing locally and pushing remotely would be fundamentally different, or something like that. Which is not to say command names aren't also confusing in git ('git add' to remove a file is my favorite), but they're not really where I imagined the substantial differences would lie?	mehrdadn	8.579058	-6.526134	comment	4.0	50.0	1572388740	-11.9098625
21393587	Since everyone is talking about what	Since everyone is talking about what is better about Mercurial compared to Git.I would like to know what git does better than mercurial.	NilsIRL	8.514375	-6.544793	comment	4.0	19.0	1572396115	-11.939343
21394460	I mostly agree with two exceptions:-	I mostly agree with two exceptions:- [Major] I feel (but could be potentially convinced otherwise?) that there is one very deep fundamental flaw in the semantic model, and that is the fact that the identity of a commit depends on its history. I simply do not understand why this has to be the case. If I later discover a ZIP backup of the tree that I forgot to commit, and I want to insert it into the history, it shouldn't suddenly completely break the entire repo. Of course it seems fine to have a hash that depends on the history, and it's very likely useful for many purposes, but that shouldn't be the primary mechanism for identifying commits. By default, I think the identity of a commit should be defined by a hash of its contents only, but independent of its history. This would (among othe	mehrdadn	8.590956	-6.522156	comment	4.0	31.0	1572406407	7.2951202
21418763	Other version control software has w	Other version control software has way simpler syntax and workflow. Subversion for example. The complexity of git makes total sense if you indeed have a complex, multi-HEADed project like the Linux kernel. But most software isn't Linux.	bildung	8.570945	-6.4683423	comment	4.0	17.0	1572616435	-11.88708
21418744	Git is the simplest, low friction, l	Git is the simplest, low friction, low cost, low everything above file storage. How can there be something simpler atop an existing file system (I know there are some versioning file systems but I've never used them). I use git for practically anything I do. I to git init and I have my project versioned and I can but don't have to even add messages to each of my versions. You don't have to use anything else if you don't want to but you have so many options if you need them. You don't have to even use git on line if you don't want but if you do there are multiple (even open source) git repositories with free private repos. What is there not to like?	kungito	8.582426	-6.452206	comment	4.0	21.0	1572616291	-11.888845
21419308	The real genius of git is the clear,	The real genius of git is the clear, concise user interface for that data structure.(for those with a severe sugar hangover, I'm being a little bit sarcastic)	maxerickson	8.565486	-6.477013	comment	4.0	55.0	1572619142	-11.881999
21418885	The git storage structure is not tha	The git storage structure is not that difficult. People could implement their own compatible clients on top of it with a quite different UI. That there is nothing that overtook git as UI in popularity seems to be an indication that the interface is not as bad as many people claim.	adrianN	8.5538025	-6.48258	comment	4.0	12.0	1572616921	-11.904704
21423782	> However they were slower - but not	> However they were slower - but not muchCVS was much much much slower; multiple branch handling was horrible until ~2004 (and even on a single branch you did not have atomic commits). Also, no disconnected operation.SVN was only a little slower than git, but didn't have disconnected operation, and horrible merge handling until even later (2007 or 2008, I think)Bazaar 2 was, at the time, while comparable in features, dead slow compared to git. But it also sufferend from bazaar1 (branched from arch=tla) being incompatible with bazaar2 and an overall confusing situation.Mercurial and Git were a toss-up. Git was faster and had Linus aura, Mercurial had better UI and Windows support. But all the early adopters were on Unix, and thus the Linus aura played a much bigger part than the Win32 suppo	beagle3	8.605982	-6.5435452	comment	4.0	12.0	1572643010	-11.886214
21434159	How do you find the commit hash that	How do you find the commit hash that is the last known good? Looking through jenkins release logs, asking someone, something else?	mooreds	8.633482	-6.518965	comment	4.0	30.0	1572792682	-11.908693
21746209	Staging (and committing?) parts of a	Staging (and committing?) parts of a hunk is cool and I have done this many times myself.  However, I am always uncomfortable with it because I am unsure how to incorporate it within the overall workflow.  I'd like each commit of mine to at least compile and pass some tests.	sigjuice	8.674733	-6.574749	comment	4.0	13.0	1575923619	-11.925322
21755731	I always assumed the state of the in	I always assumed the state of the index is stored in the binary file `.git/index`, and that mutations of the index overwrite this file. Is this not accurate?	akkartik	8.572271	-6.5269594	comment	4.0	14.0	1576004756	-11.89726
21755592	> Notice how just `git add`ing a fil	> Notice how just `git add`ing a file saves its content to the objects directory. Its content will still be safe inside Git if the user deletes data/letter.txt from the working copy.Holy crap, how do I not know this in 14+ years of working with git?!The `git add --help` manpage seems to make no reference to this feature, it just talks about adding the file to the index.	akkartik	8.570724	-6.5029616	comment	4.0	29.0	1576004016	-11.901806
39084350	Google and Facebook both use trunk b	Google and Facebook both use trunk based development for nearly all code at both companies.This guide advises you to consider trunk based development if your release cycles are less than ~4 weeks. I'd suggest doing it no matter what. The only place where I've run into problems with this was managing very long term hold outs where we wanted to avoid changing user visible behavior. Instead of branches, we maintained literal copies of all the files for multiple years. I don't think revision control is the right place to solve that problem though, because there were no clear service boundaries to decide what things to pin, we just did it in an adhoc way.	mgraczyk	8.611548	-6.4861174	comment	4.0	23.0	1705881327	-11.853148
39084466	I work at a place that has a few ver	"I work at a place that has a few very large code bases, we use trunk-based. I will never go back, ""what is your git workflow?"" Is a question on my list of things to ask potential employers now and the only good answer is ""trunk"". So much mental load is wasted on these other strategies."	pard68	8.5725975	-6.508755	comment	4.0	22.0	1705882256	-11.885651
39084602	I'm not really sure what the mental 	"I'm not really sure what the mental load is but having gone to Trunk felt like a mistake, I don't know if it was just designed wrong at the last place I worked at, but we have to do more than normal per release, and I'm not a fan of squashing commits, it means I can't just go back to a branch and merge the development branch back into it, I have to check out a brand new branch. I also preferred having ""master / main"" and ""development"" because if QA claims there's a bug introduced during the development phase, you can figure out if it's already in the main production branch or if it truly was introduced during development. Which is something you can't really do with ""trunk based development"" it's like all these people who praise it should just switch to SVN instead?"	giancarlostoro	8.620466	-6.5273614	comment	4.0	18.0	1705883454	-11.840455
39088717	Perforce seems to already fill this 	Perforce seems to already fill this niche pretty well, at least in the gaming sector which this startup seems to target.	throwaway63467	8.64562	-6.4748178	comment	4.0	20.0	1705926233	13.813657
39089041	> I often wondered why Git is so dif	> I often wondered why Git is so difficult to learn, compared to other tools.Yes! This is something many people wonder -- other than those who love git :) I used to love Mercurial and I still mourn its mostly-loss. So I welcome a new DVCS system that is friendlier than git.> Diversion’s code is managed on Diversion!This is a good sign.> can synchronize with existing Git repositories (each new commit in Diversion goes into Git, and vice versa)Can you expand on what this means please? Does it simply mirror, or is it feature-for-feature compatible? Is it a backup capability?> still using legacy tools like SVN and PerforceI won't argue re SVN, but Perforce? It's used in the game industry primarily for its excellent handling of binaries / large binaries. How well does Diversion handle that kind	vintagedave	8.547539	-6.50646	comment	4.0	13.0	1705928609	-11.930973
39089846	Disclaimer: I am designing a Git alt	"Disclaimer: I am designing a Git alternative too.Maybe ""cloud native"" will have a pull for game companies, but I am not so sure. I think a lot of studios would want to self-host.""Git compatible"" is an interesting phrase; does Diversion use the same type of backing store? If so, I am not so sure it will handle large files as well as hoped.I had to solve this problem myself, and I did, but it required a different storage design.Can it handle binary files? Is there a plan for doing so beyond ""commit the entire file every time"" or ""use xdelta""?I think this is how fourth gen version control systems will be defined. Game studios have a lot of binary assets, so this will be important.All in all, I could see a product like this succeeding, but I think taking VC money was a mistake because there ma"	gavinhoward	8.55153	-6.4765835	comment	4.0	18.0	1705933671	-11.888504
39137005	Yes, I understand. The reason that I	"Yes, I understand. The reason that I disagree is because of the number of times that having greater granularity than that has been enormously valuable.In my opinion, a VCS should maintain a history of all commits, because it's impossible to know which commits will be the key to solving a problem in the future. Even commits that are later reversed can occasionally be of tremendous value.A truly great VCS would allow you to do a ""visual squash"", hiding the intermediate commits unless you need to see them."	JohnFen	8.578753	-6.53421	comment	4.0	14.0	1706225978	-11.918862
39140564	Same. I'll also add that this compan	Same. I'll also add that this company's policy of prefixing commit messages with ticket IDs was a godsend. I could trace confusing business logic to a meeting and specific people. It made a big refactor possible. Not easier, possible.Even as a solo worker, descriptive and atomic commits are valuable. They make merging or reverting changes a lot easier.	nicbou	8.565031	-6.5044765	comment	4.0	16.0	1706261775	-11.956904
39152517	Inside .git	Inside .git	mfrw	8.5439	-6.4700384	story	4.0	86.0	1706329088	-11.908897
39218309	I despise squashs. It encourages peo	"I despise squashs. It encourages people to tread git commit as a glorified ^S of their work.You want to know why a change was made, or who so that they can explain it. You land on a blob of a diff, with no meaningful commit message (any commit message was squashed to /dev/null to be replaced with the MR title and description). And then off you go to the corresponding github/gitlab/whatever MR only to find a wall of ""hmmmm"" ""why no work?"" ""try something"" etc commits."	tuetuopay	8.57377	-6.56969	comment	4.0	13.0	1706807445	-11.944087
39218368	> I think the disadvantage with this	> I think the disadvantage with this style of documentation is you can't really alter the commit message after it's written.That is not a disadvantage. The commit is a historical record, if I come back to that commit 3 years later I want to know its purpose in the context it was in, I don’t want a whitewashed history.> Compare that with documentation stored in a .md file, or even a Wiki or even Confluence. My colleague can write something and if I see a way to improve it I can go ahead and do that, and other colleagues can improve on what I've written.That’s like comparing a bicycle and a goose.> But I also myself find it tempting to describing the design of a particular component when I commit that component, and that's something I now avoid.That’s a shame. Knowing the considerations (or 	masklinn	8.587359	-6.5232077	comment	4.0	13.0	1706807683	-11.90453
39218591	That first line of the commit messag	"That first line of the commit message is most important so that `git log` can address chesterton's fence.  And IMHO in this case the committer whiffed.The key is not to put what you did in that first line, but why.  Anyone interested in what can just look at the code, perhaps via a diff.So something like ""nginx .conf files must be in us-ascii""Then ""changed blahblah.erb to remove nonbreaking space character""Then the rest of the commit message which is quite good.Think of it as a news article: write in decreasing levels of importance and increasing levels of detail, assuming the reader could stop reading at any point."	gumby	8.595533	-6.5252047	comment	4.0	18.0	1706808608	5.74613
39218769	If writing good commit messages isn'	If writing good commit messages isn't specifically defined as part of your job, why would you waste business hours writing commit messages that are beyond what is expected of you and frankly useless since nobody would ever read it anyway?	herrkanin	8.578318	-6.5275903	comment	4.0	19.0	1706809353	-12.003623
39237668	Git Query Language	Git Query Language	fagnerbrack	8.579791	-6.489244	story	4.0	39.0	1706936539	-11.883324
39237239	Doesn't it strike you as odd that de	"Doesn't it strike you as odd that devs get ""lost"" often enough to need this ""feature""?I've used CVS, SVN, hg, bzr, and git.  Why does git stand alone as the only VCS where devs need so many foot bandages?"	notdonspaulding	8.567699	-6.452786	comment	4.0	15.0	1706930125	13.84994
39237247	"> WTF is ""detached HEAD""? I've looke"	"> WTF is ""detached HEAD""? I've looked it up dozens of times, and as soon as I get past whatever I'm working on, I forget what it means. I don't know what the reflog is, other than that it has to do with some dark internals.I could answer, but I don't think you're actually asking for someone to explain it to you.I did want to offer a different opinion though. I like detached heads, they are unnamed branches, the first thing I do when working on something new is make a detached head and get to work, making commits, etc, if I decide the work is worth keeping, then I will name the branch. As some smart people have said, naming things is hard, I don't want to name a branch before I'm sure what it is or that I'm going to keep it. Having a bunch of commits that are not part of a branch might soun"	Buttons840	8.552802	-6.538089	comment	4.0	16.0	1706930271	8.906406
32881350	Magit is an excellent and widely use	Magit is an excellent and widely used Git TUI.	snicker7	8.631921	-6.47208	comment	4.0	25.0	1663447127	-11.749387
32887097	Ah, but you're not really approving 	Ah, but you're not really approving a patch. You're approving a series of changes, and specifically their motivations. That's why git history is important. Complex code is meaningless without an understanding of what motivates it.	boltzmann-brain	8.592783	-6.476604	comment	4.0	12.0	1663505378	-11.846311
33043807	it's way easier to revert the merge 	it's way easier to revert the merge commit than potentially every commit that was included in it.having everything squashed into one commit can be annoying if the commit is too large, because it can be hard to identify why a specific change was made via git blame.With a merge commit, I can make individual commits for logical changes, potentially rebasing, or squashing commits together. that also gives an opportunity to write more intentional and informative commit messages.  once i have a good changeset, I can publish a single PR for review.I've only really taken to this approach lately,  for a long time I just didn't care.  As the years go by, I care more and more about what git blame can tell me. I've been maintaining some projects for a long time, and I've had to pick up many projects t	chrsig	8.580698	-6.5341196	comment	4.0	14.0	1664597587	-11.92336
31793263	I suppose the biggest problem is tha	I suppose the biggest problem is that the concept of SCM/VCS is just not simple enough to make both easy and useful/advanced at the same time.You can have a 'pull, merge, push'-only system, but at that point we're re-inventing subversion. So making it more advanced would mean we also need to have the knowledge and skills to do other activities correctly and that means the tooling can't make as many choices for you because there simply isn't a default way that works all the time.Most efforts at git-alternatives run in to the same problems and either they'll be just as advanced and have the samen benefits and downsides or they end up less advanced but now it's not equally useful and you can't really make it work right.	oneplane	8.571767	-6.4642544	comment	4.0	64.0	1655582332	-11.910729
31793349	> but at that point we're re-inventi	> but at that point we're re-inventing subversionSo? Maybe Subversion is all most developers need?	pan69	8.613687	-6.4577203	comment	4.0	44.0	1655582865	-11.858122
31793693	Git makes sense for the Linux kernel	Git makes sense for the Linux kernel and merging patches at scale. 99% of software development would be fine with subversion	abirch	8.555787	-6.443945	comment	4.0	26.0	1655585270	-11.879987
31794857	It's crazy how people forget the pas	"It's crazy how people forget the past. Back in the day, git was ""rewrite, rebases modify past to make beautiful commit"" vs hg ""rewriting past is bad, beautiful commits are lies about history"". Turns out people don't care about truthful history.(Nowadays mercurial can do rebase/amend just fine.. But it is too late)"	theamk	8.574432	-6.550302	comment	4.0	15.0	1655596299	-11.901696
31853015	Is there an explanation of what woul	Is there an explanation of what would go wrong with the naive approach? E.g.:- Change the binary file format in repos to support arbitrary hash algorithms, in a way which unambigously makes old software fail.- Increment the Git major version number to 3.0- Make the new version support both the old version repos and the new ones. Make it a per-repo config item that allows/disallows old/new hash formats. In theory, there's nothing wrong with having objects hashed with mixed algorithms as long as the software knows how to deal with that.- The old format will probably have to be supported forever because of Linux.Most user-facing utilities don't care what the hash algo actually is, they just use the hash as an opaque string.	ivoras	8.68865	-6.548333	comment	4.0	16.0	1656007853	7.216542
31874517	My mental model of a git repo is bas	My mental model of a git repo is basically a bramble bush with labels on it.The bramble stems and branches are the commit history (which may join and well as split, unlike a bramble). The labels are stuck to particular bits of the bramble. Some labels are even stuck to other labels!You can move the labels around, and you can glue extra bits of bramble to the tips of what you have. You can even hack about with the bramble, but this is not recommended. Label moving often happens automatically, e.g. when 'growing' a bramble tip.It gets interesting when you compare two brambles (e.g. remote and local repos). You might determine that one bramble is identical to another, just with the labels moved. Or one bramble is the same as the other but with extra stems added. Or both brambles had a common 	somewhereoutth	8.568023	-6.4969163	comment	4.0	29.0	1656158569	-11.865343
31876799	> Git is hard: messing up is easy, a	> Git is hard: messing up is easy, and figuring out how to fix your mistakes is impossible.Hyperbolic.Fixing mistakes is easy if you understand the underlying data structure. Once you can conceptual map the structure into the intended form, you figure out what operations (verbs) you need. Then it’s a matter of mapping the operations into concrete command lines.	unicornmama	8.544013	-6.49533	comment	4.0	32.0	1656176161	-11.944089
31924875	"> 
When I first used Git it drove me"	"> 
When I first used Git it drove me almost to tears of rage and frustration. But I did get it under control. I don't love Git, but I use it every day, by choice, and I use it effectively.Yes. For me the rescue was Charles Duan's git tutorial: Understanding Git conceptually. https://www.sbf5.com/~cduan/technical/git/>  you can only really use Git if you understand how Git works. Merely memorizing which commands you should run at what times will work in the short run, but it’s only a matter of time before you get stuck or, worse, break something.The original claims> 
It is very hard to permanently lose work.I disagree. So I run a git reset safety net https://gist.github.com/chx/85db0ebed1e02ab14b1a65b6024dea29 it saved my bacon quite a few times. (Bonus git cd command. It's useful.)"	chx	8.549059	-6.5011096	comment	4.0	18.0	1656532032	-11.89639
31925310	This serves as an example to me that	This serves as an example to me that git is - maybe - not the right tool for the job.	tex0	8.556798	-6.475534	comment	4.0	15.0	1656534367	-11.88502
31926263	> My question is why hasn't anyone c	> My question is why hasn't anyone come along and fixed it?Because the model is simple and easy to understand, and you get a lot of power from understanding it.  Whereas opinionated porcelain that tries to insulate the user from the model will tend to fail in obnoxious ways and will not serve the user.Really, there's objects, there's commits, then there's a couple of methods for symbolically naming commits (branches and tags) because humans need symbolic names (because we can't memory SHA-1 hashes, or any hashes).  Object and commit hashes function as pointers or inode numbers.  Symbolic commit names function as hard links.If you understand the Unix filesystem, you can understand Git.Everything else follows from these things.Merges create new objects referenced from the merge commit.Rebase	cryptonector	8.559014	-6.520658	comment	4.0	19.0	1656540353	-11.913428
31926284	I'm reading it and I think I got it 	"I'm reading it and I think I got it right.  The Git community, the Git documentation, and the Git tools all refer to ""branches"", and I think what they mean when they talk about ""branches"" is much closer to what I described than to what you did.For example, consider this very ordinary-sounding phrase that I just picked out of the git-rebase man page:> If the upstream branch already contains a change you have made …I don't think your account can explain what is meant by this.In any case, I didn't make the choice casually, thoughtlessly, or from ignorance."	mjd	8.606969	-6.5522585	comment	4.0	16.0	1656540478	-11.8437195
31934555	I say this as a senior dev with 8+ y	I say this as a senior dev with 8+ years of experience working with git: git is nightmarishly complex. Highly stateful, insanely large CLI surface, huge amounts of terminology/concepts relative to the complexity of what you're actually trying to do with it. I've learned to navigate its waters over the years, fully appreciate the difference between git and GitHub, etc etc, and I don't blame anybody for being scared away by its complexity.	brundolf	8.546826	-6.4914556	comment	4.0	21.0	1656605233	-11.884863
31967708	> How often have you or a coworker p	"> How often have you or a coworker pushed an empty commit to ""re-trigger"" the CI?Zero, because unless my dog configured the CI, I’d just click a button to re-run it on the same PR/commit/branch and not “make an empty commit”.End to end testing of large systems with hundreds or thousands of man-years of code in them will be slow because there is a large surface area to test and testing in individual modules doesn’t give the same kind of end to end coverage that testing everything together does. So while pre-commit would be good, I doubt it will replace server CI for all but the smallest repositories."	alkonaut	8.695894	-6.4987054	comment	4.0	26.0	1656856452	-11.899148
31984961	You must not ever work with junior d	"You must not ever work with junior developers. Rarely do I see a properly created commit history, what you usually get is something like:  add
  upd
  fix
  upd
  fix

Rebasing that stuff before merging it into master feels mandatory, or you're left with history with a very low signal-to-noise ratio."	5e92cb50239222b	8.573716	-6.553251	comment	4.0	12.0	1657001996	-11.965761
31985095	Would it make sense to make one comm	Would it make sense to make one commit for the move and one for the changes?	Akronymus	8.595096	-6.52255	comment	4.0	14.0	1657003327	-11.9504
31985549	Git has a terrible UI from a learnin	Git has a terrible UI from a learning point of view. You can't learn Git by using its commands. You can, however, learn Git by reading about its architecture: blobs, trees, commits, pointers to commits (refs), and index (staging area where new commits are prepared). Because Git is really just a brilliantly simple data structure manipulated by dozens of ad-hoc commands.	parasti	8.551462	-6.5199833	comment	4.0	20.0	1657007627	-11.901183
31985646	Absolutely.I've seen teams evaluate 	Absolutely.I've seen teams evaluate multiple revision systems before starting projects and each one has decided on Mercurial based on its technical merits.I'll take it on trust that git is a perfect solution for linux kernel development, but the number of teams who work the same way as them is a rounding error from zero. I see people on here complaining about cargo-culting from the cool kids (k8s, spotify's team structures, etc., ect.), but I see git as exactly the same.I don't want to have to spend time understanding how my editor handles lines in memory in order to use it, why should I have to spend time understanding how my revision control system treats revisions?Tech is hard enough without having to sink time in to unnecessarily complicated tools that can bite you in the bum really ha	midenginedcoupe	8.534902	-6.4928207	comment	4.0	22.0	1657008548	-11.894772
31985881	I've been using fossil (https://foss	"I've been using fossil (https://fossil-scm.org) for personal projects for like a decade now and I much prefer it over git. The characteristics that get me to stick with it are -1. Single file executable. No dependencies to ""install"". Just the executable and you're good.
2. The whole repo is a single sqlite DB file. Fabulous for backups, sharing, hosting etc.
3. You cannot rewrite history unlike git. Hence the name. Folks using git have no idea what kind of a peace of mind this gives me.
4. Integrated issue tracker stored in the same repo. Complete with cross references to commits.
5. Allows repeated use of same tag name. This is so convenient in personal projects I miss it in git. You can mark a commit as ""published"" and later look at the whole history of all previous commits tagged as ""pu"	sriku	8.549593	-6.4573283	comment	4.0	30.0	1657010810	-11.920473
31989309	Mercurial is also great for rebasing	Mercurial is also great for rebasing (that's cherry picking in Git terminology - not the same as git rebase!). If I had experimental changes, I would often just commit things and mark them as private (so they wouldn't get pushed) rather than shelve (the Hg equivalent of git stash). Then, when I actually wanted them, I would rebase them on to the most recent revision (using --keep so the originals were still there if something went wrong - then I could strip the originals when the dust settled). Hg is so easy to use that you can feel really confident manipulating the commit graph, in a way you normally wouldn't risk in git.It helps that Mercurial has a really nice cross platform GUI: TortoiseHg. Version control is one of those things that really benefits from a GUI because you're manipulati	quietbritishjim	8.558144	-6.553685	comment	4.0	17.0	1657034685	-11.949932
31991904	> Do/did you use other VCSes? I did.	> Do/did you use other VCSes? I did. ClearCase, CVS, SVN, Mercurial. It's a real horror (excluding later) to deal with.I did, plus MS SourceSafe, Team Foundation Source Control and Bazaar.I don't see the problem with SVN and Mercurial. If you have merge conflicts, no tool is going to solve that.If you love git so much, try to do a squash merge to the main, then do some other changes in your branch, and try to merge again. Have fun solving all the merge conflicts that actually shouldn't be there.Like I said, SVN and Mercurial are fine too. I don't see any reason why git would magically solve some merge conflict that SVN or Mercurial is not able to.	koonsolo	8.57823	-6.515141	comment	4.0	12.0	1657045669	-11.891037
39357918	You probably already know these bits	"You probably already know these bits & bobs, but I wanted to share:  [diff]
    external = difft

Use the fantastic difftastic instead of git's diff. https://difftastic.wilfred.me.uk/  [alias]
    fza = ""!git ls-files -m -o --exclude-standard | fzf -m --print0 | xargs -0 git add""
    gone = ""!f() { git fetch --all --prune; git branch -vv | awk '/: gone]/{print $1}' | xargs git branch -D; }; f""
    root = rev-parse --show-toplevel

Those are the most used aliases in my gitconfig.""git fza"" shows a list of modified/new files in an fzf window, and you can select each file with tab plus arrow keys. When you hit enter, those files are fed into ""git add"". Needs fzf: https://github.com/junegunn/fzf""git gone"" removes local branches that don't exist on the remote.""git root"" prints out the root of th"	bloopernova	8.644395	-6.510657	comment	4.0	21.0	1707834620	-11.825478
39358998	I never really understood why the ma	I never really understood why the majority of developers insist on using the git CLI, when modern UI clients like GitKraken [0] are perfectly usable and very helpful. :shrug:[0] https://www.gitkraken.com/	BerislavLopac	8.580417	-6.4929576	comment	4.0	12.0	1707840428	-11.860216
39450789	For extra amusement, make it so that	"For extra amusement, make it so that you have responsibility without authority.I.e. you know what is broken and roughly how to fix it and in everyone's view it absolutely is your responsibility to ""git'erdone"", but you can't since you either don't have access or resources to do what needs doing and you won't get the access or the resources due to office politics or some other equally unfixable issue.That's a fun little stress-biscuit to eat."	ZaoLahma	8.538028	-6.4742303	comment	4.0	15.0	1708497381	-11.850299
39452613	I'm watching Pijul from afar for yea	I'm watching Pijul from afar for years now.I'd love to see it get 1% of the investment Github gets...	baq	8.591345	-6.545945	comment	4.0	26.0	1708515621	13.889824
39482882	Thats so strange to me. I work with 	Thats so strange to me. I work with git every day and don’t use rebase. If you asked me in the interview I’d fail that. But if you asked me that question in real life I’d give you the answer in 30 seconds after looking at the documentation, and everything would carry on without a hitch.	kjkjadksj	8.569223	-6.5651264	comment	4.0	29.0	1708706611	9.378584
39571195	What’s the reason I would want to do	What’s the reason I would want to do this? Is there a specific threat I need to be aware of with regard to threat vector on git commits?	sethherr	8.568892	-6.4545608	comment	4.0	18.0	1709370482	-11.863528
39571486	I tend to agree with the argument Li	I tend to agree with the argument Linus put forward a long time ago, saying that there is little reason to sign commits instead of tags in git.* Commit references the tree. If you sign the entire commit object – which is what you want, not leaving a way to change something about the commit without invalidating the signature – you sign the file tree as you saw it and implicitly all its history. Might as well sign the tag then.* Signatures separable from the commit have a benefit of allowing someone other than the author and committer at the time to certify authenticity of the file tree. For example, if the key needs to be rotated later, you can slap a new signature over the previous one.* Signing every single commit is tedious, so you're bound to get it automated at some point. Now your sig	ilammy	8.577127	-6.465796	comment	4.0	15.0	1709374499	-11.783918
39588866	> GIT is already best model for keep	> GIT is already best model for keeping history of textual changesGit doesn't even keep history of changes, just snapshots before and after the changes. A very common problem is viewing history of a single file as it gets modified and renamed - this information just isn't stored. It's common for tools to show file history incorrectly - i.e. a previous version is removed and the new one (with small changes) magically appears.	ickyforce	8.586385	-6.498404	comment	4.0	18.0	1709548106	-11.894221
39595431	I am struggling to appreciate how th	"I am struggling to appreciate how this is _not_ a completely flawed workflow. Are many teams doing this? What is the workflow like that benefits from this? What's the ""shit not _that_ branch"":commit ratio?"	Jenk	8.604321	-6.5619884	comment	4.0	12.0	1709583351	1.9139032
32122841	The purpose of a git commit message 	The purpose of a git commit message is to answer the question “why does this commit exist?” That is the principal question you should be answering when you type `git commit`. This is the question you will be asking yourself when you find that commit in `git blame` or if it shows up in `git bisect`. Try to help your future self out.The changelog, on the other hand, answers the question “why does the customer care about these changes?” It could be the same reason as why the commit exists, but the question is different. If the customer doesn’t care, maybe it doesn’t even need an entry. Maybe why they care is slightly different than the reason the commit(s) exist.This is why I advocate for a hand-updated CHANGELOG.md. It’s a very small amount of writing that forces developers to consider how t	teeray	8.579797	-6.5181084	comment	4.0	54.0	1658013572	-11.894414
32162309	My thoughts on this:- even after yea	"My thoughts on this:- even after years of working with git, I'm still not familiar with all the dark corners I can get myself into by running the wrong command at the wrong time. Yes, most of the time my changes are still there, but the way back to the state I actually want for my repository may be long, complicated and require lots of googling/asking around.- as the article mentions, git cares a lot about stuff that has been committed, but not so much about the files in your working directory. Because of that, IDEs that keep a local history of your file system changes (like the JetBrains products) are really helpful. ""Commit early, commit often"" may save you from this, but produces more noise in the repo (which you can reduce by squashing commits, but that's extra effort) and may make it "	rob74	8.579975	-6.522534	comment	4.0	13.0	1658299283	-11.886826
32163270	If I could just convince colleagues 	If I could just convince colleagues to `pull.rebase`, so CI isn't constantly building 'Merge branch master' on the master branch, I'd be happy enough.	OJFord	8.59099	-6.5572925	comment	4.0	17.0	1658308777	-11.908763
32164342	I always tell people the `-m` flag o	I always tell people the `-m` flag of `git commit` is only ever to be used in scripts. Let git open an editor and write your multi-line message there. Look at the comments telling you which files have been changed.Even better than using `git add` and `git commit` is to use `git gui` to add and commit files. The (standard) GUI is not to help beginners, it is to make you a more effective user of git. Note there are other apps you can use with more features, for example I like gitx on MacOS, but there are also terrible apps out there that do try to be easy for beginners, and they should be avoided. The most obvious is github desktop (I haven't tried it for a while - it might have slightly improved, but I still won't go near it)	rjmunro	8.569626	-6.4989643	comment	4.0	20.0	1658317651	-11.891844
32164662	GIT is just the new Regex. Everybody	GIT is just the new Regex. Everybody uses it, most have no clue how it works and just copy/pasts stuff from other places/repeats the same little trick	NKCSS	8.561335	-6.4716854	comment	4.0	27.0	1658319511	-11.869431
32185285	Very interesting. One thing I've pon	Very interesting. One thing I've pondered - this project contains various pieces of off the shelf hardware, and some custom 3D CAD files. These don't seem to fit as neatly into the way Git functions. Is there/has there been any attempts to replicate Git with Bill of Materials or 3D CAD data?	digdugdirk	8.545585	-6.4942913	comment	4.0	19.0	1658438670	-11.882286
32190601	Mercurial just has better UX so less	Mercurial just has better UX so less need to Google	moonchrome	8.5011015	-6.56144	comment	4.0	22.0	1658487233	-11.95658
32190887	I still save changes to a file if I 	I still save changes to a file if I switch/merge while having a bigger changeset as I use PHPStorm and it caused me a semi heart attack at least 3 times with the “unstashing failed“ error (that also removed it from the stash at the same time)	jefozabuss	8.620834	-6.52509	comment	4.0	19.0	1658490023	-11.831734
32194985	If the update is going to touch 27 p	If the update is going to touch 27 places at once, how is the developer meant to communicate such a change thru commit messages?	nawgz	8.584251	-6.521862	comment	4.0	18.0	1658512344	-11.930319
32212862	Squashfs binary format	Squashfs binary format	st_goliath	8.605575	-6.566647	story	4.0	51.0	1658666366	8.874458
32263087	> Do you really want to push changes	> Do you really want to push changes to some remote CI system only to be told it's failed some boring QA check?Yes, that's what CI/CD is for.> Pre-commit is completely optional for each developer.No it is not, it's installed at your git pre-commit hook, and it gets run every fucking time I commit, even if I've set up my editor correctly to auto-format and lint everything at I develop, meaning 99.9999% of the time sure the code I commit will pass all these linter checks. I can use git commit --no-verify to bypass pre-commit, but then again, what's the point of using pre-commit in the first place if you need to bypass it? There is absolutely no point of linting twice locally and thrice in total just to hit the first stage of your deployment.	wyuenho	8.728594	-6.499786	comment	4.0	29.0	1659009039	-11.880916
32294815	I feel the title is incorrect. This 	I feel the title is incorrect. This isn’t so much a critique of Git, it’s a critique of the way Kubernetes-the-project uses it.	t3rabytes	8.654134	-6.5859942	comment	4.0	17.0	1659266397	-12.088588
32371419	"What do we call the ""--"" part in a c"	"What do we call the ""--"" part in a command like this:    git checkout HEAD -- <filename>

I find it hard to remember things unless I understand their purpose. It looks like it's specifying an argument but without an argument name (e.g. --verbose), unless it's similar to a pipe | symbol and <filename> is being passed to the checkout command as some special kind of argument?"	soupshield	8.685074	-6.5290656	comment	4.0	20.0	1659818572	-11.751397
22021998	FWIW, this has gotten a certain amou	"FWIW, this has gotten a certain amount of attention on HN over the years since it was begun but it's instantly noticeable that patches tailed off and stopped last June. Naturally that raises the question of ""is this even still alive"", and last month the starter of the project, Pierre Meunier, posted a response to a query about that indicating a major rewrite is in progress:----https://discourse.pijul.org/t/is-this-project-still-active-y...>Is Pijul still under active development?>That’s right, the last patches are pretty old. A few things have happened since then, but they’re not public yet. This has included (1) thinking about new algorithms to solve our remaining problems and (2) thinking about the future and sustainability of the project, including its funding.>Another thing going on is"	xoa	8.637271	-6.5663714	comment	4.0	24.0	1578773696	13.894723
22022991	> Compared to git, it relies on patc	> Compared to git, it relies on patches rather than a branch approach.Is this even relevant at all? I mean, in the user's POV the role of a VCS is to CRUD changesets and branches. As long as the user can commit their changesets and audit the DAG of past commits, who cares how the system is implemented under the hood?	rumanator	8.57172	-6.466481	comment	4.0	18.0	1578783597	-11.876362
22045801	Git for Data – A TerminusDB Technica	Git for Data – A TerminusDB Technical Paper [pdf]	LukeEF	8.566389	-6.457965	story	4.0	25.0	1579016664	-11.872243
22188837	the best thing about this was discov	the best thing about this was discovering https://git.sr.ht/	awalias	8.541096	-6.4406743	comment	4.0	15.0	1580358516	-11.852184
22221637	I’d also like to add on a different 	I’d also like to add on a different note, I don’t really get why git can’t support docx, pptx, and xlsx. They’re open standards not binary blobs. Basically just zipped xml.	vxNsr	8.554539	-6.4469576	comment	4.0	21.0	1580707475	-11.886157
22237216	> There is, of course, a way to unam	"> There is, of course, a way to unambiguously give a hash value in the new Git code, and they can even be mixed on the command line; this example comes from the transition document:     git --output-format=sha1 log abac87a^{sha1}..f787cac^{sha256}

> For a Git user interface this is relatively straightforward and conciseNo, it isn't. It's a complete and utter user interface clusterfuck. Just say no to this insanity."	kazinator	8.641147	-6.5154376	comment	4.0	52.0	1580832716	7.24673
22237272	Honest question: what are the use ca	Honest question: what are the use cases in Git where hash computation speed is a meaningful optimization?	_verandaguy	8.62977	-6.4812026	comment	4.0	13.0	1580832940	-11.8768015
22239645	"Just to be clear:
Every time you mod"	"Just to be clear:
Every time you modify a file, the new changes get put in using
SHA3.  In an older repository, any given commit might have some
files identified using SHA1 (assuming they have not changed
in 3 years) and others identified using SHA3.For example, the manifest of the latest SQLite check-in is
see at (https://www.sqlite.org/src/artifact/29a969d6b1709b80).
You can see that most of the files have longer SHA3 hashes,
but some of the files that have not been touched in three
years still carry SHA1 hashes.An attack like what you describe is possible if you could 
generate an evil.c file that has the exact same SHA1 hash as the
older floppy.c file.  Then you could substitute the evil.c
artifact in place of the floppy.c artifact, get some 
unsuspecting victim to clone your modified "	SQLite	8.675737	-6.527008	comment	4.0	22.0	1580843219	-6.0164933
22284126	Sidenote, but people actually take G	Sidenote, but people actually take GIS classes? Even in high school? Never heard of such a thing.As someone that does GIS related work professionally, that caught me by surprise.	war1025	8.54519	-6.4827127	comment	4.0	16.0	1581280199	-11.918529
35644637	Great questions!- As can be seen htt	Great questions!- As can be seen https://docs.cozodb.org/en/latest/releases/v0.3.html, for concurrent writes about 200K QPS can be achieved with 24 threads on a pretty old server. I think it is enough for a small to medium social network.- You can start independent instances and use them together in your user code. You can have as many as you like, but data can only be exchanged through your code: they can't talk directly to each other.- If by git-like you mean point-in-time queries, yes that's what the feature is for. But git comes with lots of other things such as merge logic, etc. These need to be implemented outside CozoDB.- We do use CozoDB for data storage in production systems ourselves, and we back up a lot. So far nothing disastrous has happened. Note that CozoDB does not have any	zh217	8.609232	-6.487245	comment	4.0	17.0	1682017384	-11.889136
35646398	I don't know why people complain abo	I don't know why people complain about git being hard to use. If you have a basic understanding of how branching works and aren't a complete dunce with CLI tools, it's very simple. It's also one of the best CLI's I've ever come across.People over complicate it - In 5 years now as a full time SWE I barely ever use commands other than the basic ones - git pull, git commit, git add/remove, git push, git merge.Occasionally annoying conflicts happen on merge that you can eyeball and fix fairly trivially.	JohnMakin	8.559798	-6.4997296	comment	4.0	12.0	1682025124	-11.885985
35668954	I have to say I love editorconfig, I	I have to say I love editorconfig, I feel that once you start running code and managing tools it starts to get too much for me. At that point just spin up a VM or container so that the environment is yours.I loathe pre-commit hooks. I often times just want to save work in progress or show someone what I have right now and they slow down my work or worse fail and lose my commit message and cause me to have to figure out how to disable them to continue. If you want to run checks for formatting or similar that is much better done in CI. I can get a reminder without breaking any dev workflows. Of course make fixing formatting a single command, and maybe an optional hook for those that prefer it. But when projects try to auto-install hooks it drives me crazy.	kevincox	8.720083	-6.505881	comment	4.0	18.0	1682184695	-11.847263
35695098	Okay, I’ve just got to know: what’s 	Okay, I’ve just got to know: what’s up with the commit messages? I’ve never seen anyone just straight up use numbers before.	CSSer	8.58718	-6.5208707	comment	4.0	18.0	1682382613	-11.925999
35920170	"""Automating DevOps with GitLab CI/CD"	"""Automating DevOps with GitLab CI/CD Pipelines"" is not a rare subject."	RobertDeNiro	8.538217	-6.4564915	comment	4.0	19.0	1683916014	9.032323
36121797	After a brief scan I’d call the  ful	After a brief scan I’d call the  full change reviewable enough I could do it in a sitting. Most of it looks reviewable on my phone. But seeing >30 commits, I’d pause. Partly because I’ve become a lot more sensitive to the impact of commit history itself, partly because the quick scan of such a small change set doesn’t seem to line up with so many commits, but mostly because it implies much more context exists than the attention I’d pay if it came pre-squashed.That kind of implication stops me in my tracks to learn more. I’ve spent literal days tracking down the meaning of single line code changes through multiple dozens of commits, sometimes across repo boundaries (ahem the original author’s suggestion of deprecating in favor of a fork comes to mind).The size of this particular PR only bec	eyelidlessness	8.591503	-6.517138	comment	4.0	28.0	1685428605	2.101397
36122051	I bet you're other thinking in this 	I bet you're other thinking in this case. In general, the expectation on GitHub is that PR commit history doesn't matter, and owners should simply squash on acceptance. I think most contributors don't event consider that all their commits are visible or would be of interest and only think about the final product.It's certainly simpler for the contributor to do the squashing, but when GitHub makes it so simple in practice it doesn't matter.	hoten	8.564708	-6.497796	comment	4.0	21.0	1685431423	-11.899473
36122099	I disagree pretty hard with this – f	I disagree pretty hard with this – for instance I've recently needed to dig into the code for the Gradio library, and when PRs are like https://github.com/gradio-app/gradio/pull/3300 (and the merge commit's message is what it is) it's hard to understand why some decisions have been made when doing `git annotate` later on.	akx	8.567529	-6.5098505	comment	4.0	14.0	1685431850	-11.923599
36159270	Show HN: JuxtaCode – native Git diff	Show HN: JuxtaCode – native Git diff tool for macOS	yorim	8.656901	-6.4929395	story	4.0	19.0	1685665333	-11.821729
36178952	Is the problem that git is too hard 	Is the problem that git is too hard or that the typical person’s mental model of collaborative development is too naïve?	fiddlerwoaroof	8.53622	-6.477618	comment	4.0	14.0	1685815447	-11.895601
36368177	Using Git-annex for Data Archiving	Using Git-annex for Data Archiving	jandeboevrie	8.577452	-6.4589043	story	4.0	69.0	1686987939	-11.922516
36372851	My suggestion would be to not learn 	My suggestion would be to not learn git. Go with just about any other version control system if you’re not using it professionally. I’ve used cvs, Subversion (svn), Perforce (p4), and others. Honestly, Subversion and Perforce were both significantly easier to setup, learn, and use than git. While they all have their growing pains, it took me about a week to get used to Perforce. It took me more like a month or two to get used to svn. I’ve been using git for years and still find it very hard to use and strongly dislike interacting with it.	thewebcount	8.573746	-6.464266	comment	4.0	16.0	1687025863	-11.879376
36381058	I'm confused by this statement:> GMP	I'm confused by this statement:> GMP is at this point the only dependency that does not offer a sane way to clone its repository.The latest release is from years ago and https://gmplib.org/download/gmp/gmp-6.2.1.tar.lz should contain every file necessary. Why would you need access to the commit history in a build script?In fact, why would you need to download a fresh copy of a dependency that almost never gets updated from upstream? Surely Github can do some kind of caching.I wonder what will happen now that their build servers can't even reach the Mercurial repo anymore. I suppose the problem should quickly correct itself soon with all the failing builds.	jeroenhd	8.508579	-6.468242	comment	4.0	13.0	1687101582	-11.888427
36468080	What are you doing to sync your file	What are you doing to sync your files?  I'm current using the git integration and while it works it's a bit too manual for my tastes. I think I'm ok with last write wins as long as the sync stores history. The whole commiting changes, pushing, pulling, dealing with merge conflicts is a bit too much workflow for my notes.	bmurphy1976	8.67247	-6.4966507	comment	4.0	15.0	1687700412	-11.865223
36486119	Nice, really hope I'll find some swe	Nice, really hope I'll find some sweet way to cache similarish with GitLab-CI. Also kinda been thinking about how cool it'd be to run Kubernetes with Nix natively (so instead of a docker layer registry you have nix paths mounted together to overlayfs)	miduil	8.543152	-6.5294766	comment	4.0	20.0	1687814950	-12.13016
36505581	Sapling looks quite cool! I've used 	Sapling looks quite cool! I've used git extensively in my career and consider myself as having a slightly-more-advanced-than-typical understanding of how to use it just based on conversations with colleagues. However, one thing that's always been very limiting with git has been stack-based PR reviews, and as they mentioned amending deep commits. It's not impossible, but it makes it awkward enough that I usually avoid it if possible.Curious if anyone has used Sapling after lots of time using git. Is it the future?	blitz_skull	8.535697	-6.4702444	comment	4.0	20.0	1687956260	-11.879828
28670105	This seems to be advocating the seco	This seems to be advocating the second workflow, i.e. pushing on a short lived branch then merging back in (their intermediate setup seems impractical technically for most setups - how do you run standard tests without committing your code, unless you do everything locally?)	sparsely	8.703929	-6.5285864	comment	4.0	19.0	1632747508	5.460362
28674707	I would maybe be interested in Git a	"I would maybe be interested in Git allowing you to plug in your own diff generators for different file types.But I would not want Git itself trying to understand the contents of files. That seems to me to be an idea that lives on a misconception of the ""things programmers believe about names"" variety. Not every file in source control is source code. Not every programming language's grammar maps to an abstract syntax tree. In some files, such as makefiles, the difference between tabs and spaces is semantically significant. Some languages (such as Fortran and Racket) have variable syntax. And so on and so forth.So I think that we really don't want the source control system itself trying to get too smart about the contents of files. That will inevitably make the source control system less com"	mumblemumble	8.682619	-6.472976	comment	4.0	26.0	1632769534	-11.764705
28689361	How to hack your Git history to look	How to hack your Git history to look active	j-sizz	8.552326	-6.469227	story	4.0	26.0	1632879304	-11.897618
28703938	We have to be very precise here I th	We have to be very precise here I think.Git doesn't really store file changes as events, rather, it's a long chain of state snapshots, in something like a persistent data structure. Sure, the history is all there, but so is the current state in its most efficient form.DB transaction logs might be considered event sourcing by some definition, but their use is very different. It's purely a technical trick. As a consequence, logs are truncated as often as possible/reasonable, and you never rerun the transaction log from time zero. Very different from the event sourcing idea to keep events as long as possible.	codeflo	8.608178	-6.505096	comment	4.0	12.0	1632986169	-11.951485
28742677	>PR’s are usually ready when the fea	>PR’s are usually ready when the feature/bug is already being worked on and in the last stage of its development process. It’s an “already change proposal to be merged into the current system”, don’t forget that.What is the second sentence saying? I can't parse it at all.	happytoexplain	8.634768	-6.451073	comment	4.0	17.0	1633317866	-11.827338
28784593	Apparently astrologers declared this	Apparently astrologers declared this the year of Git implementations. Production of Git implementations has increased five-fold.	aasasd	8.553476	-6.456236	comment	4.0	28.0	1633603618	-11.919089
23412576	I'd hate the idea of having a record	I'd hate the idea of having a record of all my mistakes as a student.  I'd probably just use a separate remote for my develop branch and squash into one commit when merging to master.	mmm_grayons	8.600982	-6.565138	comment	4.0	19.0	1591246531	-11.899318
23469914	Nice! I create two-letter aliases, i	Nice! I create two-letter aliases, it truly helps:gc = git checkoutgs = git statusetc...	adamredwoods	8.577569	-6.5097713	comment	4.0	14.0	1591730850	-11.840263
23479983	I can't disagree with this more.  Go	I can't disagree with this more.  Good commit messages are just so, so, so important.  Especially when I'm triaging an issue and have no other context than the code itself.  I want to know not the _what_ which the code gives me, but also the _why_ which is what the commit message provides.	knappe	8.582048	-6.516593	comment	4.0	23.0	1591811515	-11.908226
23480033	That's fine. I think your opinion is	"That's fine. I think your opinion is the majority opinion (at least online). It just does not match my own experiences of reality.You can and should value practices based on your context. But I will be the asshole and ask if writing good commit messages is ""so, so, so important"" -- what things are less important? Is it more important than a good test suite? Well factored code? System documentation? Capacity for senior staff to answer questions? These things cannot all be so important and, in my experience, worrying about crafting amazing commit messages is way down the hierarchy."	swanson	8.583935	-6.539123	comment	4.0	15.0	1591811811	-11.904259
23490700	Ask HN: Is Git as the only SCM ecosy	Ask HN: Is Git as the only SCM ecosystem healthy?	kitplummer	8.5748415	-6.517269	story	4.0	4.0	1591893976	-11.933697
23518548	I know this is going to be a PC war,	"I know this is going to be a PC war, but, I'm curious how they technically intend to do this. Is ""main"" just going to be a visual alias on the site? If so that will be really confusing if the branch is still technically called ""master"" and needs to be referred to that way in the command line. If they intend to actually rename the branches I don't know how they can do that without breaking all sorts of scripts and build tools."	overgard	8.514044	-6.531735	comment	4.0	13.0	1592149658	-3.877493
23518580	Wait, git by default creates master 	Wait, git by default creates master branch.So if you push master to Github, how is this going to work ?Is it not better to make the changes to Git ?Ask Linus Torvald in Finland.	sand_castles	8.508188	-6.5143743	comment	4.0	12.0	1592149775	-11.789965
23526648	"I've got to admit that ""main"" makes "	"I've got to admit that ""main"" makes a lot more sense. It's the main branch where all commits are collected before getting deployed, it's not a master that bosses all the other branches around."	mcv	8.515372	-6.5272737	comment	4.0	22.0	1592224669	-11.762474
23536922	I work as a SWE at a large AI consul	"I work as a SWE at a large AI consultancy. We've been experimenting with ""git for data"" products for a while, and we've been trying to get rid of them (notably Pachyderm) for -at least- 2 years.What they all share is a) awful performances, and b) bad design.Git semantics, (""branche"", ""merge"", ""commit"") are not well suited for data, because merging dataframes and creating ""branches"" often leads to misunderstandings and delays. Time travel is very nice to have, but it's often the case where you would like to consume your input datasets at different point in time in the same repository (unless you do one dataset per repository, but then, what's the point ?).Performances are bad, because all updates needs to go through some kind of coordination mechanism (etcd, zookeeper, or raft directly). In"	Fiahil	8.576587	-6.4942527	comment	4.0	17.0	1592294832	-11.89728
23577515	It looks like the BTFS in the OP was	"It looks like the BTFS in the OP was the ""original"", with its first commit in July of 2015. Could be wrong, because the GitHub interface doesn't make it easy to get to the beginning of the 13k commits for go-btfs."	heavyset_go	8.674431	-6.4880767	comment	4.0	16.0	1592591780	10.266751
23613683	I mostly work on desktop programming	I mostly work on desktop programming, and I've dabbled in web stuff...And I don't know what GIS is. I see it talked about _a lot_ but I don't understand how there can be so much money and interest in geography.I understand web stuff being huge, because I'm online almost all day. But what _is_ GIS? Is it something businesses do and consumers don't see?	ReactiveJelly	8.552398	-6.4783278	comment	4.0	13.0	1592919229	9.57451
23622022	The name 'main' feels overloaded, ju	"The name 'main' feels overloaded, just like naming the default branch 'default' or 'development', with the risk of ""Who's on first?"" confusion, especially when branching off branches.""What branch are you on?""
""I branched off the main development branch for this fix.""
""Like...the `main` main branch or the main branch for the feature?""I like redis' rename of their default branch to `unstable`. Just like commits are tagged with the release numbers, the latest code that isn't yet versioned is by default 'unstable'. If the industry as a whole is going to make this change, I would prefer we choose a name that can be unambiguously referenced in conversation."	ehfeng	8.518072	-6.532997	comment	4.0	14.0	1592956564	-11.76769
23648692	> Why does git not automatically ign	> Why does git not automatically ignore that?!Why doesn't Git automatically ignore desktop.ini? .desktop? __pycache__? In my experience, people end up creating bespoke .gitignore files for each project and sometimes shared online, or systemwide. I don't know if Git should make it global.	nyanpasu64	8.610519	-6.4653096	comment	4.0	21.0	1593145406	8.110225
23648743	Just add it to `~/.gitignore` and be	Just add it to `~/.gitignore` and be done with it. Yeah haven’t worried about this in 10 years.	skyzyx	8.611523	-6.466424	comment	4.0	15.0	1593145940	-11.766898
23681822	Did I read that correctly, they were	Did I read that correctly, they were on Subversion before this?	cptskippy	8.642933	-6.450922	comment	4.0	18.0	1593460294	-11.75724
23697797	Show HN: git-rename-master-branch-to	Show HN: git-rename-master-branch-to-main	jph	8.516443	-6.5250735	story	4.0	6.0	1593578420	-11.766893
23734348	Creator here! Thanks for submitting 	Creator here! Thanks for submitting - I hope people find this interesting. I’m excited to explore more use cases beyond listing and reformatting git log output! There’s a similar project called gitbase, but I had difficulty just spinning that up for ad-hoc CLI querying so created this project in hope of a better UX for that type of use case. It uses SQLite virtual tables, which was something I had been meaning to play around with. This seemed like a cool use of them!	patrickdevivo	8.589684	-6.4863286	comment	4.0	19.0	1593890922	-11.907703
23740317	Head of Engineering with 15 years of	"Head of Engineering with 15 years of experience here.If found that when we starting using Github flow, with pull-requests and etc, commit messages stopped really matter, in favour of PR descriptions. Plus when you use ""squash"" strategy, and use PR description as commit message, history looks great.When you look at commit history through Github tooling, all PR ids turned into links, and it is very easy watch for the history. Additionally you have a good integration with Github features, like discussions (which sometimes as important as description itself).Yes it is a vendor lock-in, but lets be frank, Github most likely will survive your project."	LeonidBugaev	8.561239	-6.462464	comment	4.0	20.0	1593970119	-11.904395
23752310	Which tool do you use to view commit	Which tool do you use to view commit messages and revisions for each file? I think one of the reasons this is uncommon is due to lack of tooling (or wide-spread knowledge of them). I'd really like to be able to easily see all the previous commits that affected a specific line while I'm editing code. But I usually have to resort to interacting with git, rather than having something popping up on my screen (I use pycharm and vim regularly).	aflag	8.592838	-6.5050087	comment	4.0	13.0	1594066937	-11.870274
23768114	The -v option, which the author is r	The -v option, which the author is referring to when talking about writing commit messages in vim is much better: you get to author the commit message in the $EDITOR of your choice and you can inspect the full diff while doing so.If you're using fzf [0] for history recall (ctrl+R) it also has the nice side-effect for not cluttering up your history.[0] https://github.com/junegunn/fzf	tams	8.607223	-6.5258183	comment	4.0	21.0	1594198285	-11.853992
23768161	When inheriting a project, you use g	"When inheriting a project, you use git blame a lot. Who wrote it, when it was written and any hints as to why it was written. If it has a task number like ""fixes #1402"" and you still have access to the issues, that's great.If it is like ""f*ck python"" or ""lol java sux"" that's a good indication that it was a syntax problem or a trivial mistake.If it is like ""a"" or ""aaa"" or ""x"" it's just useless and you are on your own."	nurettin	8.56145	-6.5070596	comment	4.0	12.0	1594198780	-11.912901
23771130	I personally tend to write pretty sh	"I personally tend to write pretty short commit messages, I think any important info is better stored either in comments in the code or the module's documentation. Who goes digging into old commit messages to understand what a piece of code does? I know I don't.Not to say that verbose commit messages are a bad thing, it's always better to have too many details than not enough, but I think very long commit messages might also sometimes hint that either the commit is ""too big"" and should've been broken down in smaller, atomic changes or, as I said above, that you're really just writing documentation and that may be better suited for an other place.Commits should definitely be descriptive and accurate, but if you break your changes in small chunks you can generally still do that in one or two "	simias	8.564159	-6.5454187	comment	4.0	12.0	1594223844	-11.921761
23805682	I think the best argument against gi	I think the best argument against git is to use mercurial for a few months. It has exactly the same functionality but a nicer and more streamlined interface, especially when it comes to branch management.	millimeterman	8.535377	-6.522294	comment	4.0	16.0	1594499725	-11.958988
23807292	I like staging my changes with `git 	I like staging my changes with `git add -p` before I commit as a way of reviewing what I did. I often catch mistakes or unnecessary changes this way. I suppose you could build the same workflow with stashes, but it seems quite awkward that way.	smichel17	8.595207	-6.557018	comment	4.0	15.0	1594511742	9.102601
23849786	That's it, I'm launching SubversionH	That's it, I'm launching SubversionHub.	kchoudhu	8.622541	-6.4599934	comment	4.0	13.0	1594838753	-11.835433
23871963	> I always have the feeling people j	"> I always have the feeling people just cobble around for too long and should instead take at least a few days for a more structured learning approach.There are two kinds of documentation: there's a list of all the individual things you can do, and there's a ""The fundamental abstraction is this"". The second is rare, and rarely done correctly, and much more important.A lot of people assume that X is like Y, but with Z, and they know Y, so they just need to learn about Z. A lot of time that isn't true, the fundamentals are different. The natural way do perform W in Y might be profoundly wrong in X. Examples:* git is like subversion, but distributed.* C++ is like C, but with classes.* C++ is like Java, but you have to remember to delete stuff.I love git. I love C++. I think these things are t"	nwallin	8.5567665	-6.5119557	comment	4.0	15.0	1595001791	-11.853618
23968973	You could use `git log -p` instead o	"You could use `git log -p` instead of `git log` so that the diff is included.To navigate efficiently between the commits, you could pre-seed less with a regex that matches commit (and file) lines, so that ""n"" and ""N"" jump from one commit (or file) to the next, something like this  LESS=""-R --pattern ^(commit|diff) "" git log -p

Delta[1] makes this convenient: delta --navigate.[1] https://github.com/dandavison/delta(Disclosure: I am the author of delta)"	Myrmornis	8.647566	-6.5046563	comment	4.0	13.0	1595881131	-11.7951145
23969090	I just came back to git and gitlab f	I just came back to git and gitlab from Perforce and while it's felt like coming home and some things are improving around submodules and LFS there's still a lot of rough edges I'd like to see smoothed over.Its not easy to set up git config settings for a distributed team.  I assume for security reasons a repo can't configure its own settings just from a pull but even still I want that functionality.Why do I check in the name of the merge tool used for a file type in the .gitattributes but I can't check in what that name points to?I work with less technical artists and they really don't want to think about git configs at all.  They just want to save and push.  As far as I know there's no solution to preconfigure a repo to pull submodules or set up custom merge drivers.  Best thing I've fou	jayd16	8.591476	-6.4495115	comment	4.0	21.0	1595881797	-11.830602
24039102	Launch HN: Strings – Delegated App C	Launch HN: Strings – Delegated App Copy Management	jasper_platz	8.594043	-6.4783206	story	4.0	14.0	1596469194	-11.873832
24103823	These are only merges - they don't m	These are only merges - they don't matter. The actual functional commits are excellent beyond anything you would ever find in your company VCS.	stefan_	8.598659	-6.507916	comment	4.0	42.0	1597015611	-11.889358
24104175	This is why I hate merge commits. I 	This is why I hate merge commits. I mean, I have no idea of what constitutes this Morton's work and if he could've done better, but I think messages like that are still a problem, they provide zero value and mess up the log. And this is actually only a little worse than what I usually see in merge commits, especially when they are done with some semi-automated tool like GitLab. People rarely do merge by rebase, all useful things that could've been said are usually in the commits themselves (and there are some guidelines about them), so merge commit messages are rarely empty and even more rarely are they useful, because author has no idea what to say. This is just trash.And even though it never ocured to me to check, yeah, I'd actually expect a higher quality standards of Linux kernel.	krick	8.619566	-6.5030265	comment	4.0	26.0	1597019101	-11.8915415
24103799	I'm surprised this is allowed in the	I'm surprised this is allowed in the linux kernel. I am not familiar, but assuming these are commit messages, that's pretty damn pathetic.	wmichelin	8.591808	-6.5355325	comment	4.0	67.0	1597015392	-11.894998
24141679	Does this address the cryptic-ness o	Does this address the cryptic-ness of git commands? E.g. are the various commands we all know and love like `git reset HEAD`, `git co --track origin/branch` etc. made clearer?Even after years of using git, this is for me a major pain point.	rich_sasha	8.559041	-6.506015	comment	4.0	20.0	1597313141	-11.889598
24148957	The basic idea is good, but isn’t a 	The basic idea is good, but isn’t a commit message the best place for this? That will ensure that people will find it when looking through source control history to understand some code, but equally importantly, they won’t find it on its own and be unsure whether it’s still relevant.When it’s part of the git history, the history itself tells you whether those changes stuck around or were superseded.Checking the original post to make sure I’m not just repeating it, I don’t think I am -- it links to https://github.com/joelparkerhenderson/architecture_decision... which proposes a whole bunch of acronyms (ADL, ADR, AKS, ASR) but doesn’t offer an opinion on where they should be stored! This is bureaucracy for bureaucracy’s sake, missing the wood for the trees.Edit to add: I’m not quite right, i	iainmerrick	8.577741	-6.495383	comment	4.0	17.0	1597352086	-11.905723
24174708	It's not that it's hard or complex, 	It's not that it's hard or complex, it's that I really don't care about it and am not at all interested in learning. It's a weak attitude, I know, but I just can't help it.So like most other developers, I go about my day totally not understanding git at all and when something weird happens, I talk to that co-worker know understands get (there's always at least one such psychopath on each dev team in existence) and ask him to fix it. He invariably talks about how easy and elegant git is and then finally gets around to giving me a couple commands with non-sensical names and options that fix the problem.I don't care, and I'm okay not caring. Not learning git might even give me extra time to learn about these magical computer algorithms I've heard so much about.	smabie	8.540427	-6.5028663	comment	4.0	26.0	1597548154	-11.914451
24176134	What would be nice is to add to this	"What would be nice is to add to this a way to plug language specific semantic analysers. Then it could be possible to do queries like ""which commits did changes to a specific function"" and so on."	andreypopp	8.599739	-6.501382	comment	4.0	17.0	1597565541	-11.865577
24235183	As someone who tried, and almost suc	As someone who tried, and almost succeeded, to get rid of pachyderm for the last two years, I like what I just read.Something is not entirely clear to me right now: An image is an immutable snapshot of a dataset at a given point-in-time - great - but, can I query the same dataset at two different PIT using layered querying in SQL ? Something like this: SELECT * FROM dataset:version-1, dataset:version-2Also, are you storing the entire dataset as new or only the diff between versions (and later reconstruct the full image) ?Now, onto the things that could be improved...- Git-like semantics (pull, push, checkout, commit) are poorly suited for versioned, immutable datasets. Just (intelligently) abstract fetching and sending datasets by looking at the SQL query (dataset:version-2, above)- Versio	Fiahil	8.620024	-6.496423	comment	4.0	15.0	1598020317	-11.887152
20004685	I find the staging area useful. It e	I find the staging area useful. It especially helps when you only want to commit a change in part of a file or just generally reviewing a commit before it's a real commit. And also to double check I'm not going to be uploading any secret keys (which seems to happen to people more often than it should).	ChrisSD	8.647487	-6.5605197	comment	4.0	14.0	1558726945	-11.947676
20004885	I found one article, only one, that 	I found one article, only one, that did more than anything to help me understand git. Can't find it anymore. :-( But it had to do with reflog and how any command could be undone since nothing was truly destructive, and how reflog actually had the edges in the graph and you just needed to know how to repoint them to the right nodes. Or something. This is probably one of my least helpful HN comments.edit: It might have been this one: https://hackernoon.com/https-medium-com-zspajich-understandi...	tunesmith	8.56743	-6.5290465	comment	4.0	12.0	1558728801	9.637564
20004917	Put this in your bashrc:    source /	"Put this in your bashrc:    source /usr/share/bash-completion/completions/git

And you can type ""git br<tab>"" to write ""git branch"", ""git checkout fun<tab>"" to write ""git checkout funky-feature"", ""git log --na<tab>"" to write ""git log --name-only"" etc.Pretty much every time you press <tab> somewhere while writing a git command, it does the right type of completion. And hitting <tab> multiple times lets you toggle through the options. So you learn git along the way.This was one of my most enjoyable productivity jumps when it comes to using git."	no_gravity	8.584326	-6.4990406	comment	4.0	19.0	1558729186	-11.875803
20004928	The proliferation of articles like t	The proliferation of articles like this is a very very good indication, that, yes, git is that hard, especially if you have to collaborate with other people.Everyone has a different idea of what git does, what things are called, and different interpretations of the vast git vocabulary. What is a rebase? What is a branch? What is a reset? People have different mental models for all of these things.Git would be easier if it weren't for all of the git users you have to work with. If you're a git solipsist, you develop your own mental model that works for you and you never have to care what anyone else does when they are using git.	jordigh	8.5389595	-6.50447	comment	4.0	14.0	1558729269	-11.90364
20279566	Version control software was a lot m	Version control software was a lot more primitive and less fun to use in the 90s.  On Unix you had CVS, on Windows just VSS.  SVN, Mercurial and Git all came post 2000.	mr_toad	8.642193	-6.44621	comment	4.0	16.0	1561500634	-11.842058
20430524	This is a fantastic commit, contents	This is a fantastic commit, contents aside, it's a great demo: the diff's tiny; the message is so much longer, and explains why the diff's there with even (very) historical context.	OJFord	8.649224	-6.51156	comment	4.0	17.0	1563056782	-11.8919325
20469015	There is a possible issue though - w	There is a possible issue though - would they commit immediately after coding - how long do they need to work on a commit before actually committing it?	tshanmu	8.5901985	-6.4456143	comment	4.0	21.0	1563452772	-11.891031
20470232	Strange policy about commits — why j	Strange policy about commits — why just not push at night or during weekends? Why's everyone not working on branches?	dchest	8.604298	-6.539987	comment	4.0	54.0	1563460593	-11.900111
20485503	In my opinion, the cost of creating 	In my opinion, the cost of creating branches, checking out, creating PRs, and ensuring they are part of the appropriate release can't be ignored. I have seen it happen. The backlog is high but no one wants to pick an issue (say, a styling bug)   even if they have time, just because the number of steps involved in getting it to production is too damn high. If you only had to worry about your change, there would be far fewer of those bugs.	shubhamjain	8.658016	-6.464958	comment	4.0	12.0	1563627848	-11.808879
20499396	At some point there has to be centra	At some point there has to be centralization. We are deploying one product, not N products for N commits. If I can't push, I can't have CI build my branch, and I can't submit a PR for review.	ilikehurdles	8.671398	-6.53937	comment	4.0	20.0	1563811893	-11.887527
20677238	Is this essentially a new CLI front-	Is this essentially a new CLI front-end to git? I'm excited to see the result.As a big fan and user of git i'm fairly unhindered by it's CLI design, however i'm quite aware of it's issues through helping many people learning from the outside-in - who's problems are often rooted in misconceptions caused by an exposure to git's porcelain without any understanding of the underlying graph they are manipulating... Perhaps OpenBSD can make a more honest CLI that might eliminate this confusion.	tomxor	8.588145	-6.510391	comment	4.0	14.0	1565628596	-11.882178
20720710	Yeah, it's mirroring the behavior of	"Yeah, it's mirroring the behavior of ""git checkout -- myfile"" which also does destructive changes without warning.These new commands were hatched in response to a blog post from a couple of years ago pointing out the confusion. https://redfin.engineering/two-commits-that-wrecked-the-user...A good conversation on HN followed. https://news.ycombinator.com/item?id=14712269I've long wished git checkout (and now, git restore) would save the contents of blown-away worktree files somewhere (e.g. a throwaway stash) so that they could be retrieved from the reflog or something.In my mind's eye, the command would be something like ""git trash"" and it would throw your changes into a trash can, where you could fetch them back out again later, until the GC erased them in ~30 days or so."	dfabulich	8.574421	-6.5247974	comment	4.0	17.0	1565998517	-11.864509
20722682	"This is still far from ideal. ""git s"	"This is still far from ideal. ""git switch"" and ""git checkout"" should not be able to create a new branch. It clearly should be the ""git branch"" subcommand's responsibility, because ""You want to do something with a branch"". It would be two commands to create and checkout a new branch, but less confusion. You can use your git alias anyway. But a shortcut for ""git branch -c"" would be better if you want to keep the ""create and switch"" shortcut IMO."	kissgyorgy	8.515126	-6.51373	comment	4.0	15.0	1566026320	-11.902588
20745900	I and the dozens of other remaining 	I and the dozens of other remaining Mercurial users will be severely inconvenienced by this.Still, at least SourceForge still has Mercurial support!	twic	8.494784	-6.554024	comment	4.0	22.0	1566302517	-11.988171
20745989	It's funny to see how the whole worl	It's funny to see how the whole world concentrates on this Git thing, while there is a treasure trove called Mercurial.Mercurial was made for humans. It is seriously convenient and productive. Something I cannot say about Git, which more reminds me of an adhoc job.I use both Git and Mercurial on daily basis. But my preference goes to Mercurial: it is just more sane in a big way. It is clearly a piece of art and love.	garganzol	8.516097	-6.5425677	comment	4.0	74.0	1566303191	-11.904784
20747245	> Neither of us knew about Reflog at	"> Neither of us knew about Reflog at the time, so that didn't even get onto the list of things to try.Was ""asking someone who knows how git works"" on your list of things to try?What about ""learning how git works""? Was that on your list?Frankly, you don't seem to have been trying very hard to get this work back."	phaemon	8.569357	-6.541088	comment	4.0	19.0	1566310475	-11.890258
20747541	This suck big time.HG is by far the 	"This suck big time.HG is by far the best UX of all SCM I have used. Without bitbucket I think usage of hg will drop even faster.The sad thing is that git requiere so much arcane usage that hg have spared me for so much time.I wonder why the worst always win? C, C++, JS, MySql.Don't tell me is for ""speed"" or ""features"". Is incredible how much stupid effort and money go in put a lipsick on top of that when nicer ways exists... and are know... and have proved to work... and even faster (look at you, C/C++ build times)...Even MORE bizarre is why not improve the tools coping what is good from others AND cleaning the usage of them?Probably only python of the ""good"" side have critical mass..."	mamcx	8.527105	-6.5327883	comment	4.0	20.0	1566312329	-11.94809
20747806	Git won because it's superior in a w	"Git won because it's superior in a way that many programmers think doesn't matter: performance.Git is incredibly fast. Many operations happen almost instantaneously even on large repositories. It's really nice. I've heard a lot of people talk about how they abandoned mercurial because it's slow. Some even switched to git from svn not because git's model is better but because svn is slower.""Premature optimization is the root of all evil"" is an old programming advice quote that is so horribly misunderstood that it's basically wrong. It means think about your problem at the high (algorithm and overall goal / design space) level before worrying about low-level optimizations. It does not mean that optimization is bad or that performance isn't important.I made another comment recently on the sam"	api	8.521113	-6.539012	comment	4.0	15.0	1566313736	-11.937368
20779347	I literally forgot about Mercurial. 	I literally forgot about Mercurial. It’s been years since I’ve even heard it mentioned. Are there any strong arguments for using it over Git these days? Is this just about supporting legacy code bases. I’m sure there must be a way to migrate to Git [and maintain history]. I’m not trolling, I would love to hear from someone who prefers Mercurial over Git as to how it benefits them.	todd3834	8.506136	-6.549978	comment	4.0	15.0	1566578344	-11.947743
20787956	Ask HN: Best branching strategies fo	Ask HN: Best branching strategies for continuous delivery?	ljoshua	8.744525	-6.5312796	story	4.0	5.0	1566663104	5.6850305
20875463	Can you make a recommendation of a p	Can you make a recommendation of a process which doesn't involve cherry-pick commits (or more often patch-sets)?Note, your process needs to allow a fix to be developed against V5.1, and back-ported to V4.1.I suspect one of the problems here is a lack of bug tracker, which would have associated the fix to the merge and the fix itself together.	richardwhiuk	8.595009	-6.539197	comment	4.0	18.0	1567589712	-11.876078
20875562	The question is though, why would yo	The question is though, why would you even bother changing public history, even if you can work around the practical problems?In my view, the concept of a commit mapping exactly to a functional change, and therefore being able to be correct or incorrect, improved, etc, is going against the grain of what revision control is. A commit just is what it is. If it contains a typo, a bug, etc, you notice and fix it 2 days later and that's another commit. Git just describes what happens. What is the utility in pretending that didn't happen and rewriting the history of changes as if you never made that mistake? Who benefits?If you are concerned about keeping master 'stable' so that checking out any commit will result in a clean, working codebase, you can use abstractions on top such as tags to poin	davnicwil	8.582144	-6.565182	comment	4.0	24.0	1567591005	-11.913578
20995359	"The ""Create merge request"" (from iss"	"The ""Create merge request"" (from issue) button.It creates a new branch, with a smart name like 123-my-issue-title, and a new ""pull request"" for that issue and branch."	trumbitta2	8.583714	-6.5074306	comment	4.0	13.0	1568729899	-11.9126425
13621636	Coming from companies that use reaso	Coming from companies that use reasonably-sized git repos, I absolutely hated Google's VCS.Here's some of my painpoints with it:* No branches. If you want to make a temporary code branch, you create a CL (Google's version of a pull request), but never submit it. This means nobody else can collaborate on it with you, and it must be manually updated to HEAD.* No CL collaboration. Unlike Git branches, CLs can only contain changes from one user.* No stable branch. Since everything is essentially on one long branch, it's a real hassle when a project is broken at HEAD. Sure, integration tests should ideally prevent this. In practice, HEAD is often broken. Teams have created bash scripts and mailing lists to determine 'stable' old versions that can be checked out for development.* Single versions	throwawayGogEng	8.58225	-6.446216	comment	4.0	18.0	1486799433	13.825853
13632285	This is a little disappointing for s	This is a little disappointing for several reasons. I understand the merits of GitHub but I really wish Python at least stuck with Mercurial repository and some decentralization.It's especially sad because Mercurial is just now starting to be incredibly powerful with evolutions.I guess I'm an old fart but all the centralization has made me paranoid and I still absolutely prefer Mercurial (albeit with plugins) over git.	agentgt	8.543356	-6.5274253	comment	4.0	22.0	1486947598	-11.798101
13644337	This distinction between commits and	This distinction between commits and patches (I've been following git, hg, and darcs for over a decade) is one I've never quite understood.  A patch says, take this original line of code found here and change it into this new line of code. A commit is just a patch that records when in the history you can be sure to find that original line of code.  If you take an arbitrary patch and apply it to an arbitrary set of code you might not even be able to find that original line of code.  How do darcs and/or pijul solve that problem?  Git and mercurial have tools like rebase and cherry pick that allow you to rearrange commits and they can even use three way merge algorithms (because of the DAG) to help recompute the patches for when that original line of code isn't quite what the patch specifies 	krupan	8.59542	-6.548194	comment	4.0	19.0	1487087390	13.889234
13652009	From the article:Most of them, [Sons	"From the article:Most of them, [Sons] said, ""are older than my father.... [and] are not always up to date on the latest techniques and security issues."" [...] Sons suggested that they ""should be retired.""That is incredibly asinine and discriminatory to boot.From the NTPsec project manager's comment:The main point of contention that caused the fork was BitKeeper vs Git.I can't believe that arguing over VC tooling is what caused the fork.  Why not just compromise on this, use BitKeeper for long enough to get on the maintainer's good side, and helpfully offer to convert to Git later?  This is how ESR got GNU Emacs development migrated from Bazaar to Git, and it seemed to have gone pretty well for all involved."	xenophonf	8.563037	-6.441649	comment	4.0	23.0	1487167137	-11.866443
13713557	Here's a good blog about how SHA-1 w	Here's a good blog about how SHA-1 works:http://www.metamorphosite.com/one-way-hash-encryption-sha1-d....The biggest risk I see with this is how torrents are affected:https://en.wikipedia.org/wiki/Torrent_poisoningThere's also a problem with git, but I don't see it being that as susceptible as torrents:http://stackoverflow.com/a/34599081/6448137	ktta	8.6881485	-6.5198336	comment	4.0	28.0	1487855842	-8.280302
13713625	EDIT: My original comment was wrong.	EDIT: My original comment was wrong. Git commit signing apparently only signs the commit hash itself, so it's only as trustworthy as the integrity of the hash. However, see also other comments which point out that this isn't a pre-image attack; you can't find a collision for a given thing (in this case, the linux kernel); rather, you can generate from scratch two pieces of data which happen to collide. Still, this is worrying.ORIGINALLY (INCORRECT): Git commit hashes were at least never intended as a form of authentication. That's why git has commit signing. That said, they list GPG signatures as one of the things affected by SHA1 brokenness, so maybe even that's not enough? I don't know enough about how git commit signing or GPG works to tell.	rntz	8.648568	-6.504291	comment	4.0	17.0	1487856325	7.194738
13714246	I'm trying to play with this in git.	"I'm trying to play with this in git. Added the first file, committed, and then overwrote the file with the second file and committed again. But even when cloning this repository into another directory, I'm still getting different files between commit 1 and 2. What does it take to trick git into thinking the files are the same? I half expected ""git status"" to say ""no changes"" after overwriting the first (committed) pdf with the second pdf?"	0x0	8.614366	-6.5248065	comment	4.0	27.0	1487861477	-11.863008
13714890	Ask HN: How will Git get around the 	Ask HN: How will Git get around the discovery of SHA-1 collissions?	verandaguy	8.662184	-6.5160136	story	4.0	9.0	1487865497	7.205532
13719612	Do you know if git objects' size hea	"Do you know if git objects' size header was designed to deal with a possible collision or does it serve another purpose as well?Just some context - git calculates an object's name by his content in the following way. Say we have a blob that represent a file who's content is 'Here be dragons', then the file name would be:  printf ""blob 17\0Here be dragons\!\n"" | openssl sha1
  # => a54eff8e0fa05c40cca0ab3851be5aa8058f20ea

So the object gets stored in '.git/objects/a5/4eff8e0fa05c40cca0ab3851be5aa8058f20ea'"	almog	8.64327	-6.5009327	comment	4.0	13.0	1487896935	-5.9243665
13720149	Several years ago I worked on a secu	Several years ago I worked on a security product that used git as a sort of tripwire-type database. Since SHA1 was considered inadequate for Real Security, we had to hack jgit to use SHA256. It took a stupid amount of work - the 160-bit hash size was scattered all over the codebase in countless magic numbers. But it worked.The product was cancelled. I always wondered if the patch would be of any use to anyone.	stickfigure	8.688243	-6.524645	comment	4.0	16.0	1487901212	-5.9242444
13721710	I control a fleet of servers. I have	I control a fleet of servers. I have a saltstack or ansible script. One of the steps in provisioning a new server is to pull library X from github.com.One day Egor Homakov finds a new hack and finds his way into access to the master branch for library X. As a prank, he force pushes a change to master.Being aware of such a possibility, instead of setting up my script to pull from master or even a specific tag, perhaps I pull from a specific sha1sum. That way I know I'm getting the exact version I want. That's today. Tomorrow, when preimage SHA-1 attacks are cheap, it will no longer save me.	orblivion	8.715972	-6.5185447	comment	4.0	52.0	1487920617	7.1804595
13722319	Correct me if I'm wrong, but if you'	"Correct me if I'm wrong, but if you're letting untrusted people push to your git repositories, you're pretty much screwed anyway.Given a case where someone with permission to push gets compromised and a malicious actor can pull this sha-1 attack off, aren't there bigger problems at hand? The history will be there and detectable or if they're rewriting history, usually that's pretty noticeable too.I may be totally missing a situation where this could totally screw someone, but it just seems highly unlikely to me that people will get burned by this unless the stars align and they're totally oblivious to their repo history. So I guess I agree with the ""the sky isn't falling"" assessment."	moonshinefe	8.604662	-6.4816546	comment	4.0	12.0	1487929561	-11.609565
13733951	> reversing commit hashes back into 	> reversing commit hashes back into their contentsSomewhat off topic, but is this actually possible?Given hashing is inherently lossy, I'm inclined to assume it's not possible for anything must longer than a password, but commits are text, which I suppose is low entropy per character, so I don't know.	chainsaw10	8.594046	-6.5183	comment	4.0	18.0	1488058262	-4.93298
13734512	Yes, exactly.If Linus truly doesn't 	Yes, exactly.If Linus truly doesn't care about security, then git could use any error correcting code that produces a uniform distribution of tags, such as CRC64. The size of the tag only affects the number of objects we'd expect to be able to commit before we see a collision: over 4 billion in the case of CRC64.Linux mistakenly claims using a cryptographic hash function helps avoid non-malicious collisions, but this is not the case.Where the choice of a cryptographic hash function matters is  specifically if we expect an attacker to be trying to collide tags. CRC64 is a linear function of the input data and therefore fails miserably at preventing attackers from colliding tags, but still produces a uniform distribution of tags for non-malicious inputs.git seems to be in the odd place where	bascule	8.662679	-6.5151124	comment	4.0	31.0	1488065141	7.3064466
13735305	You're saying Linus's statements are	"You're saying Linus's statements are ""hugely misleading"", but it's just that you wish git were designed to be used differently. So, your argument is ""horseshit"".Linus could have designed a cryptographically perfect system such that he could pull Tytso's signed commit from anywhere on the internet - but he didn'tLinus used sha1 as a useful tool for an effective DVCS with an initially simple implementation.He still depends on the security of the kernel.org servers, his work computers, and the top submaintainer's work computers. His git trees and all the submaintainers he pulls from are hosted on kernel.org servers. Security of the kernel.org servers is taken very seriously, especially since the well-known break-in a few years ago. Now even two-factor auth is involved in all git pushes to ker"	ploxiln	8.618797	-6.4608803	comment	4.0	21.0	1488076381	-11.901761
13736562	My takeaway from all that - the git 	My takeaway from all that - the git project is internally taking steps to mitigate vulnerabilities from this particular attack (making it harder to insert the arbitrary binary data necessary into git metadata), but a) is just throwing up their hands at the problem of projects that store binary blobs like image data in their repos, and b) is not taking this as a signal that more serious sha-1 attacks are on the horizon and they should speed up their hash-replacement efforts.This latter leads into the problems with Linus' positions in particular. In that thread, does not take seriously the threats that this poses to the broader git userbase, because he only seems to care about the kernel use-case: trusted hosting infrastructure at kernel.org (itself an iffy assumption, given previous hacks a	azernik	8.668915	-6.512852	comment	4.0	24.0	1488104629	7.163986
13818751	Utter Disregard for Git Commit Histo	Utter Disregard for Git Commit History	kiyanwang	8.577457	-6.5313845	story	4.0	14.0	1488960315	-11.887257
13895140	Ask HN: How do /you/ annotate a lega	Ask HN: How do /you/ annotate a legacy code base?	amflare	8.600738	-6.483272	story	4.0	5.0	1489767252	-11.918933
13906899	Can it really be that simple though?	"Can it really be that simple though? If you are using a newer version of Git on your repo which is committing only with the newer
hash and I try to clone your repo with an older version I will be unable to do so. I guess maybe that's acceptable though?"	ebbv	8.611279	-6.4610815	comment	4.0	20.0	1489930035	-11.803728
13907231	Perhaps you haven't read Linus' comm	"Perhaps you haven't read Linus' comments where he stated (more than a decade ago) that the usage of SHA1 here isn't for ""security""?(Hint: that's why GPG signing commits is an option.)"	jlgaddis	8.702939	-6.5164614	comment	4.0	20.0	1489933543	7.3258743
13961684	>  Git is the standard now and has b	>  Git is the standard now and has been for years.Only in the open source world and a few SV darlings.I am yet to do a project at a Fortune 500 among our customers that isn't based in Subversion or TFS.I have been using Git only on personal projects.	pjmlp	8.555823	-6.4441934	comment	4.0	28.0	1490547284	-11.884311
14014281	I got side-tracked by the talk of ve	I got side-tracked by the talk of version control.  Do they use a single repo for everything?  It seems like it from they way they talk.In that case, I am surprised git is a good fit.  SVN might have been better, though some commercial solutions like ClearCase or Perforce would actually be right for that sort of work-load.	adrianratnapala	8.598133	-6.4389114	comment	4.0	19.0	1491082206	-11.835288
14178868	Four Steps to Maintaining a Clean Gi	Four Steps to Maintaining a Clean Git History	philk10	8.568202	-6.5396566	story	4.0	9.0	1492965486	-11.901808
14249993	I tried:    https://github.com/dosay	"I tried:    https://github.com/dosaygo-coder-0/urizip/commit/cb2bfd2e04e8b814943e42a5bf87eeff31a77126

Got    kl9oo67XTkQCETxduLJSW5iUfSNh5pW6iDuhqKmzprOoJCaUYmMo5M7kiMaYxrBRjTQsWzqDks9BlBQWEQKsrKImrQU

Which is longer.Also ""OK"" isn't a great commit message for almost every commit:https://github.com/dosaygo-coder-0/urizip/commits/master"	tghw	8.5792885	-6.525282	comment	4.0	12.0	1493755016	-11.904754
14252148	Throwaway for obvious reasons.I too,	Throwaway for obvious reasons.I too, am a female engineer at one of the well known companies in the Bay Area.As a background, I have a masters degree in CS and am in my 5th year of working as an engineer.Here's the problems that I faced:1. Not taking my opinions seriously - I experimented with this one! My manager would endlessly argue over every small opinion I had but the same opinion that my colleague would have, would get noticed and sometimes even praised. Even on silly things. I can't get into project details but for a new project, I suggested that we try out the desktop version of Git to make transition from p4 easier. My manager was absolutely against it and asked me to setup a p4 project for the same and make it work with p4. A coworker(10 years my senior) suggested we use the sam	thinkaboutit113	8.540135	-6.5053053	comment	4.0	19.0	1493772528	-11.904994
14305474	Hidden in the notes at the bottom is	Hidden in the notes at the bottom is a pretty useful improvement to 'git stash':> 'git stash save' now accepts pathspecs. You can use this to create a stash of part of your working tree, which is handy when picking apart changes to turn into clean commits.I believe there may be a slight error in the GitHub blog post I quoted above: from what I can tell, it's actually the 'git stash push' command that now accepts pathspecs. But either way, still a neat new feature!	freditup	8.573832	-6.55478	comment	4.0	21.0	1494382724	-11.87913
14535369	Long time user of both bazaar and gi	"Long time user of both bazaar and git here.> To be fair git is junk;git's UI could certainly benefit from some simplification ; this doesn't make git junk, especially considering that it's incredibly fast and reliable.> it's just the standard so everyone has mostly learned it and it gets the job done, but at least Mercurial is better. Probably bzr too.Bazaar and git actually have lots in common, they both have the advantages of DVCS (which seem to be often confused with ""the advantages of git"") (like, say, ""rename""?)Here are the main differences I noticed:Bazaar is definitely slower, but you need an big-open-source-sized repo before noticing the difference.Bazaar doesn't have ""rebase"" by default, but you can install it as a plugin and it works.Bazaar has an optional ""automatic push after e"	Ace17	8.566865	-6.49494	comment	4.0	21.0	1497246284	-11.879063
14567888	Old last commit date could mean two 	"Old last commit date could mean two things:1. Project left in unfinished state and development stalled, in which case it's reasonable to run away from it.2. Project done (fulfilling it's purpose) and turned to maintenance mode, in which case I'd be quite happy (as a matter of fact I'd prefer) to use it as I know I'm dealing with a stable codebase and don't need to be afraid of breaking changes in the future.I think it would help if maintainers would state the ""completeness"" in the README file."	insulanian	8.600244	-6.460419	comment	4.0	12.0	1497610350	-11.883524
14579424	Not sure I understand.a) lead dev is	Not sure I understand.a) lead dev is stepping downb) lead dev has not groomed a successorc) this is where I am lost. he says patches welcome... But who will merge if he has no time or has no successor?	simplehuman	8.744097	-6.4512396	comment	4.0	17.0	1497770110	1.7763952
30745306	a nice feature of sublime merge that	a nice feature of sublime merge that i haven't seen in other programs is actually showing you the git commands that will run when you press whatever button	mackrevinack	8.695037	-6.499629	comment	4.0	13.0	1647801414	-11.794171
30816123	Seems like Fossil is more like an al	Seems like Fossil is more like an alternative to GitHub than Git. Fossil not only tracks code changes but team chat, bug tracking, wikis, etc.	umvi	8.503723	-6.5082045	comment	4.0	24.0	1648335738	-11.952795
30816218	I love the idea of fossil, git cli h	I love the idea of fossil, git cli has horrible and unintuitive porcelain. There is no brain dead git undo (except for the 'well actually if you sell your soul to the reflog' folks), but ultimately, just like C and unix, git may be annoying in some ways but its inertia and ubiquity keep it going way longer than it's technical merits deserve when directly compared to competitors.Also, fossil feels like someone built it for almost NIH reasons, which I freely admit is just my outsiders impression, but it feels to me like the tcl community tends to dogfood themselves a lot for cultural reasons.But fossil is already more complete and battle tested than anything this lowly amateur will accomplish in his career.	Multicomp	8.50101	-6.545253	comment	4.0	12.0	1648336643	-11.980317
30958065	I'll be trying that magic incantatio	I'll be trying that magic incantation shortly.[Edit] I tried it, and it didn't make anything worse.What I was hoping to find (and spend a few days looking) was for some set of flags I could give to a modern copy of gcc to hold it's nose and compile this code as-is, as a starting point.Git under Debian 3 seems to be a no-go. I'm tempted to just have two virtual machines that are never on at the same time  mount a separate virtual disk that holds the Stoical source code and git repository.Make changes / test in Debian 3... when happy shut it down, fire up Debian 11 and do a commit and push to github. Shut it down, fire up Debian 3, repeat.	mikewarot	8.609409	-6.476073	comment	4.0	14.0	1649430603	7.3458786
30988965	How has nobody heard of Perforce. It	How has nobody heard of Perforce. It was the SCM of choice for a lot of companies until git came along. Doesn't Google still use it?BTW, Perforce's diffing/merging tools [0] are fantastic.[0] https://www.perforce.com/products/helix-core-apps/merge-diff...	secondcoming	8.621563	-6.5121274	comment	4.0	17.0	1649686291	-11.830793
31006496	A Mercurial compatible SCM (not sure	A Mercurial compatible SCM (not sure if it is a fork) built for their workflow (monorepo) and scale (enormous, git is not usable at their scale, at least for a monorepo). Uses Python and Rust. Designed for efficient centralization rather than decentralization.	gregwebs	8.522895	-6.5368547	comment	4.0	47.0	1649787919	-11.941308
31007191	OK, slightly off-topic but maybe the	OK, slightly off-topic but maybe the right minds are here. We have been developing an introductory CS curriculum committed to thinking-with-powerful-tools, including the command line, real programming languages, and git. It's great until it isn't. We intentionally maintain a simplified workflow, but still get the occasional merge conflict or local state blocking a pull. I keep thinking there must be a simplified wrapper over git which maintains the conceptual power while avoiding the sharp edges, even if at the cost of robustness. I'd be more interested in an abstraction than a GUI, but would be interested to hear whatever others have come up with.	cproctor	8.575881	-6.4939194	comment	4.0	12.0	1649791667	-11.894567
31037164	Github is built with MVC. On rails n	Github is built with MVC. On rails no less. Where problems like soft delete are hard, or even impossible to solve (in scale).Yet there are many architectures beside MVC. Many of them decades old. Proven. Established. Yet unknown to devs who picked up a rails book on day 1 and never looked back (I've been guilty of that for years).This particular problem is a textbook candidate for Command Pattern. The problem of undo is solved naturally in any event-sourced setup (git is even sourced, and moving through history a prime feature). Probably more architectures that I'm less familiar with, solve 'undo' as well.But we are stuck with the web, backends in 2022, being built on MVC frameworks like Rails, where solving such issues is tough and complex. So we are stuck with a huge amount of warning di	berkes	8.584133	-6.5243397	comment	4.0	17.0	1650004351	-11.877315
31044575	"And what if you decide mid-vipe ""oh "	"And what if you decide mid-vipe ""oh crap I don't want to do this anymore""? In the case of branches to delete you could just delete every line. In other cases maybe not?"	orblivion	8.624993	-6.5424147	comment	4.0	21.0	1650050476	-11.871717
31048617	> Bonus points for no PR’s and trunk	> Bonus points for no PR’s and trunk driven development as that shows a very mature team.I'm not sure what Trunk Driven Development is, could you elaborate?	bluefirebrand	8.607354	-6.5352483	comment	4.0	26.0	1650075413	3.192193
31048883	https://trunkbaseddevelopment.com/tr	https://trunkbaseddevelopment.com/trunk1c.pngSo trunk driven development means no PRs, until you decide you want to use PRs?	Manuel_D	8.616732	-6.512528	comment	4.0	12.0	1650077434	3.2811577
31163913	That sucks and I know it doesn’t hel	That sucks and I know it doesn’t help fix your current situation, but I’ve found it useful to include more context and long comments in commit messages than code comments. If your team knows how to use git blame for archeology, the information tends to stay more cogent to the code, while code comments often go stale.	eloisius	8.573316	-6.497173	comment	4.0	16.0	1650946992	-11.914617
31173778	If you really want just one commit o	If you really want just one commit on your PR you can reset your branch to its target before you merge:git reset --soft <target>Which will undo all commits and leave all modified files in the staging area. Then you can make one commit and force push it to replace your branch @ remote.	elpakal	8.588095	-6.5423846	comment	4.0	15.0	1651010917	-11.938762
31174106	I built a full pipeline around this.	"I built a full pipeline around this. Basically allowed for a paved road for devs to automatically semantically version and deploy application and module artifacts for npm with semantic release by spinning up a repo with some boilerplate generators I made available to the team.Since then I've been obsessed with the conventional commit format everywhere for my own projects. Even if the commits aren't parsed for versioning, it just gets you into the habit of thinking about the scope of the commits.The laughable part about building that full paved road pipeline is that the biggest friction point was always when devs didn't use semantic commits. At the time when I implemented it I didn't have checks for the commit format at the pr phase. I DID have a commitizen cli option as well but that was """	_virtu	8.621755	-6.508003	comment	4.0	13.0	1651013224	-11.8980055
31176674	We also have a rule to prepend every	We also have a rule to prepend every commit message with its issue number in our issue tracker (we don't use GitHub). That way in Git Blame/Log you can always quickly find where the change came from and why - the issue tracker usually has more detailed information.	kgeist	8.573173	-6.506759	comment	4.0	16.0	1651037594	-11.862378
31203943	You know you can shorten the commit 	You know you can shorten the commit hash?For example https://github.com/torvalds/linux/blob/9e02977bfa/kernel/dma...I don't find this ugly, it's even very human readable. There's all info in the url that you even can use in the future if GitHub ever goes away.	bhaak	8.604597	-6.5173717	comment	4.0	28.0	1651232731	-11.87522
31288125	True to an extent--meaning mostly tr	"True to an extent--meaning mostly true in practice.You can mutate the Git data if you chose to using commands like ""filter-branch"". ""filter-branch"" isn't used frequently, since it causes issues with every up/down-stream replica if the data has been pushed/pulled, but it is possible. But, even some commonly used commands like ""amend"", ""rebase"", and ""squash"" cause limited data mutations which are broadly considered appropriate and useful."	colburnmh	8.5968895	-6.4970593	comment	4.0	22.0	1651860299	-11.895593
31402488	One of the things I like in P4Merge 	One of the things I like in P4Merge is having 4 panes - the two versions, their common ancestor, and the final merge result. Can you get all these in Meld as well?	m12k	8.730385	-6.4694076	comment	4.0	19.0	1652731105	9.2257
31403538	I REALLY love the way merge tool wor	I REALLY love the way merge tool works in IntelliJ IDEA.Is there some other tool out there that works in a similar way, and that good?(tho, typing idea . and doing a merge fix is not that bad)	kodisha	8.696802	-6.4991016	comment	4.0	15.0	1652737642	-11.808681
31420571	I mean this is only a problem if you	"I mean this is only a problem if your commit work flow is ""git add . && git commit"".A bad habit, in my opinion."	alex_smart	8.588612	-6.5113053	comment	4.0	45.0	1652864027	-11.907371
31420618	Try `git add --patch` (or just `-p`)	Try `git add --patch` (or just `-p`). git will go through each change and you can decide if you want to stage it. You can even stage individual changes in a file.This doesn't cover new files though. For those you can use `git add $filename` or even globs with `git add src/some/dir/*.$extension`.	muhbaasu	8.600268	-6.5176344	comment	4.0	16.0	1652864774	-11.905894
31449867	Why would the tool want to ignore pa	Why would the tool want to ignore patterns in a .gitignore? It isn't a git tool...	jonnycomputer	8.606508	-6.4780793	comment	4.0	19.0	1653065255	-11.779901
31459752	A lot. Here are some examples:Say yo	"A lot. Here are some examples:Say you are the reviewer, you gave some feedback for the author to address. The author says they addressed them and asked for your review again. How do you review that? Of course you can just review the whole change again, but if it's a huge change and you only asked a few small parts to be changed, it would be hard to make sure the rest are still the same. How in Github's PR model can you see the diff between the 2 states of a PR? The only way is for the author to push a separated, ""fixup"" commit to the review branch, so you can just view the diff of that commit. But that creates those ""fixup"" commits that's not useful in the final merge, so you will want to use squash merge in the end, and using squash merge means that the final commit message is totally up "	fishywang	8.582706	-6.4690127	comment	4.0	13.0	1653153344	-11.90953
31571942	The UI does look really good, but I 	"The UI does look really good, but I do wonder how much of the dev community uses a GUI vs just sticking in the command line?Personally the only GUI stuff I find useful are the features that are already part of VSCode (live showing what I have changed or doing a diff). Outside of that I generally find that any GUI for git just inevitably makes something just opaque enough that I don't really know for sure what I am about to commit or where I am pushing too. For me ""git status"" >> ""git add XYZ"" >> ""git status"" >> ""git push"" are so ingrained in my workflow that I don't get that feedback in any UI I have seen.I have started to dip my toes into it a bit now with the Atlassian integration that can name new branches properly... but even using that just gives me a weird disconnect with what is act"	nerdjon	8.577569	-6.4986267	comment	4.0	15.0	1654016528	-11.840927
31635506	Squash commits aren’t rewriting hist	Squash commits aren’t rewriting history.	cortesoft	8.581396	-6.570093	comment	4.0	19.0	1654468773	-11.962684
31635989	Sure, their are developer communitie	Sure, their are developer communities around the other SCMs, and many are passionate about those alternatives.My point is that even if you do get into one of those other communities, you are still going to have to learn how to use git because so much of the world uses it. You will need it either for your job or because the open source project you want to use is on it. You can't skip learning git.If you don't mind that, then go for it. For me, I don't want to use my limited capacity for learning things on learning a second (or third, since I still have SVN usage somewhere in my brain) SCM.	cortesoft	8.558114	-6.4575	comment	4.0	21.0	1654473654	-11.916186
31636394	Love it when people don't talk about	Love it when people don't talk about rebase. considering its both dangerous, and a requirement to use for many teams.	nmz	8.593859	-6.5598707	comment	4.0	12.0	1654477534	9.335488
31697616	Is fossil the main competitor to git	"Is fossil the main competitor to git? The ""only"" significantly different one?"	kzrdude	8.492784	-6.551971	comment	4.0	22.0	1654885171	-11.9694805
31697951	I made this comment on a post a few 	I made this comment on a post a few days ago about using a different SCM:> I feel like an SCM would have to be WAY better than git to make it worth using. The entire developer community is on git, so you are still going to have to know how to use git in order to access other open source projects. If you are already going to have to be using git for many things, why add a second SCM you have to learn to use?	cortesoft	8.555843	-6.4687047	comment	4.0	37.0	1654886829	-11.910906
31752094	Hmm no mention of Mercurial which wa	Hmm no mention of Mercurial which was also released around the same time as Git and IIRC was also a contender for Linux kernel development VCS.Larry McVoy basically forced the creation of Git via Andrew Tridgell and look where we are today - while world uses Git. Larry must have had his reasons but I wonder how he feels about the outcome.	blinkingled	8.550095	-6.4810786	comment	4.0	22.0	1655296786	-11.905672
31752920	What was the relationship or connect	What was the relationship or connection with Apache Subversion, if any?  I remember using SVN for about 5 years before GIT.	stevenjgarner	8.60125	-6.4655595	comment	4.0	22.0	1655301310	-11.863945
31753670	Git undoubtedly has disrupted the SC	"Git undoubtedly has disrupted the SCM space and become the major player for some very good reasons. But this bit of history casts the famous Linus quote in a bit of a different light; ""Git proved I could be more than a one-hit wonder."" Initial adoption by a major project is not something everyone can make happen by throwing their weight around. If he had communicated better, arch, darcs and monotone could've been git.SQLite has their own SCM (fossil), which hasn't taken off to nearly the same degree. Some of it has to do with the main problems different projects have. Some of it has to do with marketshare, and git started on 2nd base in that area."	mcdonje	8.538147	-6.484041	comment	4.0	20.0	1655304299	-11.915958
31756857	I suspect this is a myth. I used svn	I suspect this is a myth. I used svn for years and don't remember merging being problematic. In fact I remember it being better (less need to manually merge) than today's git. What svn couldn't support well is: zillions of branches. So branch-happy workflows would kill the server. Today's PR-style would probably work ok since it mirrors how we typically worked with svn -- small frequent commits to trunk. Branches only used for maintenance on past releases.	dboreham	8.588696	-6.519875	comment	4.0	12.0	1655316384	-11.919161
31763401	I appreciate this post. It's nice to	"I appreciate this post. It's nice to see that there are other teams that feel some of the pain points of git, (and unsurprising that most of the responses are ""you're holding it wrong""). The fact is that git doesn't scale to _very large_ repos, We've seen it time and time again, but there isn't really a great alternative. Perforce is.... Perforce (centralized, very expensive to license, branches are incredibly expensive and streams still feel like a band aid even years and years later). PlasticSCM (which we use at work) is fine, but closed source, mildly expensive, and has a terrible UX"	maccard	8.544262	-6.449005	comment	4.0	17.0	1655364646	-11.8660965
28845061	> presumably you can later substitut	> presumably you can later substitute the initial commit with the other one without anybody being able to detect the substitution.How? Which operation would be involved? Will it not show anywhere else(reflog)?	outworlder	8.616424	-6.544041	comment	4.0	19.0	1634072648	-11.90418
28845333	The possible attack is to prepare 2 	The possible attack is to prepare 2 versions of a commit, both resulting in the same commit id. Then later on, after the project is successful/etc, swap out the commit with the second version, while keeping the other commits intact.Granted, the file that the commit touches would need to be not touched in other commits. That's not out of question in a typical software project - maybe a file in the utils folder which is only written once and never changed?> I don't think it's possible to create a collision that's also executeable codeYou can include an unreadable binary blob in the commit. Tweak the blob to find the collision while keeping the code the way attack requires.	noway421	8.620835	-6.5246043	comment	4.0	14.0	1634074267	4.148344
28851360	On 'porcelain', the way Git uses tha	"On 'porcelain', the way Git uses that term is a pet peeve of mine. On the one hand, the intended meaning of it is that ""porcelain"" commands are meant for humans, not for other programs - scripts should use the ""plumbing"" commands (apparently, it's a toilet analogy). On the other hand, the flag that makes ""porcelain"" commands write machine-readable output is called... ""--porcelain"". Implying it does the opposite of what it does."	TeMPOraL	8.557518	-6.4946737	comment	4.0	21.0	1634128805	-11.904641
28900150	Rebase is already lightning fast for	Rebase is already lightning fast for me... Even on projects with thousands of commits! How big does your repo have to get before rebases are sluggish?	umvi	8.578509	-6.5731397	comment	4.0	13.0	1634507713	9.38035
28955477	I use emacs and git, and never got o	I use emacs and git, and never got on with magit. Not entirely sure why, but here's a braindump:- I generally dislike layers on layers; while I seriously hate the git UI, I'd rather learn that, as it's a more portable skill, than learn another UI, that relies on emacs and a package installed. First thing I do on e.g. a new cloud instance is clone a bunch of stuff, and often work on an under-setup machine for a while. For similar reasons, I don't use shells like Fish, which, nice as they may be, funnel me into something totally incompatible with good old sh. Bash and zsh, as far as I use them, are compatible.- I work in tmux, and emacs in terminal, the overhead of switching to a terminal and typing some git stuff is tiny.- I tried magit and just didn't get it. I couldn't couldn't find a hap	rich_sasha	8.636718	-6.473281	comment	4.0	16.0	1634898084	-11.739773
28955653	> but rather around being selective 	> but rather around being selective about crafting self-consistent but single-theme revisionsActually, I think git's got Magit beat on that. Magit might make it easier to stage specific lines, but git can stage specific parts of lines or even changes that are completely different than what's on the worktree, through the editing of diffs with `git add -p`'s `e` option.	jolmg	8.667372	-6.4936643	comment	4.0	23.0	1634899953	11.884111
28956919	My bad, misgoogled.But this in fact 	My bad, misgoogled.But this in fact reinforces my overall point. I don't want to be messing with `reset`, hard or soft. What is `reset`? [I now know because I had to learn, but I'd really rather not].What I want is `uncommit`, or something like that.	rich_sasha	8.676052	-6.46741	comment	4.0	28.0	1634909206	-11.721797
28958613	> If you mistype it and nuke more th	"> If you mistype it and nuke more than the last commit, that's also a bit bad - and fairly easily done.If you ever run into this, you can use `git reflog` to see the history of your local actions. It's possible to revert almost any action with it.Reset a few commits that you've never pushed to remote? No worries! Just go to `git reflog`, find a point before it happened, and `git reset` to it.    $ git reset --hard HEAD^^ # OOPS
    $ git reflog
    c48300f3 (HEAD -> master) HEAD@{0}: reset: moving to HEAD^^
    527e26e0 (origin/master) HEAD@{1}: commit: air-interpreter-wasm = ""=0.14.10""

    $ git reset --hard HEAD@{1}

And you're back before ""OOPS"" :) It's really hard to lose changes once they've been committed."	folex	8.570398	-6.5439787	comment	4.0	15.0	1634917414	-11.884463
29016060	The main thing I use Exa for is as a	"The main thing I use Exa for is as a better ""tree"":    et() { exa -alT --git -I'.git|node_modules|.mypy_cache|.pytest_cache|.venv' --color=always ""$@"" | less -R; }
    alias et1='et -L1'
    alias et2='et -L2'
    alias et3='et -L3'

Exa is great for this because it shows file details along with the tree hierarchy.(I have to manually specify a bunch of git-ignores because Exa's git ignore support doesn't work properly.)"	kbd	8.684039	-6.521591	comment	4.0	13.0	1635354534	-11.759548
29018961	I don’t try to separate every last c	I don’t try to separate every last code change that doesn’t affect behaviour, but I often find it easier to put major refactorings in their own commits. This has at least two advantages: it means you know there shouldn’t be any test changes showing up in the refactor commits, and it means there is less to understand and review in other commits that do intentionally change the system’s behaviour.It’s not really a lot of extra work to do that once you get into the habit. Tools like `git add -p` to stage partial changes in files can be useful for separating self-contained refactorings from behaviour changes if you realise they’re happening at the same time and starting to get tangled.	Chris_Newton	8.615598	-6.5283847	comment	4.0	16.0	1635367981	-11.918621
29066280	Just leave. It's the professional th	"Just leave. It's the professional thing to do, if you can sustain yourself.In 2012 I've left my hometown and went to the other side of my country to work at a startup. Within 20 days I left because the situation was critical. I was already feeling like I should leave on the second week, but decided to wait just to break-even from my moving expenses.It was e-commerce startup where the team lead / project manager was actually the only backend engineer.One of the problems I had was that it was impossible to work with him.He despised git, so we used svn. Fine. It was in the early days of git, I could understand that.
He didn't write proper svn messages (but garbage like... always 'ghnwerigkelrwn'), and told me I shouldn't care about it. Ugh... Okay, I think I can try to change this situation.T"	henvic	8.584979	-6.5041986	comment	4.0	25.0	1635772571	-11.881652
29126222	The complexity isn't needless, it is	The complexity isn't needless, it is hard to find a part of git that can be simplified without losing something important.But the command line user interface is one of the worst I've ever seen. The names are bad, discoverability is poor and which command line tool does what doesn't always make sense.	roenxi	8.580604	-6.517393	comment	4.0	20.0	1636158480	-11.883055
29126469	I'm far from convinced by this artic	I'm far from convinced by this article.It's starts by saying that it's not comparing git and fossil but just keeps trying to throw generalities at your face how fossil is so much better and smarter than git.It sometimes compares git and all of a sudden compares github or gitlab, no reason given. So what is it about, comparing git, github or gitlab?Apparently git is to complex for developers, sorry but I have yet to see a developer not managing to work with git. Either I've always worked with geniuses or this is a non-problem.	boudin	8.483987	-6.512786	comment	4.0	19.0	1636160464	-11.971096
29126571	"""The mental model for Git is needles"	"""The mental model for Git is needlessly complex""that's it, right there.  Why are you bothering me about a detached head?"	dekhn	8.545597	-6.502516	comment	4.0	14.0	1636161317	-11.854915
29126689	You're also hiding history if you re	You're also hiding history if you repeatedly edit the code while you're debugging it, and sometimes undo 17 changes and re-do them differently in your edit buffer and such.A True Scotsmans non-history-destroying version control system would reveal and be able to replay every single editing keystroke that went into a change.	kazinator	8.594621	-6.5150423	comment	4.0	40.0	1636162386	-11.857784
29126724	I used Fossil for a bit a few years 	I used Fossil for a bit a few years ago. A nice, self-contained tool that stores everything in a single file that can be easily backed up.Had to give up on it because using two different revision control systems became inconvenient after a while. But I regret the loss of Mercurial, after having used it for a decade or so, more than that of Fossil.It always bothered me how a user-hostile piece of software like git rapidly took over the world. But then I remembered sh and bash and realized that someone thought that these softwares should be designed the way they were decades after Pascal and Lisp and hundreds of other sensible languages came into being, and they took over the world too.	sieve	8.561924	-6.4892077	comment	4.0	24.0	1636162649	-11.930762
29133758	The incorrect merge is preserved bec	"The incorrect merge is preserved because that is what actually happened.  The incorrect merge was published.  People saw it (and commented on it in the SQLite Forum).  If I ""disappear"" the merge, that would be airbrushing history.  The correct solution is to fix the problem, while maintaining an immutable audit trail, not to delete the problem.When I was in high school, I was taught that if I worked as a bookkeeper and I make a mistake, I should never erase the mistake.  Instead, draw a line through the mistake, notate what is wrong, and enter a correction.  To erase an entry in the financial ledger of a company is fraud.  It is a felony.  Making a correction is fine.  But do not erase.  Always preserve an audit trail.I believe that VCSes should be treated similarly.  While you are assembl"	SQLite	8.599897	-6.5496187	comment	4.0	21.0	1636232403	-11.876554
29200046	Git (VCS in general) seems like this	Git (VCS in general) seems like this absurd accidental secret of our profession.I use Fusion360 occasionally for hobby stuff, and its version 'control' is a joke, it's unfathomable to me how (especially since they're fellow engineers, technical people!) people can use and collaborate with it to build serious stuff.I think there's a lot of money to be made and a potential huge turning point in end user software for figuring out 'git for non-technical users'. People will argue it's not even good for SEs (I happen to like it) UI sucks etc. but that's not the point, it's fine, GUIs exist, that'd be an easy problem if everything was stored in plaintext. The key will be in figuring out how you make it attractive to people building software for such users, that they want to use your VCS mechanism	OJFord	8.577791	-6.4690523	comment	4.0	13.0	1636730291	-11.877489
29255971	>    How do you tell reviewers that 	">    How do you tell reviewers that your reactions PR depends on the comments PR?It's at the top of pr.""someone wants to merge 1 commit into random-branch from another-random-branch"">    How will reviewers see the relevant diff for the reactions PR (excluding the comments PR changes)?It will show it by default? If they want to see comments PR changes, they will need to go to comments PR.>    How can you propagate changes to the reactions PR if you ever need to update the comments PR before you land it (i.e. to address review comments)?Use git rebase --onto.It would be nice if the marketing page told prospective users what exact difference their tool provides - since I'm already using that workflow and never seen one of those internal tools."	KptMarchewa	8.589109	-6.478936	comment	4.0	33.0	1637170025	-8.575171
29517419	Ask HN: Open-source tool to build CI	Ask HN: Open-source tool to build CI/CD pipeline?	kamrani	8.652018	-6.4784646	story	4.0	11.0	1639184889	8.961485
34166801	Will Git be around forever? Possible	Will Git be around forever? Possible successors: Fossil, Pijul [video]	hazelnut-tree	8.501029	-6.53613	story	4.0	12.0	1672265993	-12.0028515
34194741	What will come first? IPv4 retired o	What will come first? IPv4 retired or git SHA-1 repos retired?	usr1106	8.68624	-6.524118	comment	4.0	12.0	1672476256	7.217486
34280377	"I fail to see how ""real"" version con"	"I fail to see how ""real"" version control would significantly alter this project. He's a solo developer, so the history is likely going to be a linear series of commits. 
That's not to say that there are not quality of life gains to be made, but dated backups of the repository would be fine."	0cf8612b2e1e	8.62104	-6.464198	comment	4.0	12.0	1673036132	-11.916953
34302226	Git is great once you get how it wor	Git is great once you get how it works.It’s also a UX nightmare. I work with tons of artists and engineers from the games and film industry.Teaching git to an artist is painful. UIs work, till they invariably fall apart and then they’re confused again in the command line. Also most UIs can’t abstract the ideas to a good easy system.Even a ton of very experienced engineers fall over when you touch rebasing etc…Now people will say use Perforce. Well that has its own issues around branching/streaming and integration for code etc… plus you’re tied to their systems, and I’m not convinced their UX is great either, just better.Plastic SCM seems to be the best so far but I haven’t really put it through the paces much.Anyway I guess my point is: git is a fantastic technology marred with bad UX. It’	dagmx	8.534716	-6.4742675	comment	4.0	16.0	1673206140	-11.916515
34302620	I get where the author is coming fro	I get where the author is coming from, but personally I feel like the juice isn't worth the squeeze.  The thing about git is that it is incredibly powerful, and the model is very simple and well thought out.  The only problem is the CLI is full of warts.  That sucks for beginners, but once you get over the hump, git is like a chef's knife—you can do anything with it, quickly and efficiently.  So any layers you build on it will, at best, make it easier to learn, but they won't make it more powerful.  On the downside, making a legible UI will require some opinionated decisions about what to emphasize and what to de-emphasize (sort of like how Mercurial is designed in a way that discourages rebasing).As to the specific suggestions, some of them are very poorly thought out.  For instance, the 	dasil003	8.556191	-6.5180273	comment	4.0	14.0	1673208943	-11.919912
34302027	Three things that I feel are true ab	"Three things that I feel are true about git's model:1- the model is not intuitive to beginners. There's a really tough learning curve.2- the model is powerful but leads to a few specific workflow. If you don't have the same mental model and don't want to use those workflows, you will have the ""misery"" the author describes. Otherwise, you'll be perfectly fine.3- no one has yet to do a great job of describing that model and workflow visually.The author's ""features from the future"" feel to me like they just haven't gotten a good feel for the model. That's why they are miserable. That's partially because git's model is hard to learn, and partially because after all this time they still haven't taken an hour to deeply learn it."	mabbo	8.54503	-6.5159745	comment	4.0	14.0	1673204916	-11.8812685
34303540	So rather than a small mini essay wr	"So rather than a small mini essay written after a squash on one commit you'd rather get 10,000 ""work in progress"" and ""oops"" and ""lint fixes""?"	pydry	8.578143	-6.565348	comment	4.0	22.0	1673214654	-11.916853
34334446	I agree, but am often outnumbered by	"I agree, but am often outnumbered by people who enable ""squash commits on merge"" and that simultaneously add many process barriers against actually merging pull requests."	hedora	8.579552	-6.5513515	comment	4.0	13.0	1673405069	2.1383328
34335922	Tickets can also be some documentati	Tickets can also be some documentation about why some code is why it is. Put the ticket number in your commit message and use git blame when you want to understand something better. By fixing code without tickets you make this impossible for future developers.	oefnak	8.547275	-6.484643	comment	4.0	12.0	1673421125	-12.079187
34414495	> whenever I'm trying to figure out 	> whenever I'm trying to figure out where something went wrong, commit are not the thing I look at, it's the code changes in the commitAnd how do you locate the commit of interest? I usually search the commit messages…	scintill76	8.588404	-6.5135965	comment	4.0	14.0	1673972749	-11.898236
34440937	I don't think of myself as old, but 	"I don't think of myself as old, but certainly grumpy and this comment rubbed me the wrong way.In my time as a dev I've worked with CVS, SVN, Mercurial, and then git. I can confidently say that no dev I've worked with ever kicked up a fuss when they switched, because each iteration brought improvements.I would however say that modern devs carry with them modern baggage. There are far too many bootcamps churning out devs who say ""this is git, everyone uses it, heres the minimum you need to know"". These are the devs who will struggle with this sort of change, it would literally change a magical system they don't fully understand for reasons they may not fully understand."	ActionHank	8.568991	-6.45193	comment	4.0	14.0	1674140147	-11.8803005
34458045	Not sure I’m familiar with any proje	Not sure I’m familiar with any projects using Subversion. I think the most odd-ball version control I’ve seen in prod is SQLite using Fossil (which does seem to have benefits over git) and OpenBSD sticking with CVS.	doublepg23	8.646578	-6.4375057	comment	4.0	24.0	1674241418	-11.850421
34458955	I use Subversion at my gig in severa	I use Subversion at my gig in several places.  I don't use it to manage source code revision control, but I have several processes that require business users to manage binary files (such as audio files) in order for them to be automatically deployed to production.  Git or Mercurial are pretty awful at this kind of role.  Subversion let's me check out at a subfolder level of a repository, and not pay the cost of having the full revision history contents sitting in my clone.	histriosum	8.601669	-6.4725657	comment	4.0	18.0	1674244858	-11.883642
34479791	> I believe the core issue is devs l	> I believe the core issue is devs like above never take the time to “grok” GitI believe the same, and it's not just a problem you see with git, it's all over the place. Some developers seems eager to use something so they just skim the documentation in order to do the least amount of reading and understanding in order to implement something, but often miss some fundamental detail and have to jump back. Or, they fundamentally misunderstand the tool at all, but push forward with their own idea what the tool is, rather than stepping back and start learning again.	capableweb	8.551034	-6.4901276	comment	4.0	48.0	1674408531	-11.89775
34480384	Pretty cool!One idea I really like f	Pretty cool!One idea I really like for avoiding VCS operation anxiety for beginners and experts alike is a filesystem layer that allows revert to any historical state.  You just have your bash prompt output the current snapshot number, and then can use that as the revert target if there's a botched rebase or so. Unfortunately I do not know of a nicely packaged way to do this, or how to do it at all with OSS tools (but I bet it is feasible!).	mgsloan2	8.584703	-6.5338607	comment	4.0	13.0	1674411393	-11.922732
34480694	I'm very happy to fundamentally misu	"I'm very happy to fundamentally misunderstand GIT's internals because I want to do a finite (and small) set of operations with it, not HOW it operates under the covers.Conflating the two, like you do, is elitism.""If you just stopped and read to understand..."", a-ha, sure, I'll do that for every one of the no less than 500 tools I've used over the course of my career and will never get anything done on time.There's no time. We got real work to do and no we can't switch to a company that gives us this time. There's a big world outside the Silicon Valley.GIT is a huge UX failure and seeing people pretend otherwise makes me question my -- or their -- sanity."	pdimitar	8.5487175	-6.4803195	comment	4.0	40.0	1674412844	-11.893026
34481357	I think that the bigger problem is t	I think that the bigger problem is the misuse of Tags as the sole method of marking a commit for release for example.Tags could be utilised for naming commits which would make it much easier to reason about where in the process of your development you are instead of referencing commits by hash. Hashes are hard to remember after all.	dev_snd	8.619213	-6.475724	comment	4.0	15.0	1674415803	7.07933
34482402	I've resigned myself to accepting gi	"I've resigned myself to accepting git because I have to use it. But JFC, I've hated it from the first time I tried it.We now have a large selection of tools that allow you to visualize what's going on (I use git-kraken), as well as google for help on doing something that isn't in muscle memory.But, really, SO MUCH pain and suffering could have been resolved by refactoring the damn commands to something more coherent and consistent. Git people sometimes call this ""porcelain""-- which I guess is an apt name because it makes one think of a toilet (but an improvement to a hole in the ground)."	crispyambulance	8.5616255	-6.496598	comment	4.0	15.0	1674422703	-11.929268
34524225	When everything is in git and you ha	When everything is in git and you have the log anyway, is there really any use for a changelog?	olddustytrail	8.594554	-6.5323234	comment	4.0	12.0	1674681034	2.681421
34527144	This is pretty interesting to me. Us	This is pretty interesting to me. Usually companies will gradually switch over to git. This is the first time I've heard of a company using git and ditching it in favor of older technology.	EMIRELADERO	8.532357	-6.452008	comment	4.0	13.0	1674701068	-11.894822
34583638	"This is not a ""problem"", this is why"	"This is not a ""problem"", this is why source control exists. You should never rewrite published history."	howinteresting	8.600182	-6.567567	comment	4.0	17.0	1675101280	-11.903599
34587457	This seems like a weak argument.Firs	This seems like a weak argument.Firstly SHA is not a secure hash.Secondly if your build step involves uploading data to a third party then allowing them to transform it as they see fit and then checksumming the result then it's not really a reproducible build. For all you know, Github inserts a virus during the compression of the archive.What am I missing?	ErikCorry	8.704395	-6.495663	comment	4.0	14.0	1675117869	7.277545
34587517	In my particular use-case, I'm using	In my particular use-case, I'm using a set of local dev tools hosted as a homebrew tap.The build looks up the github tar.gz release for each tag and commits the sha256sum of that file to the formulaWhat's odd is that all the _historical_ tags have broken release shasums.  Does this mean the entire set of zip/tar.gz archives has been rebuilt?  That could be a problem, as perhaps you cannot easily back out of this change...	denom	8.707998	-6.5020614	comment	4.0	18.0	1675118136	-5.521945
34602921	Have you tried running gitea? It's v	Have you tried running gitea? It's very light on resources, has good documentation, and also defualts to a main branch. It's also very easy to control where all the data is stored, and works well w/ sqlite.	benatkin	8.603044	-6.4760637	comment	4.0	25.0	1675202650	-11.906074
34665544	Source control does look very differ	Source control does look very different in a projectional language, as git diffs no longer make much sense (viewing a pull-request with the source tree's JSON blob is essentially useless).Unison is the language that's gone farthest with this, as far as I know; their solution to diffs & merges is to handle everything from within their CLI, bypassing git entirely. I imagine I'll do something similar.	jaredly	8.658088	-6.478996	comment	4.0	15.0	1675610314	-11.811099
34673125	I've hit a couple shops in a row now	"I've hit a couple shops in a row now where squashes are The Way. It's such a short-sighted and misguided policy.I don't understand what is so appealing about a linear commit history. It's a fabrication of reality, and I have never been grateful for it, only enraged.Why wouldn't you want to know what _actually_ happened? What is being gained besides an aesthetically pleasing ""commits"" tab on GitHub?"	jahsome	8.580572	-6.5550404	comment	4.0	20.0	1675655543	-11.934323
34673691	Linear history is the only sane way 	Linear history is the only sane way to have usable history. Merge spaghetti is a good way to ensure that nobody would ever being able to navigate it.Squashing large number of commits is questionable practice, though.	vbezhenar	8.579138	-6.549705	comment	4.0	14.0	1675660988	-11.93389
34966430	"Honestly, I think that if ""git lol"" "	"Honestly, I think that if ""git lol"" was the default log command it would do the most to make things much more obvious to newcomers.  git log --oneline --graph

And git lola for a gestalt of the repo's recent state:  git log --oneline --graph --all"	Oxidation	8.580769	-6.4763913	comment	4.0	16.0	1677567063	-11.851477
35142618	How to transition a team from Git-fl	How to transition a team from Git-flow to trunk/CI-CD?	chuie	8.657537	-6.530385	story	4.0	7.0	1678741507	-11.961035
35145613	- Github Action's design is much bet	- Github Action's design is much better, just look at [1] for example, there's a lot of low-hanging fruit in Gitlab that's not done for some reason- I've had tons of issues with their kubernetes runners, hard to debug spurious system failures- They still don't display the last N bytes of the logs when logs get long, just the first N bytes, which is entirely useless when a build fails- It's awfully slow to navigate through pipelines, in particular child pipelines- The `stages` things is just useless noise, I just wanna specify dependencies please, I don't want to be forced to also put each job in a stage, it's weird.- You can't expose a secret only to a single job step; they don't really have finer granularity for job steps like Github Actions has -- they just generate a script.sh that's ex	stabbles	8.429382	-6.4493027	comment	4.0	14.0	1678754613	-11.910488
17071935	On the other hand, git became succes	On the other hand, git became successful by being fast and by not solving certain of the hard theoretical problems that specialists were obsessed with solving. It's hard to know before hand what the healthy compromise might be.	enqk	8.546778	-6.4861336	comment	5.0	29.0	1526363634	-11.918196
17083714	I wish there was something like an u	I wish there was something like an updated Make, a tool that works for everything but updated to 2018.For instance Make works based on timestamps and therefore works very poorly together with git. Switch to another branch and you can get weird effects based on what files were updated and not and often trigger needless rebuilds. And everyone uses git these days.GNU Make, just using hashes instead of timestamps, would be a huge step forward.	dagss	8.611742	-6.467926	comment	5.0	19.0	1526488158	5.3235526
17103386	IIRC, they were in a serious time cr	IIRC, they were in a serious time crunch when they drafted/made git. I can't remember the whole story...	needz	8.5328455	-6.44431	comment	5.0	18.0	1526665429	-11.886077
17243651	I don't think it is fair to say that	I don't think it is fair to say that git users loathe it overall. I enjoy using git, is this not a common experience?	mikeyjk	8.541672	-6.48258	comment	5.0	23.0	1528247722	-11.8889065
17605726	Managing dependencies and versions a	Managing dependencies and versions across repos is a pain. Refactoring across repos is quite hard when your code spreads across repos considering the tree of dependencies.Unfortunately Git checkout all the code, including history, at once and it does not scale to big codebases.The approach that Facebook chose with Mercurial seems a good compromise ( https://code.fb.com/core-data/scaling-mercurial-at-facebook/ )	ChrisCinelli	8.521578	-6.5019193	comment	5.0	23.0	1532474572	-11.877895
17633276	I think the most powerful tool for f	"I think the most powerful tool for fixing mistakes is ""git reflog"". It doesn't fix everything, but it works very well as long as you view git with the right mental model: a git repo is an ever-growing tree of immutable commits, with branches and tags pointing to the most interesting ones. As long as code has ever made it into that tree (by being in any commit at any time), it's recoverable, and reflog lets you trace your steps back to any point in the past on that tree. Supposedly-destructive operations like amend and rebase actually just build the tree at a different point and move branches to other places in the tree, but (pretty much) nothing in the tree is ever destroyed.For the actually-destructive git commands like checkout and reset, another tool that I'd highly recommend is a ""loca"	alangpierce	8.585457	-6.5330544	comment	5.0	30.0	1532787614	-11.909415
17689383	If you're an emacs user, I can't rec	If you're an emacs user, I can't recommend magit [1] enough. I was a diehard CLI user and had flags and aliases out the wazoo, and it was still a step change in usabilty and power for me. Staging hunks, rebasing, and stashing are all vastly easier. Amending or editing a commit is a breeze, and it's tied in to all of the other emacs tools you already use, e.g. org-mode to boot!It's easier to see it in action than explain it. If you've two minutes to spare, check out this emacsrocks screencast [2], or Howard Abram's longer presentation from the PDX Emacs Hackers meetup [3].[1]: https://magit.vc/[2]: https://www.youtube.com/watch?v=rzQEIRRJ2T0[3]: https://www.youtube.com/watch?v=vQO7F2Q9DwA	nickbarnwell	8.651656	-6.5231705	comment	5.0	39.0	1533436095	-11.842992
17689321	Personally I have been typing all gi	"Personally I have been typing all git commands manually into the terminal and never felt a need for GUIs or tools such as this.There are a number of git shortcuts defined in my zsh aliases [0]. It goes like:  # Git aliases
  alias g='git'
  alias ga='git add'
  alias ghb='git browse' # hub
  alias ghpr='git pull-request' # hub
  alias gp='git push'
  alias gpoh='git push origin HEAD'
  ...


Using these aliases, we rarely have to type more than 3-4 characters for a git command. Savings and efficiency not only add up over years of using git, but also accelerate as you become more proficient in using your own aliases that fit your special needs.[0] - https://github.com/sungwoncho/dotfiles/blob/master/zsh/alias..."	stockkid	8.606232	-6.519531	comment	5.0	20.0	1533434733	-11.872024
17696867	I'd like to have some way to prevent	"I'd like to have some way to prevent certain code from being committed in the first place.E.g. when I have a line saying    printf(""debug: now at: %d\n"", i); /* DONTCOMMIT */

then when I type ""git commit ..."", a script will be invoked that will recognize the ""DONTCOMMIT"" string, and it will abort the commit."	amelius	8.583873	-6.487573	comment	5.0	19.0	1533556681	-11.81881
21026023	I've never really understood Torvald	I've never really understood Torvalds' reason for not cryptographiclly signing commits.> Btw, there's a final reason, and probably the really real one. Signing each commit is totally stupid. It just means that you automate it, and you make the signature worth less. It also doesn't add any real value, since the way the git DAG-chain of SHA1's work, you only ever need _one_ signature to make all the commits reachable from that one be effectively covered by that one. So signing each commit is simply missing the point.http://git.661346.n2.nabble.com/GPG-signing-for-git-commit-t...	jimktrains2	8.611247	-6.464699	comment	5.0	20.0	1568983338	-11.733965
19000932	ATMs are a great example of a system	"ATMs are a great example of a system that really don't need a two phase commit protocol. You have an account, it has a balance, and the transaction is a subtraction from the balance.A dumb ATM would read the balance value, subtract, and issue a ""set balance to $$$"" transaction. A good ATM would check the balance, ensure theres enough money (or overdraft..) for the request, and record a ""subtract $40"" transaction.If this message gets delayed, oh well, the customer might end up with a negative balance - sucks for the bank if the customer decides to go into hiding - but as the customer typically can't control the delay - it's hard for them to abuse this feature.(I only consider delay here, as I'm sure ATMs make multiple durable copies of their transaction log - making all but the biggest disa"	kiallmacinnes	8.710048	-6.511185	comment	5.0	34.0	1548441547	-11.852317
19006416	I'm a big, huge fan of recording wha	I'm a big, huge fan of recording what should have happened instead of recording every typo and forgotten semicolon in your history. There's a difference between draft commits and published commits. When I'm reading published commits, i.e. history, I just want to know your intent, not your typos. So what are the tools that Fossil offers to make sure I don't have to see your typos in the history?	jordigh	8.530606	-6.5549755	comment	5.0	70.0	1548513133	-11.8868
19081171	The only arguments I hear against th	"The only arguments I hear against the linear history model are:1. A branching history allows use of git bisect to identify where breaking bugs were introduced.
2. An aesthetic argument to the effect of: it's awesome to have that branching history to explore, to see alternatives and choices.  A linear history is a recitation; a branching history is a multiverse.I don't find either convincing.  2 is a personal preference, but seriously, who has time to go wandering through commit histories looking for precious gems?1 seems like a more valid argument, but against it: who actually uses git bisect?  In both essays I've reading arguing for it, they cite ""once I used it to find a really gnarly bug"".  It doesn't seem like a useful everyday tool, or am I missing a larger set of use cases for it?  I"	fatbird	8.575236	-6.5343237	comment	5.0	15.0	1549318479	0.93809164
19081280	So were developers constantly having	So were developers constantly having to rebase their feature branches trying to race them into master before another developer merged? How did you solve that problem?	umvi	8.600738	-6.5464845	comment	5.0	16.0	1549319355	-11.887833
19083780	I'm not convinced either.  What's th	I'm not convinced either.  What's the performance of getting the the state 10 versions before?  What is exactly the size difference between a git repo and a pijul repo of the same thing?As for patch vs snapshot, that's arguing at the implementation level.  It doesn't affect my use of a tool except as it relates to performance and merging/branching... etc.Preferring a patch approach rather than a snapshot is like saying map(+)[1,1,1,1,1] != last([1,2,3,4,5]).  I don't care.	emmelaich	8.599927	-6.5613627	comment	5.0	25.0	1549355872	13.906877
19084241	I don't understand what justifies Pi	"I don't understand what justifies Pijul's existence. While I agree that Git is a complicated monster that takes ages to learn how to use for most people, Pijul does not seem to solve any problems with Git. Instead, it has many problems that Git solves. From a user-perspective, it doesn't even seem like there's much of a difference, despite the (annoying) choice of alternate command verbs (i.e. ""record"" rather than ""add/commit"").It doesn't really seem like the authors fully understand Git, and what problems it solves.> [...] in Git each commit is related to a parent [...] But in Pijul there's no timeline and branches are just sets of patches.To me, that makes Pijul much, much less capable as a version control system. In Git, knowing the commit ID means that you know the full source tree sta"	arghwhat	8.599352	-6.5653987	comment	5.0	30.0	1549364300	13.894774
19346263	Ask HN: Why do we have to comment ea	Ask HN: Why do we have to comment each commit?	z0mbie42	8.623485	-6.505456	story	5.0	3.0	1552142008	-11.8956995
19416535	These are excellent.  I didn't know 	These are excellent.  I didn't know about gi, and that's very useful.Today I accidentally learned that ctrl-a and ctrl-x increment or decrement the number under the cursor.  That's not terribly useful unless you're dealing with a lot of numbers, but if you are, it will save a lot of keystrokes.One set of movement keys the article didn't mention but which I use all the time are H M and L (shift-h, etc.)  They jump to top (high), middle, and bottom (low) of the editor window, respectively.	blunte	8.587731	-6.4819007	comment	5.0	23.0	1552856226	-11.747283
19445668	counterexamples: git, paxos, TeX	counterexamples: git, paxos, TeX	jhpriestley	8.541809	-6.470991	comment	5.0	23.0	1553108806	-11.871377
19567322	Git9: Git Reimagined for the Plan 9 	Git9: Git Reimagined for the Plan 9 OS	adamnemecek	8.542895	-6.4653254	story	5.0	71.0	1554326130	-11.872664
19568669	Same here. Without staging how do I 	Same here. Without staging how do I change 10 files but only commit 3 of them? For example working on a change, then notice a bug that should be fixed now. Currently I just stage the 3 files for the hot bug fix, commit those, deploy, then continue working on the remaining 7 files.	pytyper2	8.636531	-6.560799	comment	5.0	36.0	1554342163	-11.91737
19598358	But why? Why create a tool that does	But why? Why create a tool that does `git status` 10x faster?	thwd	8.570219	-6.4403663	comment	5.0	24.0	1554658124	-11.860095
19608113	Wait do people not use .env files? I	"Wait do people not use .env files? I've aliased ""gitinit"" to make a .env file, .gitignore that ignores env nodemodules etc, then runs git init"	herohamp	8.598613	-6.4534636	comment	5.0	21.0	1554750421	-11.830202
19632384	ok, so just so everyone is clear, th	"ok, so just so everyone is clear, the point between parent and grandparent is Andrew Chael seems to have written a hell of a lot more code than Katie Bouman, for a lot longer* achael 566 commits  850,275 ++  131,044 --* klbouman 90 commits  2,410 ++  1,265 --However, at least at the level of reading the commit messages, Katie's are pretty math heavy:""fixed bug in the fake briggs weighting""""starting to fix chirp problems with polrep""""made it possible to do a min uv cut on closure phase when adding it a...""While Andrew's lean frequently toward code maintenance:""updated some docstrings in imager_utils""""moved imgsum to plotting.summary_plots""""modified README""That said, Andrew and others seem to have pretty good insight  too."	killjoywashere	8.570388	-6.471802	comment	5.0	30.0	1554974914	-11.830927
19637305	850,000 loc vs what looks to be an i	850,000 loc vs what looks to be an initial commit and a merge: https://github.com/klbouman/hopstools/commits?author=klbouma...if I'm wrong here please point it out	sodafountan	8.577909	-6.486674	comment	5.0	17.0	1555005290	-11.877663
19878267	But those high level tasks could als	"But those high level tasks could also be exposed directly. There's nothing to stop there being more commands which more directly accomplish the desired tasks.The idea that git is good because it is difficult to use is just ""git snobbery"", as is the idea that it must be difficult because it's a DVCS.There's nothing to stop git having two levels of the API, one exposed for tools to build off of with the full complexity and another for every day use."	Sahhaese	8.549472	-6.4925	comment	5.0	31.0	1557499694	-11.912972
19881606	It's not 'editing' the raw history f	"It's not 'editing' the raw history files, but you're still presenting a false history to your coworkers. To me there are essentially two kinds of rebases:- Summarizing history: squashing ""implemented subfeature A.A"" and ""implemented subfeature A.B"" into ""implemented feature A""- Rewriting history: moving commits around, changing the base commit, and so onIn my opinion summarizing history is acceptable, you're making a creative decision that certain information will not be useful in the review/when trying to understand the code in the future.Rewriting, on the other hand, is essentially lying. You're creating repository states that never existed, and which you have never tested. In the worst case, consider the following history:    *     F: (master) Merge branch 'component2'
    |\  
    | * "	Nullabillity	8.575231	-6.5587955	comment	5.0	50.0	1557517871	9.109969
19907801	Sure but I've never found a GUI or e	"Sure but I've never found a GUI or editor that lets me resolve conflicts in the way I want.For example say I change one line of code in a big function. I rebase and that function has moved. Conflict!I want a tool that says ""here's what you changed, and here's the current state of the source"". None of them do that though - they all just show the conflicts that git writes to disk - the code after you changed it, and the current code.You basically get two copies of the function, one with your change and one without and you have to manually (visually) diff them to work out what you changed (or go back and look at your commit) and then reapply that change to the moved function.It's really awkward and could definitely be better."	IshKebab	8.629129	-6.52349	comment	5.0	15.0	1557823411	-11.850848
19908885	>  Mercurial and git is like Honda a	>  Mercurial and git is like Honda and Toyota; maybe one is a bit nicer than the other, but they're both offering you more or less the same thing.As a car guy, Honda makes cars. Toyota makes appliances for people who hate driving.	ethbro	8.511143	-6.547167	comment	5.0	17.0	1557837505	-11.921784
19931471	"What's ""GI""?Please don't use acronym"	"What's ""GI""?Please don't use acronyms that people might not understand."	simonebrunozzi	8.559316	-6.484267	comment	5.0	16.0	1558031004	-11.862741
19933011	Git basics – the only introduction y	Git basics – the only introduction you'll ever need	areknawo	8.547146	-6.484889	story	5.0	29.0	1558039525	-11.896949
19945984	My Git Workflow (2008)	My Git Workflow (2008)	peter_d_sherman	8.554333	-6.492414	story	5.0	32.0	1558160332	-11.886801
37622583	It is extremely rare that I have a f	It is extremely rare that I have a file over 100MB.I also think it’s one of those situations where if I have a giant binary file in source control “I’m doing it wrong” so git helps me design better.It’s like in the olden days when you couldn’t put blobs directly in a row so databases made you do your file management yourself instead of just plopping in files.I like git. I don’t like giant binary files in my commit history. It’s cool that you like fossil, but I don’t see this as a reason for me to use it.	prepend	8.557262	-6.4648504	comment	5.0	24.0	1695471133	-11.888794
37721162	"So you have endless ""Fix a"" ""Typo"" """	"So you have endless ""Fix a"" ""Typo"" ""fixup"" ""revert redo"" ""add y missed in z"" commits and then the squash pushes all that crap into the commit message for whatever the final mess will be?Here is a random series from DRM patchwork: https://patchwork.kernel.org/project/dri-devel/list/?series=...Would you squash that? Hell no, of course not. You would be mixing atomic changes in different subsystems. It breaks bisect and makes blames a mess.Honestly, squash merges are frequently a sign of people who lack mastery in Git itself or make no effort to produce high-quality independent commits."	stefan_	8.572731	-6.571925	comment	5.0	16.0	1696118399	-11.93756
37749955	Tig: Text-Mode Interface for Git	Tig: Text-Mode Interface for Git	fdeage	8.579296	-6.490254	story	5.0	15.0	1696328526	-11.882053
37799980	I must be some kind of genius, as I 	I must be some kind of genius, as I find git quite easy?I've been using it daily for years now, but I started out with subversion which was quite nice because it had TortoiseSVN.Later went to Mercurial which was pleasant to work with but since GitHub arrived to the scene the choice both private and professionally became the obvious. Besides git and hg are IMHO not that different anyway from a daily use pov.	TheChaplain	8.544922	-6.4666476	comment	5.0	31.0	1696666620	-11.882344
37881543	The worst application I use about mi	The worst application I use about misrepresenting timestamps is gitg.Check this screenshothttps://ubunlog.com/wp-content/uploads/2018/06/git-gui-gitg....There are a number of commits marked as 3 days ago. It's only a little bit better than no information at all: or doesn't tell me if they happened in the morning or in the afternoon, or all within an hour or spread on all the day. That's important when I didn't logged how many hours I worked for a customer and I have to assess it one week later. I have to click every single commit and check the timestamp on the other side of the screen.	pmontra	8.570325	-6.4732537	comment	5.0	15.0	1697299184	-11.852824
37915306	It’s a bad review. The snarky prose 	It’s a bad review. The snarky prose is annoying. He could be much more concise as well. “Won’t merge. Commit messages need far more detail. Don’t do bitmask translations. All of these operations should use the same mask instead of creating redundant ones. Rethink the logic here, not sure if it makes sense. This needs a rewrite, not small tweaks”…was really all it needed. The wall of text is more offensive than the insulting tone.	foooorsyth	8.609476	-6.484302	comment	5.0	30.0	1697551762	-11.872645
38114171	This approach works by storing the a	"This approach works by storing the actual SQLite binary files in Git and then using a custom ""diff"" configuration to dump each file as SQL and compare the result.It's a neat trick, but storing binary files like that in Git isn't as space efficient as using a plain text format.I built my own tooling to solve this problem: https://datasette.io/tools/sqlite-diffable - which outputs a “diffable” copy of the data in a SQLite database, precisely so you can store it in Git and look at the differences later.I’ve been running that for a couple of years in this repo: https://github.com/simonw/simonwillisonblog-backup - which provides a backup of my blog’s PostgreSQL Django database (first converted to SQLite and then dumped out using sqlite-diffable).Here’s an example diff: https://github.c"	simonw	8.645944	-6.4907236	comment	5.0	20.0	1698936264	9.831869
38114878	Don't worry, git manpages have a bui	Don't worry, git manpages have a builtin glossary, just type in `git help glossary`, and you can get helpful definitions for confusing terms:> index> A collection of files with stat information, whose contents are stored as objects. The index is a stored version of your working tree. Truth be told, it can also contain a second, and even a third version of a working tree, which are used when merging.Correction: you can get unhelpful definitions of all the confusing terminology.	jcranmer	8.564538	-6.515712	comment	5.0	35.0	1698938915	-11.878834
38119825	Hard agree.Weekly, I witness co-work	Hard agree.Weekly, I witness co-workers confused about git, I see posts online asking for help, I see articles like the one here once again trying in vain to explain something that should be simple.In all my time coding, I don't remember anyone wasting hours trying to undo some mess they'd made in SVN, TFVC, Perforce, etc.Tools exist to make our lives easier. If they can't do that, they don't deserve our time.	failingslowly	8.549815	-6.457794	comment	5.0	16.0	1698957632	-11.887954
38161105	Well, can you explain why it applies	"Well, can you explain why it applies here?Mercurial vs. Git is IMHO a textbook example of ""good enough with large user base"" beats ""subtly superior with smaller user base"" over the long term."	The_Colonel	8.509741	-6.5453305	comment	5.0	25.0	1699269379	-11.956463
38165285	I love rebase (I'm a tip-of-master-o	I love rebase (I'm a tip-of-master-only person, no merges ever, squash all your commits with `rebase -i` before pushing and write one good commit message for the group). But there's one really, really irritating thing about them:You should not be able to use `--amend` during a rebase.For me editing all my changes onto the commit I'm working on with `git commit -a --amend` (or as I've aliased it, `gcaa`) is automatic; I do it 500 times a day, just to save my work. But I can't count how many times I've been in the middle of squashing commits and accidentally typed `gcaa` and amended someone else's commit after fixing a merge conflict, and it's super annoying to unwind (if you realize after typing `rebase --continue`) so usually I end up just giving up and starting over. I really wish amendin	ajkjk	8.578467	-6.557163	comment	5.0	22.0	1699290464	-11.906503
38172516	Commit your code and commit it often	Commit your code and commit it often. There's no reason not to.	_heimdall	8.605978	-6.4735065	comment	5.0	18.0	1699324741	-11.9008665
38223154	I could use a Git By Example course 	I could use a Git By Example course where we walk through increasingly gnarly gituations.	hiAndrewQuinn	8.552066	-6.4823003	comment	5.0	22.0	1699643600	-11.887524
38223276	I must be misunderstanding...If you 	"I must be misunderstanding...If you are in the situation    B -- X1 -- X2 -- X3 -- Head
     \
      Y1 -- Y2 -- Cherry

then Y2 can't be a merge-base for the difference between Head and Cherry, the merge-base is B, that's a graph property and not an input. (You can even calculate it with `git merge-base`.) Right?And saying that ""Y2 and Cherry are the patch"" doesn't help my brain much.Now just thinking out loud I think there's something there... I know from Darcs that basically there is a mathematically precise thing to do here with two merges, so basically since ""merge"" is just ""inverse, apply_patch, commute, drop_commit"" and ""cherry_pick"" is just ""commute, drop_commit, merge"", you have  a first merge being of the tree,    B -- Y1 -- Y2 -- inv(Y2) -- inv(Y1) -- M
                 \       "	crdrost	8.601674	-6.546963	comment	5.0	17.0	1699644179	-11.896148
38369187	Before git, most people in my larger	"Before git, most people in my larger circle used RCS, a UNIX version control system from the early 80's.  It was very limited (basically each file had its own side-file that contained revision data, and there was no project-wide file) but did its job.  Many people moved over to VCS, which used RCS files but added project-wide files so you could manage a dir tree.After that, I think many people moved to subversion, which had a lot more functionality for distributed VC, for exmaple there was a server.  svn was popular for a while but building it was painful (due to berkeley db) and it sort of never grew.  I invested a lot of time in (specifically apache with mod_dav and mod_dav_svn) but lost interest in VC after fighting with subversion.git came along and from what i can tell it mainly had """	dekhn	8.610618	-6.493576	comment	5.0	23.0	1700596675	-11.874147
38370850	That change was so dumb. Mercurial s	That change was so dumb. Mercurial support was the bit that put them as something different from github. Once they didn't have it anymore, why would anyone use them at all?	Blackthorn	8.503382	-6.5274487	comment	5.0	30.0	1700603646	-11.984272
38393494	A lot of things in git are just poin	A lot of things in git are just pointers to commits, and then the git implementation handles them under the covers in some way that usually makes sense but not always.One example that also bites people: moving files isn't stored in git - if you move files (even with `git mv`) and create a new commit, the moves aren't stored, but this is reconstructed later by the client based on similarity, which comes from the diff algorithm.And git has multiple diff algorithms to pick from: https://git-scm.com/docs/git-config#Documentation/git-config...And optionally to not detect renames in diff output with `diff.renames`: https://git-scm.com/docs/git-config#Documentation/git-config...	zdw	8.588006	-6.526586	comment	5.0	35.0	1700751967	-11.8773775
38394116	The issue is that if you consider a 	"The issue is that if you consider a branch to be what is really the history of the branch tip, then a branch is not just the part starting from the last join with another branch. Instead it is some directed path through the commit DAG, a path that in general can’t be reconstructed from the information Git keeps.If, for example, you have a structure like        |
        o
       / \
      o   o
   A  |   |  B
      o   o
       \ /        
        o
       / \
      o   o
   C  |   |  D
      o   o
       \ /
        o
        |

then conceptually the path CA might be one branch and DB the other branch (or alternatively, CB and DA). But this is not something that is represented in Git’s model."	layer8	8.5596485	-6.5493884	comment	5.0	26.0	1700754919	-11.901601
38394305	This was the most useful piece of in	This was the most useful piece of information that I have ever read about Git.But what happens if you merge branch A into beanch B? A and B will both contain the commits of A, but in B there may be commits of B between the commits that were merged. Do the same commits of A then have different parents depending on which branch they are on?	jansan	8.5656805	-6.5617824	comment	5.0	23.0	1700755884	-11.896297
38591865	The git model has fundamental limita	The git model has fundamental limitations because it saves snapshots rather than changes, and doesn't capture some metadata changes like renames.  A tool like Darcs or one of its spiritual descendants will have fewer merge conflicts than git.Totally agree on your main point though.  The benefits of switching are far lower than the costs.	bryanlarsen	8.576161	-6.5161557	comment	5.0	28.0	1702219893	-11.877646
38592752	Git keeps the entire history on your	"Git keeps the entire history on your local machine, this becomes a problem if your project grows to several hundred GB (not untypical in game dev). Even SVN was much better for working with large repositories, you only needed a big server. Git is quite nice for ""source code only projects though""."	flohofwoe	8.568452	-6.467179	comment	5.0	21.0	1702226335	-11.866402
38593053	I generally don't hear too many comp	I generally don't hear too many complaints about GIT in the Windows/.NET development world, probably because there are good UI front ends and there's not as much 'tough guy' cred from sticking to the CLI. Visual Studio does a decent job of abstracting the GIT nuances, but I personally use GIT Extensions, which looks and feels much better on Windows than the other cross platform UIs.I drop to the CLI occasionally, especially for multi step or automated scripts, but you can pry a nice visual commit graph and full featured integrated diff viewer from my dead hands. GIT is powerful and option-laden; the perfect tool for a UI to aide in discoverability. The CLI feels like programming in a text editor vs a real IDE	briHass	8.591973	-6.5405736	comment	5.0	19.0	1702228371	-11.856209
38594054	This post is a terrible failure of i	This post is a terrible failure of imagination that would make one stop language development as C because it was so much better than Assembly.If you have no problems with Git, then I’m happy for you. I certainly have problems with Git, eg its inability to handle large repositories meaningfully (enjoy a Chromium checkout!), the arcane CLI commands, the shut-your-eyes-and-hope of moving commits between branches and other sharp edges.That Git has been as resilient as it has is largely a function of being written by Torvalds and GitHub network effects. It isn’t for lack of better/as good features found in other VCS methodologies.	cflewis	8.553859	-6.4901443	comment	5.0	18.0	1702235912	-11.89334
33108243	Rebase has become so integral to my 	Rebase has become so integral to my workflow, it's hard to imagine living without it. I intentionally avoid merge commits, including configuring git pull to rebase rather than merge. I find it so much easier to commit a bunch of tiny iterations while doing local testing, rebase and squash them, then post them for review. As a bonus, I frequently push after each of those small commits to a feature branch so I don't have to worry about losing work if my drive dies.	placatedmayhem	8.5760355	-6.5681405	comment	5.0	31.0	1665064857	-11.950211
33108248	I don't know if Christian would go t	I don't know if Christian would go this far, but I actually put this into my ~/.gitconfig so that I'm always rebasing[pull]rebase = trueedited for line spacing	boleary-gl	8.582061	-6.5040975	comment	5.0	17.0	1665064888	-11.844816
33141009	> Clunky, it is not.I want to roll b	> Clunky, it is not.I want to roll back an accidental commit of an extra file to the previous, uncommitted state. Or even simpler, undo a commit to restore the exact state just before it happened.	pxmpxm	8.601768	-6.527596	comment	5.0	24.0	1665323579	-11.8819475
33388297	Raise your hand if commits are mainl	Raise your hand if commits are mainly just a way to save progress. It can’t just be me.I appreciate that needs differ between projects. In some public project I’d be more disciplined. But at work I just commit like a madman and collapse them all automatically upon merge.	Waterluvian	8.584077	-6.5331445	comment	5.0	17.0	1667080348	-11.905921
33388318	"""Link to issue for context""Just no.."	"""Link to issue for context""Just no...Why would you decouple the change from its context? Just add all the relevant information to the commit message itself, so it's preserved.I follow my friend's approach which works really well.https://yrashk.medium.com/solving-problems-one-commit-at-a-t...Too many a times I had to do code archeology to encounter archived Jira or some old space I don't have permissions for, that was originally migrated from GitHub issues and all the ticket numbers are in complete mismatch."	vsviridov	8.578314	-6.516786	comment	5.0	19.0	1667080454	-11.917631
33443424	When one sees the last commit as 29 	When one sees the last commit as 29 days ago, or the previous commit as 8 years ago, one can easily assume it wasn't code from 1995. So again. Why is this even interesting?	brianbreslin	8.598086	-6.471337	comment	5.0	16.0	1667426008	-11.945753
33533136	The problem with git is hardly anyon	"The problem with git is hardly anyone reads the fucking manual. Git is not hard. The UI is inconsistent, but documented. When you just foist commands onto people, you can't be surprised when they fall off the happy path and don't have the mental model to understand how to fix it. There's no such thing as ""idiot-proofing"" for people who don't RTFM.--force-with-lease as a default is a really bad idea. Copying random aliases is a bad idea."	huimang	8.556504	-6.482	comment	5.0	23.0	1668008425	-11.889448
33534104	The reason people on here tend to di	The reason people on here tend to dislike those types of tools is because they've probably been the ones who had to fix the tangles people get themselves into by using those tools. Tools that obscure details in favor of simplicity are fine in some cases, but version control is an inherently complex problem domain where having those details is important.In my experience mentoring juniors new to git, those who are just given a few basic commands don't create as much of a mess because they don't have the commands required to make a big mess. When they do make a mess, it's usually because they've copy-pasted something from the internet, and most will acknowledge that blind copy-pasting _feels_ wrong. Give them a GUI, and suddenly there are buttons to create all sorts of unholy mangles right at	RadiozRadioz	8.602871	-6.4679976	comment	5.0	17.0	1668011965	-11.899827
33614183	Its interesting how these threads ab	"Its interesting how these threads about Git simultaneously have(a) People arguing git is fine, and shouldn't be simplified(b) People arguing about the right way to use git, and flame wars about best git workflowsI mean most people simply see (b) and conclude ""this is a huge hassle, I don't want to annoy some git-workflow-purist, I'm just going to walk on eggshells on this tool and hope I don't break anything""It's as much a social problem around conventions, and lack of opinions in the tool itself, then anything about the underlying technology (which is rock solid IMO)"	softwaredoug	8.562854	-6.490957	comment	5.0	18.0	1668542315	-11.895475
33614378	I use the staging area to allow me t	I use the staging area to allow me to more easily break larger changes into smaller commits. I am usually all over the place while writing/refactoring code and making commits as I go along doesn't work well.How does sapling let me take a long list of commits and break them into larger but more manageable chunks?git add -p allows me to add chunks easily and create commits, git commit --fixup allows me to mark a commit as fixing a previous commit, and with git rebase -i --autosquash I get to easily take those fixup commits and meld them into the previous commits.Also reviewing a stack of patches is annoying in many cases as I care more about the end result vs each individual commit. But that may just be my experience talking in open source where I am working on smaller but better well define	ArchOversight	8.593986	-6.5205803	comment	5.0	22.0	1668543254	-11.901389
33616464	Forget the CLI. VSCode implements a 	Forget the CLI. VSCode implements a ton of git features as commands, which can be bound to any keybindings. For me this is way faster than CLI, as I don’t even need to leave my text editor - I have it set up chorded, so AltG followed by P,U,C,Y, will push (actually sync), pull, commit, undo, respectively. Two keystrokes beats any CLI interaction I’ve seen.(Disclaimer used to make VSCode)	jakear	8.607867	-6.4890327	comment	5.0	22.0	1668553488	-11.838106
33618313	I guess you didn't start from cvs or	I guess you didn't start from cvs or svn, because the experience moving to git was otherworldly. If git was your first versioning system than you had to learn some concepts first, which you already internalized when you switched to Mercurial.	riquito	8.536351	-6.524254	comment	5.0	33.0	1668567879	-11.890096
33626971	Just the ergonomics of git are somet	"Just the ergonomics of git are sometimes mind-boggling.
for instance: ""git checkout"" is used for 3 different things:  “switch”, “create branch”, and “revert a file”.
Deleting a remote tag is “git push” but a deleting a local one is “git tag -d”. There are many such examples"	guytv	8.569382	-6.516417	comment	5.0	17.0	1668619879	-11.823691
33627232	If I had a dollar for every time som	If I had a dollar for every time someone complains about how git is unfriendly, I'd have enough to buy Twitter.I've been using version control systems since CVS and I've found git the easiest and most sensible thing to use. Admittedly, some of the commands reflect internal data structures and concepts rather than what a user would want to do but that's just a learning curve issue. To address specific points.1. Of the 157 commands, there are maybe 10 or so that one would need on most days and maybe 5 or 6 others when things go awry. Perhaps another half dozen for specific workflows but that's it. How many times do people use git daemon or git instaweb or git fsck? Why are these listed there? I do git trainings and teach a handful of commands in half a day which are sufficient to get people 	noufalibrahim	8.557513	-6.4974456	comment	5.0	15.0	1668620691	-11.91239
33705480	In your example, you pretty much hav	In your example, you pretty much have to change the same line, or neighbouring line, those 10 times to end in that scenario. If it's just somewhere else in the file, git auto-merging will handle it just fine.It seems like a very contrived example to me. We have been running rebase/fast-forward only for close to 10 years now, and I have never experienced anything that unfortunate.	broeng	8.584343	-6.5608068	comment	5.0	42.0	1669123521	9.167817
33710909	Github-style rebase-only PRs have re	Github-style rebase-only PRs have revealed the best compromise between 'preserve history' and 'linear history' strategies:All PRs are rebased and merged in a linear history of merge commits that reference the PR#. If you intentionally crafted a logical series of commits, merge them as a series (ideally you've tested each commit independently), otherwise squash.If you want more detail about the development of the PR than the merge commit, aka the 'real history', then open up the PR and browse through Updates, which include commits that were force-pushed to the branch and also fast-forward commits that were appended to the branch. You also get discussion context and intermediate build statuses etc. To represent this convention within native git, maybe tag each Update with pr/123/update-N.The	infogulch	8.581294	-6.551324	comment	5.0	24.0	1669148434	-11.912607
33730922	Hi, author here. Happy to answer que	Hi, author here. Happy to answer questions.Version 0.8 just got out[1]. For the next one, I'll try to focus on making the codebase fully ready for multi-entities and introduce a Project Board. Later we can add support for code review!If you are looking for how it works, you can have a look at the data model introduction[2].git-bug is only pushed forward by volunteers so it's taking its time to fully grow, so I'll take the opportunity to welcome everyone to join the fun :-)[1]: https://github.com/MichaelMure/git-bug/releases/tag/v0.8.0[2]: https://github.com/MichaelMure/git-bug/blob/master/doc/model...	michaelmure	8.573301	-6.4933705	comment	5.0	27.0	1669295519	-11.882479
33732262	I understand why the bug IDs are has	I understand why the bug IDs are hashes, but that's going to be pretty inconvenient for practical use. Yes I know we manage it with Git commit names, but bug IDs are printed and spoken much more than commits, e.g. when communicating with a test team, management, or even in release notes.I wonder if we could use some sort of distributed naming scheme for this, similar to Blockchain DNS?	foreigner	8.580947	-6.474481	comment	5.0	19.0	1669303183	6.011678
33746763	Interesting, the exclude file (actua	Interesting, the exclude file (actually, everything under .git/info) 403s, while .git/index is a 404.- https://www.tesla.com/.git/info/exclude- https://www.tesla.com/.git/indexREADME.txt 403s too.  https://www.tesla.com/README.txtedit: just going to add files I've found here:- https://www.tesla.com/.editorconfig- https://www.tesla.com/profiles/README.txt	tomjakubowski	8.575429	-6.451377	comment	5.0	16.0	1669410461	-11.807933
35372654	Git alternative command line interfa	"Git alternative command line interfaces just make no sense1. If you want to do something advanced, it will be a lot easier to find help online using regular/original git commands2. You still need to learn this new interface , so you will end up learning too different command line interfaces (one for the easy stuff and one for the advanced stuff)3. You will surely, almost certainly  mix the two interfacesUse and learn git ""original"" commands to do advanced stuff
Use a nice UI for the easy straightforward stuffThe only alt command line interface I might consider is magit, because it mixed the emacs commands with GUI elements, and still i think magit is not all that because its not GUI enough, if magit becomes faster and more graphical, only then it might make more sense (for now its really o"	systems	8.54093	-6.5237484	comment	5.0	17.0	1680184090	-11.844058
35511240	Modeling Git Internals in Alloy, Par	Modeling Git Internals in Alloy, Part 2: Commits and Tags	surprisetalk	8.562804	-6.472707	story	5.0	126.0	1681127221	-11.867238
28025188	It's not really new anymore, but sti	It's not really new anymore, but still way underused, so it could certainly do with more attention. Git's UI has become better, but they can't really remove the old UI and tutorials using those, so people keep sticking to that.	Vinnl	8.551385	-6.4906344	comment	5.0	19.0	1627812673	-11.916562
28025357	What is a good resource to learn mod	What is a good resource to learn modern git properly? I have been using git for 10 years and get around with a really small set of old commands.	helltone	8.542803	-6.4758577	comment	5.0	15.0	1627815194	-11.893298
28025412	Another difference is that with git 	"Another difference is that with git checkout you can create and switch to the new branch in one command using the -b flag:  git checkout -b new_branch

You can do the same with the new one, but the flag is -c:  git switch -c new_branch

A good example why developers should not try to be designers. Even of talking about ""API/CLI design."	clon	8.562661	-6.5348697	comment	5.0	16.0	1627815853	-11.902878
28026149	We are all using git only because Li	We are all using git only because Linus wrote it.  The cargo cult is real and very much alive in our industry, I think precisely because we are all here to write specialist software.  Too busy in our domain to worry about version control nuances so we just go with what is popular and don't think about it too much.  It's not just version control, it's libraries, frameworks, languages, all of it.  If it's not popular it's doomed to failure.	snarfy	8.566084	-6.4576726	comment	5.0	35.0	1627825008	-11.878944
28027304	As a helpful aside, in my experience	"As a helpful aside, in my experience, there are only about a dozen or so Git commands you need to do ninety percent of your work. You don't need to become a git zen master right away.1. git init: to start a new repository2. git status: checks your current state3. git add -A: To begin tracking files4. git commit -am: Commit all changes in the working directory with a message added on5. git switch -c [branch name]: Create a branch and switch to it.
(git checkout -b will do the same thing)6. git switch [branch name]: switch between named branches7. git merge[branch]: merge named branch into current branch8. git branch [branch name] -D : delete branch if not tracked9. git log --pretty=oneline: show a graph of commit history.11. git push12. git clone [repo]: Copy of a project/file onto your loc"	Lordarminius	8.566556	-6.525676	comment	5.0	24.0	1627833972	-11.898598
28025468	> but I'm seriously falling behind d	"> but I'm seriously falling behind due to jetbrains integrationThis IntelliJ integration is the source of quite a lot of git problems in teams I worked with.I'm quite flabbergasted by this - devs claim to know git on their CV, come in and know what ""commit"" is and how to use the IntelliJ UI, but don't even understand what its doing. And everyone is acting like it's OK and learning git is a ""hard thing ill never need"" and we should all use sourcetree or jetbrains. Or people just get so used to it and never understand what exists below it. They lose all sense of what they're doing and just think ""the machine knows what I want"". Then a vaguely questioned dialog appears - or something similar - and they cause clusterfuck upon their branch - or sometimes even other people's remote branches.How "	thecupisblue	8.55807	-6.4847097	comment	5.0	37.0	1627816729	-11.86923
28026554	I think sublime merge is pretty clos	I think sublime merge is pretty close to the optimal git GUI, https://www.sublimemerge.com/. It uses standard git commands and terminology and allows you to add custom git commands to the GUI. Unlike Sourcetree is cross platform for Windows/Linux/Mac and includes a merge tool. I think command line git and Sublime Merge git translate back and pretty easily.	tkuraku	8.635148	-6.4721913	comment	5.0	16.0	1627828849	-11.836604
28033619	I've always found it interesting tha	"I've always found it interesting that Git gets a pass for its horrible UX by so many devs. The programming community wants to provide too many options for _everything_. If there's a tool you don't like, there are probably 10 other versions that do similar enough things that you can just switch. Devs are harshly critical of tools. And yet, with Git, the response just seems to be ""if you don't like it you must just not _get it_."" Which, I guess is fair, but I don't particularly understand why everyone has to ""get it""? Why can't we expect a tool that's used by so many be intuitive? Or at least, _more_ intuitive? It feels a bit like hazing at this point. The post recently about `git undo` was great, I think, because of the frequency with which users encounter surprising and unintended behavior"	void_mint	8.552669	-6.489926	comment	5.0	20.0	1627887028	-11.892675
28154576	In fact, a commit should have a sing	In fact, a commit should have a single purpose, otherwise it creates dependencies and, for instance, you cannot revert a feature without also reverting a bug fix and it makes cherry-picking a nightmare.	mytailorisrich	8.593153	-6.5313697	comment	5.0	29.0	1628765227	-11.912297
28395337	that's just laughable considering SV	"that's just laughable considering SVN needs a central repo to work and I can just do ""git init ."" to create a git repo in any directory at any time I want and is entirely self-contained.Once an SVN user discovers the magic of a staging area, stashes, or ""git add -p"" I don't know how they could claim SVN does anything better. All I remember from those days was how slow everything in SVN was. It felt like every command was backed by some horrible O(n^2) operation or really slow network connection.git isn't hard. FFS, we shouldn't keep seeing these posts hitting HN every week. iptables? That's tough. DNS? No thanks. Managing package.json and keeping an app up-to-date? Git is nothing in comparison to the real challenges I face everyday."	deckard1	8.588728	-6.4576344	comment	5.0	17.0	1630606021	-11.858564
28461528	In my experience GHA far outclasses 	In my experience GHA far outclasses Jenkins and Travis. After GHA released composable actions (https://github.blog/changelog/2021-08-25-github-actions-redu...), there's not much of a comparison to be made. GitLab is more on par, but the docs are less accessible and they don't seem to have a long-term development strategy the way GHA does.As far as the limitations in the blog post, they are real, but most of them are limitations in features that are not available to begin with in Jenkins or Travis.	ak217	8.547254	-6.4578485	comment	5.0	23.0	1631127348	12.010422
28510744	Every time I see some type of branch	Every time I see some type of branching strategy it's always about main/master. Don't people have multiple environments, such as dev, test, pre-prod, prod? These strategies always apply merge/pull requests or changes directly to master. I protect every remote branch and require merge/pull requests to start on dev (unless of a hotfix.)	jcon321	8.616534	-6.544085	comment	5.0	18.0	1631536920	-11.881992
28581734	Why is git the hardest to grok for m	Why is git the hardest to grok for most developers compared to almost anything else in the web dev ecosystem? It always feels like a tool with very less or very leaky abstractions.Is it because the complexity is really needed, or if papering over them and making it user friendly has failed? For example, you won't find a cheat sheet of SQL commands submitted and upvoted so many times on HN, even though SQL implementation and internals are very complicated. Reason being it's able to hide the implementation details and abstract it away.At the very least the terminology in git is very confusing. Especially 'checkout' for people who came from a SVN/CVS background.	belltaco	8.547291	-6.4849334	comment	5.0	25.0	1632026178	-11.9268465
12582358	Your use case is super weird. If you	Your use case is super weird. If you're going to do a --no-ff merge why would you rebase?	lmm	8.612088	-6.539561	comment	5.0	27.0	1474901961	9.298555
12582432	This strikes me as perhaps the worst	This strikes me as perhaps the worst merge method possible for git. Sometimes people call your main branch soup, and this will make that an incredibly accurate description.People are bizarrely terrified of merge commits.	stormbrew	8.56454	-6.584452	comment	5.0	43.0	1474902472	-11.915598
12582614	Then please don't use it. In the mea	Then please don't use it. In the mean time, here's how a flat tree looks to contributors:https://github.com/jleclanche/fireplace/commits/masterVersus a merge tree:https://github.com/hashicorp/terraform/commits/masterConsider that the git log is one of the first thing contributors will look at. The cleaner it is, the better the experience.I've been waiting for this for a long time. Thank you github!	scrollaway	8.575743	-6.535303	comment	5.0	24.0	1474903723	9.246816
12615196	But isn't this what changelists do? 	But isn't this what changelists do? I've certainly done pretty much what you describe in hg, svn and Perforce, which don't have staging areas.Also, if you end up committing only parts of files, then how do you know that what you commit works?	david-given	8.634722	-6.5626893	comment	5.0	36.0	1475268416	-11.876621
12622203	Very cool. The idea which I liked mo	Very cool. The idea which I liked most, is the ability to switch between branches, even though you still have uncommitted changes. With git, I'm forced to either make an extraneous commit, just to enable branch switching, or stash all my changes into a stack which I may later forget all about. Both of the solutions above are really cumbersome and prevent easy context switching.The only feature I noticed missing, is the ability to stash changes. I use this most often to move changes from one branch to another branch, without cluttering history with an extraneous commit. How would this work on gitless?	whack	8.576045	-6.54466	comment	5.0	43.0	1475414700	9.423335
12623163	Version control is arguably confusin	"Version control is arguably confusing for beginners, but building a shim instead of learning the tool isn't the answer in my head.I always struggle with ""lowering the barrier of entry"" and it's not a ""I did it they need too do it"" it's more of a ""Usually high barriers mean it's complex, and learning how to understand complex things is important.""If this was some new novel way to version that wasn't just pretty git, I'd be a lil more excited."	lbotos	8.593345	-6.4708967	comment	5.0	29.0	1475426848	-11.877906
12654645	Safer branching	Safer branching	gitdude	8.685452	-6.53918	story	5.0	19.0	1475777275	-11.829475
12674205	Back in the day using CVS, and subve	Back in the day using CVS, and subversion later was a constant struggle. Before switching to git i used darcs for several years and tried mercurial. Git was clearly better than any of them.So, how can you tell that git is no good, if it is the best of the tools available?	pampa	8.567693	-6.4605155	comment	5.0	18.0	1476056954	-11.880158
12677383	Maybe it's just my inherent bias tow	Maybe it's just my inherent bias towards command-line-based Git, but I have to wonder just how useful this is to Git newbies if a lot of their page is dedicated to learning how to use Tower, especially with a 24-part video series.	PascLeRasc	8.591744	-6.5547786	comment	5.0	20.0	1476111191	-11.886444
12734899	Relevant quote:  > Facebook is writi	"Relevant quote:  > Facebook is writing a Mercurial server in Rust. It will be distributed and
  > will support pluggable key-value stores for storage (meaning that we could
  > move hg.mozilla.org to be backed by Amazon S3 or some such). The primary
  > author also has aspirations for supporting the Git wire protocol on the
  > server and enabling sub-directories to be git cloned independently of a
  > large repo. This means you could use Mercurial to back your monorepo while
  > still providing the illusion of multiple ""sub-repos"" to Mercurial or Git
  > clients. The author is also interested in things like GraphQL to query repo
  > data. Facebook engineers are crazy... in a good way."	steveklabnik	8.442352	-6.5718007	comment	5.0	20.0	1476801976	-11.911519
12739675	What about speed?Our team just moved	What about speed?Our team just moved from hg to git for an enormous project that has ~25 years of history (CVS -> SVN -> hg|git).   The biggest improvement to my daily life is that a git pull takes seconds, while an hg pull takes minutes (or even large fractions of hours when I've spent a week or two away from work).	drewg123	8.537733	-6.4990826	comment	5.0	21.0	1476833504	-11.902826
12785598	The interesting thing about git is, 	"The interesting thing about git is, that while it is heavily criticised for begin difficult, it is such a huge success.Most of the time, criticism of git can be summarized as ""Bad user experience"", which is often blamed on git exposing its implementation details. I.e. most git criticism proposes that the backend of the VCS should be ""private"" and the user should see a carefully designed UI, that is optimized for workflows.I think we don't need to redesign git in such a way, for the mere fact, that we already have a mature, distributed version control system that has a carefully designed UI and has a core that is opaque to the user: mercurialIn fact, given mercurial's age, the availability of github-like hosting services (bitbucket offered mercurial hosting for years) raise a very important"	wirrbel	8.553653	-6.4920983	comment	5.0	29.0	1477374484	-11.892998
12803287	> During the last 5 years, many GUIs	"> During the last 5 years, many GUIs have filled in this gap, making it increasingly likely to find people completely stuck because they miss knowledge of the foundations.Arguably, these GUIs became popular because Git by itself offers awful UX. I am all for obscure commands and switches (I use Linux and prefer CLI to mouse), but Git really took it to the next level. And it's not as if it couldn't be done better (as Mercurial shows).As a user I don't want to know the intrinsic details about how some system is implemented. I just don't care - give me an external model which helps me use it, and leave it at that. I have my own code I need to worry about.If most users get the ""wrong"" mental model when using Git, then the problem lies with Git, not with users. </rant>"	annnnd	8.577707	-6.494453	comment	5.0	53.0	1477550423	-11.8921385
12828565	Giteveryday – A useful minimum set o	Giteveryday – A useful minimum set of commands for Everyday Git	ymse	8.567573	-6.479145	story	5.0	114.0	1477811606	-11.885741
12886544	I am in the other extreme: I always 	I am in the other extreme: I always use `git add -A` (but I read the diff before) and avoid doing more than one thing in the first place (which would make me want to use `git add -p`). IMO it is an antipattern to do bazillion changes at once, and then do several commits out of it (unless you really know what you're doing) - because you commit a state of the repo that (probably) never existed. I prefer to do change, commit, do change, commit, and at the end do interactive rebase and perhaps squash some things together.	jakub_g	8.576294	-6.534265	comment	5.0	24.0	1478459571	-11.909342
12942296	We've been using the Github flow (or	We've been using the Github flow (or some variation of it) in teams of 2-10 people for a few years now. We work on feature branches, merge after code review using the github web UI. Here's a few things that help us:- Make a rule that anything that's in master can be deployed by anyone at any time. This will enforce discipline for code review, but also for introducing changes that f.e. require migrations. You'll use feature flags more, split db schema changes into several deployments, make code work with both schema version, etc. All good practices that you'll need anyway when you reach larger scale and run into issues with different versions of code running concurrently during deployments.- If you're using Github, check out the recently added options for controlling merging. Enable branch 	grk	8.613605	-6.456248	comment	5.0	17.0	1479022588	2.1854086
13021060	This looks impressive, especially ho	This looks impressive, especially how they seem to handle rebases/squashes with force push, which is a problem that pretty much all other repo managers simply ignore (except for Gerrit, but that one has other problems...).	deng	8.578377	-6.5553784	comment	5.0	21.0	1479889617	-11.918527
13230892	> One thing often missing from the d	> One thing often missing from the debate is this: version control is a fundamentally complex problem.No, it's not!I've been teaching SVN to Electronics Engineers, Designers and other folks who have never used version control before. It's always been very straightforward. They'd be able to use it effectively after a quick tutorial and demo, with a few notes of advice.I've been teaching Git recently... until I gave up. It's a giant WTF clusterfuck. Git is the ultimate failure in simplicity and user experience.Just use SVN (it works on git repo).	user5994461	8.610703	-6.4616156	comment	5.0	19.0	1482341508	-11.867705
13359765	SourceTree is the only software that	SourceTree is the only software that they make that doesn't suck.If you compare SourceTree to other halfway modern git clients (like Tower or GitX-dev), oh boy does it suck! The layout is completely disorganized, the diffing is super lousy. It's slow. It sucks up lots of memory. It's literally the last GUI client I'd use before just going to the command line.	rsp1984	8.617562	-6.4416766	comment	5.0	15.0	1483995761	-11.910845
13393671	When to make a Git Commit	When to make a Git Commit	bhalp1	8.583148	-6.516655	story	5.0	10.0	1484334332	-11.9090395
13492533	Should be noted, it is often temptin	Should be noted, it is often tempting to describe everything about the change in the commit description rather than comments in the code. Remember, git commits disappear from sight pretty soon and become fossils, whereas there may be something important that should be said in the code itself.	mojuba	8.57901	-6.5226774	comment	5.0	24.0	1485447219	-11.911145
13610033	Fascinating. Can someone detail the 	Fascinating. Can someone detail the pros/cons of this? Are they copying/cherry-picking commits from a dev track?	liquidise	8.587623	-6.482287	comment	5.0	20.0	1486668501	-11.887076
27540548	Ask HN: How often do you use Git bis	Ask HN: How often do you use Git bisect?	mkchoi212	8.573099	-6.5240393	story	5.0	6.0	1623943177	0.8963742
27580291	> novice users are terrified of it. 	> novice users are terrified of it. When they make a mistake, many would rather delete and re-clone the repository than try to fix itIn my experience most beginners use a GUI like Atlassian Sourcetree or the Github desktop client. It's a lot harder to make mistakes using the GUI in my experience.I still really like this idea though; eventually a subset of the beginners wants to learn the git cli and that sure seems scary at first.	float4	8.551338	-6.4774017	comment	5.0	16.0	1624290290	-11.876222
27580654	Not a single person I’ve met using g	Not a single person I’ve met using git in the last decade has thrived using a UI for it.	an_opabinia	8.55867	-6.467107	comment	5.0	27.0	1624292242	-11.892883
27581275	like why it's different?`git fetch` 	"like why it's different?`git fetch` (and by extension `git pull` when given a remote) and `git push` copy data to and from a remote. When you specify `git pull origin master` you're saying ""pull down a copy of the remote ref master from origin"", which it then saves locally as the ref `origin/master`.Everything under `origin/` (or really `refs/heads/origin/`) is just a cached pointer to the last known state of that ref on the remote.All other commands operate only on these local references. So when you want to refer to what you know to be the state of things on `origin`, you can use `origin/master`. Otherwise that command has no particular knowledge of how to talk to origin.Incidentally this is a shortcut I use all the time to update my local master from a remote:`git fetch origin master:ma"	stormbrew	8.548207	-6.4932446	comment	5.0	20.0	1624295948	-11.879183
27581598	There is no doubt that a bunch of th	"There is no doubt that a bunch of the general commands are really poorly named, or mixed together. `git checkout branch` means switch to a branch - that's fine. But `git checkout filename` means ""undo changes to the file"". What? That's totally insane.`git branch new-branch-name` means create a new branch. Great, but it doesn't check out the branch, which you want like 99.9% of the time. If you want to do that, you use `git checkout -b new-branch-name`. Yes, a third separate use for git checkout.Why not (e.g.) `git branch -c new-branch-name` with a config option to make `-c` the default if you want it?If you rebase and push, it tells you to do a `git pull` to ""fix"" it, when in every workflow I've ever done, you want to add a `-f` and push away, just be aware that you are intentionally overw"	rjmunro	8.562519	-6.538949	comment	5.0	25.0	1624297491	-11.895164
27616949	current git branch is missing (helps	"current git branch is missing (helps me to avoid working on the wrong branch). (tried to do it with colors, but things got too messy). I never managed to work with colors in bash propmts; they look different on each environment.  parse_git_branch() {
    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
  }

  PS1=""[\u@\h \W\$(parse_git_branch)]\$ """	MichaelMoser123	8.595528	-6.4777184	comment	5.0	18.0	1624540534	-11.879914
27630541	I understand the overhead, but it se	I understand the overhead, but it seems like bundling lots of unrelated cleanup fixes into one large commit would make it easier to sneak in something nefarious.	hundchenkatze	8.591835	-6.547527	comment	5.0	15.0	1624627884	-11.916235
27660033	How would this work?  How many proje	"How would this work?  How many project maintainers would sign on for this?""Hey, can you merge this PR?  I'll fail if you don't review and merge this by tomorrow morning.  I'm sorry I left it until the last minute but I had a bunch of work do to in another class and couldn't get to it until today.""""Hey, I ran everything through flake and black and spent the past 72 hours getting my test coverage (and the coverage of the rest of the project) to 100%.  /Now/ will you approve this PR?""""Hey,  you stopped responding for the past week, are you on vacation?  Is there any chance of approving this PR by Friday?"""	Ensorceled	8.669571	-6.4712615	comment	5.0	22.0	1624876164	3.7118285
27683563	This is a dangerous feature for git 	This is a dangerous feature for git repository hosts like GitHub to support. It makes it all too easy for subtle vulnerabilities to be introduced and omitted from visible blame history, with reviewers presuming trust based on historic content. Example: codebase went through an audit, was approved, then someone sneaks in some subtle changes to some files under the guise of a bulk change, adds the commit to the ignore list, continues making more commits to other files. Pulling a report to see historic changes could result in the file made vulnerable being skipped because it appeared to occur before the last audit. Hard pass.	cassonmars	8.567914	-6.516922	comment	5.0	16.0	1625013097	-11.907211
27738091	> Git strives to record what the dev	> Git strives to record what the development of a project should have looked like had there been no mistakes.Hmm. I think I disagree. One can clean the commit history to look like that, but it's optional. You can merge all of your messy starts and restarts right into master if you want. Easier to do, in fact.	rendall	8.573471	-6.550072	comment	5.0	22.0	1625493684	-11.91122
27779856	Git-power: emPOWer your commits with	Git-power: emPOWer your commits with bespoke hashes	breck	8.630141	-6.5061526	story	5.0	31.0	1625797065	7.1923113
12246170	We've got a great update framework a	"We've got a great update framework already, if only everyone would use it: git.Seriously.  I can't think why this wouldn't ""just work""."	fit2rule	8.550365	-6.440055	comment	5.0	18.0	1470643821	-11.891154
12290740	My most important git tip is: use Ma	My most important git tip is: use Magit (https://github.com/magit/magit).  It really is a huge step forward from using the git CLI — but, unlike many UIs to CLI tools, it actually helps one learn the CLI, but presenting flags and git subcommands.  Thus, it both supersedes the git CLI and teaches it, just in case one is ever on a computer without Magit.	zeveb	8.566816	-6.5009756	comment	5.0	20.0	1471272151	-11.890673
12310131	For the unfamiliar, git stash [0] is	For the unfamiliar, git stash [0] is a solution to a problem like this:You're working on a feature, and suddenly realize the need to switch gears to work on something else — say a prod hotfix — and you need to store your WIP somewhere, but you're not ready to commit.  You run `git stash` with an optional commit message and get back to business.What happens for me is I end up making many small stashes across many projects.  It might be a trivial change or a prototype of an idea, sometimes I forget creating them in the first place and implement the same thing again and/or they become stale.My question for others is:Do you use git stash?  Do you forget them sometimes some?For some more context: I'm pondering writing a little program to peruse all stashes from all repos on your drive in one pl	tedmiston	8.575211	-6.5456758	poll	5.0	16.0	1471488911	9.355741
12358249	There seems to be a split among git 	"There seems to be a split among git users between those who think history should show what actually happened (i.e. it's left alone), and those who think history should tell a story about the changes (i.e. once you've finished something, turn it into a coherent set of commits like ""stub out X"", ""add tests for X"", ""make first X test pass"", etc.).I agree with you, that history should be left alone; mostly I think of the YAGNI argument that its futile to think that you have a better idea of what future developers want to see, compared to those future developers themselves.My repo histories are riddled with stuff like ""finished X"", ""stubbed out Y"", ""fix typo in X"", but at least nothing has been hidden from future devs who might be digging around for their purposes, regardless of whatever elegan"	chriswarbo	8.572881	-6.539011	comment	5.0	29.0	1472125164	-11.910652
12383615	The only thing that jumps out at me 	The only thing that jumps out at me is the visual of the git tree diagram on the left - other than that why not just use the command line?Am I missing something?	kzisme	8.580295	-6.4713116	comment	5.0	18.0	1472492461	-11.871054
12460800	Its true -- and actually the well de	Its true -- and actually the well designed gui that accurately depicts the graphical state of your local repository makes it far easier to learn the concepts behind git than does the command line.  Distributed vc is conceptually nuanced, but not overly complicated -- the complexity of git really is in the interface wherein you are asked to map command line syntax into abstract operations that manipulate a state that you actually can't easily see from the command line.  The value of having a graphical depiction of the state that's changing as you invoke operations should not be underestimated.http://gitup.coI love this tool -- it's honestly one of the best graphical tools I've ever used -- rock solid reliable -- intuitive, not leaky in the abstractions it represents -- and not limited to on	breatheoften	8.573094	-6.4933114	comment	5.0	30.0	1473416017	-11.880257
12460273	I think the biggest problem people h	I think the biggest problem people have with git is that you can't and shouldn't want to change shared history, and yet git provides some tools that suggest that maybe you can.It's better to accept history as it is, and fix the problem with reverts, cherry-picking and new commits. History won't be as pretty or clean, but it will reflect what actually happened, which is what history is, after all.The biggest trick to understanding git is to learn to think in commits rather than file content. If one branch has a commit and the other branch doesn't, merging them will mean that the commit is there. If one branch has the commit while the other branch has the commit and a revert for that commit, merging will mean it will be reverted.Same goes with pushing. If you reset locally to before a commit	mcv	8.573668	-6.5408707	comment	5.0	19.0	1473406793	-11.902744
12460435	SVN is much easier to use for the st	"SVN is much easier to use for the standard corporate workflow of a group of people making commits to a project which mostly advances monotonically with continuous integration.Edit: also in a Windows environment, svn copes slightly better than git. First project we tried it on had the worst possible environment, a mix of Windows and Linux systems. Line ending nightmares everywhere.It also took a while to work out how to kill (with fast-forward) the spurious ""merge commit"" you get every time someone does a pull. You don't have that with svn, you just do the merging locally when you update and it doesn't generate a commit."	pjc50	8.58794	-6.495435	comment	5.0	22.0	1473409616	-11.890064
12487416	We would seriously consider GitLab i	We would seriously consider GitLab if they supported Mercurial. I am so annoyed with atlassian (another company that perhaps could pay attention more to developers). I like git for OSS but we love hg for our internal projects.	agentgt	8.514781	-6.534775	comment	5.0	33.0	1473768956	-11.951739
12489078	I'm not a gitlab employee or anythin	I'm not a gitlab employee or anything, but I'm curious: How is gitlab CI not flexible enough for you?I mean, it basically just runs arbitrary docker containers. From my mostly amateur (when it comes to this, i'm a professional developer but I don't manage our CI system directly) point of view it seems like the gitlab CI is more flexible than jenkins not less.	mordocai	8.595894	-6.4881887	comment	5.0	23.0	1473780316	11.929817
22489397	> It's honestly crazy how much time 	"> It's honestly crazy how much time we as a community of software developers spend thinking about Git.It's funny, I can't remember the last time I had to give serious thought about how to use git.Sure, there's a learning curve. When I was just starting out, I didn't get it all right away. But it's been years since I've thought much about branching strategies and stuff. And I don't get myself into ""terrible messes"" that take hard thought to get out of.Not saying you're 100% wrong. But it doesn't line up with my experience."	PaulStatezny	8.547156	-6.496047	comment	5.0	38.0	1583365415	-11.88957
22489472	Here is an exhaustive (~99.5%) list 	"Here is an exhaustive (~99.5%) list of the git commands I use:  git init
  git clone
  git clone --recursive
  git remote add
  git checkout
  git branch
  git merge --no-ff
  git add
  git add -p
  git rm
  git reset
  git commit [-a] [-m]
  git commit -p
  git commit --amend
  git submodule add
  git push
  git push -u
  git pull
  git log
  git show
  git status
  git update-index --assume-unchanged (aliased to ignore)
  git update-index --no-assume-unchanged (aliased to unignore)

The 1 in 200 is probably a git rebase -i.If we're doing something other than git I'll be happy with those. Specifically add/commit -p are important to me."	kohtatsu	8.574439	-6.5399795	comment	5.0	22.0	1583365947	-11.907175
22490883	> I like squash commits: build a fea	"> I like squash commits: build a feature iteratively in a branch + pull requests, squash to master once it has the tests and documentation bundled together with the implementation. This gives you linear historyI disagree with squashing commits when merging to master, here's why:Your commit history is what you will use later down the line (think 6 months, a year, 2 years later) to find a very nasty yet incredibly subtle bug in your application.Imagine said bug was introduced by a feature that took about 1 full month to code, introducing 1000 lines and removing 500.That feature was probably made of many small commits (say, 25 commits total), on a feature branch called ""super-feature"".If your developer cared at all about making ""atomic"" meaningful commits, each one of those commit will be int"	gouggoug	8.576055	-6.556812	comment	5.0	37.0	1583381432	-11.936689
22497522	AFAICT Gitflow just has one more bra	"AFAICT Gitflow just has one more branch than it needs. If you got rid of the master branch and supported production releases off release branches it would be just as useful and significantly less complicated.
Can anyone explain to me what real value the master branch adds in this model? And without using fluffy meaningless words like, ""source of truth,"" please."	arghskwidge	8.516445	-6.509162	comment	5.0	25.0	1583438460	3.0510306
22544678	Little Things I Like to Do with Git 	Little Things I Like to Do with Git (2017)	kaeruct	8.536522	-6.450231	story	5.0	35.0	1583923773	-11.935471
22780119	Some other Git features that I find 	"Some other Git features that I find super useful, which past colleagues of mine haven't known about (which maybe suggests they are not universally known).git rev-parse branch-name: gets the hash of a branch name, useful for verifying two branches are at the same place (so ""git rev-parse HEAD"" gets the current hash)The ^ and ~ notations for navigating commits: my_branch^ points to the commit 1 before my_branch, and can be repeated multiple times, ie. my_branch^^^ to get the commit 3 from the top. Likewise the tilda notation allows one to jump a fixed number of commits up: my_branch~10 is the commit 10 above my_branch.git rebase -i HEAD~10: interactively rebase the last 10 commits. Easy way to re-order, squash, drop, and/or edit the commit messages of recent history in a single git command."	rjtobin	8.568498	-6.543018	comment	5.0	16.0	1586023589	-11.906799
22780178	I really don't think git reset --har	I really don't think git reset --hard should be at the top of a list of git commands intended for beginners.	saila	8.557848	-6.527621	comment	5.0	18.0	1586024010	-11.929478
22853063	For better or worse, I find GUI git 	"For better or worse, I find GUI git clients to be less useful than the CLI. But like any CLI tool, it's productivity is limited by your ability to type without errors. Git has an Autocorrect[1] that will help you out.> git config --global help.autocorrect 1Based on bash history data, I've also added a simple alias to my bash config:> alias gti=""git""[1]: https://git-scm.com/book/en/v2/Customizing-Git-Git-Configura..."	jldugger	8.572672	-6.4936876	comment	5.0	23.0	1586750396	-11.893696
22915411	Bitbucket deleting Mercurial repos J	Bitbucket deleting Mercurial repos June 1	dd82	8.470274	-6.4918427	story	5.0	21.0	1587299017	-11.96368
22944096	I really want a hybrid command line/	I really want a hybrid command line/gui git client. Either a GUI app with a terminal front and centre, or a command line tool that has some commands to use UI style things.I hacked together a bash script that prints out all the branches and lets you click on it to switch to it and it's been pretty useful, just wish I could be bothered to make it properly with more features.	jon889	8.572405	-6.471743	comment	5.0	15.0	1587551272	-11.874368
22997308	This looks cool. I'm curious if peop	This looks cool. I'm curious if people use Git's tree view, in any form, as part of the regular workflow? If so, how? I have never found it useful, intuitive, or usually readable / parsable. Not the graph drawn on the command line, certainly not Github's tree view GUI of forked projects. I've also only ever worked on a project with one or two main trunk branches (master, and maybe dev), and feature branches, and very little merging between other arbitrary branches.	stevebmark	8.581165	-6.4853554	comment	5.0	17.0	1588004802	-11.901018
23045745	I disagree with naming conventions f	I disagree with naming conventions for branches. Just give it a name, I like to have have a bit of fun sometimes. For example: 'org-mode', 'more-org-mode' and 'org-mode-3-still-org-moding' are 3 real branches I recently shipped. All the naming convention does is make another pointless argument. As long as the name is more descriptive than 'my-branch' I'm fine with it. Argue over something less pointless.	craigmcnamara	8.526749	-6.5337176	comment	5.0	18.0	1588362105	8.997312
23311791	I wish there was UI that I could jus	I wish there was UI that I could just point at a repository locally and get a GitHub-like view of the repository, where I can browse all the files, see their last commit date/message, click on them, and see the contents as well as history and git blame. I keep hoping someone will build a GitHub UI without having to use GitHub but for some reason every one of these Git UIs focus on just showing me the commit history and diffs. This is useful too but it's not really much different from all the other apps that do this.	jameslk	8.567001	-6.4472632	comment	5.0	22.0	1590504341	-11.8436
23312510	wat? doesn't this prevent you from d	wat? doesn't this prevent you from doing anything else w git?	chrisweekly	8.557988	-6.48828125	comment	5.0	16.0	1590507714	-11.867762
26554774	This was very cringey.  A super cont	This was very cringey.  A super contrived demo and bashing Heroku through a Twitter reference.  Reads like someone is drunk/high and wanted to shitpost about a competitor.  I would be appalled by this if I were GitLab's PR department!	candiddevmike	8.334923	-6.455824	comment	5.0	30.0	1616506515	-12.069764
26579449	How is the security with Fossil?  I'	How is the security with Fossil?  I'm always leery of hosting (niche) web facing services written in C.	candiddevmike	8.533019	-6.4865212	comment	5.0	21.0	1616675840	-11.928118
26579818	Fossil looks very interesting, but I	Fossil looks very interesting, but I completely disagree with their [stance on rebasing](https://fossil-scm.org/home/doc/trunk/www/rebaseharm.md). This is a dealbreaker for me.I do not consider having 10 buggy commits per feature instead of 1 working one an advantage. It just complicates reading history and hinders debugging (e.g. bisect). I get their arguments, I just disagree.	Hendrikto	8.515142	-6.5660896	comment	5.0	56.0	1616678042	9.48968
26742511	Commits are snapshots.How to represe	"Commits are snapshots.How to represent those snapshots, and fix the storage bloat a naive implementation would cause, is a completely different problem.One of the things that makes Git smart is that it doesn't try to optimize things prematurely. SVN and co. would store actual diff data, but this made some operations really hard to implement (and, in many cases, slow).Git has commits conceptually as snapshots. It's up to the storage code to figure out how to deal with this.> But I find it far more intuitive and useful to think of commits as ""diffs + some metadata"".Except that this is not what's happening. I wouldn't even call it an abstraction, it's how things actually work. What you call abstractions are actually operations. If we run a diff we are interested in the changes, but if you ask"	outworlder	8.596478	-6.5259666	comment	5.0	36.0	1617908906	10.276115
26742746	> If you think a commit is a diff, y	"> If you think a commit is a diff, you have a mismatch between the mental model and what's actually happening behind the scenes. This will make it difficult to understand concepts later on.I find that thinking of commits as snapshots is not so useful.  I prefer to think of them as a pair of parent commit and diff.With that in mind, things like rebase become obvious: Take the same diff and attempt to apply it to a different parent.It's not clear to me how thinking of commits as snapshots helps me to explain operations such as rebase.I do concede, however, that ""git cat"" (I think that's the command) seems more closely related to a snapshot: you identify a commit and a file, and it will give you the content of that file at that commit.  Clearly in this case the concept of a snapshot works wel"	hibbelig	8.597786	-6.5392194	comment	5.0	27.0	1617910284	10.224044
26743233	It strikes me as bizarre that someth	"It strikes me as bizarre that something as old and as important as git is to the general version control problem, doesn't have a beautiful, complete and helpful user interface.With the status quo how it is, I definitely love articles like this because every time I use git I get a kind of anxiety that fades only in proportion to the depth with which I understand actual git mechanics.The thing I find strange is that when I interact with databases that have beautiful, helpful user interfaces, I have almost none of this anxiety, and just kind of accept ""black box that handles things"", and move on with my life.I figure I must not be alone in this psychological niche. Which again, makes it bizarre that the problem of giving git a beautiful, complete, helpful front end has not been solved."	Tomminn	8.556941	-6.485378	comment	5.0	18.0	1617913088	-11.878597
26765205	care to explain what is Brave and wh	care to explain what is Brave and what is FLoC?	riq_	7.823448	-7.68856	comment	5.0	17.0	1618089455	-14.480832
26801908	Ask HN: How do you approach code rev	Ask HN: How do you approach code reviews?	chpmrc	8.601835	-6.5372024	story	5.0	7.0	1618363555	-11.937365
26961865	It is also really absurd that you ca	It is also really absurd that you can reset everything with `git reset --hard` but you have to use `git checkout -- ` to reset individual files. It's not even clear why `checkout` is involved in resetting files at all.	ajkjk	8.539942	-6.5473332	comment	5.0	21.0	1619559063	-11.905979
26997902	The older I get the more I find thes	The older I get the more I find these discussion as counterproductive as figuring out where to put the bike shed.I worked in teams that did squash merge and in teams that didn't. And in teams where some did and some didn't, on the same repo. In the grand scheme of things it didn't matter, except for hardliners who had nothing better to talk about.	decebalus1	8.573938	-6.5725017	comment	5.0	16.0	1619809773	-11.949948
26998495	> A complete and utter waste of time	"> A complete and utter waste of time. You spend more time messing about with rebase than solving problems.Unless you're using a garbage client (eg, the git CLI) a rebase to get rid of the ""typo"" ""oops"" type commits (when you forgot something) takes I'd say 10-20 seconds.Most commonly I do this when I have several changes on the go at once and forget to commit a fixed unit test, new import, or something like that. I usually realize it right away, so my commit will usually be ""add test"" or ""amend 2 commits ago"" or something to remind myself which one it goes to (and it sticks out, because my other commits are usually in the format ""PROJ-1234: Add new --host command-line option"").> When you're digging through VCS history due to a bug you often ignore the commit message anyway - if the code di"	gregmac	8.582535	-6.5486064	comment	5.0	17.0	1619812577	-11.896652
27015794	Which files get the most commits?Whi	"Which files get the most commits?Which sections of each files get more than usual commits? eg which functions?Who wrote this particular function first? who subsequently?How many of those include expletives? Curious minds need to know.If I want to answer these earth shattering questions, could I just grab the entire git repo and go from there? is it that simple? is it text exportable without too much ""other"" scary?"	sfgweilr4f	8.572813	-6.4911747	comment	5.0	20.0	1619967207	-11.885306
27095477	Ask HN: Tool to download a Google do	Ask HN: Tool to download a Google doc as a Git file (version history)?	beckman466	8.578621	-6.4400525	story	5.0	7.0	1620563822	13.739348
27135457	Okay, so I should avoid it. What is 	Okay, so I should avoid it. What is the alternative?I see so many git repos with READMEs saying download this huge pretrained weights file from {Dropbox link, Google drive link, Baidu link, ...} and I don't think that's a very good user experience compared to LFS.LFS itself sucks and should be transparent without having to install it, but it's slightly better than downloading stuff from Dropbox or Google Drive.	dheera	8.566765	-6.450922	comment	5.0	16.0	1620855519	-11.919989
27276522	I haven't tried very hard yet, but m	I haven't tried very hard yet, but magic has been fairly unintuitive for me.  Perhaps it's just that I've been using git for so long.There have been several times that I tried something with magit, and messed things up enough that I just dropped into a shell and did everything with the git command line	aidenn0	8.561305	-6.4786024	comment	5.0	29.0	1621949343	-11.865121
27359196	you can target an Economist reader a	you can target an Economist reader a week later on a different website. If FLoC works, you can still do that.https://github.com/WICG/floc won't really let advertisers do that, this is what https://github.com/WICG/turtledove is for(Disclosure: I work on ads at Google, speaking only for myself)	jefftk	7.864418	-7.680878	comment	5.0	28.0	1622572379	-14.486565
27434234	I never understood the point of squa	I never understood the point of squashing if you just want the short version, only read the merge commits; if you want the full details to figure out some bug or whatever, then yes, I want those fix typo commits most definitely, because as often as not, those are at fault.Squashing buys you next to nothing, and costs you the ability to dive into the history in greater detail.I suppose if your project is truly huge, it becomes worth it to reduce load on your VCS, but beyond that...	emn13	8.574801	-6.5620255	comment	5.0	70.0	1623155334	-11.965138
14712801	> Aside: This is when git started pe	> Aside: This is when git started performing destructive actions without warningIs there anything truly destructive in git though? Unless there's a GC, you can still recover any unreferenced objects.	rootlocus	8.576942	-6.5102696	comment	5.0	16.0	1499366548	-11.8835745
14712439	I really agree with this, it's too l	I really agree with this, it's too late for git now, but I consider the overloading of 'checkout' to be one of the worst pieces of UI I've ever come across, and the source of confusion for many people when I try to teach them git.I didn't know that 'git reset' has a similar problem.If git gained the 'checkout-tree' and 'checkout-file' (and other) commands mentioned, I'd personally use them instead of checkout.	CJefferson	8.548208	-6.514746	comment	5.0	18.0	1499364355	-11.89536
14839233	It's sad so many people use GUIs on 	It's sad so many people use GUIs on top of git - you really end up not understanding what git is doing and it can lead to problems. Command line is supreme for the same reason that a majority of books are better than their movie counterparts. They are easier, though, but in the case of git that isn't a good thing.	methodin	8.572253	-6.486948	comment	5.0	22.0	1500910078	-11.879304
14967310	I personally almost never rebase and	"I personally almost never rebase and/or squash, since I think that the information that gets lost (like: when was it started, what were mistakes along the lines) might be useful for future understanding of how the project work evolved over time, and what adjustments should/could be made to the development process.But I understand that a screen as shown in the article is not immensely usuful. But if it comes down on how to present git history information to users, maybe an additional aproach would be to come up with a better presentation layer (that, for example, could hide merge commits, ""squashes"" branches, etc."	radiospiel	8.570825	-6.559776	comment	5.0	27.0	1502275854	-11.934037
14967472	Editing git history makes sense in s	Editing git history makes sense in several cases:1. Projects like the Linux kernel which use frequently use 'git bisect' to perform a binary search on the history of project (to find when a bug was introduced), or where the patch series tell a story to code reviewers.2. Open source projects, where some contributors have terrible git habits that the maintainers don't want to merge.Editing git history makes less sense in other circumstances:1. When dealing with less sophisticated git users who don't understand git's data model. About 90% of git nightmares begin when a novice git user tries to rebase something.2. When it adds a whole layer of unnecessary process for zero payoff. If your developers all work in short-lived branches with clean histories, then just go ahead and merge normally wit	ekidd	8.567615	-6.526842	comment	5.0	35.0	1502277583	-11.913618
15044450	The sad part is that he didn't learn	The sad part is that he didn't learn his lesson. The problem obviously isn't with Visual Studio Code, but with Git (or whatever version control software he tried out). It seems that he didn't know anything about using git and accidentally checked out a bare repo instead of adding his files to stage. From his post, he says he's using windows and he's used to things going into the recycle bin, something a Linux tool like Git obviously isn't going to do. So this is a mismatch between a beginner software developer on windows never having used Git before, and the mental model of Linux tools like Git.I agree with him that Visual Studio Code could probably have designed their warning message a bit better, for people like him who have no experience with Git.And now to the sad part, having accident	theknarf	8.552414	-6.4807653	comment	5.0	33.0	1503044198	-11.914768
15263897	`git rebase --exec {rebuild project}	`git rebase --exec {rebuild project}` solves the issue of invisible errors in commits.  I'm a big fan of Gerrit's review workflow, which requires every commit to build in isolation.  I also usually try to squash my changes into logical independent commits before review.I like rebase because it's prettier, but I also think there's an issue with the non-rebase case that the OP has missed: unless you rebase, you're setting yourself up for failure in the `git bisect` case: when you step back to find the source of an bug you're tracking down, the worst possible case is that you find it's introduced by a merge and not present in either of the parents.  That's much more likely if your merge commits contain fix-ups of their own, which in turn is much more likely if you've got overlapping branches.	andrewaylett	8.583851	-6.547905	comment	5.0	21.0	1505556414	-11.906307
15375765	> - rediscover the arcanes required 	> - rediscover the arcanes required to save only what you want. Maybe I should branch and commit. Or stash. Or reset and add. Or do an interactive thingy ?Here's something I'm trying:1. Always branch and commit.2. Push branch as a work in progress.3. When branch seems ready to merge, make a new branch from that branch.4. In the new branch, go crazy. Squash, reorder, whatever the heck.5. If you screw something up royally in #4, delete that new branch and go back to step #3.6. If CI succeeded for new branch, merge new branch.7. Delete work-in-progress branch.What kind of situations aren't covered by this approach?	jancsika	8.578464	-6.5595155	comment	5.0	18.0	1506817991	-11.91949
15563853	I must be lazier. I use `gitst` for 	I must be lazier. I use `gitst` for `git status`. That is 1/6 shorter and IMO not harder to remember.	Someone	8.586926	-6.512735	comment	5.0	15.0	1509057561	-11.850792
28954606	I want to know if it is a hard G as 	I want to know if it is a hard G as in Git, or soft G as in magic.Ok, soft G might be the best choice.	robbrown451	8.534132	-6.474715	comment	5.0	16.0	1634888678	-11.514529
28955122	Magit is such an unbelievably good p	"Magit is such an unbelievably good piece of software. If you haven't used it, please at least take a look. It seems like ""just a GUI for git"", but that's missing the point — many operations suddenly become frictionless, so your entire workflow changes.I regularly do things like ""stash some of my changes, switch branch, cherry pick a commit, switch branch, do an interactive rebase reordering commits and dropping one, pop one of my stashes"", and they become routine, so working with code becomes a fluent experience, rather than fighting with your tools.I would say that Magit and structural editing using Paredit are the two most important technologies that make programming great."	jwr	8.620694	-6.4904084	comment	5.0	128.0	1634893834	-11.739924
28956670	Why would I use magit over the git C	Why would I use magit over the git CLI?1. Discoverability. It'll display the contextually relevant options and commands at most points. By using magit, you're learning the git CLI commands at the same time, including commands that you'd normally never come across without a comprehensive read of the manual or release notes.2. Fewer keypresses. Also, extra shortcuts for some common operations.3. The bits that CLIs aren't very good for: staging and unstaging pieces of files, viewing conflicts.(I do still use the Git CLI a lot of the time too.)	GlennS	8.601836	-6.493406	comment	5.0	17.0	1634907488	-11.860128
29126069	> Git does not track historical bran	> Git does not track historical branch namesThat's my biggest pet peeve on this list. Git branches are really just pointers to the HEAD of some commit history, but if you've had a bunch of merges in the past it can be very difficult to tell which commit belonged to a particular branch at some point in the past.Is there a good solution for this? Seems like it would be trivial to add a piece of metadata about which branch someone was on when a commit was made.	hn_throwaway_99	8.563735	-6.543036	comment	5.0	75.0	1636157326	-11.912081
29126227	We say this now, ignoring the hot me	We say this now, ignoring the hot messes that were SourceSafe, Pervasive, CVS, and SVN. Git is light years more elegant that predecessors, and its holding power is evidence of that. We're able to criticize now because we've had the privilege of forgetting (or never having experienced) just how bad it used to be, and the sheer amount of time with one tool that's been a staple for far longer than previous tools lasted.	andrew_	8.566437	-6.477612	comment	5.0	26.0	1636158498	-11.895281
29185532	> Like all powerful *nix cli tools, 	"> Like all powerful *nix cli tools, if you don’t you’ll shoot yourself in the foot one day.Surely we can do better than this? A tool being powerful should be no excuse for it having footguns!For example, see ""Why SQLite Does Not Use Git"": https://sqlite.org/whynotgit.htmlIn my eyes it addresses many of the problematic bits of Git and offers alternatives to them. Admittedly, it was sad to see other VCSes like SVN die out, since there were some things that they did more clearly than Git (e.g. revision numbers), despite their other shortcomings.Currently, for many Git is essentially forced upon them and they have to learn commands that they don't understand to use it, much like you said. If version control were easier and more intuitive, then more people would adopt it and the ones using it w"	KronisLV	8.56568	-6.479294	comment	5.0	18.0	1636617294	-11.885185
29239987	well... strictly speaking ... how ca	well... strictly speaking ... how can a git repo exist when a single artifact is blocked. the hashes will not sum up anymore.	oaiey	8.6321745	-6.5011125	comment	5.0	24.0	1637067576	7.203173
29260542	I've worked at both FB and at smalle	"I've worked at both FB and at smaller companies. The ""stacked diff"" workflow is quite good, although it can be replicated via Github's PRs via ""logical commits."" The basic workflow is:1. Each commit is a Phabricator-style diff. Put the whole idea into a single commit via `git add -p` and rebasing.
2. Multiple ideas/diffs for the same feature? Split them into multiple commits on the same PR.
3. Review the PR commit-by-commit: you can click on the links in Github to the individual commits and see+comment on the changes there. Comments on commits automatically propagate back to the PR FWIW, so this works pretty well.The mental model becomes: the PR is the overview of the full feature, but not how reviewers are expected to review. Reviewers review commits.It works pretty well!  Assuming you ha"	reissbaker	8.596537	-6.484514	comment	5.0	20.0	1637193834	2.2638364
29308294	- CI servers could do much more and 	- CI servers could do much more and their findings should be merged back into the IDE UI: integration tests, CVE analysis, tracking possible merge conflicts from concurrent feature branches- Bake the distributed nature of the software process into the IDE. What environments and servers is the developed software running on? That information is currently spread out over multiple tools and should be synthesized and presented coherently from the IDE, so one could dive straight from it's IDE into a problematic server and start debugging using the appropriate code  without having to spend 2 hours reproducing the build configuration locally.-  Finally, _Team Workflow_ is especially taken for granted, ground rules being implicit in most organisation but having the most actual impact on team produc	speed_spread	8.687701	-6.4448	comment	5.0	20.0	1637598924	5.461354
29396257	I maintain a bunch of git aliases in	"I maintain a bunch of git aliases in my .gitconfig for my company's rebase based workflow. They cover 90% of my 'dumb' git usages    synced = pull origin master --rebase. # Update myself with master

    squash = rebase -i origin/master # Let me optionally squash whatever has happened since master

    publish = push origin HEAD --force-with-lease  # Save to orig in (github)

    pub = push origin HEAD --force-with-lease  # Save to origin (github)

    ammend = commit --amend  # I cannot spell this word for the life of me

    amend = commit --amend"	softwaredoug	8.574835	-6.518455	comment	5.0	16.0	1638299995	9.628112
29586389	I agree with the middle ground comme	"I agree with the middle ground comment. That is how we tend to do things where I work.We have a modified GitFlow:
main: is the source of truth and is what is in production.
develop: is the constantly moving branch we make PRs against. You can commit directly here which is discouraged but it isn't a hard rule.
ticket: is a branch for each JIRA ticket not each feature.
release: We don't make these and just use tags on main. Each ""release"" is a merge from develop to main and that gets deployed.
hot fix: These are made against main and merged back to develop when they are used. It is rare enough I have to look up our ""official"" procedure.With that we can easily use PRs, release code in small hidden chunks, do code reviews, etc.Seems like the big win they got was releasing small hidden chunks o"	PontiacParade	8.5916605	-6.4912176	comment	5.0	27.0	1639703295	-11.905451
29586676	> 2) You can commit to main/master i	> 2) You can commit to main/master if it’s a reasonably small change not needing reviewI earnestly do not believe there exists any change small enough to not need a review.	seattle_spring	8.585377	-6.476007	comment	5.0	28.0	1639705242	-11.848793
25545713	I love how git calls this feature “b	I love how git calls this feature “blame” :)	savrajsingh	8.561956	-6.4916205	comment	5.0	27.0	1609010678	-11.877871
25893785	I always love these sort of things. 	I always love these sort of things. Here's the same for the US constitution: https://github.com/JesseKPhillips/USA-ConstitutionAs a bonus, this one attempted to backdate the commits in a cyphered way (git dates are unix timestamps so the author needed to get clever to do anything before t=0 in 1970).	frob	8.553213	-6.460195	comment	5.0	19.0	1611509159	-11.881741
26083108	What's the other options besides hg 	What's the other options besides hg if it ain't git?	livvelupp	8.525478	-6.468345	comment	5.0	15.0	1612908839	-11.933922
26189563	Jetbrains IDEs have a local history 	"Jetbrains IDEs have a local history feature that provides snapshots with diffs and allows partial rollbacks.I only use it when experimenting with different approaches.Mostly I only use the ""Local Changes"" tab in the Git panel that shows the diff compared to the last commit, or ""Compare with branch""  to see the overall changes relative to the base branch."	indexerror	8.632217	-6.513514	comment	5.0	19.0	1613707653	-11.76864
26248715	"Great idea.
One question - what pain"	"Great idea.
One question - what pain point is this solving?As a GitLab, GitLab Pipeline and Docker user I don't find running pipelines that slow to run or initiate"	obayesshelton	8.488104	-6.4424834	comment	5.0	15.0	1614164411	9.041931
26370733	You can also use Git for data!It’s a	You can also use Git for data!It’s a bit slower, but smart use of partial/shallow clones can address performance degradation on large repositories over time. You just need to take care of the transformation between “physical” trees/blobs and “logical” objects in your dataset (which may not have 1:1 mapping, as having physical layer more granular reduces likelihood of merge conflicts).I’m also following Pijul, which seems very promising in regards to versioning data—I believe they might introduce primitives allowing to operate on changes in actual data structures rather than between lines in files, like with Git.Add to that sound theory of patches, and that’s a definite win over Git (or Doit for that matter, which seems to be same old Git but for SQL).	strogonoff	8.626965	-6.4811463	comment	5.0	26.0	1615066548	9.535845
13651090	If you found a similar mistake in yo	If you found a similar mistake in your repository, you can delete commit from history using: `git rebase --onto <commit-id>^ <commit-id>`. Or if you want actually rewrite it, see git  rebase -i` documentation.	LeonidBugaev	8.569975	-6.5238743	comment	5.0	29.0	1487155939	-11.918194
13722500	I don't like the living-on-the-edge-	I don't like the living-on-the-edge-attitude that Linus and others here promote regarding Sha1 in git. First, attacks only get faster over time. What costs millions today is likely to be achievable on commodity hardware in the coming years. Second, attacks only get more flexible over time. A contrived collision on MD5 in 2004 got perfected to a single block collision in 2010 [1]. Third, devising an update strategy and rolling it out takes time. I can't guess how much hardwired use of Sha1 is in Github.Fourth, people use git in creative ways. Linus may think it is a cardinal sin to commit binary blobs in a git repository, but I can't imagine I'm the only one using git as a poor man's backup and file sharing solution.And last but not least, relying on Sha1 takes effort of constantly assertin	Perseids	8.673715	-6.5176973	comment	5.0	18.0	1487932119	7.222522
13733899	I'm mystified as to why this is even	I'm mystified as to why this is even a discussion.SHA1 is busted. That impacts some git users. The fix is not invasive. Fix the bug. Make the transition. Move on.Super unprofessional.	debatem1	8.674313	-6.5167646	comment	5.0	26.0	1488057683	7.2212195
13735843	Not really. From Linus — I think the	Not really. From Linus — I think the most important point that has not been discussed extensively:> But if you use git for source control like in the kernel, the stuff you really care about is source code, which is very much a transparent medium. If somebody inserts random odd generated crud in the middle of your source code, you will absolutely notice.	leoh	8.5685005	-6.4454556	comment	5.0	24.0	1488087157	-11.905941
13739121	you can report issues in the github 	"you can report issues in the github repo. However, if you want to ignore files and folders you need to pass those patterns to the function. For example, you want to exclude .git and .png then you need to run the command:    notes -x *.git/ -x *.png

in general if you want to exclude hidden files and folders you need to run it with -h true which excludes hidden dirs and files, so you can run    notes -h true -x *.png"	ahmadassaf	8.624441	-6.4739814	comment	5.0	24.0	1488136437	-11.828295
13742589	I think the fingerprint argument is 	I think the fingerprint argument is pretty weak actually. There is still a lot of unreadable content in git repos, including binary blobs in the kernel.	strictfp	8.65678	-6.499001	comment	5.0	25.0	1488181494	-11.799317
13793089	Is that doing Ctrl+Z , Ctrl+Y in the	Is that doing Ctrl+Z , Ctrl+Y in the background?Before opening the link I was thinking this was going to be a cool feature that lets you scroll through older revisions of a file in git. This, paired with a git blame GUI would be awesome.A minority report for git reposSweet feature regardless :)	vmarsy	8.576124	-6.470203	comment	5.0	20.0	1488664049	-11.880048
13889366	"The most important tip is ""Use the b"	"The most important tip is ""Use the body to explain what and why vs. how"".I'd also say: remove thw -m option from git and force people to open the editor. Do not accept messages shorter than 3 lines, start the editor with a template  Title

  What changed and why it changed."	pmontra	8.587926	-6.501698	comment	5.0	19.0	1489699641	-11.870126
13889892	I find tons of small commits a clutt	I find tons of small commits a clutter and waste of time. I don't see any reason for doing so. On the contrary I can see disadvantage - reading and understanding a history later may become difficult task. After all what counts is your full chunk of work, reviewed via pull request, and merged to master. It should be treated as a whole.Has it really become so common with git? I don't see such trend around me.	wst_	8.570724	-6.5174494	comment	5.0	19.0	1489704782	-11.913216
13920743	One thing I'm wondering about that I	One thing I'm wondering about that I haven't seen discussed yet is the possibility to make circular git histories:When a git commit hash is calculated, one of the data that is used are the pointers to parent commits. That results in two properties for commits:1) A child commit's hash cannot be predicted without knowing the parent commits2) Once a commit is created, its parent pointers are practically immutable. The only way to change them is to create a new commit with a different hash - which cannot carry over the old commit's children.Those properties meant that it's impossible to construct a commit with a parent pointer that points to its own children. Therefore it was safe to assume that a git history is always a DAG.I think with deliberate SHA1 collisions now possible, someone could a	xg15	8.580991	-6.5366263	comment	5.0	17.0	1490087671	8.3578615
14386904	Those who think a wrapper is going t	Those who think a wrapper is going to help their development is in for something when things break and they don't know how to operate things the way they're meant to.git is an especially poor choice for wrappers. You're hiding the concepts of staged and unstaged information, branches, tags, remotes, submodules. Regardless of VCS, you're setting yourself up for failure when you buy into a third-party tool's workflow rather than knowing what the hell you're doing.Pick up git as you go along. Rather than a tool doing who knows what behind the scene. If you really goof things when you're starting, don't be afraid to git reset --hard <ref> / git commit --amend + force push, as long as you know where you're at in history.	git-pull	8.541343	-6.4875746	comment	5.0	24.0	1495368353	-11.915603
14401307	Sad to see this in the grey. Git is 	Sad to see this in the grey. Git is unintuitive to those who don't understand it. If you read about its internals and learn how it works, the command line gets much better. It's well documented and it gives you a whole lot of power and insight into the inner workings of the VCS. Things like launching your editor to do more complex commands, plugging a script into git bisect, these are all great design choices.	Sir_Cmpwn	8.530081	-6.508632	comment	5.0	20.0	1495548775	-11.900517
14410140	Yes, I have similar:    gs    git st	"Yes, I have similar:    gs    git status
    gp    git push
    gac   git commit -am 
    gc    git commit
    gcm   git commit -m
    gA    git add -A
    gC    git checkout
    ga    git add
    gd    git diff
    gm    git merge
    gmc   git merge --continue
    gpu   git pull
    grc   git rebase --continue

The only problem is that I cannot use git on anybody else's machine, the muscle memory is too strongly ingrained now. This is a common message:    The program 'gs' is currently not installed. You can install it by typing:
    sudo apt install ghostscript"	fredley	8.559121	-6.4925723	comment	5.0	28.0	1495635332	-11.860686
14410101	I also have aliases in my shell inst	"I also have aliases in my shell instead of git aliases.    st    git status ...
    gl    git log ...
    gd    git diff ...
    gg    gitg
    gup   git pull --rebase
    gb    git branch

The dots mean there are more arguments. The point is, every once in a while I analyse my shell history and add aliases for the most used commands. Looking at it now, it seems I should add aliases for `git push` and `vi Makefile`.I also have the aliases g for git, m for make, and v for vim."	qznc	8.631146	-6.5139427	comment	5.0	42.0	1495634994	-11.827611
14412534	When you have that many conflicts, i	"When you have that many conflicts, it's often due to massive renames, or just code moves.If you use git-mediate[1], you can re-apply those massive changes on the conflicted state, run git-mediate - and the conflicts get resolved.For example: if you have 300 conflicts due to some massive rename, you can type in:  git-search-replace.py[2] -f oldGlobalName///newGlobalName
  git-mediate -d
  Succcessfully resolved 377 conflicts and failed resolving 1 conflict.
  <1 remaining conflict shown as 2 diffs here representing the 2 changes>

[1] https://medium.com/@yairchu/how-git-mediate-made-me-stop-fea...[2] https://github.com/da-x/git-search-replace"	Peaker	8.609934	-6.53363	comment	5.0	36.0	1495652396	-11.900829
14421738	As someone who creates open, medium-	As someone who creates open, medium-sized, reusable datasets, is Dat something I should try? Is it too early? The linked page is very much about technical details of the implementation and not about how one would typically use it.I maintain ConceptNet [1], a multilingual knowledge graph. I do everything I can to make its published results reproducible. The biggest hurdle for people reproducing it has always been getting the data -- building it requires about 100 GB of raw data or 15 GB of computed data that can be imported into PostgreSQL.I once tried git-annex. It turned out not to be a good choice -- its tools were flaky, its usage patterns confusing, it leaves a permanent record of your mistakes in configuring data sources, and it was very hard to convince to use ordinary HTTP downloads	rspeer	8.60495	-6.4594216	comment	5.0	25.0	1495767875	-11.860555
14568055	Show HN: GIT xD – append xD to all y	Show HN: GIT xD – append xD to all your commit messages	karolmajta	8.562415	-6.450115	story	5.0	12.0	1497612770	-11.842637
23518534	how are we going to call the master 	how are we going to call the master branch in git?	MichaelMoser123	8.517652	-6.526178	comment	5.0	16.0	1592149585	-11.768219
23531507	"How does GitHub use ""master""?In part"	"How does GitHub use ""master""?In particular, how is it different from what is called ""mainline"" in other VCS systems?"	gowld	8.447321	-6.5467587	comment	5.0	15.0	1592247639	-11.607353
23582776	I've never seen an adequate answer t	I've never seen an adequate answer to this but it boggles my mind that this problem wasn't foreseen.When Git came out we'd already seen a move from MD5 hashes to SHA-1 because MD5 was no longer deemed secure. Of course this was going to happen again.So why wasn't the protocol and the repository designed to have multiple (hash algorithm, hash) pairs?At this point it becomes a client and server issue if you support a given protocol or not so you have this handshake to agree on what you're using (eg a server may reject SHA-1), much like we have with SSH.This seems like it would've been trivial to allow for in the beginning. Or am I missing something?	cletus	8.679975	-6.518117	comment	5.0	23.0	1592644270	7.189402
23623036	Trunk flow has a lot going for it. H	"Trunk flow has a lot going for it. Here's a link in case others don't know of/haven't heard about it -- it starts off with a tl;dr summary: https://trunkbaseddevelopment.com/One of the key elements of trunk flow that I value about it is that ""the software you released"" is not a living stream. Because of that, it should not be tracked by a long-lived branch with commits that flow in in over time except in rare fix situations. With trunk flow and similar styles, you can always merge to master, and you can always deploy master. You do so by cutting a new branch, and in my opinion, you then build a static artifact. Next time you deploy, you cut another branch, build your artifact, and put it somewhere.Need to do a hotfix, but there's other work since last release that you just can't ship? Cher"	wcarss	8.608973	-6.543351	comment	5.0	18.0	1592963662	-11.907941
23682107	Fair question, you shouldn't be gett	Fair question, you shouldn't be getting downvoted for it imo.Larger projects need a way to collect bug reports, feature requests, maintain documentation, and set up milestones and release schedules, at a minimum. Ideally you want all of this integrated into your vcs, so that when a developer decides to push a commit related to a specific bug or feature request, that commit gets attached to that bug or feature request.When these are set up and run well, they are very powerful for mid-to-larger organizations.	thaumaturgy	8.565943	-6.4574313	comment	5.0	17.0	1593461387	-11.864407
23805711	Don’t agree with you about git at al	Don’t agree with you about git at all, I find it’s one of the few tools I work with that behaves expectedly and gets out of my way, if you want that workflow of stash, pull and reapply a stash why not make an alias for it?	jamil7	8.563475	-6.510909	comment	5.0	70.0	1594499925	9.449015
23806069	The functionality of git is great.  	The functionality of git is great.  Mostly.  (I think the whold concept of stage/index/cache is completely unnecessary though)  I find the UI to be inconsistent and confusing.  Why would I ever want to make a branch without checking it out?  It's literally never happened, yet it's the default.	recursive	8.552936	-6.5000486	comment	5.0	51.0	1594502140	-11.902485
23819975	So is it wrong to use a master branc	So is it wrong to use a master branch now? If so, it'll be interesting to see how Git(*) responds to this.	nmpennypacker	8.538805	-6.5285306	comment	5.0	15.0	1594643126	-11.792344
24104281	Git and Subversion even allowing sin	Git and Subversion even allowing single line “-m” commit messages was a mistake. You would see a lot better messages if they forced you to use the editor. I bet a lot of programmers don’t even know you could do multi line messages and assume there is some short-ish character limit. I know I did for a long time	0x00000000	8.602068	-6.5250044	comment	5.0	23.0	1597020209	-11.871108
24173664	Correct me if I’m wrong but these al	Correct me if I’m wrong but these all seem to fix problems that exist in a local clone only. And that’s where none of my “oh shit” moments happen.All of my oh shit moments are two flavours: I have pushed to  remote, or I have pushed to remote and force pushes are disallowed.I want a list of as graceful solutions as possible for those scenarios. And certainly they can be real-world solutions like “this cannot be undone in a desirable way so here’s an approach to handle the commit(s) necessary to fix the problem.This also brings up a question I didn’t realize I had: are people using git without frequently pushing to remote? I feel like having a remote backup of my work in progress is the killer feature. I can’t imagine doing any amount of work and not backing it up.	Waterluvian	8.603736	-6.473009	comment	5.0	36.0	1597537383	-11.850482
24173309	Needs an entry for git submodules is	Needs an entry for git submodules issues where the answer is to light the computer on fire and find a new profession.	ThrowawayR2	8.543296	-6.46597	comment	5.0	46.0	1597533632	-11.911116
24196608	Git is also incompatible with GDPR, 	Git is also incompatible with GDPR, you can't simply delete a file from all history.	visarga	8.533884	-6.4896765	comment	5.0	20.0	1597741650	-11.8461895
24208815	Conventional Commits	Conventional Commits	smartmic	8.5915575	-6.520144	story	5.0	37.0	1597831579	-11.894592
24215106	After working on a project that had 	"After working on a project that had code commit linters like this, that block you from committing if there's a violation, it's absolutely awful. You cannot work incrementally at all since ""inject logger"" is not a feature. Since most people aren't comfortable with rebasing (i don't know why), you end up with a ton of nonsense like a whole chain of refactors or feats that aren't actual refactors or features, they're just there to appease the tool since you can't commit (even locally!) without them.Just stick to squash-before-merge-to-master, thanks."	OpossumMinister	8.585125	-6.5541515	comment	5.0	23.0	1597865471	-11.966087
24374268	> Have you ever tried to read git do	"> Have you ever tried to read git documentation? It is the most useless godawful piece of nonsenseI ran ""man git"" for the first time ever.https://www.man7.org/linux/man-pages/man1/git.1.htmlHeey, that's actually pretty good! I don't think it's ""godawful"". In the second sentence it recommends starting with gittutorial and giteveryday, for a ""useful minimum set of commands"".https://www.man7.org/linux/man-pages/man7/gittutorial.7.htmlhttps://www.man7.org/linux/man-pages/man7/giteveryday.7.htmlI must admit, I still occasionally (regularly?) search for ""magic incantations"", particular combinations of flags for sed, git, rsync, etc. But the man pages are my first go-to, and they "	lioeters	8.553608	-6.491364	comment	5.0	53.0	1599222010	-11.853745
24386598	Page rank. I thought git was named b	Page rank. I thought git was named by Linus, and to the extent that it is named after him, it was self awareness of his reputation?I remember when Duff's Device was a neat trick; does anyone still use it these days?Edit: a neat trick, not a bear trick.	ben_w	8.564616	-6.456227	comment	5.0	21.0	1599337484	-11.893524
19986058	One way to look at Stackoverflow is 	"One way to look at Stackoverflow is that it's a gigantic index that maps ""intuitive plain English"" to ""non-intuitive exact syntax"".A good exampe of bridging this mismatch is ""git"" commands.  A lot of questions about Git are just translating natural English into the ""secret decoder ring"" lingo of Git.[0]  E.g. ""How do I undo a commit?"" isn't something obvious like ""git undo"".  Instead, it's the more cryptic ""git reset HEAD~""[1]A lot of the programming grind is like that.  You know the English words for what you want to accomplish but don't know the exact programming syntax to make it happen.  So this app is sort of like putting Stackoverflow lookups with copy&paste directly into the IDE.In contrast, the existing ""insert snippets"" functionality in Visual Studio[1] or IntelliJ have abbreviati"	jasode	8.568745	-6.4936337	comment	5.0	23.0	1558562697	-11.854355
20394464	I have heard often people's view tha	I have heard often people's view that git is not user friendly, but it's always confused me because that hasn't been my experience compared to any other tool I need to learn. Can anyone explain more this view? Perhaps I'm too accepting and forgiving.	spraak	8.534561	-6.4595494	comment	5.0	28.0	1562693870	-11.889225
20469252	I dislike the apparent inability to 	"I dislike the apparent inability to label groups of changes with `git stash`, so instead before leaving a branch with in-progress changes I'll commit them all as ""WIP"". Then, when I return to the branch, I'll check if the previous commit was WIP (`git log -1`), and if so will reset it (`git reset HEAD~1`). It's the best workflow I've discovered for dealing with this problem, and it means that I don't lose my commit history which is otherwise very clean."	samhh	8.5737	-6.5523715	comment	5.0	21.0	1563454743	9.498816
20470280	> Strange policy about commits — why	> Strange policy about commits — why just not push at night or during weekends? Why's everyone not working on branchesThat is what I’m saying. The policy is avoid pushes to master. My policy does apply to branches too once there are more than a few people in the branch.Lots of people do work in branches, but everywhere I’ve worked, plenty of people skip branching when they’re making what they think are “small” changes. And some places I’ve been, the team has decided on a policy to skip branches & merges for single commit changes due to the history noise it causes.The policy is to avoid breaking changes being committed to master when people aren’t around to notice & fix it.	dahart	8.582716	-6.538504	comment	5.0	51.0	1563460796	-11.895707
20499343	Why not just keep working? That next	Why not just keep working? That next commit will work just fine without a central server.	mattnewton	8.585247	-6.4916997	comment	5.0	46.0	1563811531	-11.9154215
20500126	I was in the team where we decided w	I was in the team where we decided what to use to serve git repos + to do peer reviews for a big German car manufacturer. We decided on GitLab because it had a normal fork-workflow but was open source and we wanted to divert some of the money into one of the open source projects. Now we have around 600 users in that project.Most of the things work great but we have the problem that we want to use Jenkins instead of the build in CI/CD solution but the only way to trigger MR jobs from GitLab forks in Jenkins is this non maintained plugin which has been in alpha since we started two years ago https://github.com/Argelbargel/gitlab-branch-source-pluginSo I wonder, what is the reason behind not investing into integrations with other CI systems like Jenkins which are hugely popular and used by so	jeena	8.647106	-6.5123615	comment	5.0	19.0	1563815827	12.009367
20746091	The ease of use is a big thing for m	The ease of use is a big thing for me. I find Git a bit arcane -- it's better than it used to be (around the Hg 0.9 era), but it's still quite bad.Hg has this way of actively pushing you towards the safe way of doing things (e.g. if you try to change history). Git will let you blow away a month's work if you mistype a command.I get the impression Git is the popular option because it underpins the Linux Kernel and Android development processes. That means it's popular, not that it's perfect for every use case.Mercurial is especially powerful when given to developers who know Subversion. A ~20% productivity boost just from being able to losslessly branch off and merge back without worrying about stepping on other devs' feed.Another team found out about it and were interested, but ultimately 	philpem	8.542938	-6.516711	comment	5.0	49.0	1566303876	-11.910789
20746265	I started my distributed version con	"I started my distributed version control journey when SVN was still king of the hill and git and mercurial were both tiny challengers.I actually picked mercurial first. I found the interface more intuitive, especially coming from svn. The problem was that everyday commands were just dog slow -- 5, 10 seconds on every single interaction. It felt like wading through molasses, contrast to git, which was effectively instantaneous on small repos and git on my large repo was still multiples faster than hg on a small repo. Also, IIRC hg didn't have a ""git stash"" equivalent. I chose git on its merits and didn't look back.A few years later (2010 ish?) I met a mercurial evangelist who said things had changed on the performance front, but I checked and they hadn't.I'll give hg the benefit of the doub"	jjoonathan	8.521639	-6.537559	comment	5.0	61.0	1566304979	-11.943093
20749797	> June 1, 2020: ... all Mercurial re	> June 1, 2020: ... all Mercurial repositories will be removed.It's understandable that they would discontinue Mercurial support, but this part is shocking. No doubt that 1% includes more than a few obscure but historically interesting repos that will disappear because the owner wasn't monitoring their email (or is no longer with us).Is BitBucket really that pressed for disk space? I hope they will reconsider and move those repos to a read-only archive like Google Code and CodePlex did instead of obliterating a piece of history for no good reason.	mcbits	8.44983	-6.530208	comment	5.0	24.0	1566323512	-11.965134
20752268	I like Go more. The git/hg/svn/bz re	"I like Go more. The git/hg/svn/bz repository is the ""package"". No custom (and central) ""registry"""	thefounder	8.592644	-6.452388	comment	5.0	24.0	1566335867	-11.849213
20861409	"Once I read ""this is ugly and pollut"	"Once I read ""this is ugly and pollutes your history graph"" as a justification for any git feature, I'm immediately turned off.What really is wrong with having a graph that actually reflects the real history of changes as they were made at the time?Why not keep things simple and improve git-log so that anything you find ugly or that looks like pollution can be hidden while viewing the history of a repo?  In this case, for example, would it not be far more ergonomic to add a ""--hide-control-merges"" flag to git-log?This rerere feature described looks like a lot of the foot-guns git provides.I know I'm in a minority here - I've given up arguing with collegues that it's possible to have a branch&merge work-flow without constant re-basing.  Allowing the history graph to be manipulated and change"	derriz	8.569503	-6.5442834	comment	5.0	26.0	1567454042	-11.91896
20939843	I'm not sure if the Aeon article exp	I'm not sure if the Aeon article explains what Everett really meant, at least I still have questions.Suppose we're eternally branching, as in the example about the up/down spin. If there's no way to visit other branches, how will we ever confirm this?Second, what is the benefit of the branching interpretation? It seems to simply be a way to think about probabilities?	lordnacho	8.677765	-6.5402575	comment	5.0	15.0	1568208241	-11.807724
30739689	I find it crazy how many people like	I find it crazy how many people like working with git from the command line and just use -a any chance they get.I never commit from CLI and have been using GitHub Desktop for years (it works on any repo/remote). Selecting individual files, patches, or even lines is a breeze. I usually make a bunch of changes, then pick, commit, branch, repeat. Every branch is based off `main` and can be pushed independently. Any leftover will just be dropped (any logging/testing lines that I never picked, for example)Using a UI makes it easy to review your changes before you commit them, there’s no way you can review (and pick or discard) your 100-lines 5-files changes effectively on the command line.GitHub Desktop is quite limited and I hope it stays that way, I still use the cli for operations other than	mushyhammer	8.59114	-6.5131755	comment	5.0	20.0	1647745468	-11.886845
30743811	This is cool. I’m learning a lot rea	This is cool. I’m learning a lot reading through the docs. Why is subversion so instructive? I’ve read about SSL certificates a gazillion times and it’s simple enough in theory but for some reason this is making everything click.What’s the use most common use case for something like this, by the way?	jorgesborges	8.608191	-6.4653525	comment	5.0	22.0	1647792306	-11.870423
30803259	This is fascinating to me! How did y	This is fascinating to me! How did you manage to merge code in the 80s? What tools were available? Did you have three-way merge tools or did you do it more manually?Or rather did you talk frequently and ensure that you weren't stepping in each other's files? How did you make changes to shared APIs?	cecilpl2	8.7104845	-6.4853787	comment	5.0	15.0	1648221778	9.166741
30817027	> Does Fossil have a unique or kille	"> Does Fossil have a unique or killer feature that makes it a good alternative to git, other than ""simpler to use""?If you click on the link it lists a ton of additions to git.  The first bullet lists ""bug tracking, wiki, forum, email alerts, chat, and technotes"" none of which are supported by git.Then again, bullet 4 is ""Self-host Friendly"" (every git client is also a full git server -- after all it's fully distributed) and bullet 5 is ""Simple Networking - Fossil uses ordinary HTTPS (or SSH if you prefer)"" Pretty sure git supports https out of the box these days (though I don't use it -- ssh is so much simpler).So yes, I would call those killer features for those who want them, and are pretty unique to any revision control system I've used, though some centralized sites have encrusted git "	gumby	8.525517	-6.4742517	comment	5.0	23.0	1648345579	-11.85992
30817708	I remember when there were many diff	I remember when there were many different reasonable options for source control.  I’ve really enjoyed recent years how there’s at least one thing in software development where basically everybody agrees what the right solution to a problem is.  For source control, use git.  Almost nobody disagrees.  Is git perfect?  Of course not.  Is it hard to learn?  Hell yeah.  But everybody does, at least enough to get by.I find the standardization that git has brought to the industry to be wonderfully simplifying for the lives of people developing software.  If only we could all agree on things like a programming language, or a database - how much more productive would we be?  How many life years do we spend trying out or learning new technologies that don’t go anywhere, or which only offer marginal 	oofbey	8.562874	-6.4614325	comment	5.0	18.0	1648355287	-11.884911
31010789	I shouldn’t ask too much of an open 	I shouldn’t ask too much of an open source project, etc. etc., but this sounds like something Git should fix themselves rather than just outright disabling. “I want to go into a directory and run git log” is kind of a simple thing to want to do and to not be able to do that sucks. It’s easy to pontificate on this forum but having a “safe” git that doesn’t automatically run hooks or whatever seems like the way forward here, and useful outside of even just a “I want my PS1 to work”.	saagarjha	8.563031	-6.448057	comment	5.0	29.0	1649819265	-11.854256
31044204	The one I use the most is `vipe`.> v	"The one I use the most is `vipe`.> vipe: insert a text editor into a pipeIt's useful when you want to edit some input text before passing it to a different function. For example, if I want to delete many of my git branches (but not all my git branches):  $ git branch | vipe | xargs git branch -D

`vipe` will let me remove some of the branch names from the list, before they get passed to the delete command."	topher200	8.607581	-6.5053473	comment	5.0	30.0	1650048790	-11.853948
31124657	Its worse because suddenly 20 years 	"Its worse because suddenly 20 years worth of tutorials are slightly 'wrong' and will confuse new users even more for no reason.""Why does my git say main and not master? Did I break it?""""Why cant I push to master like the 100x tutorials show? I get errors!"""	tryptophan	8.541917	-6.4913626	comment	5.0	24.0	1650647572	-11.893119
31173851	I like the conventional commit style	I like the conventional commit style [0]. You may have seen these in open source repos or used them at work. They look likefeat: support new line chartfix: update props for new line chartchore: bump dependency versionWhat's also cool is there are tools (semantic release) that will then handle automatically the versioning and publishing of your module based on these commits using the commit type (feat, fix, chore etc) to determine the next appropriate version [1].[0]https://www.conventionalcommits.org/en/v1.0.0/[1]https://github.com/semantic-release/semantic-release	bern4444	8.716767	-6.4481926	comment	5.0	51.0	1651011396	-11.886604
31176141	What do people think of this line?> 	"What do people think of this line?> Use the imperative mood in the subject lineThe only rationales I've seen for using imperative (""fix bug"") over the indicative (""fixed bug"") are that it's what git does by default anyways.Is it really that big of a deal to use the indicative sometimes and imperative other times?For what it's worth, I always write commit messages in the imperative, out of habit. When others write commit messages in the indicative tense, part of me notices, but I move on because I can still understand the message if it adheres to the other guidelines."	rafaele	8.611304	-6.5436864	comment	5.0	15.0	1651032056	-11.913669
31449343	Ok, I'm not one of those who conside	"Ok, I'm not one of those who consider the naming of the ""master"" branch in git offensive, but naming your service proxy ""massa"" (https://www.urbandictionary.com/define.php?term=massa) sounds a bit... unfortunate, even to my ears."	rob74	8.502736	-6.5141335	comment	5.0	17.0	1653062886	-11.688375
31481604	What are the pros and cons of branch	"What are the pros and cons of branches+merge-commits vs tags?So instead of a ""v4.11-rc7-87"" tag you would have a ""v4.11-rc7-87"" branch and a merge commit that holds the meta info about that branch."	TekMol	8.580858	-6.541877	comment	5.0	15.0	1653325130	-11.9188
31629751	what?am i the only one who thinks pr	what?am i the only one who thinks primary school children shouldn’t be learning git?edit: thanks for downvoting me and sorry for questioning your parenting principles	ushakov	8.537077	-6.4822345	comment	5.0	55.0	1654425878	-11.894898
31698196	Can you elaborate on some use-cases?	Can you elaborate on some use-cases? I'm finding it hard to imagine a situation where `git worktree add <path> <commit>; do_operation_in_path <path>; git worktree remove <path` is any different than `git checkout <commit>; do_operation_in_path <path>; git checkout -`	scubbo	8.57066	-6.5323324	comment	5.0	16.0	1654888056	-11.906856
35668518	Part of a good software team's toolb	Part of a good software team's toolbox.Others:https://direnv.net/ -- when you cd to a directory, do things like set variables.https://asdf-vm.com/ -- manage and use specific versions of software. Can work with direnv too!https://pre-commit.com/ -- git hooks that I personally found easier to manage than Husky.https://github.com/qoomon/git-conventional-commits -- enforce standard commit messages. Works with pre-commit!	bloopernova	8.622279	-6.4930596	comment	5.0	28.0	1682182517	-11.903408
35788039	My understanding is that before git 	"My understanding is that before git a substantial portion of the industry used the ""one big shared drive and shouting across the room to lock files"" version control system. There was also SVN that was pretty popular pre-git.I don't believe any version control system achieved as deep industry penetration as git has."	lolinder	8.603555	-6.4446054	comment	5.0	23.0	1683037865	-11.861299
35930895	Committing changes to a 130GB Git re	Committing changes to a 130GB Git repository without full checkouts [video]	eliomattia	8.6734705	-6.476992	story	5.0	20.0	1684000782	-11.859197
36178904	I mean I don’t want to troll but Mer	I mean I don’t want to troll but Mercurial has existed all this time.	moritz	8.500423	-6.575823	comment	5.0	17.0	1685815113	-11.965731
36180249	Git Blame-Someone-Else	Git Blame-Someone-Else	MrGagi	8.5563545	-6.469768	story	5.0	52.0	1685824193	-11.893222
36372230	I haven't used Gitless before but us	"I haven't used Gitless before but usually these types of abstractions fall short for me. It never helped me as much as truly learning git.I learned so much about the commands that intimidated me by playing ""Oh My Git!""[1]. It's an open source game that presents commands as quick-to-understand concepts and lets you experiment with them by using playing cards on the visual rendition of a repository. I was honestly surprised nobody else mentioned it here, maybe it's not that well known.Of course it's not completely accurate all the time in its descriptions but it sure helps understanding the underlying workings a bit more, and it pushed me into actually reading the manual.[1] https://ohmygit.org/"	taink	8.554903	-6.491838	comment	5.0	28.0	1687022445	-11.900816
29672199	That’s horrible because the git comm	That’s horrible because the git commit messages are easily lost, disconnected or hard to find in any reasonably active codebase. For example as soon as you do a change and move a file it almost always disconnects from the previous change history.Whats even more difficult is searching through a code base when the documentation isn’t in or near the code. I don’t know any IDE or editor that makes it easy to search though git commit message and source code at the same time.On top of that, do you review git commit message in code review? Do you aks people to improve descriptions, typos and language in commit messages?	interactivecode	8.579173	-6.5188513	comment	5.0	23.0	1640340018	-11.888425
29672845	Yep. I make a commit on every little	Yep. I make a commit on every little change and every team I've been on makes me squash them on merge.Comments in Git commits are bad. Just comment the code and make sure the comments are updated while you're in the code. You can also look at them in a code review. The argument that they get outdated is easily remedied, but people just want to keep claiming they write 'self documented code.'	zerocount	8.584975	-6.5438747	comment	5.0	17.0	1640346620	-11.949944
34194595	> There is also the risk (which cann	> There is also the risk (which cannot really be made to go away) that the longer hashes used with SHA-256 may break tools developed outside of the Git projectEasy fix if that is really an issue, just truncate sha-256. The length of the hash is not the issue that needs fixing (even if its a nice side benefit).> that is only the first step in the development of a successful attack. Finding a collision of any type is hard; finding one that is still working code, that has the functionality the attacker is after, and that looks reasonable to both humans and compilers is quite a bit harder — if it is possible at all.I mean, if you have any sort of binary files in your repo, that's pretty doubtful.The way you mostly do this, is the colliding part is a short binary blob which is embedded, and the	bawolff	8.669165	-6.518788	comment	5.0	29.0	1672474078	7.1413097
34195008	It's not an issue to use SHA-1 for g	It's not an issue to use SHA-1 for git. Heck they could have used md5 and it still would have achieved the same. The use of SHA-1 in Git is not for security purposes, it's for accidental data corruption and uniqueness purposes as you're guaranteed to never accidentally get a collision.	mlindner	8.683114	-6.5334544	comment	5.0	46.0	1672479940	7.2101326
34230679	Anyone use Git for writing projects?	Anyone use Git for writing projects?	auctoritas	8.5644655	-6.4843087	story	5.0	1.0	1672749742	-11.889501
34302029	I would like a ui that can show me w	I would like a ui that can show me what conflicts are about to happen before I do a merge or rebase. Trying to resolve a conflict after it's already happened is much harder then if I knew what files and lines are about to blow up on me. Even better start warning me about which files I've been editing are going to conflict with origin once I eventually have to sync up	seanalltogether	8.696432	-6.499461	comment	5.0	17.0	1673204927	-11.860349
34302097	Mercurial has been around for approx	"Mercurial has been around for approximately the same length of time, and from a UX perspective, I find it to be much superior to Git, which was largely built in terms of ""what is the easiest way to solve this problem from an implementation perspective"", rather from the user's standpoint.Of course, Git won for a reason, but I doubt that it wouldn't have still won had it incorporated some UX design ideas from Mercurial or elsewhere.> I have loved working with Git since it was created and I still enjoy working with it every day.I have been profoundly frustrated by working with Git every day, hence the article, and the linked set of tools which I wrote to improve my workflow. Not even because its mental model is hard to grasp or that the UI is poor, but because it doesn't even streamline the k"	arxanas	8.513866	-6.5515475	comment	5.0	29.0	1673205382	-11.931897
34302196	> Of course, Git won for a reason1. 	"> Of course, Git won for a reason1. Linus Torvalds wrote it2. GitHub3. Linus Torvalds wrote itTo be fair, there are some real differences; e.g. there is no easy ""hg rebase"" by design, and whether that's a good or bad thing has been a topic of contention for about 15 years. But that Linus wrote it gave it a huge boost, and GitHub really was much better than many things that came before it (and arguably, still is)."	Beltalowda	8.534481	-6.450911	comment	5.0	21.0	1673205963	-11.886219
34302445	I'm a fan of just having my $HOME as	"I'm a fan of just having my $HOME as a plain git repo with ""*"" in ~/.gitignore. Having to force add new files is a minor chore but one I'm more than happy to live with."	g0xA52A2A	8.622616	-6.465206	comment	5.0	18.0	1673207708	-11.850194
34302634	> since the commit chain can be clea	> since the commit chain can be cleaned up later.This seems to be one of the major divisions in SCM users, some see it as a clean up for seeing a understandable 'history', others see it as a falsification.	rileymat2	8.588385	-6.5503497	comment	5.0	39.0	1673209062	-11.899546
34447060	For me the point of this demo is tha	"For me the point of this demo is that even a good commit message is often redundant information.As programmers we learn that adding a comment like:   // The limit is 16

to    const SOME_LIMIT = 16

is bad because is redundant information that serves no purpose to the reader and can easily misalign in the future.So what's a good commit message for changing this limit? Ideally we want to describe why we've changed it but this information isn't always available so even when we're avoiding redundant comments we often use redundant commit messages like ""increased SOME_LIMIT"" to make browsing through history easier for others.As we do not need to provide this information (it is already in the code), it seems like a reasonable idea for an AI to help us provide it."	tomtomtom777	8.58019	-6.5282707	comment	5.0	21.0	1674170533	-11.913608
34460392	I remember when they added Subversio	"I remember when they added Subversion support; I thought it was hilarious. And it worked!This quote from the linked blog post made me raise my eyebrows though:> In 2010…it was not yet clear that distributed version control would eventually take over, and even less clear that Git would be the dominant system.I think it was actually extremely clear that Git would win. It had a guaranteed audience by virtue of hosting the Linux kernel. And forget even about its distributed nature; Git was already better at the centralized model than ""centralized-only"" version control systems ever were.When Subversion came out I was overjoyed; finally someone had fixed most of the broken things about CVS. I jumped on it with gusto. But when Git came out it was so much better than SVN that I was blown away. And"	neallindsay	8.597225	-6.461431	comment	5.0	22.0	1674251068	-11.865072
34481324	> I believe the core issue is devs l	> I believe the core issue is devs like above never take the time to “grok” Git.The problem I have with git us that it's just too complicated. When I'm juggling project complexities and design complexities and implementation complexities, I frequently don't want to have to deal with git too.I understand how to stage and check in and squash, and branch and merge, and how to manage remotes. But last week I still managed to get a new repo into a state where I couldn't push local changes to github without doing a pull first, and I couldn't do a pull without (apparently) first updating the remote. I had a hard deadline and ended up deleting the repo and starting fresh. Nothing much was lost. I never had this trouble with tfs...Maybe I'm just not clever enough, but I've never come across a dev t	andyjohnson0	8.557885	-6.4598756	comment	5.0	60.0	1674415627	-11.906866
34592365	Can you give some examples of good c	Can you give some examples of good commit messages?	fatfox	8.585872	-6.534399	comment	5.0	20.0	1675150390	-11.922066
34602520	The single, killer feature I'm looki	The single, killer feature I'm looking for in a document management system (besides collaborative environment that we're used to from gdocs) is a way to stamp versions and have those be reviewed independently, with git like diffs across them.Think gerrit for docs.	frostysocks	8.687546	-6.455066	comment	5.0	17.0	1675200825	-11.816702
34660651	I thought this was interesting, anyo	"I thought this was interesting, anyone using this?  Is the juice worth the squeeze?Full title:
Conventional Commits
A specification for adding human and machine readable meaning to commit messages"	nikolasavic	8.586383	-6.5336328	comment	5.0	16.0	1675560913	-11.90271
34673583	Ask HN: How would you redesign git?	Ask HN: How would you redesign git?	tashmahalic	8.550369	-6.487615	story	5.0	4.0	1675659980	-11.907135
34737002	they don't see any issue with long l	they don't see any issue with long lived branchesProbably because for most teams there isn't an issue. You only start to see the problems long term branches cause when you have multiple long-term branches in a single repo, and that only happens when your team is sufficiently big to be working on several big things at once or when your product is big enough to use a monorepo where devs on different teams work on the same parts at the same time.If you're Google or Meta these are very obvious problems that you'll see causing issues regularly. If you're a team of 6 in a corporation or a SaaS then you'll be able to work on a branch for weeks and still be able to merge it without any big problems.This is my main issue with TBD actually - it's a solution to a problem that few teams actually have.	onion2k	8.6138115	-6.5330195	comment	5.0	17.0	1676016960	-11.856655
34737942	"It's rather funny.""Trunk-based devel"	"It's rather funny.""Trunk-based development"" is essentially counter-marketing to Gitflow. Before Gitflow, trunk-based development was so routine it didn't need a proper name or website.Gitflow has the ""interesting"" properties of being more complex than release-ready trunk-based setups, while (in most contexts) decreasing quality, and delivery speed.Unfortunately, Gitflow is very appealing to mediocre managers who want to point to a website and some pretty pictures and say ""we do that"" (thus, alleviating themselves of any actual engineering or contextual thinking). So the counter-marketing is helpful, but it feels rather ridiculous how the software world is so susceptible to these trends.It reminds me of the Alan Kay quote, ""programming is a pop culture."""	agentjj	8.632452	-6.5552936	comment	5.0	40.0	1676025338	3.213261
39370604	The same tool you use for merging co	The same tool you use for merging code, with the same ownership & maintainer model. In our case, that's git, and our docs live in markdown files in a docs/ folder.	coldpie	8.654205	-6.4996862	comment	5.0	22.0	1707923262	-11.760469
39452748	I seem to recall very positive comme	I seem to recall very positive comments regarding pijul's underlying architecture/theory.  However, as I don't have the headspace to delve into it, I would love a blurb at the beginner level that highlights the benefits of using pijul compared to other VCS, and a very brief and simple comparison between pijul and git (focusing on the differences).	ykonstant	8.592284	-6.556712	comment	5.0	71.0	1708516636	13.891246
39595845	I've been where OP is. For me it's b	I've been where OP is. For me it's because, for whatever reason, I don't want to commit my shitty in progress work right now to go work on this interrupt. And if I stash it, I will likely forget I did that, and waste time looking for it again.Worktrees are a different way of managing multiple branches in flight. They're not hard to use, and using them doesn't imply any incompetency with git. They are likely being used to cope with another kind of problem.	tomjakubowski	8.584437	-6.5202646	comment	5.0	23.0	1709585299	-11.889418
39596742	The thing that annoys me about workt	The thing that annoys me about worktrees is that you can't have two checked out to the same commit at the same time [0], which can be inconvenient when I forget about one that I had open a few days ago. This also breaks the feeling of isolation, since the issue doesn't exist if I do a fresh `git clone` to another directory, so it begs the question of what fragility is present in worktrees that isn't in a fresh clone.In other words, I wouldn't feel safe doing weird Git operations in a worktree, so why use one in the first place? If I want a true throwaway repo, I'll just re-clone in another directory (and make sure to remove the remote, to be extra safe in case I accidentally push).Also, git worktree requires me to make a new directory anyway! So why would I not just put a fresh clone in th	chatmasta	8.586142	-6.521856	comment	5.0	18.0	1709589717	-11.922562
39667109	The biggest quality of life improvem	The biggest quality of life improvement for me with git is a bash function I wrote that does add all, commit and push in one. Turns out I don’t care about all the granular control it provides 99% of the time, it’s cumbersome:$ save This is a commit message no quotes	user3939382	8.579088	-6.521174	comment	5.0	33.0	1710158864	-11.871987
38830597	> When fixing a bug, add a failing t	> When fixing a bug, add a failing test first, as a separate commit. That way it becomes easy to verify for anyone that the test indeed fails without the follow up fix.I would genuinely like to know in what world this is useful advice. Maybe in personal projects or small teams or companies with a maniacal lead?I just can’t imagine someone in a sufficiently large organization (which most companies hope to be someday) goes sifting through feature commits to get to the bottom of a failing test.	dclowd9901	8.728754	-6.497204	comment	5.0	20.0	1704100339	-11.897764
38830669	> Second, not every change needs a g	> Second, not every change needs a great commit message. If a change is really minor, I would say minor is an okay commit message!I want to slightly disagree on this for folks who are early on in career e.g me; I think there is a lot of value in learning to communicate precisely and having a habit of writing good commit message has certainly improved my skills, both verbal and written.Even though, this activity appears futile for a minor change; it might help to improve other skills :)	mfrw	8.581121	-6.5313935	comment	5.0	30.0	1704101374	-11.91323
38831270	> Second, not every change needs a g	> Second, not every change needs a great commit message. If a change is really minor, I would say minor is an okay commit message!It's very hard to rank them, but very high on my list of things that make me want to send people actionable threats is when I'm searching down the history of a bug to figure out if it was a deliberate change that had unexpected consequences or just a mistake is when the git blame path ends on a commit like this.I don't care how minor you think your change is, if you're working on something collaboratively you need to express intent in your commit messages!	lexicality	8.582656	-6.531212	comment	5.0	21.0	1704110592	-11.903738
38835128	I used to use Mercurial as well and 	I used to use Mercurial as well and greatly preferred it, but for better or worse, Git won. I started using Git several years ago and haven't looked back.No matter what people might say, I think this stuff matters for contributors and users who might be looking at your project, and git/github is the typical expectation. This is likely the right decision, as they are now ubiquitous.	nu11ptr	8.525872	-6.541747	comment	5.0	18.0	1704141433	-11.928431
38844306	What's the convenient lie taught abo	What's the convenient lie taught about branches?The standard concept that I remember is 'a branch is a pointer to a commit', which still feels accurate	david_allison	8.586713	-6.5482597	comment	5.0	21.0	1704216795	-11.882687
38888969	Reading through this and then thinki	"Reading through this and then thinking about rebases in particular.... I think whoever comes up with a good mechanical explanation of rebasing deserves a prize. I just imagine it as ""it figures out diffs and then tries to apply them over at another place"" but this runs up against reality way too often."	rtpg	8.58173	-6.5666065	comment	5.0	24.0	1704521990	9.459719
32519863	I think most of these need to be up-	I think most of these need to be up-leveled to being open ended like “tell me about your development process” or “describe my role in the organization”. Even then differing questions will be asked to various interviewers either with you guiding the conversation or asking in Q&A at the end. I mean, is your entire decision going to be made on GIT being used?	sys_64738	8.54803	-6.4821744	comment	5.0	17.0	1660909874	-11.885658
32535264	It's somewhat comforting to hear eve	It's somewhat comforting to hear even Brian K. say he doesn't understand Git well.	stakkur	8.533736	-6.476363	comment	5.0	22.0	1661030817	-11.900698
15753966	can someone explain succinctly what 	can someone explain succinctly what they like about fossil over git? I found a few overall articles but a nice HN comment would also help if anyone is game. Are there certain types of projects where it just works better for you than git?	grogenaut	8.500854	-6.5324097	comment	5.0	22.0	1511320825	-11.967801
15903208	I've just never found a reason to mo	I've just never found a reason to move on from SVN, to be honest.I use GIT when I am forced to, but for everything under my control, SVN works the best.I was unaware you could get rid of the staging area in GIT. I may need to look more into that.	bluetwo	8.576476	-6.4768834	comment	5.0	20.0	1513056470	-11.878647
15903421	Partial commits through piecemeal st	Partial commits through piecemeal staging is great as a poweruser's tool, like rebase.  But it's beyond weird that anyone thought it was a good idea to make people deal with staging for every commit.It doesn't even have to go away.  (And on that note, I'm bummed that the conclusion in the article is to do that, especially because everytime this comes up, there's an uproar.)  But, jeez.  Just tuck it away so futzing with it is an opt-in decision for the 5% of the time that you need to make sure you aren't committing all of your changes.  (And on note #2, if a person is doing partially staged changes more often than that, my question is why?  What kind of chaotic, stream-of-consciousness style of development leads to that, and is it even producing good results?  It doesn't take especially ca	carussell	8.649559	-6.56963	comment	5.0	27.0	1513060194	-11.931285
15952321	I think git provides a sane level of	"I think git provides a sane level of abstraction.I don't think it provides the most consistent UI or helpful help, though.  Once you move away from ""learning git commands"" to ""learning how git works"" and kind of figuring out which parts the commands refer to has helped also. That's still terrible though."	jimktrains2	8.550547	-6.495446	comment	5.0	21.0	1513611700	-11.903547
15952654	> I think anyone who uses the CLI is	> I think anyone who uses the CLI is either trying too hard or hasn't realized the beauty of a git GUI.Or, you know, understands and thinks in the semantics of the underlying tool and is already working in other text-based tools.	aschampion	8.58554	-6.4928484	comment	5.0	19.0	1513613782	-11.846985
15953107	It's not anything inherent to a visu	"It's not anything inherent to a visual UI though, it's just that most of the UIs that exist are trying to put their own model on top of git, rather than embracing git's model.The one exception to this I've found is GitUp (mac only, sadly), and it's excellent. It's whole model is, ""what operations can I perform on this graph,"" which is exactly the model git has. It's great."	dilap	8.522296	-6.4674687	comment	5.0	46.0	1513616574	-11.911518
15953554	I think you've put your finger on th	I think you've put your finger on the schism of why so many git users prefer a GUI.  The built-in porcelain is stupidly inconsistent and confusing.  And yet, git's underlying model is so simple and powerful that I think it's worth suffering the bad CLI just to be more fluent and able to utilize git's power fully.  The model itself is very easy to grok, it just takes some time to memorize the various random incantations and occasionally look something up, but I don't consider that a big deal for a core tool I use every day.	dasil003	8.570486	-6.4901385	comment	5.0	31.0	1513619343	-11.887869
16516308	For those who haven't looked at some	"For those who haven't looked at some of the commits by @pixiuPL, the list is here : https://github.com/ariya/phantomjs/commits?author=pixiuPL.To summarize: It does not look like the guy has done a single commit with any meaning. His commits are basically the following:1. Adding his own name in package.json 
2. Adding and deleting whitespace. 
3. Deleting the entire project and commiting. 
4. Adding the entire project back again and commiting.Just out of curiosity: How likely is that someone may be able to use a large number of such non functional commits(adding and removing whitespace) to a popular open source repository to boost their career ambitions.(e,g. Claiming that they made 50 commits to a popular project might sound impressive in an interview.)"	enitihas	8.578134	-6.4613705	comment	5.0	17.0	1520193376	-11.88383
16518759	A Hidden Git Feature: Notes	A Hidden Git Feature: Notes	sonicrocketman	8.5583105	-6.4461484	story	5.0	35.0	1520224709	-11.819314
16689591	Git Tower v3 beta: interactive rebas	Git Tower v3 beta: interactive rebase, reflog, PRs, more	tnorthcutt	8.57203	-6.563333	story	5.0	13.0	1522165487	-11.760603
16806283	"""The mental model for Git is needles"	"""The mental model for Git is needlessly complex and consequently distracts attention from software under development. A user of Git needs to keep all of the following in mind:    The working directory
    The ""index"" or staging area
    The local head
    The local copy of the remote head
    The actual remote head 

Git contains commands (or options on commands) for moving and comparing content between all of these locations.In contrast, Fossil users only need to think about their working directory and the check-in they are working on. That is 60% less distraction.""I don't think about any of this when developing. I check out a branch, work on it, commit to it, and push it back up. If the fix is larger than a few commits i'll make a feature branch. What's so hard about that?Also, everyone "	vangar	8.516763	-6.467794	comment	5.0	44.0	1523400275	-11.928863
16806372	I haven't used Fossil, but just a co	"I haven't used Fossil, but just a comment on some of that page, in the order they're presented:1. It's unclear to me what he means. Yes git doesn't store anything like a doubly linked list of commits, and thus finding the ""next"" commit is more expensive, but you can do this with 'git log --reverse <commit>..', and it's really snappy on sqlite.git.It's much slower on larger repositories, but git could relatively easily grow the ability to maintain such a reverse index on the side to speed this up.2. Yeah a lot of the index etc. is complex, but I wonder how something like ""git add -p"" works in Fossil. I assume not at all. Is there a way to incrementally ""stage"" merge conflicts? Much of that complexity comes with significant advantages.3. This is complaining about two unrelated things. One is"	avar	8.506843	-6.560387	comment	5.0	65.0	1523400889	-11.945496
16806454	Everybody uses git because it's the 	Everybody uses git because it's the most sane and powerful source control tool there is.	kadenshep	8.558484	-6.4428434	comment	5.0	77.0	1523401576	-11.867818
16806588	I've built two source management sys	"I've built two source management systems (NSElite, internal to Sun, and bitkeeper, now open source at bitkeeper.org).Calling Git sane just makes it clear that you haven't used a sane source management system.Git has no file object, it versions the repo, not files.  There is one graph for all files, the repo graph.  So the common ancester for a 3 way diff is the repo GCA, which could very well be miles away from the file GCA if you have a graph per file (like BitKeeper does).No file object means no create event recorded, no rename event recorded, no delete event recorded.  If you ask for the diffs on ""src/foo.c"" all Git can do is look at each commit and see if ""src/foo.c"" was modified in that commit.  That's insanely slow in a big repo.  And it completely ignores the fact that src/foo.c got"	luckydude	8.6386	-6.5057917	comment	5.0	63.0	1523402551	-11.851987
16807587	I am not a git expert or anything, b	I am not a git expert or anything, but I have helped resolve weird git issues for my teammates usually using a lot of Google and StackOverflow.I just know 5 basic commands; pull, push, commit, branch, and merge. Never ran into any issues. People who run into issues are usually editing git log or doing something fancy with “advanced” commands. I have a feeling that these people get into trouble with git cause they issue commands without  really knowing what those commands do or even what they want to achieve.	amerkhalid	8.549253	-6.489949	comment	5.0	55.0	1523413925	-11.915039
16807758	“rebase” is just “pull before push”,	“rebase” is just “pull before push”, right?While I have no opinion on git, I can’t abide by all the precious chaotic mutant misuse, like git-flow.I’d happily accept a subset of primitives, if only to disallow bad ideas. Kinda like Git vs SVN, C/C++ vs Java, flamethrower vs peanut butter.	specialist	8.554214	-6.5839276	comment	5.0	29.0	1523416631	9.34645
16807953	merge is what civilized people who c	merge is what civilized people who care about getting history and context in their repository use ;)  ... I worked a lot in git using both rebase and merge workflows and I'll be darned if I understand the fear of the merge commit ... If work happened in parallel, which it often does, we have a way of capturing that so we can see things in a logical order ...	YZF	8.589781	-6.5475736	comment	5.0	16.0	1523419636	-11.922106
21027947	I really dislike the term chosen for	I really dislike the term chosen for this feature. “Blame”, assumes the code is broken or written improperly in some way. Most of the time I use it I’m just trying to find out who wrote it so I can find the original commit to understand it in more context.Should have named it “git who”	eljimmy	8.557334	-6.4883456	comment	5.0	17.0	1568994210	-11.893632
21309810	What are the best practices for exte	What are the best practices for extending git? Every example seems to be a shells script that calls out to git; is there a better approach?	ridiculous_fish	8.567527	-6.469034	comment	5.0	16.0	1571639910	-11.893122
21339568	Git is awesome.But it's terminology 	Git is awesome.But it's terminology is really confusing.But yeah some layer of abstraction would be handy.I always think of introducing it to my wife when she looses a document or something but god damn the terminology.	duxup	8.545348	-6.47044	comment	5.0	21.0	1571868438	-11.894301
21394366	It's not. hg users generally don't u	It's not. hg users generally don't understand that git is doing something fundamentally different from hg. git adds a 3rd dimension to your file system. dimension 1 = files, dimension 2 = directories, dimension 3 = branch. That git adds this 3rd dimension makes it useful for version control but that's effectively a side effect. hg on the other hand is specifically about version control so it does not handle adding this 3rd dimension well. This is why for example things like gh-pages on github where there's a branch that has absolutely nothing to do with any other branch and no shared history is a normal thing to do in git (because a branch is another dimension to the file system, not a version control construct).That difference, adding branches as a 3rd dimension, is why git is more powerf	greggman2	8.536413	-6.5293546	comment	5.0	16.0	1572405176	-11.96477
21418363	I think it's kind of weird that they	I think it's kind of weird that they left out any mention of BitKeeper in this article.The whole impetus for git (someone correct me if I'm wrong):1. Linux source was hosted on BitKeeper before git. It basically was one of the first distributed source control systems (or the first? not sure if anything predated it).2. Linux devs got into conflict with the BitKeeper owner over open-sourcing and reverse engineering, so Linus realized they needed a new system because no other source control system had the features they needed like BitKeeper had (mainly, I understand, the distributed repos).So basically, Linux is to Unix like git is to BitKeeper (roughly).	hn_throwaway_99	8.585703	-6.437382	comment	5.0	34.0	1572614106	10.08722
21420334	No. Git did not prove that Linus cou	No. Git did not prove that Linus could more more than a one-hit wonder. It proved halo effect is real.Mercurial had a better interface and early on was equal or better (as far as I know) for most things. Everyone went with Git because Linus made it. I think it also might have been faster for huge code bases... but that pretty much only affects the kernel team and a handful of others. Your standard CRUD app could easily use a slower VCS without noticing.Instead of going on merits, everyone just followed Linus. Which is what always happens in technology communities. Everyone just does whatever some guy at the front is doing.	jw14	8.564608	-6.4758625	comment	5.0	24.0	1572624626	-11.918593
21581420	Git. It has few commands and can be 	Git. It has few commands and can be rapidly learned in one hour, mastering commands such asGit fetchGit pullGit commitGit pushGit mergeGit log	mister_hn	8.59896	-6.507864	comment	5.0	17.0	1574229376	-11.867084
21669557	> In fact, I'm sure that you're lyin	> In fact, I'm sure that you're lying too: every time you Ctrl+Z in between commits, you're removing parts of your audit log. Choosing when to commit is telling a story.And I disagree here. The way I view it, my editor is my sandbox, I keep playing in it until I have something that I want to enter into record. When I commit work, I enter it into record, with a commit message explaining what the piece of work is.But to be honest, my repo clone is sort of my own sandbox too, I don't consider Git a fully append-only log, so I'd sometimes do commit editing on my local repo. But once published, I consider it immutable.(Or rather I'd prefer to; the team in the main project I'm working on right now has a rebase-heavy workflow.)On a practical note, I'm fine with history cleanup done on the spot. E	TeMPOraL	8.576329	-6.548725	comment	5.0	16.0	1575113985	-11.913567
21679051	> The scenario we want to avoid is t	"> The scenario we want to avoid is that a faulty commit makes it to the main branch.Close. The scenario we want to minimize is faulty code on the main branch. As your team grows, as the number of commits go up, it becomes a game of chance. Sooner or later something will get through. The more new teammates you have, the more often that will happens.This is an inescapable cost of growth.  The cost of promoting people to management. The cost of starting new projects. Occasionally you can avoid it as a cost of turnover, but you will have turnover at some point.What matters most is how long the code is ""broken"" (including false positives) before it is identified, mitigated, and fully corrected.  The amount of work you can do to keep these number relatively stable in the face of change is profou"	hinkley	8.604975	-6.527908	comment	5.0	36.0	1575248469	-11.90668
21755090	Git from the Inside Out (2015)	Git from the Inside Out (2015)	dpeck	8.538247	-6.46423	story	5.0	195.0	1576001766	-11.894784
39077289	I feel like CI to master with pull/m	I feel like CI to master with pull/merge requests in very short lived feature branches works really well, even better than when everyone tried to merge their in progress work to master. Though, both are certainly better than when you’d work on a release branch for 3 months, try to keep it in sync with master and a few hotfix branches, and then merge it all at once at the end. That was a total nightmare, and was actually really common.	j4yav	8.652956	-6.5388265	comment	5.0	22.0	1705833322	-11.883938
39081053	I'm confused by this. I've never wor	"I'm confused by this. I've never worked in an organization where ""commit directly to main"" would get you anything but in a ton of trouble.Is that a normal/common practice for anyone here?"	ivraatiems	8.589315	-6.5310926	comment	5.0	29.0	1705861156	-11.927512
39081132	Super common. I’m not sure how that’	Super common. I’m not sure how that’s any different than teams who create a PR, beg someone to review it, they glance it for 3 sounds and leave a “LGTM!” approval so you can finally merge to main.Same result, whole lot less performative bullshit.We use branches and reviews for large changes. Small scope changes go directly to main. If it breaks, we rollback and tell that person to stop breaking things.	hipadev23	8.653211	-6.4517436	comment	5.0	17.0	1705861470	-2.8388486
39084271	Wait so no develop branch? The utili	Wait so no develop branch? The utility gained by having “what’s in production” and “what we’re working on” as separated feels hard to part with.	redcobra762	8.615261	-6.54216	comment	5.0	27.0	1705880804	-11.831896
39088958	Even a force push doesn't destroy th	Even a force push doesn't destroy the reflog or runs the GC server-side. I wonder how you can accidentally loose data with Git. I've seen lot's of people not being able to find it, but really destroying it is hard.	funcDropShadow	8.561458	-6.5178647	comment	5.0	66.0	1705927992	-11.905346
39089239	It's about time someone revisited & 	"It's about time someone revisited & reimagined version control.  the previous generations each lasted about 15 years: SCCS/RCS -> CVS -> Bitbucket/git/mercurial -> ??? so I am glad to see this.I would start by talking about what is great about Diversion -- what it lets you do that you couldn't before.Since you mention gaming and perforce I looked in vain to see if it supports binaries (a major limitation of git -- just simply not in its design space).  ""Binaries"" can actually mean for some people compiled code -- not for me but I understand why people do it -- as well as images, data files, Word files etc.Sounds like the second is scaling but you don't say what you mean by that.  Git scales pretty well until either the repo & its history gets enormous or when there are a lot of people maki"	gumby	8.558548	-6.4512825	comment	5.0	25.0	1705929779	-11.86913
39091360	The world needs a git alternative. A	The world needs a git alternative. Anyone who has used mercurial at Google or Facebook knows the tooling could be much better.As soon as you have 2-3 people committing to the same repo daily, git falls apart fast. The biggest difficulties with git are merging and branch rebasing. If git could do rebases better, I would suspect software development teams to universally move about 20% faster.	calderwoodra	8.529492	-6.496963	comment	5.0	17.0	1705940953	-11.911859
39139954	Git information is extremely useful 	Git information is extremely useful to me. I notice colleagues who don't have that tend to struggle using git on the command line and use git status nearly every other command (much as I tend to do when I'm remoting into a shell with a plain prompt).Python venvs are useful too if you have a shell for running the program and other shells that just happen to be within that directory.	adhesive_wombat	8.55555	-6.477433	comment	5.0	20.0	1706256218	-11.878832
39311893	I've been seriously considering usin	"I've been seriously considering using Git for all sorts of oft-changing-but-rarely-majorly data. Lists of books in my bookshelves.The other problem is that I sorta want transactional-database features on top of these things. Git does this well. I also want fast indexing on parts. Git does not do this well. I am considering writing a ""standard"" for the dumping of sqlite to git, so that I can just delegate this out; Any transaction can be expressed as a git commit, and I can run both at once for both the durability and the reasonable indexing; The sqlite database can be re-created and reindexed whenever, and it also sorta works for backups...Definitely just spinning my wheels, though. We'll see where databases take us next."	GauntletWizard	8.5957155	-6.5035696	comment	5.0	21.0	1707458643	-11.869951
18008966	I've recently started using Fossil[0	I've recently started using Fossil[0] to archive all my personal data. It works rather brilliantly. Technically you can use any VCS but Fossil is unique in that the entire repo is a single SQLite db, so it's very easy to backup and restore. Not to mention the web UI to have a quick glance before checking out any files. Even better I can sync flawlessly between multiple hard drives and computers. I've a few separate branches for Docs/Photos etc. I checkout the related branch and just add more files whenever needed. After files are added to the repo, I just remove the working copy. There are some limitations though like files larger than 2GB aren't supported.[0] - https://www.fossil-scm.org/	rwbt	8.582091	-6.502066	comment	5.0	15.0	1537211150	-11.928318
18030004	Speaking as someone who used both Gi	Speaking as someone who used both Git and Mercurial, and who has used both to contribute to projects:Git's concept of branches as simple names for commits, and the ability to switch branches really easily within one checkout (rather than encouraging the use of multiple working directories) helped hugely. Mercurial grew the ability to do git-style branching later, but git had it from the beginning.Git has always treated performance as a first-class feature, and that has enabled certain types of workflows that Mercurial makes painful. Git is fast enough that many things don't feel like they take any time at all.Git integrated first-class support for carefully constructing and reworking a set of patches to be sent by email. Mercurial again eventually grew such support, but early on, it was mu	JoshTriplett	8.519744	-6.5554695	comment	5.0	28.0	1537421596	-11.942667
18030321	"For a strong contender to ""next-gen "	"For a strong contender to ""next-gen DVCS"", I recommend checking out https://pijul.org/.Written in Rust and based on a sound theory of patches. If GitLab actually merges Mercurial, I sincerely hope Pijul is next."	erlend_sh	8.55798	-6.5253386	comment	5.0	32.0	1537426975	-11.991655
18030950	Pijul looks very interesting but unf	Pijul looks very interesting but unfortunately as it stands (and without a huge open source project à la Linux to back it) I can't really imagine it taking over git as it stands. It might be better than git but is it enough an improvement to justify the cost of switching? I'm not sure.Now if pijul takes inspiration from Fossil and implements things like issue tracking as part of the DCVS then that would be an other story as far as I'm concerned. That would be a pretty radical upgrade from git.	simias	8.5851145	-6.548014	comment	5.0	17.0	1537436501	13.88541
18137501	> How do you git bisect a codebase w	> How do you git bisect a codebase where every 6th commit doesn’t build because it was jammed into the middle of a Pull Request?This I think is the main problem with pull requests. A better default would be squashing the commits into a single one after review.	petters	8.57927	-6.531062	comment	5.0	25.0	1538632348	-11.885264
18171554	"If you want to go the mentioned ""rew"	"If you want to go the mentioned ""rewrite-whole-history"" route, I have used BFG Repo Cleaner [0] successfully in the past. It's way faster than git-filter-branch [1].Another thing: You can work with shallow clones. If the commit is ancient, no need to pull the whole history of a project.[0]: https://rtyley.github.io/bfg-repo-cleaner/[1]: https://git-scm.com/docs/git-filter-branch"	leipert	8.568401	-6.5227056	comment	5.0	15.0	1539034749	-0.8085783
18205798	Show HN: FaaStRuby 0.2 released – fe	Show HN: FaaStRuby 0.2 released – feedback appreciated	parruda	8.511379	-6.4387813	story	5.0	25.0	1539392853	-11.912818
18227307	I'm really bad at rebase, but doesn'	I'm really bad at rebase, but doesn't rebasing a branch A onto branch B, remove all the history from A?	wodenokoto	8.577738	-6.567368	comment	5.0	19.0	1539674082	-11.912699
18310304	> To understand Git's design philoso	> To understand Git's design philosophy better it is helpful to understand the circumstances in which the Git project was started in the Linux Kernel Community.I don't understand this sentiment. It's not helpful to know the history at all. At best, it romanticize the choices made. Stating the goals would be an intro that shows some level of analysis.	ArchTypical	8.554917	-6.4476223	comment	5.0	23.0	1540568694	-11.899118
18374120	How you can go wrong with Git	How you can go wrong with Git	adityasridhar	8.553743	-6.4831195	story	5.0	12.0	1541303938	-11.903973
18394798	> TabNine builds an index of your pr	> TabNine builds an index of your project, reading your .gitignore so that only source files are included.Heads up, it's not necessarily uncommon for JS developers to include node_modules in their git repos. If you're developing something like an Electron project or a website instead of a library, it's even sometimes advised to do so -- there's a line of thought that your static dependencies should be tracked as part of your source control.It might not be a terrible idea to have an alternate config for this that allows excluding other directories. Even if a developer doesn't include their dependencies, they might have old code that they don't want integrated into their suggestions if they're in the middle of a refactor or something.	danShumway	8.722433	-6.4925613	comment	5.0	25.0	1541537568	-11.780532
18429135	A Git Horror Story: Repository Integ	A Git Horror Story: Repository Integrity with Signed Commits (2012)	pmoriarty	8.584096	-6.459283	story	5.0	89.0	1541976004	-11.820663
18513589	I could never understand the complai	"I could never understand the complaint that Git is ""hard to use"".  Having used a plethora of version control systems over many years, I never found Git to significantly more or less complicated than any other system.  Version management includes many use cases, some of which are inherently complex.  Therefore any version control tool must be able to perform both simple and complex tasks, and the latter ones will obviously require a more complicated syntax and conceptual model.In any case, we are supposed to be professionals.  Complaining that Git is hard to use is a bit like a machinist complaining that a CNC machine is hard to use.  If you want to accomplish non-trivial things in any field, you have to be prepared to deal with some level of complexity.  /rant"	deepspace	8.535643	-6.507581	comment	5.0	25.0	1542934035	-11.901139
18514228	Don't partial commits run the big ri	Don't partial commits run the big risk of commiting code that may not work, since the partial commit on your own computer will be tested against your working tree, wheras after it's committed it run with a different view of the files?	joppy	8.594151	-6.5466366	comment	5.0	15.0	1542945130	-11.938004
18664105	So tell me, this is readable for you	So tell me, this is readable for you?https://imgur.com/GCWsFwUAnd I'm not cherry-picking... I usually see much, much worse git logs than this from merge-commit users. In fact, if I scroll down, this is what it looks like:https://imgur.com/a/nQXWa4QEdit: For a point of comparison, here's one of my projects using atomic commits and rebases:https://imgur.com/a/vTZ5qxT	scrollaway	8.579069	-6.5457006	comment	5.0	26.0	1544624737	-11.891304
18773932	> As a novice programmer, I was abso	"> As a novice programmer, I was absolutely stunned that this was not standard practice.I agree with your point, and I will be benefit from this style if it were the standard, too.  But don't you think a good community culture can make people maintain a good git history for this purpose?My daily job is a Linux kernel developer.  I found that source codes are only the ""What"" part, git comments can and should state the ""How/Why"" part, and if all those still make no sense to me, I look for the original mailing list for the deeper ""Why"".  Most of the time the information is sufficient."	qlk1123	8.581451	-6.497972	comment	5.0	20.0	1545957431	-11.898728
18898675	Since I'm working in git repos the m	"Since I'm working in git repos the majority of the time, I type these hundreds of times per day:    alias s=""git status""
    alias d=""git diff""

I prefer looking at this stuff in a terminal rather than an IDE. Reducing them to a single character just feels so good. Note: not a git alias like ""git s"", literally just the single character ""s"" in Bash itself.And coming in third:    alias ..=""cd .."""	exogen	8.602088	-6.518995	comment	5.0	23.0	1547413511	-11.844823
18919935	An honest criticism:If I had trouble	"An honest criticism:If I had trouble with understanding the reason behind add->commit->push workflow, I would definitely have no idea what this article talks about when it says things like ""merge, rebase, diamond shape"". The flow chart looks almost exactly the same for ""pull"" and ""pull --rebase"". The only difference between the charts is the wording which has no meaning at all for a newbie."	diegoperini	8.579536	-6.548053	comment	5.0	19.0	1547638247	-11.918733
29756927	Yeah. Git is great software, but the	Yeah. Git is great software, but there's seriously no reason I should be typing multiple CLI commands over and over again as part of my workflow in the year 2022.	ramesh31	8.583995	-6.4906554	comment	5.0	16.0	1641029366	-11.86324
29759562	Blender – Top Committers 2021	Blender – Top Committers 2021	oumua_don17	8.571089	-6.4733424	story	5.0	91.0	1641052594	-11.87528
29826783	Author here; the idea came from frus	"Author here; the idea came from frustrations with the original Python roguelike tutorial on Roguebasin. Since the entire thing was written in one file, it was difficult sometimes (for me anyway) to tell what was going on.While I'm happy with the way the diff style turned out, I will say there is one big downside for me: It's a huge pain to write. Not only did I do a ""git diff"" every time I made changes and documented it, but if you end up changing something later down the line, then I basically had to go back to the very beginning of the chapter, follow the tutorial along, and double check everything. Maybe there's a more efficient way to do this, but it was a bit tedious and time consuming.Still worth the effort in the end though, I think."	TStand90	8.686978	-6.474256	comment	5.0	17.0	1641490911	-3.9020135
29841046	About half the time I get stuck duri	About half the time I get stuck during squashing and rebasing I end up trashing everything, re-cloning the repo and just doing one commit with all my changes from the other branch. Much easier than trying to figure out what series of errors or issues git is having.Fundamentally, this is my fault - I don’t have a good mental model of git, and even when I do have a solid understanding of what I’m attempting to achieve the actual repos/situations I find myself in rarely line up with the examples to any useful degree.	AcerbicZero	8.568382	-6.5333304	comment	5.0	16.0	1641572769	-11.918823
29876350	Always check git blame before wingin	Always check git blame before winging out insults. Then, only blame people no longer at the company ;)	matwood	8.555752	-6.4828043	comment	5.0	17.0	1641828722	-11.941158
29882946	"On the topic of ""who wrote this shit"	"On the topic of ""who wrote this shit"", I'd really like to plug the idea that some of the most high-impact documentation you can write is a good commit message.Say you track down a bug, find a line of code that makes no sense, and `git blame` it, to discover that you wrote it yourself, 2 years ago. If the commit message is ""bugfix flaky builds"", good luck figuring it out.If the commit subject rather, is ""bugfix flaky builds"", followed by a message that explains what the flakiness was, why you think the change will fix it, what other bugs or limitations you were working around, and what upstream changes you might be waiting on that prevented further work, you're in a much better position. Suddenly you have a lot more context on what you were doing, why you were doing it, why you didn't do it"	Yen	8.58161	-6.512577	comment	5.0	30.0	1641850467	-11.909855
29922990	I wish this article also covered how	I wish this article also covered how google manages sql like code. In my projects I have sometimes struggled with keeping my table definitions, constraints, functions, etc in sync with the SQL in my git repo	zffr	8.632196	-6.5326405	comment	5.0	20.0	1642092460	9.840369
29979670	"""In this case, the conflicting resul"	"""In this case, the conflicting result is left in the working directory for the user to fix and commit, or to abort the merge with git merge –abort.""I've used git for many years, and I still zip the repo folder, before doing a large merge, since 'fix the commit' can be a large effort with conflicts. Quickly renaming the repo root folder, then unzipping the old version can be quicker/safer, if you are not a git ninja and don't want to loose any work. There is probably proper command for it, but I sometimes get into a git mess that I cannot get out of. (reading stack overflow, trying get reset, git checkout, git reset --hard and so on)"	erwincoumans	8.583461	-6.542696	comment	5.0	41.0	1642516384	-11.8884735
29992875	I downloaded this and tried to follo	I downloaded this and tried to follow the documentation [0]. `pijul add` doesn't accept wildcards, instead returning a pretty unhelpful error message:> λ pijul add *.*> Error: The filename, directory name, or volume label syntax is incorrect. (o error 123)The documentation for add [1] gives no information on the format, however I put 2 and 2 together and managed to do `pijul add . -r`. The next step is `pijul record` [2] which returns another error:> Error: No identity configured yet. Please use `pijul key` to create oneOk great. I ran `pijul key` [3] (which isn't documented) which returns 0, with no output. `pijul record` still says the above, so I tried `pijul key --help` which tells me I need to run a _different_ command (`pijul key generate <LOGIN>`) but doens't tell me what `login` is	maccard	8.608758	-6.5540543	comment	5.0	57.0	1642596271	13.893199
29999576	The reset part seem superfluous, mos	"The reset part seem superfluous, most of this can be handled via rebasing. In fact, this is exactly what we do at <day job>.Much like the thesis of this article, the goal is to have a set of well organized commits so that when it comes time to do a PR review, you have 1-3 logical units of change and it also improves the ability to do reverts.But you can very easily do this just by rebasing instead of resetting and re-committing.In particular, `git commit --fixup <ref>` and `git commit --squash <ref>` are extremely useful for this during the ""WIP"" stage as well as when handling PR comments, and these are things that I only learned about in the last 6 months. I would recommend doing a google search on ""fixup commits"" to learn more about them. I enjoyed this article: https://www.mikulskibarto"	dljsjr	8.578638	-6.5403633	comment	5.0	35.0	1642624240	-11.911508
30069890	Finally there is `git stash --staged	Finally there is `git stash --staged` and I can stop making temporary commits which I might forget about later and accidentially push.	clktmr	8.584179	-6.5360446	comment	5.0	41.0	1643102316	9.447733
30070605	I really want those temporary commit	"I really want those temporary commits to end up part of the finished git history, but be hidden from most views...    for example, they could be called ""sub commits"", and tools could not show them by default unless given some extra flag.   Then there could be sub-sub commits, etc to show more and more minor edits, potentially down to individual keystrokes.Throwing away the construction history of something just seems wrong in git-land.   The git format already allows this - it's just the tooling and culture that needs to be adapted for it to happen."	londons_explore	8.555279	-6.5508804	comment	5.0	25.0	1643109748	-11.900618
30070827	Just my quick listCode that relies a	"Just my quick listCode that relies alot on pointless abstractions (aka. bad ""signal to noise ratio"").Code with lots of microdependencies to perform really trivial tasks.Code with premature ""optimizations"" (usually done before actual performance measurements).Code sacrificing readability (and thus maintainability) to be overly clever or to do trivial optimizations (usually with little to no impact on overall performance).And of course all the different ways to mess up comments, style and versioning (Yes, I consider the versioning part of the code):    * Uncommented code
    * Over-Commented code
    * Comment-Banners
    * Commented-Out code (git exists for a reason)
    * Inconsistent naming
    * entirely_too_long_variable_names for things that exist for 20 LOC
    * Unhelpful commit mess"	usrbinbash	8.597603	-6.489397	comment	5.0	21.0	1643111892	-11.907492
30112894	> Never say what you ware doing (it'	> Never say what you ware doing (it's obvious this commit is updating build scripts)DEFINITELY say what you are doing. And then say why.This blog post is a good description of the most prevalent convention in how to write good and useful messages (e.g. this is what the Linux Kernel does and given the history of git there's some flow down): https://cbea.ms/git-commit/The key thing that means you should start with what is having a short one-line summary of what you're doing so you can look at a simple log and see which commit you're interested in.	rkangel	8.592433	-6.5370903	comment	5.0	29.0	1643365790	-11.904769
30227008	Let's say you are editing a source c	Let's say you are editing a source code file. You save and you run. Than you tweak, save and run again. But then you would like to go two changes in the past, but you did not make a commit. Very recent changes are not captured by backup systems, no matter how competent they are.I'd like to have all my files under git, for every save - and frictionless. I know it is a lot to ask.	choletentent	8.58187	-6.4776416	comment	5.0	15.0	1644100700	-11.865734
30275655	You're free to name a Github branch 	"You're free to name a Github branch ""master"" if you want.Others are free to pick ""main"". Github's free to pick a default. People are free to infer what they like from your choice.Over time, we figure out which one we, as a society, prefer."	ceejayoz	8.511808	-6.5072293	comment	5.0	20.0	1644429081	-11.773262
30399360	The index is mostly useful to me to 	"The index is mostly useful to me to split a commit in multiple ones. You do that with a sequence of ""git add -p"" and ""git commit"" commands. I am interested in how to do this with jj, because otherwise it looks like a very interesting tool."	bonzini	8.574584	-6.5344214	comment	5.0	23.0	1645296102	-11.92517
30524252	Isnt docx binary ? So git is storing	Isnt docx binary ? So git is storing a new version of the file every commit. That way too much storage space youre wasting.	IceWreck	8.58906	-6.4651313	comment	5.0	21.0	1646200669	-11.89569
30525990	The idea is pleasing, but when you s	The idea is pleasing, but when you specifically look at Git, its UX is rather disappointing. I'm not even talking about the CLI (after a while you can get used to it). I'm talking about resolving conflicts. If I have a sequence of changes A -> B -> C, then I change A and rebase B on top of A resolving any conflicts, then rebasing C on top of B will most of the time mean that Git will most likely ask me to resolve the same conflicts all over again and more. The kind of conflicts is also staggering. Each time I look at the conflicts it generated, I cannot explain how it could come up with that craziness. And all the while it also merged some changes without signalling conflicts, but instead breaking something in significant ways, without notifying me in any way, i.e. silently breaking someth	yakubin	8.605661	-6.5605927	comment	5.0	21.0	1646218958	13.892604
30587986	And the reason for the commit was to	And the reason for the commit was to have 'nicer code'. The code was working perfectly fine before someone decided it was not nice enough?	dncornholio	8.580605	-6.5093207	comment	5.0	30.0	1646662323	-11.912276
30677615	This would never work. If someone ch	This would never work. If someone checked out a file, locked it, and then went on vacation, this would block everyone else. Imagine if some breaking bug was in the checked out file, now you have to find some admin to remove the lock. You could put a timer on the lock, but how would this be different from git?Perforce does trunk based development and checkouts involve talking to the server (depot). This allows you to see who else has a file checked out, but doesn't block you from editing. I have used Perforce for multiple years in a thousand+ developer org, and have never actually needed to see who else has a file checked out.	dexwiz	8.571211	-6.4716005	comment	5.0	15.0	1647288767	13.833178
30702210	Deal breaker for me (last time I che	Deal breaker for me (last time I checked it out) was the lack of a built in git diff. I don't need anything fancy, but I can't live in an editor without it. Does anybody know if this is planned or workable in later versions?	nfadili	8.635196	-6.482198	comment	5.0	19.0	1647454896	-11.824323
32826072	Scaling Git’s garbage collection	Scaling Git’s garbage collection	todsacerdoti	8.581074	-6.533417	story	5.0	114.0	1663084931	-11.906913
32884305	Here's a way to introduce version co	Here's a way to introduce version control without having to stop everyone and teach them how to use it first:1. Commit the entire production codebase to git and push it to a host (GitHub would be easiest here)2. Set up a cron that runs once every ten minutes and commits ALL changes (with a dummy commit message) and pushes the resultNow you have a repo that's capturing changes. If someone messes up you have a chance to recover. You can also keep track of what changes are being applied using the commit log.You can put this in place without anyone having to change their current processes.Obviously you should aim to get them to use git properly, with proper commit messages - and eventually with production deploys happening from your git repository rather then people editing files in production	simonw	8.585705	-6.4509664	comment	5.0	18.0	1663473625	-11.878471
32937529	I'm trying to cleanup a Git tree rig	I'm trying to cleanup a Git tree right now where people haven't put JIRA tags in their commit comments, it is impossible to find out why a change was made, it isn't a totally stupid requirement.	rjsw	8.554424	-6.4979467	comment	5.0	28.0	1663847038	-11.9202795
36572009	> when we say CI, what CI really mea	"> when we say CI, what CI really meant was actually integrate your code regularly. Code living on separate branches is, by definition, not integrated.When I work on a long lived (say, a week or two) branch, I just rebase it on main every morning or some times several times per day. It always contains 100% of everyone elses code. But their code contains 0% of my commits yet. Because that's the point of the branch. That none of it is visible to anyone else, until I deem it ready to. The point is that when I merge it, it looks like an atomic change on main, which takes it from one working state (100% passing tests and so on) to another working state. And the only way to ensure that is to make the validation take place IN my branch.If I'm eager to ""publish"" my work, I can do that. I can make m"	alkonaut	8.635294	-6.537572	comment	5.0	28.0	1688387718	-11.921719
36605512	Dear Gitlab... please focus on finis	Dear Gitlab... please focus on finishing out your parent/child pipeline concepts. I'm very disappointed to see basic CI capabilities missing in 2023. None of the shiny AI things matter if CI isn't solid.Today parent pipelines cannot consume any test report from the child pipeline using the Gitlab CI DSL: https://gitlab.com/groups/gitlab-org/-/epics/8205We would effectively need to roll up the child pipeline's results manually in the parent pipeline by calling APIs ourselves.	ellisd	8.444397	-6.45817	comment	5.0	21.0	1688584087	9.011113
36693669	Ask HN: What is your favorite tool t	Ask HN: What is your favorite tool to resolve Git merge conflicts?	ctenb	8.621473	-6.5240474	story	5.0	3.0	1689165517	-11.871939
36744746	I'm a fan of this approach in genera	I'm a fan of this approach in general, but I've been looking for a way to accomplish almost the same thing, except I would like to have the version defined in a git repository.I suppose I could git pull on a cron job, copy over the systemd unit files, and restart, but I'd like to have just a little more smarts than that. I've been working on my own tool to accomplish this but it's not super stable just yet.	xmodem	8.610904	-6.451868	comment	5.0	20.0	1689495660	1.1658955
36812619	It's sad when politics enters the co	It's sad when politics enters the community in git. Ugh.	WhatDFHere	8.538437	-6.4515953	comment	5.0	22.0	1689939367	-11.881237
36831838	> git, for all its issues, is not bu	> git, for all its issues, is not bundling the kitchen sink.It doesn't bundle the kitchen sink in its native *nix environment, but for Windows it does. Git installer is > 50 MB, including (if I remember correctly) even a terminal.While you can download Fossil as a 3.3 MB standalone binary for any supported platform.	maxxk	8.518503	-6.466987	comment	5.0	32.0	1690077058	-11.892757
36831847	Most of these arguments are nonsense	"Most of these arguments are nonsense. ""Standing up a git server is non-trivial."" It's literally just ""git init"" and providing ssh access to the directory. Most of the other ones seem to suggest the author never learned git.git has a beautiful data model and a horrible user-space to poke at it. Writing a new user-space makes sense. This seems to poorly re-invent the data model, by virtue of not bothering to understand git.The only argument I buy is: ""2.6. Git provides a poor user experience,"" and the xkcd is not an exaggeration."	blagie	8.515107	-6.5039244	comment	5.0	20.0	1690077147	-11.889365
36831876	> and do it wellIf only Git did it w	> and do it wellIf only Git did it well!Ok that’s not fair. Git is pretty okay for the Linux open source project. But it’s pretty mediocre-to-bad for everything else.The D is DVCS is a waste of effort. Almost all projects are defacto centralized. In fact the D is anti-pattern that makes things like large binary files a still unsolved problem in Git. And no Git LFS doesn’t count.Source control should be capable for petabyte scale storage and terabyte scale partial clones, imho.Git feels like an inferior technology that succeeded and now we’re mostly stuck with it. Maybe someday someone will create a proper Perforce competitor and we can all migrate to something that’s actually good.	forrestthewoods	8.581608	-6.4487576	comment	5.0	59.0	1690077389	-11.883912
36833249	I think git gets a bad rep because n	I think git gets a bad rep because no one can agree how to use it.GitHub PRs vs pushing a branch, rebase vs merge are just two examples of tools that do identical things in fundamentally different ways.And the problem is none of them are wrong. Rebasing minor commits simplifies unnecessary complexity in your history. Merging preserves what actually happened which can provide insight into why changes occurred. Of course reverse merges are the worst but that is a can of worms...When pushing to a branch you can never force push but you always force push a PR branch...Hell sometimes the easiest things create unsolvable rifts. I know of the main repo as origin and fork for my fork. Some have learned that the main repo is upstream and origin is your fork.Neither is necessarily wrong but good luc	Guvante	8.576278	-6.557638	comment	5.0	37.0	1690096837	-11.918271
36833891	Subversion is basically CVS done rig	Subversion is basically CVS done right. The problem is that CVS was a dead end that didn't scale to a distributed development model.Git goes back to the local RCS model and adds atomic commits to that model. That's how it climbed out of the local optimum that was Subversion. There were a couple controversial choices that Git made, for example not tracking renames and not having linear revision numbers, but they turned out to be not a big deal and they allowed very efficient operations without the performance issues of e.g. darcs.Given all the attempts to fix version control between 1995 and 2010, the basic data model of git seems to be very hard to improve on, especially with additions such as git-lfs.There could be new command line interfaces but it has become harder and harder to kick aw	bonzini	8.586062	-6.4618936	comment	5.0	22.0	1690106080	-11.864779
37016008	What is the advantage of worktrees o	What is the advantage of worktrees over multiple clones?  Using multiple clones is trivial - there are no new git concepts to learn - and works perfectly with all build tools particularly ones that heavily use caching.  What productivity improvements do worktrees bring?	derriz	8.598183	-6.498549	comment	5.0	21.0	1691267353	-11.910084
37042336	Up to 2011 I used Subversion. Then I	Up to 2011 I used Subversion. Then I worked for a year for a company that used CVS. So, by comparison, my time with Subversion looks trouble-free, as you can imagine. I've worked in Git ever since, but every time Git makes my feet hurt, I think back with fond memories to Subversion and TortoiseSVN, probably unwarranted so.	sverhagen	8.601198	-6.456346	comment	5.0	30.0	1691450846	-11.860776
37095243	Nothing against the project or talk 	"Nothing against the project or talk itself. But kinda funny when a talk starts with “i bet many of you thought X was a solved problem, well im here to tell u it isnt.” 
Git was populare not because its somehow revolutionary, its popular because the previous options where so increadibly shit. Any alternative to git is gonna have a hard time without that advantage"	crickey	8.544733	-6.482075	comment	5.0	20.0	1691796242	10.266403
37292481	> probably shouldn't have been in gi	"> probably shouldn't have been in git at allSomething being autogenerated, or binary, doesn't mean it shouldn't be in version control. If step one of your instructions to build something from version control involve downloading a specific version of something else, then your VCS isn't doing it's job, and you're likely skirting around it to avoid limitations in the tool itself. People still use tools like P4 because they want versioned binary content that belongs in version control, or because they want to handle half a million files, and git chokes.In my last org, we vendored our entire toolchain, including SDKs. The project setup instructions were:- Install p4
- Sync, get coffee
- Run build, get more coffee.A disruptive thing like a compiler upgrade just works out of the box in this scena"	maccard	8.571244	-6.4877777	comment	5.0	28.0	1693222399	-11.873719
37434526	"""Subversion was slow and clunky""Luck"	"""Subversion was slow and clunky""Lucky you, you never used clearcase or Visual SourceSafe!"	philbarr	8.639572	-6.457865	comment	5.0	18.0	1694185828	-11.83971
37440673	This is rough, no? Sort of a ticking	This is rough, no? Sort of a ticking time bomb in any large repo. If someone wants to have zero association you've got to remove their PII, but if you do that you rewrite the commit graph and no past commit will work.That's really placing people in a tough situation. Oof.	renewiltord	8.579177	-6.4987125	comment	5.0	20.0	1694216589	-11.90163
37515787	I feel like git culture is one of th	I feel like git culture is one of the worst about these sorts of things. I've run into people that think you're a loser if you don't use it from the command line, but my commits using a GUI client are much cleaner and I seem to have much less trouble than they do.	glhaynes	8.570385	-6.486399	comment	5.0	21.0	1694731452	-11.900417
37515820	I used git for years now. I’m comfor	I used git for years now. I’m comfortable with all of the basic functions. It is my experience that I have had several times where merging/branching has caused a repo to “break”   It doesn’t happen often, but when it does it’s super frustrating and this I avoid the merging workflows where possible. I’m sure if I educate myself a bit more about git and pay more careful attention to the details, I wouldn’t occasionally have this problem, but Git really shouldn’t be like this.	zadokshi	8.569635	-6.50515	comment	5.0	46.0	1694731624	-11.920407
24454777	As an engineer that worked both at g	As an engineer that worked both at google and Facebook, I vastly prefer googles monorepo on perforce. Combining that with citc was pretty solid way to develop your project.Hg is a bit of a nightmare in the wfh situation. Really slow, hangs for a long time if you haven't synced in a few days. Yes, im sure there are ways to tweak, but not sure if you can tweak them enough!	tehlike	8.610098	-6.4978294	comment	5.0	26.0	1599938397	13.834336
24593255	If you've ever used Darcs, that migh	If you've ever used Darcs, that might help motivate why Pijul is interesting. Darcs was the first system I used with an interactive mode, sort of like `git add -i`. Obviously that's a UX-side change that can be (and has been) replicated in Git. But at the time it was fairly mind-blowing to work that way.The other part is the theory of patches. Darcs took the lead here too, but the algorithms and implementation left something to be desired. So Pijul could be really cool if it finally gets this to really work.On the other hand, if I'm being honest, all of my really hairy merge conflicts are not things that I think could be resolved by this---not without changing the way we think about code from being about text to being about ASTs. So I'm not sure if Pijul would have any practical day to day	eslaught	8.598488	-6.565516	comment	5.0	25.0	1601061875	13.902878
24686794	One obvious requirement for bisect t	One obvious requirement for bisect to work is that your code builds on every commit - and so does everybody else participating in the git history.Straw poll - do you enforce this? If so, for literally every commit, or do you use partial squashing to maintain this property?While that's certainly a _desirable_ property, I've never really been concerned if, say, the penultimate commit on a PR failed CI. It feels like it would be a hassle.	thombles	8.582527	-6.5406322	comment	5.0	15.0	1601898708	0.7594716
24686927	Programmers can have the best of bot	Programmers can have the best of both worlds. Use granular commits on a local branch and squash merge into shared branches.That way one gets clean shared history while preserving local work history.	alexmingoia	8.586049	-6.561959	comment	5.0	34.0	1601899674	-11.915073
24687012	> If I rollout a rewrite of an endpo	> If I rollout a rewrite of an endpoint and run into a weird issue in the QA environment, I'm a simple git revert away from fixing the issueI'm firmly of the belief that any benefits that squashing brings would be better achieved with better tooling, rather than by re-writing history and throwing away potential debugging information. In this case, what you need is for git to make it easier to revert 25 commits in one go	m12k	8.604723	-6.562475	comment	5.0	24.0	1601900249	-11.894807
24687161	The problem with this approach is th	"The problem with this approach is the local branch is no longer represented in the shared branch.  So if I'm working on a larger feature and want to PR an intermediate part and continue working, I'm in for a bad merge.If I want to merge my hotfix topic branch into both the release and the master branch, their commits won't match so I can't check if it's present in both automatically.If a topic branch is left up instead of deleted after a squash merge, I can't even see that master is ahead of it!Squash is an ugly hack that creates as many problems as it solves.I desperately wish git had a ""group commits"" feature that let me manage a cluster of related commits as a single commit for the purposes of history-viewing, reverting, and cherry-picking."	Pxtl	8.565617	-6.569042	comment	5.0	21.0	1601901516	-11.941756
24686748	I find the individual commits on fea	I find the individual commits on feature branches to be more noise than signal after they are merged. They can be useful during review, sometimes, but mostly I want a cleaner history.> they really would like a complete story, not 20 gargantuan commits that contain 3 years of developmentThat sounds like maybe we split up work differently. 3 years of development for me or my team would likely have hundreds+ of merge/squash commits, not 20 large ones.	Kihashi	8.566382	-6.565131	comment	5.0	36.0	1601898324	-11.906528
24720132	> Churn from other dev's stuff gets 	> Churn from other dev's stuff gets in your merge/rebase workWouldn't other people' work only cause issues if they are changing the same files, in which case conflicts would happen even if the work is spread in multiple repos?	ht85	8.608502	-6.5446167	comment	5.0	19.0	1602171478	-11.879171
24733815	So using git instead of a database w	So using git instead of a database when a database would be more suited?	baby	8.573476	-6.4701095	comment	5.0	27.0	1602273690	-11.857489
24752492	I really liked the look of this, unt	I really liked the look of this, until I got to `save`/`sync` in the readme...That's not how I want to work, and it's not how I want other people to work in a repository I'm using. I know 'I don't have to use them then I can just use the git subcommands', but that's not the point, it's a big signal ('90% of the time the above commands will have you covered.') about the motivation/angle/philosophy of the project that doesn't match my attitude towards git at all.Which is a shame, because the autocomplete stuff looks really nice.	OJFord	8.570132	-6.484522	comment	5.0	25.0	1602491489	10.058986
24784473	I do find this mildly amusing – and 	I do find this mildly amusing – and sad – as git is possibly one of the worst SCMs for non-programmers because its command set is so bottom-up, and therefore doesn't align with a naive mental model of how version control should work, while at the same time it exposes an interface that makes it all to easy to screw things up catastrophically.GUI tools only help with that to some extent, too, and only the right ones.	dognotdog	8.5812845	-6.4676266	comment	5.0	19.0	1602731181	-11.8789425
24830236	From the title I was hoping that it 	From the title I was hoping that it was going to do syntax-aware alignment of diffs, but alas no.I've been using kdiff3 even though it hasn't been updated in a very long time because it has one killer feature: manual diff alignment. I can select a token in both (or all three) files and then force the diff to align at that point. It makes  merges a whole lot easier. Sometimes, a single realign is all that's needed for a file merge to sort itself out. Even when that's not the case, it's easier to reason about the changes.Did I miss something? That is, is that feature available in other diff/merge tools and I just haven't seen it?	joncp	8.710848	-6.4956923	comment	5.0	18.0	1603137254	9.15302
24859412	Some interesting arguments are prese	Some interesting arguments are presented in this article but there are a couple of pretty important issues this workflow totally elides. First of all, where are code reviews? If you're committing directly to master, does that mean every commit has to get reviewed before it can be merged? So in fact you are creating a new branch for every commit and then merging it into master (presumably amending to address review comments). So now you are back at square one. Secondly, how do people work concurrently without constantly pulling/merging? I suppose you could argue it's better to resolve small conflicts frequently than to address them all at once, but surely there are times when a developer needs to be able to work unfettered.Overall I like the idea of working incrementally and ensuring that e	jgwil2	8.595421	-6.5278373	comment	5.0	17.0	1603382340	-11.912699
25002159	What are those weak points and how d	What are those weak points and how does Anu fix them? I found a technical example in https://anu.dev/documentation/associativity.html, but it was unconvincing. In their example, three way merge should produce a conflict for a human to resolve it. Which is good, we don't want a 'smart' tool to do the wrong thing and silently introduce bugs. If the argument is that pijul/anu reduce the number of conflicts by exploiting history, is there a quantization of this benefit for practical workloads, e.g. popular git repos?	alquemist	8.6034	-6.5634894	comment	5.0	24.0	1604611583	13.8973675
25044902	"    git add .
    git commit -m ""wip"	"    git add .
    git commit -m ""wip""

when you're back    git reset HEAD^

Keeps working changes nice and tidy in the branch they belong to, you can push them, and they are easily recoverable from the ref log, unlike stashes.Also, god help you when a stash fails to apply."	ricardobeat	8.572246	-6.5448194	comment	5.0	15.0	1605008829	9.467131
25126704	Now I want to see the unorthodox git	Now I want to see the unorthodox git manager.	davibu	8.544803	-6.4826875	comment	5.0	19.0	1605634666	-11.883809
25155937	Gitlab CI could almost replace Jenki	"Gitlab CI could almost replace Jenkins.I say almost because Gitlab CI lacks one critical thing: support for tasks independent of a commit or other event. Stuff like ""take a dump of the production database and synchronize it to the integration environment"".Also, Gitlab CI is, due to its nature of polling workers instead of the master pushing work to the slave as well as spinning up a new container for each job instead of reusing the same environment, slower than Jenkins which does matter for some people.A particularly dumb case showing this is when something needs to be done on a remote server via ssh - in Jenkins, one has to click ""SSH Agent"", choose the credential, and you can use ""ssh user@host"" just fine and do whatever you want. In Gitlab CI, one has to check if ssh is available on the"	mschuster91	8.619131	-6.4934263	comment	5.0	17.0	1605830641	11.944043
25184897	Most of the stuff in the article I a	Most of the stuff in the article I already know but it's still nice to have a document that you can point folks to who aren't familiar with these things. I think one interesting point from the article is that CVS is from the 80s, SVN from the 90s, and git from the 2000s.The past decade had no major VCS show up, but rather was characterized by the success story of git replacing everything else. Gcc's and LLVM's migration to git isn't that far in the past at all. So I wonder, as the last decade lacked a major leap in VCS technology, can VCS be considered a solved problem now?I recently read on hn a comment saying that Linux will be the last OS. Is git the last VCS?	est31	8.5755415	-6.462245	comment	5.0	55.0	1606122370	-11.8826685
25247164	The one potential effect of this tha	The one potential effect of this that I'd love over git is being able to check in local changes that I never intend to upstream. E.g. I could have a local change adding some editor config files, or modifying some compiler flags in the Makefile to suit my local config.With git my typical solution for this is to basically keep rebasing them as uncommitted changes with `git stash`, until I inevitably lose them. Or keep a separate branch, and keep explicitly rebasing (and stay on my toes not to accidentally push the commits).	rstarast	8.580441	-6.5228887	comment	5.0	17.0	1606676692	-11.856999
33043387	Why do people think that having bran	"Why do people think that having branches in their history is ""unclean""?  I'm struggling to understand what is the issue here."	Ferret7446	8.587703	-6.5418005	comment	5.0	37.0	1664592994	-11.798947
33043531	Genuinely asking: What's the value p	"Genuinely asking: What's the value prop of having the merge-commit in the history for you? Have you ever capitalized on it? And if so, could you share the command-line-fu that's helped you take advantage of having such a commit in your repo history?I'm asking because I used to do exactly this and feel much the same way as you — I felt it was nice to preserve the historical context.At some point, it dawned on me that, amidst all the anecdata I'd acquired, I'd never once benefited from having those commits cluttering up the history.These days, I usually advocate ""squash & merge"" for the 80%+ of teams that lack the discipline to write good commit messages for every one of their branch commits. And, for those rare teams where every engineer writes thoughtful commit messages on their branches ("	q7xvh97o2pDhNrh	8.581491	-6.5492926	comment	5.0	21.0	1664594425	-11.9149685
31852538	Does the usage of SHA-1 in Git actua	Does the usage of SHA-1 in Git actually have security implications, though? It's basically only used to generate addresses for refs and hunks and all that.	bradhe	8.675039	-6.519181	comment	5.0	35.0	1656005861	7.2429686
31874876	Git's UI/UX is one of the worst engi	"Git's UI/UX is one of the worst engineering sins to be committed in the last two decades, and this website shows why. Literally nothing about git is intuitive and the ""underlying model"" is entirely ad-hoc. Instead of celebrating how Linus built git in only a few days he should be castigated for knowingly setting up ill-conceived software to go viral."	kcl	8.55188	-6.478813	comment	5.0	32.0	1656161412	-11.894542
31877099	So that’s exactly my problem and I’v	So that’s exactly my problem and I’ve yet to come across a guide that explains the underlying concept well. Any recommendations? I often feel like I’m uttering spells without understanding it when I use git. I hate working like that. Thanks in advance!	hangonhn	8.5229025	-6.504825	comment	5.0	15.0	1656178497	-11.900307
31889442	I've been using git for a while now,	I've been using git for a while now, through combination of command line, tig [0] and lazygit [1]. Is it worth transitioning to magit? It's touted as one of the hallmarks of emacs, akin to org-mode.What I'm saying is, I'm quite productive with git already, is magit really the next level?[0] https://jonas.github.io/tig/[1] https://github.com/jesseduffield/lazygit	tra3	8.60617	-6.4835014	comment	5.0	17.0	1656290332	5.695918
31924658	> Unfortunately, this is not quite t	> Unfortunately, this is not quite true. Git checkout will silently and irretrievably clobber all the changes in your working tree.Not by default it won't.It can do that, if you explicitly run it with the options to checkout a specific path. But why would you do that if it's not what you want?	atq2119	8.542828	-6.580125	comment	5.0	26.0	1656530968	-11.853327
31925796	Am I the only one sad that Git beat 	Am I the only one sad that Git beat out Mercurial as the industry standard?And am I also the only one who still knows how to do things in Mercurial but not how to take the corresponding action in Git? I mean, they're things I haven't had a reason to do in years, but it has some psychological cost to feel like I'm using a system I'm worse at.	HWR_14	8.513288	-6.5492606	comment	5.0	34.0	1656537253	-11.927484
31925224	I'm not a fan of this mythos around 	I'm not a fan of this mythos around Git's complexity. It is simply a DAG, a bunch of references to nodes in that graph, and a stack of commands that let you make any modification to that system you so desire.If you just learn the mapping of those concepts to Git's vocabulary, you really don't need to memorize all the commands. In the odd case, you can just look up the docs. Nodes are commits, references are either branches or labels depending on whether they stick to leaf nodes or any other node. Your working tree is the current state of the repo in your filesystem, and staging is how you assemble commits.	OkayPhysicist	8.568807	-6.516182	comment	5.0	16.0	1656533931	10.131648
31985641	hg up --cleani dont know why mercuri	hg up --cleani dont know why mercurial doesn't get more love.	8n4vidtmkvmk	8.511293	-6.5584955	comment	5.0	21.0	1657008521	-11.974099
31985700	The checkout command is severely ove	The checkout command is severely overloaded; I'd hardly remember the functions if it wasn't for aliases.The reset operations are also very inconvenient, due to the mix of: different types of reset (soft/hard); overlapping with the checkout command; different states of the files.Pushing is also overloaded, due to handling both branches and tags (this is probably due to the fact that both have refs).There are strange warts (e.g. adding with --patch doesn't include files not in the index; displaying the content a given stash entry requires typing the whole - unnecessarily complex - entry name), which I don't doubt make sense technically, but from a user perspective, they're odd.There's probably a lot of stuff that one can find, depending on how wide their usage is. For example, I actually did	pizza234	8.563066	-6.5405197	comment	5.0	24.0	1657009087	-11.902235
31987740	> marvel at how it ever became popul	"> marvel at how it ever became popular.It's worth going through old HN comment sections that have flamewars of SVN v git (or cvs vs hg or whatever) from 2006-2012 or so. The dvcs systems won because they changed a bad paradigm to one that's much much better - literally the way you think about version control these days is a radical departure from the previous way it was done. Merges are much much nicer in git then they ever were in those old systems - I've never spent more than an hour dealing with the results of git issues, but I've lost literal weeks to a single svn mishap.Why did git win over other dvcs systems?2 main reasons I see:1. Linux uses it - literally, that means its the ""cool one""2. Linux uses it - and that means the people developing it work similar to the kernel, they are wi"	sophacles	8.5716	-6.492394	comment	5.0	33.0	1657026382	-11.859227
32053223	> It is possible to keep database fu	> It is possible to keep database functions in git. It requires some discipline but it's not hard.My experience differs. How do you check that the stored procedures in the DB are exactly as defined in Git?I remember spending several hours on a bug that was caused by an altered stored procedure. One SQL function was not as it should have been. I don't know if someone had patched it live, or if there had been an unnoticed failure in a DB migration script.With a compiled executable, consistency is guaranteed. With interpreted code (Python, PHP), consistency check is done with a command like `git status`. But there is no standard way to compare the state of store procedures in the DB with their expected code in versioned files.	idoubtit	8.619444	-6.4970746	comment	5.0	15.0	1657523841	9.87215
32124104	> The purpose of a git commit messag	"> The purpose of a git commit message is to answer the question “why does this commit exist?”Why? Every time I have asked this people say because you'll search the logs (which I have never done in my life) or because ""it's good practice"""	ArrayBoundCheck	8.576402	-6.527287	comment	5.0	46.0	1658027030	-11.906771
32195031	Not sure there's evidence there. I b	"Not sure there's evidence there. I bet if you look over the vast majority of commit messages you will find that they're ""lol fuck"" or ""whoops"".The reality is that developers convey intent through pull requests and rarely go through a commit log.Most people use commits as ""ctrl s"", which means commit messages are just some dumb shit in the way of me backing up my files."	staticassertion	8.589865	-6.553653	comment	5.0	26.0	1658512524	-11.907575
32213873	As someone who interfaces deeply wit	As someone who interfaces deeply with Git on a daily basis, please don't imply that it's trivial or simple. There are a million edge cases you can get into, and people with 7 YOE on my team are regularly surprised by the facts we uncover.	ironmagma	8.540777	-6.494126	comment	5.0	21.0	1658673284	-11.897482
32216027	I do stacked PRs at work, they work 	I do stacked PRs at work, they work great until someone suggests an invasive change in a PR lower down in the stack. Does anyone have ideas on how to deal with merge conflicts in this type of flow? For example let's say I have the following stack of PRsPR1 -> PR2 -> PR3 -> PR4The reviewer reviews and suggests a change in PR1, this change causes a merge conflict in PR2 and therefore in PR3 and PR4 as well. And then you have to go in manually resolve the exact same merge conflict all the way through you PR stack in each of the PRs. This gets annoying and hard to work with.Does anyone have a better way of dealing with this pattern of merge conflict? I've tried using git rerere which in theory sounds helpful but doesn't seem to do anything when I strike this issue.	avl999	8.594233	-6.496198	comment	5.0	20.0	1658686036	-11.887395
32217204	There is active work related to teac	"There is active work related to teaching ""git rebase"" to natively support stacked branches in the Git core currently being worked on by Derrick Stolee [1].If you ""stack"" your changes across multiple inter-dependent branches it looks like ""git rebase"" is going to learn how to update related branches using a new ""update-ref"" command (alongside ""squash"", ""fixup"", ""exec"", etc) that gets activated automatically through a ""git rebase --update-refs"" command-line flag and config option.(This is from Derrick, not me)""""""
This is a feature I've wanted for quite a while. When working on the sparse
index topic, I created a long RFC that actually broke into three topics for
full review upstream. These topics were sequential, so any feedback on an
earlier one required updates to the later ones. I would w"	davvid	8.577443	-6.5544114	comment	5.0	15.0	1658693514	9.2998085
22022898	What's the value proposition of Piju	What's the value proposition of Pijul? I mean, not being Git is not a good reason to convince anyone to adopt it as a VCS. A tool needs to actually be better at something and add tangible value where others may not have.  What's the absolute best reason to convince anyone to adopt Pijul?	rumanator	8.582867	-6.545325	comment	5.0	34.0	1578782615	6.6439333
22221681	You can configure it to support it. 	You can configure it to support it. Git supports configuring different diff programs for different file types. And there are tools to diff docx etc.	scrollaway	8.6882715	-6.490017	comment	5.0	19.0	1580708175	-11.834916
22234480	Ask HN: How to commit properly when 	Ask HN: How to commit properly when starting out a project?	m712	8.579709	-6.522434	story	5.0	4.0	1580816489	-11.890169
22233651	I can't find documentation for the c	"I can't find documentation for the command in the article:    git convert-repo --to-hash=sha-256 --frobnicate-blobs --climb-subtrees \
    --liability-waiver=none --use-shovels --carbon-offsets

Surely some of those options aren't real..."	tcharlton	8.657503	-6.465505	comment	5.0	19.0	1580807319	-11.815978
22237864	That cute rhetoric will not fool any	"That cute rhetoric will not fool anyone. Common git workflows use fairly succinct git commands:  git diff
  git commit -p
  git rebase -i HEAD~3

The command quoted in my original comment is just this we strip away the SHA256 garbage:  git log abac87a..f787cac

(Or maybe it is:  git log abac87a^..f787cac^

I cannot guess whether the ^ operator still has the same meaning or whether it is part of this ^{sha...} notation.)The hashes will typically be copy and pasted, so you type just the git log, .. and spaces.The fixed parts of convoluted git syntax can be hidden behind shell functions and aliases. But notations for referencing objects are not fixed; they will end up as arguments."	kazinator	8.614666	-6.5195813	comment	5.0	41.0	1580835335	-11.8755665
39381674	Splitting up commits is totally unde	Splitting up commits is totally underrated and seen rarely. I see colleagues over and over again plumbing 4 kinds of changes into the same commit. Good luck reverting the one change that caused an outage.	torblerone	8.586886	-6.5347033	comment	6.0	48.0	1707998477	-11.923965
39402280	I think a critical one would be: ini	I think a critical one would be: init.defaultBranch masterEspecially since places like GitHub are making main the default unwittingly	peterhadlaw	8.508485	-6.5331917	comment	6.0	46.0	1708114063	-11.8097105
39403559	Why? I use git add -p absolutely all	Why? I use git add -p absolutely all the time, its really simple to learn	dgellow	8.570081	-6.4978886	comment	6.0	29.0	1708121126	-11.909576
39453012	I have the same question every time 	"I have the same question every time Pijul comes up on HN, and I have yet to get an answer:Can someone give me a real world example (person a makes X change, person b makes y change etc. etc.) that would work better in Pijul than Git?I am a complete believer on a sound underlying model producing better results for users at a high level, but I'm not clear on how it maps through for Pijul. I think that's what they're missing in the sell - the ability to explain to devs ""it will make your life easier in the following specific ways"".For example when getting my employer moved from SVN to Git I could talk to people about how much easier it was to create and then merge a temporary branch for a feature in Git. Git understand the topology of the history, knew the merge base and had better merge algo"	rkangel	8.592745	-6.560923	comment	6.0	65.0	1708518824	13.897774
39453387	I used darcs before git and it was v	I used darcs before git and it was very nice - the first distributed RCS I'd ever used. I believe pijul is a follow-on to that so it should be great.  Later on I used Mercurial and it was very easy with a great GUI and it felt safe.git is like shaving with a straight shaving razor - alarming until you've developed your set of frequently used commands and ways to stay out of trouble.Even I have to use git because who uses anything else? Every project that I know that used Mercurial dropped it in the hope of getting more contributions.We have all rushed like Lemmings into Github - now owned by those nice people at Microsoft - who have used it to automate our jobs with copilot.   How ridiculous  that Open Source has been embraced into the clutches of the Empire on such a scale! :-) I am jokin	t43562	8.545825	-6.4957957	comment	6.0	35.0	1708521360	-11.923657
39554262	SVN was a thing by the mid-2000's, a	SVN was a thing by the mid-2000's, and history from that is easy to preserve in git. Just how old are the sourcebases in question? (Not to shoot the messenger; just like, wow.)edit:typo	KerrAvon	8.593313	-6.442123	comment	6.0	19.0	1709236849	-11.904808
39588731	You can't, and it was one of the maj	"You can't, and it was one of the major pain in the ass points allowing git and Mercurial to eat their lunches. Also developers ""locking"" entire subdirectories in SVN and blocking any others to merge into, bonus point when they forgot it and went on vacation.Merges in SVN and CVS were also very painful to do. After being bitten by it, every single place I worked at had to create protocols and guidelines on how often to merge/reconcile code to not waddle in a eventual merge hell.VSS, CVS and SVN were ok to use when there were no other choices, Perforce was really good but very expensive, git and hg felt like the future when they showed up."	piva00	8.584054	-6.5165877	comment	6.0	18.0	1709546716	-11.926142
39589239	Thinking about large parts of the ga	Thinking about large parts of the game development world still using Perforce (or even SVN!) because they frequently need to commit lots of binary asset files to their repos... I guess text is not the only thing that runs the world.Really there is still no real alternative to Perforce when it comes to handling binary files. Previously PlasticSCM was a good contender but Unity bought it for their own version control system and seems they've stopped developing the original software (which is a shame...)	cyber_kinetist	8.6350565	-6.489438	comment	6.0	20.0	1709552206	13.833731
39589741	> GIT is already best model for keep	> GIT is already best model for keeping history of textual changesNo it’s not. Git isn’t a model of textual changes. It’s just a model of textual snapshots connected over time.If I were building a replacement for git, it would store character by character changes instead - though for that to work properly you’d want editor integration. Then the same tool could act as both a version control system and as a platform for realtime collaborative editing (via CRDTs). You can still have commits - they’re essentially just tags. And I’d keep the concept of branches.Most of the algorithmic work has already been done - at least from the CS research side. Combine my work in diamond types with some of Martin Kleppmann’s work on BFT CRDTs & automerge. There’s a few more tricks needed. For example, you d	josephg	8.584348	-6.485308	comment	6.0	28.0	1709556087	-11.920279
36578164	I understand the desire to make larg	I understand the desire to make larger patches, but how do you effectively manage them in the review process? For super large commits in the past, I’ve had other engineers hop on a screen share to review the diff together and answer questions, but it feels inefficient.	phatskat	8.621152	-6.4470873	comment	6.0	50.0	1688415219	1.9172957
36779240	Think if you have that many develope	"Think if you have that many developers you need to start doing it Linux kernel style and have maintainers responsible for certain parts of the project making sure merges go in fine.And maybe have actual communication in other means than via comments on tickets. The whole hypothetical example could be avoided by typing ""hey, I'm changing this field to be that, anything against?"" on team's chat> Since my_branch was merged before it was rebased onto someone_elses_branch, this error goes unnoticed and BAM - main is broken! This is known as a semantic merge conflict — a merge is technically possible, but results in a regression.Do people not merge master into their branch before pushing? All that seems like mostly problem caused by having too long living branches.I'm also confused how that even"	ilyt	8.598897	-6.5546794	comment	6.0	27.0	1689715084	-11.901579
36831569	I think there are some legitimate cr	I think there are some legitimate criticisms of Git here. But some of them are...odd. Despite using Git in a variety of circumstances, from a local personal repo project to very large company repos, I admit I haven't run into about half of these issues.> The closest I have found is the network, which is slow to render (unless it is already cached), does not offer nearly as much details, and scarcely works at all on mobile.I hope my team never has to consider their mobile device as a way to check the status of a branch. It hasn't even crossed my mind as a use case. Does this come up often for others?	NBJack	8.544167	-6.4593644	comment	6.0	42.0	1690074059	-11.900586
23676065	Are you saying that Git should imple	Are you saying that Git should implement those features?	coronadisaster	8.55361	-6.473797	comment	6.0	23.0	1593425284	-11.867397
23866436	Is anyone just using Git{Hub,Lab,Tea	Is anyone just using Git{Hub,Lab,Tea} issues and being fine with it?Is the absence of a Kanban board a deal breaker? Perhaps for management.	mrslave	8.532411	-6.4540215	comment	6.0	20.0	1594953817	-11.8777275
23905274	You can extend this further: git is 	"You can extend this further: git is the wrong representation model for code (text).It's a useful representation model, but really only because programming languages are mostly designed to be line-oriented (though not enough: i.e. Python should disallow multiple imports on one line because it lightly breaks diff-viewing). Git is the dumbest possible thing that can work, and it does work, but it's also wrong.What we really need is a generic way to store graph-structured data (which is what an AST really is) into something like git. Because then we could finally get rid of the notion of code-formatting as anything but a user experience peculiarity (the rise of ""push button and blackbox fixes code for commit"" elucidates why this should be).But more importantly, it would mean we could reasonabl"	XorNot	8.595318	-6.494524	comment	6.0	29.0	1595320711	-11.858983
23997976	Show HN: Gomp – a tool for comparing	Show HN: Gomp – a tool for comparing Git branches	philipkiely	8.56844	-6.467082	story	6.0	92.0	1596116448	-11.871426
24067186	What SCM has sequential commit IDs, 	What SCM has sequential commit IDs, rather than hashes?	ianmobbs	8.634917	-6.560932	comment	6.0	18.0	1596675303	7.3400483
24166489	Using Askgit – A SQL interface to yo	Using Askgit – A SQL interface to your Git repository	pcr910303	8.58379	-6.4907236	story	6.0	176.0	1597472614	-11.902843
24209353	Python: Commit removing White Suprem	Python: Commit removing White Supremacy relics	mtnsaoeu	8.590224	-6.5299397	story	6.0	8.0	1597837207	-11.910155
24264725	I guess I've not worked in big enoug	I guess I've not worked in big enough corporates to use this.Can any user here provide some context what JFrog does? The website doesn't really say much, the example pipeline files for JFrog pipelines seem more complex than GitLab CI.	thesimon	8.434347	-6.4535317	comment	6.0	35.0	1598298653	8.957301
24289299	Set the default branch for newly-cre	Set the default branch for newly-created repositories	jeamland	8.503362	-6.5512705	story	6.0	28.0	1598491874	-11.773033
24290595	Is renaming Git master branches for 	Is renaming Git master branches for inclusive language reasons going overboard?	tawaybayarea	8.524122	-6.527297	story	6.0	6.0	1598508649	-11.743483
20004626	> Git isn't that hard.It's not, but 	"> Git isn't that hard.It's not, but if you don't use it mostly every day, or if you decide to ""Delete repository and clone again"" every time there's a problem, you won't ever get to learn how to fix it.The staging area is totally unnecessary IMO.  I think git would be easier if we didn't have it.The term `checkout` is multiplexed to do more things than I would've guessed."	wyldfire	8.622044	-6.555393	comment	6.0	26.0	1558726292	-11.936574
20006048	I, on the other hand, see these thre	I, on the other hand, see these threads and wonder how arrogant and fraudulent our industry is when programmers have to pat eachother on the back and say the problem is git.Git is a tool for creating and navigating a directed acyclic graph of revisions.  It’s fine to chuckle and make fun about how esoteric that sounds, but at the same time I expect people that work on my team to rise to the challenge of proving that they occasionally attended data structures and algorithms class.I understand not taking a day to learn git, I really do.  It’s hard to find the time to learn everything that comes your way at work, and you’re not exposed to the practical challenges that augment documentation as part of learning if you try to crush it out all at once. But, if someone can’t learn git, I don’t kno	finnthehuman	8.541537	-6.4954243	comment	6.0	24.0	1558738946	-11.909385
20128574	"The ""who wrote this?"" mentality is a"	"The ""who wrote this?"" mentality is a trap that's good to avoid. Get comfortable with different ways of writing something that, while they might have different tradeoffs, accomplish the same thing, and try to see past that. Understand that most code wasn't written by anybody--lines 1 and 3 were written by Alice a year ago, line 2 was written by Bob 2 years ago, and line 4 was written by Alice yesterday. `git blame` is very useful for seeing the change in context, which can give a lot of insight into why it's written that way, but usually the author isn't very useful to know, unless you're planning to ask them about it. Sometimes it's useful if you happen to know that the author isn't very familiar with something when you're wondering why they didn't use it, but try to keep in mind what the "	kbp	8.564805	-6.5018225	comment	6.0	25.0	1559941245	-11.909375
19006593	I'm also a big fan of not deleting d	"I'm also a big fan of not deleting data. I don't like squashing commits, for example. But I also want to be able to see high-level intent.If instead of ""squashing"", it were ""grouping"", I'd be happy. I could encapsulate a bunch of messy commits that I made while I didn't know what I was trying to do. The intent would be clear at a higher level, but if you want to dig in to see what it actually took me to achieve that, you can see all my experimentation by looking at the commits inside the group.Groups should be able to be nested, of course.The only way I know how to achieve this in git is my relying on no-fast-forward merges. There's a post detailing this approach [1], but unfortunately a lot of git tools don't support this workflow that well. I haven't gotten it to work well in gitlab, for"	gugagore	8.567228	-6.557463	comment	6.0	66.0	1548515638	-11.944787
19007171	You misunderstand me. Almost everyon	You misunderstand me. Almost everyone does. I do not think you should squash all of your changes into a giant hairball commit, and I don't think first parent (which is effectively the same thing) solves this problem either.I think each of your commits should be individually rewritten until each commit makes sense and tells a single, indivudal story that makes sense on its own, while at the same time be completely atomic and as small as possible.You created a new function? That's one commit. Take a moment to explain why this function is going to be useful in future commits.You called that new function from several new spots? That's another commit. Explain why each of these calling sites requires this function.You decided that there had to be some style and whitespace changes? That's another	jordigh	8.581997	-6.5651937	comment	6.0	32.0	1548522798	-11.919178
19101723	Mercurial support, fuck yeah:https:/	Mercurial support, fuck yeah:https://hg.sr.ht/This is the killer feature for me.Why Mercurial?Here’s a list of Mercurial features that I think are really cool:Revsets – a domain-specific language for querying your commitsTemplates – a domain-specific language for altering the output of almost every command. Putting together these two you can do things like this: http://jordi.inversethought.com/blog/customising-mercurial-l...Evolution – a distributed and safe way to share rewrites (think automatically recovering from upstream rebase without any git reset --hard and no git push --force).Absorb – automatically amends an entire stack of WIP commits at once by picking the right diffs from your working directory based on which commits’ contexts they fit best.Curses interface for hunk-picking – a	jordigh	8.534515	-6.556276	comment	6.0	27.0	1549498986	-11.947276
19165079	Help me understand something -- righ	Help me understand something -- right now my workflow is to create a new branch when I'm working on a new feature.  One branch per feature.  I check in frequently and push up so my work is saved.Sometimes I ask people to look at the code in progress when I want opinions on architecture or just overall code quality.When I think the feature is ready for merging, I'll create a pull request.How does a draft PR help me?  What do I get with a draft PR that I don't already have?I assume it's a good idea, and everyone here seems to think so too, so I think I'm missing something obvious.Edit:  Lots of great points below, mostly pointing out features that I don't really use a lot, which is why I didn't see the improvement.  Thanks everyone!	jedberg	8.599989	-6.521085	comment	6.0	32.0	1550172615	-11.936913
19273736	Ask HN: Next-Generation Version Cont	Ask HN: Next-Generation Version Control?	ehu_fugaces	8.606402	-6.4561043	story	6.0	6.0	1551378753	-11.883455
19291633	I like the picture at the beginning 	I like the picture at the beginning of some CLI novice trying to git push his home directory	umvi	8.560065	-6.4590855	comment	6.0	24.0	1551567298	-11.895534
19388406	Yeah, I too don't really understand 	Yeah, I too don't really understand git. It seems that it was developed without any concern for affording a good mental model of its operation to its users, and thus it is just a complex black box you chant arcane rituals at and hope it doesn't decide to burn your world down. I know I could build a mental model of it if I put enough time into it, but who wants to do that when there's actually useful things to do? So instead when I have to use it to contribute to open source projects I have a sheet of notes with incantations to cover the specific things I've had to do with it in the past.	AnIdiotOnTheNet	8.539642	-6.4783187	comment	6.0	30.0	1552564812	-11.89895
19570289	“Problems” with git format-patch	“Problems” with git format-patch	davvid	8.549963	-6.450682	story	6.0	134.0	1554367315	-11.86269
19629493	"Isn't ""merged"" a nice way of saying "	"Isn't ""merged"" a nice way of saying that the men and children were likely murdered and the women taken for breeding?  ""Merged"" conjures an image of living peacefully side by side and interbreeding for many generations."	daenz	8.737743	-6.4727902	comment	6.0	20.0	1554936595	9.225517
19782464	GitLab CI is pretty good.I hate, on 	"GitLab CI is pretty good.I hate, on a fundamental level this whole ""bash in YAML"" trend. Let's take a powerful, turing complete language and put it in a _config file_.What? I don't even...And the fact that you only get _one_ .gitlab-ci.yml file. That is legitimate madness. Want modularized CI/CD configuration? Not in these parts, buster. Have submodule build dependencies? We laugh at your use case.Sure as shit better than Jenkins though."	badloginagain	8.669331	-6.483949	comment	6.0	31.0	1556570911	8.97008
19903381	The three most important basic git o	"The three most important basic git operations to know (in my opinion)    git checkout -b
    git log
    git rebase -i"	333c	8.569561	-6.5367923	comment	6.0	29.0	1557777967	-11.900751
19907024	> I committed and immediately realiz	> I committed and immediately realized I need to make one small change!I think it might be nice to add a disclaimer saying that this is not advisable if you've already pushed the code. Suck it up and make a new commit–don't rewrite public Git history.	saagarjha	8.586039	-6.5170383	comment	6.0	43.0	1557812272	-11.90838
15756667	Author of the referenced wiki post, 	Author of the referenced wiki post, and of SQLite and Fossil here...The other day, I had 60 minutes of free time between events and so I brainstormed a few ideas for improving Fossil while sitting in a Starbucks, and those unedited, spur-of-the-moment notes trigger a big discussion on HN...  Yikes!  I do appreciate the feedback.  Seriously. Your comments are very, very helpful.  But let's not attach too much weight to my musings over coffee.Should I interpret the response here to mean that there is latent demand for a new-and-improved VCS in the world.  Does this mean that Git is ripe for disruption?Some Issues I Have With Git(1) A Git repository is a pile-of-files and/or a bespoke key/value store (packfiles).  The format of the repository is underdocumented.  (Proof sketch:  try to write 	SQLite	8.512519	-6.5014434	comment	6.0	21.0	1511358033	-11.9276285
15903254	The general sentiment of this articl	The general sentiment of this article is in things like:> A commit message is already too annoying for many users!So because your ass is just lazy another guy a few months down the road has to suffer (in this case decipher what it is you wanted to do with your changes)?Put some damn effort in, we have enough crapware already, we don't need to add more just because you were 'annoyed by having to document changes'.The thing with git (the way I see it more and more while working with it) is that it barely cares if it makes sense to the 'lay user', it instead cares about wrapping the most fundamental operations on text files. And that's a good thing in my book. I would not like seeing all this ruined just because it was 'zomg too confusing, not useful for most users'.	gear54rus	8.588688	-6.51748	comment	6.0	35.0	1513057410	-11.893814
15903293	It's clear that there will be a succ	"It's clear that there will be a successor to Git some day, in the sense that Git is a successor to SVN (yes, I know Linus's viewpoints on SVN).  But the successor won't be a ""better Git"" just like Git isn't a ""better SVN"".The driving features of Git's successor will be unrelated to Git UI gripes. If Git's UI gripes were important enough, people would just be using Mercurial (which has it's own quirks). The biggest problems I've personally seen with Git are the same problems you see with other VCS, where two people change the same file, and one commits the changes first. Now you have to merge the changes and sometimes it's a pain in the ass when you just want to submit your changes and go home. A better VCS isn't going to solve that!I'm still glad that Git delivered me from all the merging "	klodolph	8.569671	-6.4880357	comment	6.0	40.0	1513058175	-11.892221
15952387	A git off my lawn moment: Every time	"A git off my lawn moment: Every time I see someone complaining because they have to dive into the reflog to fix their own mistake, all I can hear is ""I was operating my table saw without using a push stick and can't understand why I lost a thumb"".Friends don't let friends (especially those who don't learn how to use their tools) rewrite shared git history. If you don't understand rebase, amends, etc can do to your (and everyone else's) repo, DON'T DO IT."	falcolas	8.565736	-6.5365324	comment	6.0	54.0	1513612095	-11.902836
16056925	One thing I miss on every merge tool	"One thing I miss on every merge tool is full history context for both sides (""side"" == ours/theirs).i.e., I don't want to just see the final state of ours/theirs, but the changes that us/them did in order to get to those final states.IOW, often, both sides of the diff are nearly identical, and I have to squint to see the actual difference, and make some additional effort to figure out the intent of each side.A better format would be, for each side:Original state -> change -> final state- ""Original state"" would be normally identical for both sides- ""change"" would be tiny and unique for each side, helps you see the intent of each side clearly- ""final state"" is normally pretty similar between sides, (which is what troubles me, if no context given).Maybe I'm missing something, feel free to cor"	vemv	8.697756	-6.505021	comment	6.0	32.0	1514935872	-11.837827
16264573	On undoing, fixing, or removing comm	On undoing, fixing, or removing commits in git	signa11	8.579446	-6.534408	story	6.0	157.0	1517313316	-11.913063
17915036	How exactly does the image-based app	How exactly does the image-based approach mesh with version control like git? I'm trying to picture a possible approach, but failing.	int_19h	8.631452	-6.502023	comment	6.0	20.0	1536121784	9.457316
17986370	It is a shame that a lot of critical	It is a shame that a lot of critical projects (including compilers, browsers...) still try to do things a la CVS/SVN (even if they use a DVCS).Please, stop it. Do it the way the kernel does it. A hierarchy of maintainers that reviews the work sent by others and a single person with commit access to the main repository.I am amazed that these smart people have not realizead yet that unrestricted commit access is simpy a no-go, with or without signed commits/tags.	throw28363	8.622271	-6.444694	comment	6.0	32.0	1536924546	-11.793461
17987521	I understand why everyone wants git 	"I understand why everyone wants git cheatsheets (there are a lot of commands), but I have yet to see a cheatsheet/etc that does little more than become a crutch.For better or for worse, git really demands that you learn the concepts and fundamentals. It has a steep learning curve, but it's one that easily pays dividends.Do I wish it were easier to learn? Of course.Can you substitute actually learning how git and its workflows are used with cheatsheets and quick primers? Not remotely.That being said, I think this one is a step in the right direction by being interactive. Something like a ""git simulator"" could be incredibly powerful in teaching people git."	epicide	8.517407	-6.4929156	comment	6.0	28.0	1536936169	6.228906
18031173	"""Conflicts are presented with a 3-pa"	"""Conflicts are presented with a 3-pane view. On the left are your changes and on the right are theirs. In the center pane is the resolved text""They are missing a pane then.  A 3-way merge involves your changes, others changes, a common ancestor, and the resolved text.  kdiff3, Beyond Compare, and very recent versions of emacs are the only tools that I've seen that present this properly."	krupan	8.698054	-6.500474	comment	6.0	21.0	1537439788	9.141769
18243330	I always struggle to see why people 	I always struggle to see why people bang on about git bisect. You need tests to make it work. If you have tests, why aren't you running them continuously? If you're running them continuously, why do you need git bisect?	HereBeBeasties	8.573367	-6.5362577	comment	6.0	19.0	1539807392	0.85899854
18513666	Curious as to why - What usecases do	Curious as to why - What usecases do you have for staging? Why does sourcetree make it better? To me it's just an inconvenience and a redundant step on the way to committing stuff.I get that you can use it for partial commits of in flight work but that's never something I've needed in practice. Usually I just want to commit everything I'm working on at once.	davnicwil	8.651979	-6.5564384	comment	6.0	39.0	1542935263	-11.9476
18513181	I must admit I'm a little bit confus	I must admit I'm a little bit confused. It opens with a discussion that people find Git hard to use, and a statement that these problems are likely more than skin-deep but then goes on to describe a wrapper around Git which is mostly a bunch of aliases. Don't get me wrong, I'm know that many people do find Git hard-to-use, but I don't see anything in the eventual project implementation which backs up the original claim that the problems are conceptual. I don't think it's possible to fix conceptual problems in a tool by just wrapping it.I have heard people complain about the staging concept (personally I find it useful, because you can do 'git add -p' which allows you to craft intermediate commits or to-be-squashed fixup commits after you've finished some development), so it's removal in th	cyphar	8.58361	-6.5315943	comment	6.0	36.0	1542928393	-11.900797
18513697	If anyone wants to know what it is l	"If anyone wants to know what it is like working with a ""hard to use"" revision control system then I highly recommend trying out IBM Rational ClearCase [1]. Or as I lovingly used to refer to it as Irrational ClearCase. To be fair, I have not used it since 2009, so perhaps it has been improved?If you use emacs and you find git difficult then please try out magit [2]. I actually really like the git cli, but I use magit a fair amount also. Plus, emacs is awsome :-P[1] https://en.m.wikipedia.org/wiki/Rational_ClearCase[2] https://en.m.wikipedia.org/wiki/GNU_Emacs#Extensibility"	dustfinger	8.537682	-6.473451	comment	6.0	21.0	1542935777	-11.864563
18620833	> This is a fantastic demonstration 	> This is a fantastic demonstration of why i exclusively use git from a command prompt...Thanks for this. I've always felt the same way but haven't been able to put my finger on why. As more things get integrated into my editor (I use VSCode) I feel like I should use the shiny features, but for source control I think I'm going to only use the commandline forever. (Edit: though plugins such as GitLens that give you source control info inline are fantastic.)Along with some nice features I've added, such as my 'git af' (add + fzf) shortcut[1][2], the commandline is very usable (don't have to 'git add' and type filenames manually).[1] https://github.com/kbd/setup/blob/65b3d0abcb34540b43880792e8...[2] https://github.com/kbd/setup/blob/	kbd	8.586564	-6.4850388	comment	6.0	26.0	1544121991	-11.878765
18664091	Writing the good quality commit mess	Writing the good quality commit message is not that hard and is sometimes actually enjoyable (after all i get to brag about this feature / bugfix / solution).What does cause a lot of mental overhead (and consider myself a decent engineer) is creating commits that have a single purpose in the first place.Working on a new feature I often have to refactor something, and while I am at it, I clean up some related parts. That is at the minimum 3 commits applied in the correct order, sometimes over different branches. At that point there is a lot of `git add -p` and `git stash apply` going on, which takes considerably more mental energy while you see some colleagues getting away with `git commit -a`.Writing good commit messages itself is the reward for creating good commits.	sly010	8.583828	-6.532922	comment	6.0	28.0	1544624629	-11.9093
18793578	Ask HN: What are some underrated ski	Ask HN: What are some underrated skills that a programmer should have?	gymshoes	8.544602	-6.4748135	story	6.0	6.0	1546242949	-11.920612
18919954	Personally, I think using git from t	Personally, I think using git from the commandline is too complicated for the purpose it serves in most companies.Using a git GUI works quite well for people inexperienced with git.	meuk	8.559236	-6.482754	comment	6.0	29.0	1547638582	-11.882399
29698932	The flip side of getting great perfo	"The flip side of getting great performance is all the exposure to security vulnerabilities.Git seems to have an excellent security track record: https://www.cvedetails.com/vulnerability-list/vendor_id-4008... However, I think the right claim here is, ""be very sure you have the chops to benefit from C's speed without compromising security."""	akkartik	8.620543	-6.4592032	comment	6.0	127.0	1640577003	-11.8643875
29965890	Is it just my impression or security	"Is it just my impression or security in Jenkins seems much more challenging and more time-consuming than in GitLab? 
This post gives many examples where GitLab was attacked, so of course bad practices like privileged containers can lead to the compromise of a server independently by the technology used, but from my experience with Jenkins, I've seen using passwords in plaintext so many times, even in big companies."	Lucasoato	8.657675	-6.5150228	comment	6.0	21.0	1642422655	11.984259
29979135	Git's CLI is it's greatest weakness.	Git's CLI is it's greatest weakness. Someone should really just scrap that part and rebuild it from scratch on sane ground.	speed_spread	8.566798	-6.494684	comment	6.0	32.0	1642514279	-11.858755
29979604	quick: explain to me the difference 	"quick: explain to me the difference between ""git reset"", ""git revert"" and ""git restore"", without looking up the docs."	_dain_	8.560186	-6.5341973	comment	6.0	24.0	1642516094	-11.910592
29981959	> Are you really shocked that someon	"> Are you really shocked that someone would make a backup before doing something they are unsure of?No, but I'm shocked git is so misunderstood that this would be considered a time to do this.Keeping a backup of previous versions is git's raison d'être. If you can't trust git to do this, how can you trust ""cp"" to make a copy of a file? I would love to get a genuine answer to my question: what do you think git is for and why do you use it? This would help me enormously to understand where you are coming from."	globular-toast	8.57515	-6.442953	comment	6.0	20.0	1642524968	-11.8424225
30026196	Two Phase Commit	Two Phase Commit	clockworksoul	8.708856	-6.53394	story	6.0	97.0	1642784045	-11.836365
30115980	For iOS maybe, but for websites coul	For iOS maybe, but for websites couldn’t you just revert the commit?	symlinkk	8.600695	-6.5151286	comment	6.0	18.0	1643384485	-11.890225
30259458	Every time I was tempted to do somet	Every time I was tempted to do something like this, I hesitated because I didn't want every other line in every file with my name on a single commit, mostly to avoid making git blame harder than necessary. It would be nice if there was a kind of diffing algorithm that can diff code units *syntactically* across history.	wyuenho	8.655293	-6.499917	comment	6.0	25.0	1644333873	-11.772773
30661010	> Flash -> html5HTML5 is definitely 	"> Flash -> html5HTML5 is definitely not simpler than Flash was. I'd argue, it's far more complex, if you include all the sub-technologies and frameworks required to reach feature parity.There was also no ""natural"" progression from Flash to HTML5. Oracle and the browser vendors had to run an involved depreciation campaign to get developers off flash and move them to HTML5. If you had left the web ecosystem on it's own, my guess is, we'd still be writing flash applications today.> Perforce, svn, mercurial -> gitThis progression was definitely natural, but I doubt again that git is less complex than svn or mercurial. However, one big advantage of git is that it is extremely easy to set up: You can just install it and use it locally without bothering any admins or setting up any servers. Once "	xg15	8.630069	-6.4614196	comment	6.0	19.0	1647177876	-11.891466
30712327	Here's how I address this problem.Wh	"Here's how I address this problem.When I'm developing, but before I create a PR, I'll create a bunch of stream-of-consciousness commits.  This is stuff like ""Fix typo"" or ""Minor formatting changes"" mixed in with actual functional changes.Right before I create the PR, or push up a shared branch, I do an interactive rebase (git rebase -i).This allows me to organize my commits.  I can squash commits, amend commits, move commits around, rewrite the commit messages, etc.Eventually I end up with the 2-4 clean commits that your coworkers have.  Often I design my commits around ""cherry-pick"" suitability.  The commit might not be able to stand on its own in a PR, but does it represent some reasonably contained portion of the work that could be cherry-picked onto another branch if needed?Granted, al"	jawns	8.588752	-6.545907	comment	6.0	51.0	1647531554	-11.924482
16400149	There are two different methods to m	There are two different methods to merge pull requests in the article. When do people prefer one over the other?Are there any good reasons why someone should try to rebase and merge (fast-forward) a pull request to avoid a merge commit? It involves more steps than the method which creates a merge commit. What benefits warrant these additional steps?	foo101	8.593637	-6.4894776	comment	6.0	26.0	1518865252	7.7974286
16587380	I believe people have a hard time wi	I believe people have a hard time with Git because it's simply not user friendly. Once you've grokked a handful of essential concepts, Git becomes easy to use proficiently, but both the user interface and documentation are so user-hostile that most people never get to that point.A few examples:- `git reset` command can perform wildly different actions depending on its options- `git revert` does not do what most users would hope it does- if you actually need to revert your working tree changes, you might need to use `git checkout`Naturally, people get confused and reach for the docs, which are filled with even more newbie-hostile terms like 'tree-ish', 'hunks' and 'refspec'.As a result, people tend to see Git as this scary, incomprehensible hairball.	CodeMage	8.557608	-6.5233135	comment	6.0	45.0	1521054278	-11.893619
16703676	This is cool, I guess. Personally co	This is cool, I guess. Personally coding in a terminal like window for me would be awful - I like using my mouse to navigate among folders and save stuff etc in Atom/VSCode like environments. Plus, how often are people switching branches of code that the number of key strokes for git becomes a problem? Seems like an overengineered solution for a very niche audience - if it works for them great though.	patientplatypus	8.625691	-6.4756236	comment	6.0	49.0	1522285508	9.988718
16806255	I don't know anything about Fossil, 	I don't know anything about Fossil, but saying that no one understands Git just makes me think they're ignorant to learning Git. I doubt that's the case, but still, why say that?	deedubaya	8.497647	-6.5481095	comment	6.0	29.0	1523400080	-11.971747
16807592	The number 1 reason my team has not 	"The number 1 reason my team has not moved from Subversion to Git is we can't decide what branching model to use. Use flow, don't use flow, use this model, use that model, no, only a moron would use that model, use this one instead. Rebase, don't rebase, etc. No doubt people will say that it all depends on the project/team/environment/etc., but nobody ever says ""If your project/team/environment/etc. look like this, then use this model."" So we keep on using Subversion and figure that someday we will run across information that convinces us that it is the one true branching model."	irrational	8.548857	-6.497033	comment	6.0	20.0	1523414039	-11.936803
17072267	This rings as a wrong interpretation	This rings as a wrong interpretation of history.When git became successful, there were scant few other options with a comparable feature-set regardless of speed.Its distributed nature, ability to easily merge and rebase sets of changes, etc, were all wonderful solutions to real problems.I'm unconvinced that its success was because it solved fewer problems than the state of the art, but rather that it solved more. This is a stark contrast to vgo which is intentionally solving fewer problems than other modern dependency management tools.In addition, git must be performant enough to handle a git repo (namely the linux kernel, its original usecase). Beyond that, I think there's no evidence it intentionally cut features or complexity to be faster.In the case of vgo, it cuts additional user-faci	TheDong	8.554787	-6.470776	comment	6.0	20.0	1526369680	-11.912391
17103514	Too bad they didn't make Git LFS par	Too bad they didn't make Git LFS part of Version 2[0]. Most vendors[2] support LFS already but because it isn't required, some still lack it and its support cannot be assumed.[0] https://git-lfs.github.com/[1] https://github.com/git-lfs/git-lfs/wiki/Implementations	Someone1234	8.567989	-6.4519544	comment	6.0	27.0	1526666296	-11.915925
17306363	Ask HN: Best Git tutorial for teachi	Ask HN: Best Git tutorial for teaching non technical people the basics	anm89	8.541797	-6.488002	story	6.0	17.0	1528919472	-11.952633
17379513	Not to mention the default main bran	Not to mention the default main branch of a git repo is master	chinhodado	8.513163	-6.524508	comment	6.0	22.0	1529727404	-11.759282
17485381	Do any source control systems have f	Do any source control systems have filetype-aware merge algorithms? We can do something smarter when merging XML than textual line diffs.	cpeterso	8.7402935	-6.47827	comment	6.0	18.0	1531075500	-11.707017
17540464	Supercharging the Git Commit Graph I	Supercharging the Git Commit Graph IV: Bloom Filters	matthewwarren	8.582042	-6.51678	story	6.0	205.0	1531741194	-11.860347
17690567	You know what would make me faster a	"You know what would make me faster at git?""git undo"" : undo the last git command line, whatever it did. Especially if you don't understand what it did or it overwrote local files."	pjc50	8.571363	-6.527118	comment	6.0	21.0	1533464026	-11.886688
17794587	Suppose I asked if there's a practic	"Suppose I asked if there's a practical example of merkle trees in the wild. Someone answers, ""of course: git."" Then 7 troglodyte friends and I jump on github/gitlab/whatever (which is super easy because everyone already uses one of these user-friendly services that wrap around git) and immediately see how git helps us develop by leveraging merkle trees. We realize that the merkle trees are leveraged so that we can ensure (most of the time) data integrity in the history of our source code. Thanks, git!Now suppose I asked if there's a practical example of SSS in the wild. Someone answers, ""of course: ___."" Then 7 troglodyte friends and I jump on ___ (which is super easy because everyone already uses one of these user-friendly services that wrap around ___)and immediately see how ___ helps us"	jancsika	8.576838	-6.4813123	comment	6.0	21.0	1534691857	-5.5374246
17820961	The Git project selects SHA-256 as t	The Git project selects SHA-256 as the next-gen hash function to migrate to	avar	8.669606	-6.51464	story	6.0	133.0	1534963809	-11.814399
21191643	Can anyone point to a good guide and	Can anyone point to a good guide and/or tool for resolving merge conflicts?	psv1	8.712488	-6.486779	comment	6.0	18.0	1570538897	-11.833854
21392727	Explicitly super early, but if this 	"Explicitly super early, but if this got mature it would be really nice since Mercurial has a much nicer UX IMO. So I'd be very happy to use hg to control all of my git repositories. (I'd generally prefer to just use hg for everything, but unfortunately network effects are murder on tools that are explicitly meant for collaboration and integration; there isn't really a ""mercurialhub"", CI/CD support is lacking, etc.)"	yjftsjthsd-h	8.5058	-6.5429745	comment	6.0	149.0	1572387579	-11.968369
21584737	It would be useful in this article t	"It would be useful in this article to hear about what content is acceptable in a merge request. For example: can these all go straight to queue because they use feature flags? Are commits a ""single piece of work"", etc.Not to sound like a downer but this is really an article about fixing a broken process because not running CI on branches before merging to master goes against best practices. Would have loved to actually hear about their work process as this whole article could be summed up as ""not running CI on branches before merging their commits to master is a great way to ruin master""."	dkoston	8.588295	-6.5405383	comment	6.0	69.0	1574263792	-11.921236
21669504	"> In other professions, it's not ""ly"	"> In other professions, it's not ""lying"" or ""dishonorable"" to present your work in the most clear and understandable way to others, it's a basic condition for entry. I don't see how software's any different.That's because you joined the ""it's a story"" camp without noticing. If you instead view git history as a sort of gentlemen's audit log, then ""refactoring"" it is indeed both lying and dishonorable. And in no other profession it would be OK to mess with something used for review / audit purposes.Personally, I'm in favor of the history/audit log view, because you can't predict today what information you may need in the future, and refactoring git history throws away a lot of historical context."	TeMPOraL	8.587982	-6.581464	comment	6.0	34.0	1575112903	-11.916981
21680653	How do you handle situations like th	How do you handle situations like that: multiple dvelopers added merge requests to queue, the changes they made are mutually exclusive (automatic rebase wont work). What happens when the first branch gets merged to master and next 10 are still in the queue ? How do you mitigate that to decrease development cycle ?Lets just say in my company it also takes 30m to run tests and 4h to run them on merge pipeline with FATs and CORE tests.. Its way too long and highly cripples productivity.	pojzon	8.662483	-6.5518355	comment	6.0	20.0	1575273264	-11.888664
39124995	Unsigned Commits	Unsigned Commits	todsacerdoti	8.596957	-6.4594655	story	6.0	14.0	1706145531	-11.860675
39219148	On my work I make 1-15 commits a day	On my work I make 1-15 commits a day. If I have to spend thought cycles on the commit message, that is time that goes from other productive endeavours.I think, as the original commenter also wrote, this might be worth it in much slower paces projects that is run in another cadence / over mailing lists.I particularly think that high paced application development do not benefit from git as documentation.	madsbuch	8.582388	-6.513782	comment	6.0	23.0	1706811009	-11.904585
39220523	The thing is that writing a good com	"The thing is that writing a good commit message for future people doing `git blame` is only worth it if it's a line of code which someone in the future will look at and need to know why it was changed from its previous form to the current form.If you simply want to comment the current state of the code, you should add a comment in the code.No one will ever need to know in the future why that particular space character is an ascii space, so the whole commit message is just a blog entry in the wrong place.It would have made sense to just put a comment at the top of the file saying ""make sure encoding is whatever""."	neilkk	8.613806	-6.529692	comment	6.0	32.0	1706817552	-11.860464
39226611	Sapling – A VCS from Meta	Sapling – A VCS from Meta	bensadeh	8.605573	-6.5237904	story	6.0	77.0	1706864114	12.627645
12613073	I use stash when I forget to branch.	I use stash when I forget to branch. So I might be working and then realize I never branched. So I stash my changes, create a new branch, and then pop my changes on the new branch.	ryanSrich	8.574925	-6.546755	comment	6.0	31.0	1475249746	-11.92396
12651925	I learned to code in a way that the 	I learned to code in a way that the variable and function names also would tell you the why. And otherwise the git log is your friend.Tl:dr; i only do comments to excuse really stupid code.	herbst	8.593768	-6.484058	comment	6.0	27.0	1475757929	-11.891126
12673788	IIRC people DID give fossil a chance	IIRC people DID give fossil a chance but it turned out it could eat your data. So adoption stopped abruptly. Losing data is very difficult for someone who knows how to use git reflog.	plq	8.497123	-6.548525	comment	6.0	20.0	1476050725	-11.995646
12703331	Those jerks who wait until the last 	Those jerks who wait until the last second to merge are actually right	apress	8.735099	-6.4801493	story	6.0	9.0	1476386523	9.196471
12785401	I personally think Git's staging con	I personally think Git's staging concept is one of its best features.  Yes it is different and increases the learning curve somewhat, but it also provides a lot of flexibility in what you commit.  For anyone that thinks Git is too complicated, consider using Mercurial.	xedrac	8.593599	-6.521081	comment	6.0	30.0	1477371389	-11.947859
12786213	The issue here is that git is:1) A t	The issue here is that git is:1) A tool for managing collaborative work through a beautiful distributed graph theory tree model[1]...2) ...with a very, very difficult to use UI.  Unfortunately:3) A good, intuitive UI for manipulating the underlying model without ignoring edge cases or removing functionality is extremely difficult, and indeed, nobody has done it yet.So you periodically see these articles pop up decrying the UI, but nobody ever makes a great UI that wraps the underlying tools.  This article talks positively about gitless, and it's a great tool, but it gets a good UX only be hiding/disabling large chunks of functionality.  And like most tools...4) Git suffers heavily from the 80/20 rule[2].I'd say 95% of the time, I'm using maybe 5% of git's features.  But the other 5% of the	Lazare	8.551431	-6.5070662	comment	6.0	31.0	1477384529	-11.906812
12803474	A large part of the point of Git (in	"A large part of the point of Git (in contrast to earlier tools like CVS) is that the internal data model that it enforces is one that works in the long term in distributed project settings.Distributed source control requires a kind of hygiene, much like dental hygiene, or like cryptographic security. In the practice of hygiene, what's convenient is usually opposed to what's sustainable. Hygiene is effectively the set of discoveries of un-natural or non-intuitive ways to do things that work better than the equivalent intuitive/natural practices. Thus, any process that is ""hygenic"" is going to cause at least a little bit of pain or annoyance to follow—if it didn't, it'd be ""natural.""And that's the fundamental problem with Git: that it tries to paper over the fact that it's ""hygenic"" by prese"	derefr	8.546859	-6.4844275	comment	6.0	45.0	1477554085	-11.9095125
12886430	I agree completely. On that note, I 	I agree completely. On that note, I also consider `git add -A` to be horrible practice. Adding files manually makes you tons more aware of what changes you actually made, and also prevents you from accidentally adding extra files you don't want.I also recommend people to look at the Linux kernel git history for good examples of how to use git well. Even if you have no knowledge of kernel code (and most people don't) it's still extremely clear how each commit makes a single change and is fairly easy to review. Now, the Linux kernel has the luxury of being able to demand people fix their commits, but that's not to say you shouldn't strive to reach similar states in your commits.	DSMan195276	8.576752	-6.5139794	comment	6.0	61.0	1478457974	-11.906732
12965300	> But after closely studying Git I'm	"> But after closely studying Git I'm a little bit awestruck; Torvalds is a frickin' genius, a true visionary, and somehow managed to just ""get it"" and instantly, in a flash of insight, come up with ""the solution"" for version control.Wait, what?  Git was the response from Torvalds to BitKeeper being proprietary and the author being upset with some kernel developers.  It's basically taking what was then state of the art for DCVS and reimplementing it, not coming up with some new paradigm.  It's a good program, and to my knowledge it was engineered well, but let's not rewrite history so Torvalds is the father of DVCS."	kbenson	8.5919285	-6.4571004	comment	6.0	74.0	1479284261	-11.8819475
13074373	I actually have no idea. I had a lot	I actually have no idea. I had a lot of unchecked work - about a weeks worth. (I know, I should not have let it go that far.. it was just one of those tasks that just seemed to get bigger and bigger.) It was time to check in, so I went through file by file staging it all (using Magit). I then decided to do some more testing. Built a lisp image. Then I became distracted, started thinking about home time etc... so my recollection of what I did is a little hazy. I think I saw I had some changes that I wasn't wanting to commit and test. So I think I stashed them. Then probably surfed hacker news or something.. When I got back to things I suddenly noticed that none of my changes were there any more. Nothing was staged, nothing was stashed. It was all gone. I spent a few hours looking around for	weavie	8.55851	-6.515539	comment	6.0	26.0	1480537495	-3.4719985
13261038	Once you get the essence of git (obj	"Once you get the essence of git (objects, graph, commits as snapshots etc) everything becomes really easy. You don't need to memorize all command just need to understand some basic concepts.And some points about the article. Git is a framework actually, you need some workflow to use it in a team. So git requires a lot of discipline from all team members. You can't just ""commit"" as in subversion, you must understand what are you doing. So you can't directly compare git with something like subversion. And git ≠ github.Some points are valid: bad and unclear documentation, no ""included"" workflows, bad command line UI. Author also didn't mention authorship issues, it's a real pain."	sigsergv	8.539922	-6.496676	comment	6.0	19.0	1482808147	-11.905985
13379817	Either I don't get most of the koans	Either I don't get most of the koans or they are intended to disparage git's UX instead of truly enlighten. Is the joke just going over my head or am I not thinking hard enough?	positr0n	8.539693	-6.4520826	comment	6.0	25.0	1484195086	-11.856074
13559855	This is exactly what I was thinking 	This is exactly what I was thinking when I read the article. There is no reason for any Git repo to be that big. It's not a bug in Git, but more like a reasonable limit... if your project exceeds it, you're doing it wrong.I'm also curious as to how they used to do it without git, maybe using TFS? I wonder what the timings on that were.Anyway, I don't think GVFS is the way to go, and I hope that it either doesn't get accepted or doesn't play a role outside of Windows. It's good to see more Git usage, but hacking away instead of fixing the problematic project seems somewhat idiotic. I can imagine other tools having problems with a single project that size, are they going to hack those as well?	oneplane	8.564359	-6.464881	comment	6.0	29.0	1486131009	-11.857704
27580459	I use the Pycharm/Jetbrains Git GUI.	"I use the Pycharm/Jetbrains Git GUI. At this point I can't imagine effectively handling merge conflicts any other way.EDIT:
Also, I really like being able to look at a diff of every file before I commit, and easily choosing which files to include in a commit.  Too often I see people on the CLI accidentally committing changes they didn't mean to, because there is no easy way to check everything at the last minute."	dec0dedab0de	8.636306	-6.527673	comment	6.0	22.0	1624291271	-11.866243
27581737	Git is one of those bizarre products	Git is one of those bizarre products that has remained a leader in its category for almost a decade while being extremely difficult to use, even for experts. Another one of these products is Apache.Why is this?At least from my naive point of view I would expect these extremely user-hostile products to have been overtaken but more user-friendly alternatives. I know the best products don't always win, but when they don't there's often at least some theory about what is going on (network effects, business partnership, government regulation, etc.) that I don't have with these two products.	jonathanberger	8.533424	-6.450565	comment	6.0	19.0	1624298216	-11.896083
27587317	I'd be fine with Git if it wasn't fo	I'd be fine with Git if it wasn't for every single GUI for it being a steaming pile of crap.I use CLI for committing/pushing/branching etc... But anyone who pretends that CLI is adequate for inspecting history and changes or operations such as cherrypicks is a macho pretender.	BrissyCoder	8.5808325	-6.4892263	comment	6.0	21.0	1624329289	-11.851506
27683992	The one feature of perforce (which m	"The one feature of perforce (which my current employer uses) that I miss going back to git is the ""time lapse"" view. It's like git blame but you also have a slider that can scroll through the revisions to a file. This is sorta similar to that, but I still think p4's version is still a better UX."	yissp	8.584129	-6.4915924	comment	6.0	18.0	1625017620	13.831285
27729648	Do people actually do code reviews p	"Do people actually do code reviews per commit? I know it's a thing, but in all my years of experience, I haven't met anyone who actually does this. The usual practice is to review all the changes at once (e.g., go to the ""Files changed"" tab of a PR in GitHub and start reviewing the changes). This, of course, means, that PR are ""small"". If a PR is too ""big"" then one politely asks the author to split the PR in many."	danny_sf45	8.578282	-6.461576	comment	6.0	21.0	1625406863	2.1049027
27738077	Dr. Hipp seems to be trying hard to 	Dr. Hipp seems to be trying hard to promote Fossil as superior to Git. Perhaps it is, but that ship has sailed already. He recently commented in an interview that Fossil is tailored and perfectly suited for the needs of the SQLite project. That's a strong argument in favor of Fossil and all he really needs to say on the topic.	chmaynard	8.493786	-6.550337	comment	6.0	25.0	1625493649	-11.970413
27998614	Sure, but it also removes most of th	Sure, but it also removes most of the reason to use Git.	AnIdiotOnTheNet	8.559118	-6.4686785	comment	6.0	28.0	1627577878	-11.879431
12140161	1-byte docs commit?  Not without a C	1-byte docs commit?  Not without a CLA	chrissnell	8.609857	-6.4943333	story	6.0	13.0	1469136004	-11.837843
12290530	> ... `goops file`, it adds the file	"> ... `goops file`, it adds the file, amends the last commits and force pushes the branchNote that you should only ever do this if you are absolutely sure that you are the only person pushing to that branch.You should consider using ""--force-with-lease"" instead of ""--force"". Otherwise you'll sooner or later overwrite a coworker's push without a trace. Maybe they'll notice know Git good enough to fix this, but it would still be very, very annoying.EDIT: Changed ""repository"" to ""branch"", mention ""--force-with-lease""."	vog	8.574499	-6.5285435	comment	6.0	23.0	1471270340	-11.867193
12358283	I wonder how much time and money has	I wonder how much time and money has been wasted trying to operate Git's confusing UI.  The repository format itself seems fine, but I'm surprised we're not all using a better frontend by now.	panic	8.546017	-6.469091	comment	6.0	51.0	1472125738	-11.885963
12461418	I'm curious: What are the best free 	I'm curious: What are the best free GUI for Git?	Im_a_throw_away	8.563366	-6.4462404	comment	6.0	18.0	1473423317	-11.868474
12480514	Deep knowledge of git is a sign of i	Deep knowledge of git is a sign of immaturity :) There are literally 10 commands one will ever need, which can be conveniently aliased to something more sane. Keep the brain space for something that produces higher value add.	pacala	8.556555	-6.5043225	comment	6.0	25.0	1473694034	-11.901484
12533169	> But I ended up picking Mercurial f	> But I ended up picking Mercurial for the distributed version control system, which we were definitely wrong on that one–should have picked Git.I'm curious to know: is this sentiment widely shared? Is git really that much better than hg?	dude_abides	8.515849	-6.5306907	comment	6.0	27.0	1474306859	-11.946399
35335171	Curious what creative use cases peop	Curious what creative use cases people have around this bizarre file format. The only reason myself and millions of other people have to deal with this stupid file is adding it to .gitignore as part of the ritual of spinning up a new codebase	SOLAR_FIELDS	8.710804	-6.444784	comment	6.0	47.0	1679971207	-11.748514
28088152	> NEVER try to explain HOW your code	> NEVER try to explain HOW your code works in a commentNever is a strong word, sometimes the algorithm is just inherently complex and it's worth it to explain what you are doing.Why is much more important, but it's also partially solved automatically by git blame and adding the task number to each commit message (and writing good commit messages which IMHO is more important than writing good comments). Each line of your code has commit message associated with it whether you care about it or not - make it useful.	ajuc	8.583449	-6.5173955	comment	6.0	25.0	1628262346	-11.912906
28090020	IMO commit messages are for why.	IMO commit messages are for why.	jlc	8.582525	-6.5276904	comment	6.0	22.0	1628269648	-11.913403
28394146	I think it's the other way around. T	"I think it's the other way around. The fact that git does not provide a clean analogous way to intuitively interact with it just demonstrates that the git interface is horribly broken.This is not essential complexity, it's just bad design that stuck.Take a look at https://gitless.com/If you just look at a summary of the commands, you will have an accurate mental model of what's going on:    gl init - create an empty repo or create one from an existing remote repo
    gl status - show status of the repo
    gl track - start tracking changes to files
    gl untrack - stop tracking changes to files
    gl diff - show changes to files
    gl commit - record changes in the local repo
    gl checkout - checkout committed versions of files
    gl history - show commit history
    gl branch - list"	Certhas	8.564913	-6.506212	comment	6.0	32.0	1630600459	-11.916987
28564335	Title is horribly incorrect.Simulati	Title is horribly incorrect.Simulating git would be more appropriate.I expected this to be a look at other version control systems around today. It's yet another 'let's recreate git from scratch, kinda' post.	_hilro	8.597695	-6.4575543	comment	6.0	24.0	1631879456	-6.387371
22455933	Your Gitbooks link seems to go to so	Your Gitbooks link seems to go to something about Go?	saagarjha	8.629642	-6.488099	comment	6.0	18.0	1583053563	10.209625
22489687	If you've never had a git commit FAI	If you've never had a git commit FAIL (eg https://github.com/okonet/lint-staged/issues/565) you aren't very experienced with git. By your description, you've probably just used it casually a lot. You don't do anything complicated and conclude that git isn't complicated. Given the history of working with:* Submodules* Binaries* Large Repositories/branches* A disparate set of development platforms/clients* Git auth/credentials	Supermancho	8.555951	-6.482145	comment	6.0	24.0	1583367571	-11.965081
22491412	I'm in the camp that rebasing is unn	I'm in the camp that rebasing is unnecessary and useless for large projects.  I work in a code base with 50 other devs, no one is reading the commit log line by line, there are 100 commits per day.  We use JIRA and have to prefix our commits with TICKET-<ID>. If I want to see the commits for a ticket, I filter the git log on that. If I want to see the combined diff for the commits, I open up the PR in JIRA.Squashing public commits I'm also against. People say it 'cleans' the history. I would say it erases it. Who, when, why - all gone.  For what? to save a few commit lines? Like I said, our commits are tagged with the ticket number already, if you want a summary of what the changes were and all the commits that were part of it, you open the ticket, or filter the git log on the ticket. No n	trixie_	8.571926	-6.547054	comment	6.0	35.0	1583389751	-11.949315
23296805	Unpopular opinion: This is how git r	Unpopular opinion: This is how git rose to where it is today. If people were less blinded by celebrity status, they'd see that Linus' lack of exposure to paradigms beyond C such as OOP or FP (due to deliberate disdain; his loss) meant that C pointers were the primary abstraction on which he built git, and that it suffers greatly because of this. Not to mention that good UX is a rare skill among developers in general. See https://stevelosh.com/blog/2013/04/git-koans/Mercurial should have won. And Plastic SCM is awesome, designed conceptually from the ground up to build on lessons learned from git (and by an Associate Professor in CS). In fact, the whole concept of DVCSs is ridiculous in 99% of corporate contexts where you can't use your laptop / desktop at home without logging in into the V	vijucat	8.525241	-6.5225644	comment	6.0	24.0	1590370223	-11.911147
23360223	The Myers diff algorithm that is use	The Myers diff algorithm that is used in Git (2017)	dgudkov	8.740519	-6.488689	story	6.0	122.0	1590836104	-11.752124
33072673	Other day I started using a remote m	Other day I started using a remote machine and after some months a git command behaved unexpectedly. I checked git version and it was a very old one. I realized that I'm not using any new feature of git.What am I missing? Which somewhat newer Git feature or configuration are you using that is useful?	neves	8.550756	-6.4783664	comment	6.0	18.0	1664826314	-11.879393
33388267	Its tragic how either/or git is.Both	Its tragic how either/or git is.Both are great in different ways. If Im trying to understand a complex tricky bit of code, a long string of small commits is ideal. If Im browsing a repo, large squashed commits or PRs are better.It's be great to have better heirarchy, to get both.	rektide	8.581525	-6.521854	comment	6.0	32.0	1667080140	-11.928452
33532570	How is push origin HEAD --force-with	How is push origin HEAD --force-with-lease different from normal git push? Can someone please explain this to me?	distcs	8.549938	-6.4850683	comment	6.0	24.0	1668006272	-11.877289
33534751	This is off topic:I have a dumb git 	This is off topic:I have a dumb git question and I can never seem to formulate a google search that will help me.I use a Mac and for some reason I am able to use `head` (lowercase) instead of `HEAD` (uppercase) in every command and its trained in my muscle memory.So when I go to another computer, this shortcut isn't there, so when I type `git reset --hard head^` I get an error, and I have to go back and change it to `git reset --hard HEAD^`.Anyone know of a configuration option or something somewhere that I can enable this?	jgworks	8.553066	-6.518725	comment	6.0	18.0	1668014343	-11.874308
33534045	Git commit crafting (and rebase to a	"Git commit crafting (and rebase to achieve it) is overrated. If you care about crafting beautiful series of commits so that the future readers understands what's going on: don't. Context is more useful to find out why something changed. Example:- you build feature F that is touching N files and M lines of code- you craft your git commits so that each of them is atomic and ""understandable"" on its own- now if I want to see the context of change for line X, I won't get the changes in all the N files... I'll get your crafted commit that updates only line X (worste case) or its immediate surroundings (best case). But how do I get the full context (i.e., this line is about feature F)? I have to git blame lines around line X and see if I can actually make a picture of the bigger feature. Examples"	danwee	8.577888	-6.538066	comment	6.0	41.0	1668011768	-11.913849
33613803	This won’t go anywhere even if its 2	This won’t go anywhere even if its 20% better than git. To replace git’s network effects, you need to be 10x better.How I think that will happen is using CRDTs against an AST to remove most merge conflicts.	nailer	8.628215	-6.53827	comment	6.0	25.0	1668540690	-11.864233
33626969	The git UI built into JetBrains IDEs	The git UI built into JetBrains IDEs is the only thing that makes git work for me. It's very intuitive to use.Cmd+K to commit changes. There's a list of all files changed, organized by file hierarchy. You can click any of them to get an embedded editor and you can edit right from there.There's a VCS pane you can pop up to view commits from any of the branches you have pulled without switching, you can select commits and right click > cherry pick to pull them into your current branch.And the diff resolver is perfect. 3 vertical panes with the incoming and local changes on the left and right, and center is the merged product. You can press arrows on each side to bring those changes into the center, it shows right where they'll go with colored highlighting before you even make any changes. An	hbn	8.615218	-6.5070524	comment	6.0	22.0	1668619875	-11.83828
33653552	I just ran into this problem last ni	I just ran into this problem last night... if you shouldn't rebase after pushing to remote, how do you update a PR days after you originally created it to be on top of the latest origin/master and be able to resolve merge conflicts locally?	chrisshroba	8.578234	-6.5590463	comment	6.0	22.0	1668773941	9.364814
33653474	When I realized it's just a DAG and 	When I realized it's just a DAG and you're just manipulating a graph and pointers.Then it just became a matter of mapping git CLI commands to how they manipulate the graph.	doix	8.572034	-6.492551	comment	6.0	35.0	1668773287	-11.889039
33710974	I love neovim but I don’t have a goo	I love neovim but I don’t have a good replacement for the git plugin of vscode. I haven’t found my way to replicating that experience in neovim. I tried lazygit but I find the diff viewer hard to understand and navigate. Diff view (https://github.com/sindrets/diffview.nvim) might be it, but I haven’t made the time to install a newer version of git from source (Debian…)	barefeg	8.738622	-6.4877167	comment	6.0	19.0	1669148706	-11.72654
33761384	The Terrible UX of Git (2021)	The Terrible UX of Git (2021)	tipiirai	8.554435	-6.479029	story	6.0	7.0	1669537413	-11.894393
33804442	I finally understand why some people	"I finally understand why some people are so against rebase. They're doing it wrong.I've always heard people talk about how it doesn't scale, but I use rebase like 99% of the time, and have worked on projects with hundreds of ICs. This is the first time I've seen someone explain it in a way where I get it. NO I'M NOT FORCE PUSHING TO MAIN YOU SILLY NILLY! Turns out I'm ""squash rebasing."" I guess I didn't know I need to specify that.I do it slightly differently tough. I use git commit --amend to build up a single commit as I go.    git checkout -b blah-feature

    # do some work

    git commit -m ""Main description of my feature""

    # do more work

    # no -m, and then I just add bullet points for each subsequent change in vim (example below)
    git commit --amend


Then, once I'm ready"	itslennysfault	8.571821	-6.559752	comment	6.0	24.0	1669830274	-11.91747
34062915	I think the argument that calling gi	"I think the argument that calling git branches ""master"" hurts people is ridiculous, but I also think that ""main"" makes more sense. The master/main branch doesn't have any power over other branches - it's just the one that you happen to use primarily. ""Main"" describes that better."	resonious	8.515982	-6.522404	comment	6.0	21.0	1671522918	-11.723259
26645645	> The difference between signed tags	> The difference between signed tags and signed commits is minimal — in the case of commit signing, the signature goes into the commit object itself. It is generally a good practice to PGP-sign commitsNote: Linus says otherwise, the two are very different: http://git.661346.n2.nabble.com/GPG-signing-for-git-commit-t...One of the most important reasons it doesn't make sense to sign commits is that keys expire so when you sign something you implicitly say it is valid at most until the key is valid; nothing can be guaranteed after that. It is easy enough to re-sign a tag (even automatically) but you can't re-sign a commit without changing its identity and that defeats the whole purpose of git.The only reason you'd want to sign commits is to defend from malicious maintainers ie if your patch i	rakoo	8.582034	-6.4692197	comment	6.0	27.0	1617187763	-11.773222
26704171	I don't know the name of this type o	I don't know the name of this type of learning style but I would eat up a tutorial on Git that started with the plumbing commands like this and worked their way up. I think this is oddly one of the clearest explanations of Git I've ever read. I know that wasn't really the point of the post but still.	Spivak	8.572945	-6.5536633	comment	6.0	18.0	1617654179	-11.927991
26742041	> I think it's a tragedy that just a	> I think it's a tragedy that just about every developer uses git but most learn add, commit, branch, and merge and then just stop learning.This is because Git is too hard to use.How do I know that Git is too hard to use? Because there are literally thousands of blog post tutorials explaining how easy Git is to learn. Things that are easy do not need thousands of different guides telling you how easy it is.	forrestthewoods	8.543771	-6.501095	comment	6.0	21.0	1617906234	-11.907888
26742137	I think this is incorrect, no?Can’t 	I think this is incorrect, no?Can’t all commits be turned into patches? Thus, aren’t commits isomorphic to diffs?	breck	8.61957	-6.5207033	comment	6.0	21.0	1617906782	-11.828593
26742507	This is the thing though. You're tal	This is the thing though. You're talking about snapshots which actually have duplication removed... in my mind this really fits more with the 'diff' model. I've already done the exploratory diving-into-git-internals thing years ago, so I could develop a better understanding of how things actually work.But for newcomers who want to understand how git is working, it really makes more sense to tell them it's 'like a diff. Not exactly under the hood, but think of it like a diff for now'.  This is what I've been telling people as I've mentored a number of people in getting acquainted with git over the years, and if they're curious enough to look under the hood, they'll get a better understanding of the internals.As a programmer, what you're working with is essentially the diff. This is the easi	hmsimha	8.603686	-6.5340133	comment	6.0	22.0	1617908879	10.268348
26923639	Sure you can force push it, but the 	Sure you can force push it, but the reviewer has to review the whole branch all over again. No diff between versions of the branch.	pritambaral	8.586061	-6.4921174	comment	6.0	25.0	1619257656	2.1668537
27105767	Director of Eng gave me surprisingly	Director of Eng gave me surprisingly poor feedback. Should I escalate to VP?	angebracht	8.569254	-6.51438	story	6.0	2.0	1620653420	-11.913535
27435655	"long long long time ago 
Fossil dest"	"long long long time ago 
Fossil destroyed code for Zed ShawAnd since that day, not one looked at Fossil the same way, at least not the same way they looked at githttps://www.mail-archive.com/fossil-users@lists.fossil-scm.o...I can't tell for sure how much of impact this had on fossil's adoption, its hard to beat git no matter how good you are, but I think it was a bit hit"	systems	8.497613	-6.547807	comment	6.0	25.0	1623162604	-11.996113
37622377	Well, do you use GitHub or an equiva	"Well, do you use GitHub or an equivalent?The point of this, as the article states:> These additional capabilities are available for Git as 3rd-party add-ons, but with Fossil they are integrated into the design, to the point that it approximates ""GitHub-in-a-box.I’ve not used fossil, but I appreciate this idea.Sure, it’s not unixy, but maybe a VCS reasonably demands such features, and today, it’s not as though these are crazy advanced or complex features."	maegul	8.503076	-6.476522	comment	6.0	34.0	1695469464	-11.906153
37800067	OK, Git is easy? I got a trivial sou	OK, Git is easy? I got a trivial sounding task for ya: delete 1 file from (all commits in) a repository with 100's or 1000's of commits.Without using any external tools. You've got 5 minutes. Should be plenty of time to delete 1 file and/or figure out how to do that simple task right?Good luck.	bboygravity	8.612191	-6.4590106	comment	6.0	27.0	1696667799	-11.915501
37810949	I love these posts. I bookmark all o	I love these posts. I bookmark all of them.I feel strongly that VCS's could have much better UX and reliability. I'm trying to design one myself instead of implementing it in a weekend. (Though I do understand the constraints Linus was under when he made Git.)I'd love to hear more about what people hate about Git.	gavinhoward	8.56287	-6.470667	comment	6.0	46.0	1696776503	-11.877158
37996440	Everyone committing to the main bran	Everyone committing to the main branch all the time sounds like a nightmare to me, to be honest.  I would probably seriously consider quitting if this was forced on me.(Or rather, I would probably just run on my private git copy, and only pull every once in a while, and ignore that the main branch always changes.)When / how do you do code review in your suggested workflow?	eru	8.580011	-6.4841228	comment	6.0	32.0	1698137670	2.1675613
38031398	Windows used to have a version contr	Windows used to have a version control called Visual Source Safe.You'd have to select files you want to modify and check out them. Then they're locked. No one else in the team can touch them.God forbid you forgot to check them in at the end of the day and are not at work for a week then those files are locked and don't even have your changes.Yet to talk about branching.Better then that was svn which was no less horrible.So net result was that around 2000s, there was no concept and culture of version control for the windows developers. Pretty much. It was difficult to do, was cumbersome and such.Then came git. Offline, distributed, instant branching without creating a whole copy of the project and what not. It came from Linux but it's ease of use and feature set made it defacto in Linux wor	wg0	8.624101	-6.449451	comment	6.0	22.0	1698352721	-11.871985
38111275	"The filter[0] attribute with ""smudge"	"The filter[0] attribute with ""smudge"" and ""clean"" would be a better solution for storing SQLite into git.[0] - https://git-scm.com/docs/gitattributes#_filter"	redleader55	8.608425	-6.493071	comment	6.0	30.0	1698919808	9.906815
38116358	"It's been about a decade since git """	"It's been about a decade since git ""won"" the version control war due to the (yet another) unjustified tech hype wave, and we're still having difficulties with what should be trivial tasks.
I remember reading a comment by Linus Torvalds being surprised that people started using git directly rather than putting a friendlier layer on top. If it was capable of introspection, the industry would admit it made a mistake by going with git and switch to another VCS instead, rather than wasting huge amounts of time on a tool whose only job is to save text."	Tomis02	8.569704	-6.478155	comment	6.0	62.0	1698943719	-11.88372
38160321	I wonder how much the “victory” of g	I wonder how much the “victory” of git vs mercurial was influenced by having a big name like Linus Torvalds behind it.	Xenoamorphous	8.558211	-6.494548	comment	6.0	27.0	1699261934	-11.944675
38161030	Speaking for myself, coming from git	"Speaking for myself, coming from git, I found the branching model of Mercurial hard to understand.  Then it turns out that instead of branches I should have been using ""bookmarks""?  But which to use when?I tried to work on a Mercurial-based project (not firefox) but eventually gave up and just used git to track my changes and then prepare, very carefully, specific big merged commits to contribute back.  It was easier, because I could never figure out how to clean up properly if I made a mistake -- so this way, I could just wipe the local copy and start over instead.  But it was annoying, and I was glad to stop using it.Completely bewildered by every thread about mercurial full of people proclaiming its advantages and ""simpler mental model"".  Simpler than a DAG with pointers?  Sure.If I rem"	radarsat1	8.523282	-6.559422	comment	6.0	38.0	1699268479	-11.942414
38165161	I like how Atlassian puts it:> The g	I like how Atlassian puts it:> The golden rule of rebasing> Once you understand what rebasing is, the most important thing to learn is when not to do it. The golden rule of git rebase is to never use it on public branches.https://www.atlassian.com/git/tutorials/merging-vs-rebasing#...For me, even though rebasing comes with some trappings, I still greatly prefer it to the alternative, which is to have merge commits cluttering up the commit history.	jawns	8.577822	-6.5706654	comment	6.0	193.0	1699289998	-11.9875555
38165389	Never understood why you wouldn't wa	Never understood why you wouldn't want it clean. There's no benefit whatsoever to it being messy and it's a liability for a lot of reasons, whereas the clean version is free and easy and makes everything you do that interacts with git history simpler.	ajkjk	8.571613	-6.541759	comment	6.0	49.0	1699290883	-11.885129
38165421	I actually hate squash merge because	I actually hate squash merge because of all the noise it adds. Sure, the commit graph looks nicer, but it come with a terrible loss of information when doing git blame.I'm a big proponent of rebase and squash if it helps to make a commit more coherent, but we use squash merges by default in the current project I'm working on, and I die a little bit each time I try to understand what changes were related to a line when tracking down a bug.	mablopoule	8.577479	-6.587202	comment	6.0	52.0	1699290996	-11.922902
38166399	I ser it the other way around - why 	I ser it the other way around - why spend time on a ‘nice’ commit history in a (smallish) feature branch when you can squash merge later.I prefer one commit to main per feature, a long with a good description on the GitHub PR.Sometimes I’ll branch out from a feature branch for the occasional and infamous ‘get CI working’ round of 10 one-line commits though, to not make it too muddy.	bogeholm	8.585324	-6.5423455	comment	6.0	66.0	1699294613	-11.911034
38172251	That looks like the PR from hell - 1	"That looks like the PR from hell - 190 files changed, 143 commits? Mostly with names like ""tidy"" and ""wip""Props to whoever actually reviewed that, you are a warrior"	scorpion_farmer	8.599853	-6.459412	comment	6.0	55.0	1699322727	-11.883682
38172275	I prefer to read the unified diff an	I prefer to read the unified diff and commits don't matter as much.	lrx	8.598294	-6.5252275	comment	6.0	48.0	1699322909	-11.8980255
38172494	don't know why, but recent teams aro	"don't know why, but recent teams around me have always made strict rules about number of commits in PRs. I just wanted to tell them the same thing you said: ""Why don't you just look at the diffs?"" curious for other opinions. (sorry not really about this particular topic)"	readline_prompt	8.582537	-6.4929967	comment	6.0	32.0	1699324611	-11.887928
38370715	FB/Meta replaced Mercurial with Sapl	FB/Meta replaced Mercurial with Sapling which is git-compatible: https://engineering.fb.com/2022/11/15/open-source/sapling-so...Mercurial is over.	wmf	8.511308	-6.544258	comment	6.0	35.0	1700603122	-11.960705
38371263	I liked the thorough article, but my	"I liked the thorough article, but my goodness did they beat around the bush w/regard to their actual contribution to this process (per the title).I think the short version is: they made `git-cinnabar`, which is a git-to-hg translator, to help git users interact with the Mozilla repos.----One contribution I can make:> For reasons I don't know, Mozilla decided to use separate Mercurial repositories as ""branches"".Originally, separate clones was the recommended way to do ""topic branches"" in Mercurial (not to be confused with ""named branches""). There was no direct equivalent to git's branches. Eventually, Mercurial got 'bookmarks' which basically closes that gap, but that only became a core feature in 2011, well after these Mozilla repos were established.----Aside: I prefer Mercurial myself, an"	interroboink	8.515853	-6.5531654	comment	6.0	38.0	1700605380	-11.951699
38393905	While the explanation is right in so	While the explanation is right in some sense, it misses a few points.Branches are pointers to a commit and that pointer is refreshed when a new commit is created. One could say they are a wandering tag (without explaining a tag for now).The actual chain of commits that represent what we see as branch comes from the commits themselves. Those commits point back to their parent commit.And then one can see why no branch has any special meaning: It is a chain of related commits with a named entrypoint. Once you delete a branch (i.e. the named wandering pointer to a commit), you cannot identify a branch as such anymore. It is just a chain of related commits without a named label now. And nothing besides the name distinguished the branch from other commit chains before.The master/dev/release bran	riperoni	8.574629	-6.5275087	comment	6.0	72.0	1700753972	-11.916846
38396957	I’d love to see a project that would	I’d love to see a project that would do this, but more generally.I don’t use GitLab CI, but I do use a good handful of other file types that essentially inline shell scripts. Dockerfiles, GitHub Actions, and Justfiles, just to name a couple.Usually, and almost exclusively for the sake of ShellCheck, I make a point of putting anything more complex than a couple of commands into their own shell scripts that I call from the inlined script in my Dockerfile.(This pattern also helps me keep my CI from being too locked into GitHub Actions)	brirec	8.465833	-6.437545	comment	6.0	24.0	1700770118	9.058277
38590411	Subversion was really good. It wasn'	"Subversion was really good. It wasn't perfect, but it was relatively painless.Instead everyone switched to a ""distributed"" version control system that is such a pain in the ass it is all now hosted by a single company."	mike_d	8.621289	-6.453015	comment	6.0	31.0	1702201473	-11.854837
14803177	Reminds me of one of the nice featur	Reminds me of one of the nice features of Git: git bisect. Find the breaking commit in the smallest number of steps.Some random blog post about it: http://webchick.net/node/99	warpech	8.583251	-6.521349	comment	6.0	33.0	1500458906	-11.916363
14836260	Nginx and Git.Nginx has a lot of res	Nginx and Git.Nginx has a lot of respect on the market for handling high concurrency as well as exhibiting high performance and efficiency.I don't even have to speak about the Git architecture. It speaks plainly for itself.There's a series of books called The Architecture of Open Source Applications that does justice to this topichttp://aosabook.org/en/index.html	elorm	8.577693	-6.456171	comment	6.0	53.0	1500877531	8.871447
14861835	What's the easiest way to view the a	What's the easiest way to view the actual commit diff? I'm curious about what version of clang they're using, as the message indicates that they were using gcc4 before, which is fairly old.	saghm	8.622346	-6.5514174	comment	6.0	68.0	1501117721	9.83528
15263668	What's even the point of using rebas	"What's even the point of using rebase? Merging the development branch into your feature branch periodically is the obvious history preserving thing.Git already has merge commits, that can be used to label and describe bigger sets of changes in retrospect. There is no need to rewrite the commit history with the benefit of hindsight, it only erases the record of how changes were arrived at, thus losing the opportunity to revisit conclusions from debugging or experiments.You can also use merge commits to describe sub-units of work in your feature branch. Just rename your branch to some subtask and merge that into your feature branch.edit: towards the middle of the article, the author also opines
""What motivates people to rebase branches? ...
I’ve come to the conclusion that it’s about vanity."	fulafel	8.573401	-6.5676284	comment	6.0	31.0	1505551924	-11.919478
15312793	Seems pretty difficult to use, almos	"Seems pretty difficult to use, almost on the same level as trying to learn to use vim/emacs on 2017, somehow i expected a ""poweful (G)UI"" rather than a text-based one. Anyone has a good recommendation for a good GUI for GIT, GIT-GUI its a really confusing and jetbrains integrations felt like someone with heavy background on cvs/svn made the interface."	SadWebDeveloper	8.59342	-6.4816117	comment	6.0	41.0	1506092574	-11.856209
15374341	Git, Graphs and Software Engineering	Git, Graphs and Software Engineering	tsemple	8.547116	-6.471398	story	6.0	110.0	1506796867	-11.880766
15375136	Except most hard but interesting ope	Except most hard but interesting operations with Git are not very visible in histories.They are:- getting a clear status of you repo so you know where you are and what you do;- figure out which one of the various method of undo you need for this specific screw up;- find a practical way to compare this particular version of a snippet with another particular version of a snippet, and work on the result;- merge the terrible mess you coworker rush-pushed to avoid to be the one to have to merge;- rediscover the arcanes required to save only what you want. Maybe I should branch and commit. Or stash. Or reset and add. Or do an interactive thingy ?- survive a rebase with squashing;- use the history, trying to look for clues of what the heck is going on with the current version of your code.- setti	sametmax	8.585437	-6.5267043	comment	6.0	34.0	1506807906	-11.876226
15726260	> in others it is flat out wrong. Gi	"> in others it is flat out wrong. Git was designed for tens of thousands of developers (the Linux kernel),This is easy to check, and the article is right. The Linux kernel does not have tens of thousands of active developers. Over a little more than the last year:    titan:~/src/linux geofft$ git log v4.8..v4.14 --format='%aE' | sort -u | wc -l
    4857

If you look at just the most recent release cycle:    titan:~/src/linux geofft$ git log v4.13..v4.14 --format='%aE' | sort -u | wc -l
    1839

Alternatively, if you look over the last ~year, but at people who have more than five commits (chosen arbitrarily):    titan:~/src/linux geofft$ git log v4.8..v4.14 --format='%aE' | sort | uniq -c | awk '$1 > 5' | wc -l
    1814

A codebase with 20,000 actively working on the code base is at least "	geofft	8.562833	-6.463918	comment	6.0	39.0	1510955242	-11.872544
20469144	I'm a forgetful person, so I commit 	"I'm a forgetful person, so I commit very often but with label ""tmp"", and later I squash them all into 1 proper commit before pushing. I'm sure I'm not alone, so commit time can't be used as barometer."	wiradikusuma	8.583291	-6.53207	comment	6.0	41.0	1563453783	8.942215
20576302	But why can't the committer just ref	But why can't the committer just reformat (and otherwise improve) the patch when accepting? Why make the extra round-trips to the submitter?	floatboth	8.631435	-6.4768634	comment	6.0	18.0	1564593646	-11.846968
20577303	This seems so backwards to me. Why n	This seems so backwards to me. Why not do it as part of your CI process where you're not foisting unnecessary tooling on your developers local machines? The lag involved in spinning up and running the commit hooks is noticeable and disruptive especially if you commit often and rebase locally.	huntedsnark	8.73452	-6.503235	comment	6.0	21.0	1564600733	-11.907836
20647093	It's a horrible trend. CI should not	"It's a horrible trend. CI should not be tied to version control. I mean we all have to deal with it now, but I'd much rather have my CI agnostic and not have config files for it checked into the repo.I've browsed through the article you linked to, one of the subtitles was ""Realizing the future of DevOps is a single application"". Also a horrible idea: I think it locks developers into a certain workflow which is hard to escape.  You have an issue with your setup you can't figure out - happened to me with Gitlab CI - sorry, you're out of luck. Every application is different, DevOps processes is something to be carefully crafted for each particular case with many considerations: large/small company, platform, development cycle, people preferred workflow etc. What I like to do is to have small "	snitko	8.6319275	-6.438638	comment	6.0	32.0	1565288372	8.953532
20891248	CL? Is that perforce? Hopefully it w	CL? Is that perforce? Hopefully it works better than the real perforce. A really tough and confusing versioning tool.	jorblumesea	8.673888	-6.4960318	comment	6.0	21.0	1567722835	13.831412
20998279	Related question. Is it possible to 	Related question. Is it possible to use Gitlab CI with a runner running on your own hardware to get unlimited CI time? I'd like to take a machine at my home and use it to run automated tests/etc, especially because some of the integration tests can be quite long (ie, chewing up CI minutes).I thought this was possible, but after searching I was often confused. I imagine I'm using poor terms during my search. Thoughts?	asdkhadsj	8.462818	-6.4416027	comment	6.0	21.0	1568743701	8.955035
13643915	"""Because Pijul is based on a mathema"	"""Because Pijul is based on a mathematical model of collaborative edition, its behavior matches intution, every time.""That's not how math and/or intuition works."	mhd	8.602635	-6.56862	comment	6.0	27.0	1487084688	13.890819
13669456	I dont see the point of Fossil, I lo	I dont see the point of Fossil, I looked into it. The commands arent that much easier to understand. If I'm using an SCM anyway and I still need to use a cmd line and I still need to memorize commands then I might just as well use git. And Git has Guis now.	hubert123	8.501303	-6.5287914	comment	6.0	27.0	1487349148	-11.966889
13670084	This is a good point. I think once d	This is a good point. I think once developers learn Git (or as much as they need to use), then they forget how esoteric the the cli tool is.I think a lot of devs have the attitude that a tool being more difficult to use makes it a powerful one (cf. Vim/Emacs), whereas most people are happy when tool does the three things they need to get from a=>b, b=>c, a=>c.Maybe this is to do with our desire for everything to be as flexible as the programming languages we write in. Most people don't view computers as blank slates ready to do their bidding, but as systems where the behaviour of a few facets is to be memorised without concerns for their mechanics or abstractions. This is probably one of the reasons that mobile software is seen as so easy to use, since it obscures/abstracts elements like t	bananaoomarang	8.601106	-6.5138264	comment	6.0	31.0	1487352992	-11.84999
13907341	That's exactly what this change is. 	That's exactly what this change is. You mean why wasn't it that way before the change? Maybe because it wasn't ever needed before? Git's been good with only sha-1 for 12 years. Think about the flip side of your question... what were the alternatives 12 years ago, or 5 years ago? And why would someone write code for alternatives that aren't expected to be used and maybe don't exist?In my experience, generalizing ahead of need more often than not causes problems, and I've watched over-engineering result in far more effort to fix when the need it was anticipating does arrive than just waiting until the need is there.	dahart	8.668062	-6.5198545	comment	6.0	29.0	1489934483	7.1744514
13925390	Got 15 minutes and want to learn Git	Got 15 minutes and want to learn Git?	fgeorgy	8.5119705	-6.4461937	story	6.0	88.0	1490124579	-11.904264
14133870	Every day:$ git pish$ fuck	Every day:$ git pish$ fuck	m4tthumphrey	8.552413	-6.4776316	comment	6.0	45.0	1492458702	-11.881774
14534872	To be fair git is junk; it's just th	To be fair git is junk; it's just the standard so everyone has mostly learned it and it gets the job done, but at least Mercurial is better. Probably bzr too. I have probably 5 more years experience with it than Mercurial and I'm still googling for the correct incantation for things that are just infrequent enough for me to commit them to memory. With Mercurial, the command is what you would expect 90% of the time.	weberc2	8.514969	-6.541959	comment	6.0	67.0	1497233777	4.529449
30743892	Meld might be useful for comparison,	Meld might be useful for comparison, but in my opinion it is inconvenient as a git merge tool. For git merge I need four panels: original file, version A, version B, merged result. Meld has only three panels.Currently I am using KDiff3. It is a little buggy and doesn't have a nice UI but it is the best open source merging tool that I am aware of. It allows choosing lines from original file, from A, B and manual editing.I noticed that certain popular and highly praised commercial IDE also provides only 3-panel interface for merging. This makes resolving conflicts more difficult and prone to errors.	codedokode	8.668186	-6.5075145	comment	6.0	23.0	1647792813	9.204919
30787577	"I wonder if we should let ""git"" foll"	"I wonder if we should let ""git"" follow this rule, sometimes."	m463	8.558514	-6.491677	comment	6.0	19.0	1648112581	-11.942227
30816223	The author of Fossil considers rebas	The author of Fossil considers rebase harmful, and because of that, it wasn't implemented[1].I'm not a fan of that decision. I don't want to live with my mistakes forever, especially on local branches.[1] - https://www.fossil-scm.org/home/doc/trunk/www/rebaseharm.md	xeeeeeeeeeeenu	8.524329	-6.5682034	comment	6.0	28.0	1648336672	9.479125
30910706	>tinygrad will always be below 1000 	>tinygrad will always be below 1000 lines. If it isn't, we will revert commits until tinygrad becomes smaller.Love this ethos so much.  Wish more projects would follow suit.	jonahx	8.578977	-6.521156	comment	6.0	48.0	1649098990	-11.855148
31048899	> Bonus points for no PR’s and trunk	> Bonus points for no PR’s and trunk driven development as that shows a very mature team.Ugh, pass. Trunk development is fine. Skipping PRs just brings back nightmares of SVN. Even if 90% of PRs are approved without comment, it's extremely helpful for everyone to have a second set of eyes on work before it is merged in.	zdragnar	8.613633	-6.5072126	comment	6.0	111.0	1650077541	-11.89282
31174161	I hate that rule about 50 characters	I hate that rule about 50 characters. IIRC, it started because someone noticed that the average commit message in the linux kernel is about 50 characters. Then, for whatever reason it morphed into this widely propagated mantra saying that the maximum should be 50 characters.	ufo	8.641879	-6.530034	comment	6.0	20.0	1651013578	-11.876252
31306122	git is line based, so good for code.	git is line based, so good for code.But not for most markdown files, at least how I use it. I only start new line (actually, 2 new lines) when I reach a new paragraph, and I think this is normal for most people who ever write something in markdown.So now I get a huge 2000 character line with a few small edits, and I can hardly see where the changes are.	chaoxu	8.628512	-6.492124	comment	6.0	24.0	1652031003	-11.71607
31635323	What large team workflows require re	What large team workflows require rewriting history? I’m genuinely curious as someone who is always looking for a better team git workflow.	dmtroyer	8.570106	-6.519803	comment	6.0	41.0	1654467370	-11.931079
31697796	As an avid git worktree user, I use 	As an avid git worktree user, I use multiple checkouts for the same repo all the time. It avoids a lot of context-switching pain.	froderick	8.585642	-6.5401464	comment	6.0	24.0	1654886089	-11.900399
25811971	"Why do you need to use a git ""client"	"Why do you need to use a git ""client""? What's wrong with just using the standard CLI? I use VS code and never bother with its git ui. Just open a terminal and use git commands."	perryizgr8	8.588831	-6.488306	comment	6.0	24.0	1610900478	-11.847933
25979200	I hope it works out. What I do, is c	"I hope it works out. What I do, is create a file, usually called something like ""DoNotCheckThisIntoSourceControl.swift"", and then put that in a directory called ""DoNotCheckThisIntoSourceControl"". I then add ""DoNotCheckThisIntoSourceControl"" to my .gitignore.Clunky, but it works. I add things like server secrets and whatnot, there. I keep the file small, and usually add the contents to a secure note in 1Password, so there is version control, of a sort."	ChrisMarshallNY	8.604036	-6.455442	comment	6.0	23.0	1612104546	-11.82708
26189351	Hello from the bizarro universe of p	Hello from the bizarro universe of people who do this all the time and can't imagine the opposite. Do you never rewrite some code only to realize it didn't precisely capture all the edge cases of the thing you rewrote? In those cases I use the git gutter in VSCode to view what the old code looked like and compare and contrast to the new version to see what I missed. It seems to me that that's the same as what these engineers are doing, just with a bit more primitive tooling.Can't imagine how anyone doesn't do this - unless there's just a race of God-programmers I've never encountered that write everything perfect the first go. But I don't think so. :-)	johnfn	8.710322	-6.523275	comment	6.0	24.0	1613705774	-11.824184
26240021	You wouldn't publish a first draft, 	"You wouldn't publish a first draft, but neither would you burn it once the final draft was off to the printer. Personally, I'd prefer it if ""squashing"" commits was purely a UI thing; the underlying commits were all still there, but grouped together and displayed as a single big ""virtual"" commit. That way you could still drill down to the real history if you needed to."	professoretc	8.577815	-6.5574856	comment	6.0	29.0	1614101186	-11.9670515
26241867	As a much newer developer, the bigge	As a much newer developer, the biggest problem I have with git is that I rarely end up actually making one change at a time. I'll be working on some larger thing, and in the process I'll notice and quickly fix a smaller thing before returning to the original task. This might be a typo in a code comment, a poorly named variable, or a block of code I realize is dead.I suspect this is the type of tendency which goes away with experience, but it makes git a lot less useful. My commits won't really tell you what changed; the most they can tell you is the primary change I was working on.	Wowfunhappy	8.561856	-6.510826	comment	6.0	22.0	1614109261	-11.903375
26288322	Hijacking this topic to talk about s	Hijacking this topic to talk about something I've been thinking about lately: literate diffs.I find that the order of diffs given by git is not optimized for helping a reviewer understand the change. Sometimes the order of files will not be in the most logical way; sometimes unrelated changes (e.g., a text editor removing blanks at the end of lines) create noise; etc.I've been thinking that it would be interesting to have a tool where the author can take the diff of their commit(s), order them in a way that is conducive to understanding and explain each part of the diff. That'd be similar to having the author do a code walkthrough, but at the pace of the reader rather than the author.	gnuvince	8.70761	-6.44739	comment	6.0	19.0	1614461170	-11.795136
26351762	"> Words such as ""master"", ""owner"", a"	"> Words such as ""master"", ""owner"", among some other ones were deemed problematic and needed to be changed.This is slippery slope happening right before your eyes. For those who claimed that slippery slope is just a fallacy and never ever can be true.When did Github change the default branch name from ""master"" to ""main""? Few months ago? Now it's ""owner"" too, and using this word probably could get you in some real trouble.I'm not even going to comment on ""see"" and ""visible""."	ttt0	8.504862	-6.5246453	comment	6.0	61.0	1614911339	-11.717043
26371552	This is absolutely fascinating, conc	This is absolutely fascinating, conceptually.However, I'm struggling to figure out a real-world use case for this. I'd love if anyone here can enlighten me.I don't see how it can be for production databases involving lots of users, because while it seems appealing as a way to upgrade and then roll back, you'd lose all the new data inserted in the meantime. When you roll back, you generally want to roll back changes to the schema (e.g. delete the added column) but not remove all the rows that were inserted/deleted/updated in the meantime.So does it handle use cases that are more like SQLite? E.g. where application preferences, or even a saved file, winds up containing its entire history, so you can rewind? Although that's really more of a temporal database -- you don't need git operations l	crazygringo	8.603762	-6.4736357	comment	6.0	29.0	1615073702	-11.859673
35730446	"A tool called ""diff modulo base"": ht"	"A tool called ""diff modulo base"": https://git.sr.ht/~nhaehnle/diff-modulo-baseGiven two version (old and new) of a Git change (i.e., individual commit or patch series from a pull request) it produces a diff that is actually useful for reviewing purposes, assuming you've already reviewed the old version of the change.It's sort of like `git range-diff`, but where `git range-diff` produces a ""diff of diffs"" that is very hard to impossible to read, this tool gives you a direct diff between old and new versions, but filters out any irrelevant changes that were introduced because the author rebased on a more recent version of the target branch.I hope that makes sense - I never know quite how to put it into words for somebody to understand who isn't intimately familiar with Git. It is very powerf"	nhaehnle	8.626058	-6.5025005	comment	6.0	18.0	1682612554	-11.798067
35787901	Is it though? Don't know anyone who 	Is it though? Don't know anyone who likes merging or rebasing. Especially big merges. I don't know a solution. But I'm sure someone comes up with a significantly less painful way at some point.	jiggywiggy	8.696202	-6.4701824	comment	6.0	27.0	1683037417	9.264119
36178915	What do you really need to know beyo	What do you really need to know beyond pull, push, commit, stash, rebase, worktree, and .gitattributes?	replygirl	8.574484	-6.5377755	comment	6.0	18.0	1685815210	-11.93065
36372308	BIG PROBLEM with git is that it work	BIG PROBLEM with git is that it works in terms of editor lines and not in language constructs. It should instead track changes in terms of language constructs. For example, tracking the history of a class individually, an interface, etc... changes could be logged automatically. For this to work it would, of course, require to be adapted for each language.Furthermore, it could work in architecture terms, such as an MVC files that could be tracked as an individual unit. The architecture for a file system could be defined and enforced in a git file, it could spot missing pieces.Also, it needs dependency management for these units.	Jacky4Chan	8.5991	-6.4898562	comment	6.0	18.0	1687022919	-11.884016
28671124	It's not that you're going too far, 	It's not that you're going too far, it's that you're not going far enough!It's not a Git question, it's a programming language question. There's no reason source code need to be stored as plain text[1]! Editors show it as text, we edit it as text, but why wouldn't it be _stored_ as an AST? Not only does formatting becomes an editor concern, but code could even be edited as a tree, as a graph, as whatever you want[1] - well, actually there's plenty of reasons: chiefly because plaintext is very interoperable	williamdclt	8.703894	-6.4512115	comment	6.0	41.0	1632753337	-11.750033
28900286	Im looking for a workflow to replace	Im looking for a workflow to replace having multiple dependent branches (unmerged code reviews) and rebasing each of them when you have to revise one of the branches for Code review comments. Any suggestions?	faizshah	8.592614	-6.5131564	comment	6.0	26.0	1634508853	1.3394247
28900639	All I want are some more guardrails 	All I want are some more guardrails and maybe visualization when I’m doing rebase stuff.My biggest burn is when I am rebasing and addressing conflicts and I do the wrong thing like a pull or a commit or something and then it’s just completely unclear to me what I’ve broken and why my conflicts are getting far worse every stage of the rebase.	Waterluvian	8.581899	-6.570566	comment	6.0	26.0	1634512880	9.305685
28954607	Magit is an exceptionally well made 	Magit is an exceptionally well made interface to Git. Yes, it’s built on top of Emacs, and that might stop many from even looking into it. - I am glad I made a deep dive into Emacs last year, and although I stopped using it as an IDE (VS Code is just too good), I still come back to it because of Magit (and macros, general text editing and org-mode). Yes, I have an interface for Git in VS Code as well, but it‘s very rudimentary compared to Magit, and it’s limited to the narrow left bar. And to give an example: Making „micro commits“ by staging various lines of changes is super easy in Magit, but I still haven‘t found out how to select several disconnected lines for staging in VS Code.	submeta	8.614508	-6.490208	comment	6.0	32.0	1634888687	-11.734251
28954693	Magit is insanely ergonomic. Like ho	Magit is insanely ergonomic. Like how easy is it to selectively stage portions of files in the git CLI? In magit it is usually just a few keystrokes.I wish magit-forge [0] had more features though - like I cannot create new labels from it.Please consider donating [1] to the developer if it has made your life any easier.[0] https://github.com/magit/forge[1] https://magit.vc/donate/	yewenjie	8.599177	-6.4676456	comment	6.0	32.0	1634889688	-11.780441
28956554	What I dislike with git terminal UI 	What I dislike with git terminal UI is that commands reflect the innards of git, not what the user wants to do. It also forces a deeper understanding of the innards for basic commands than ought to be necessary.Examples where undoing an operation looks totally different to doing it:- To stage a change you `add` it, to unstage you `reset HEAD`- To commit you `commit`, to undo a commit you `reset --hard HEAD^`The last example is also where you get pointed to an unsafe command for a fairly benign operation. Uncommitting is not particularly dangerous, but anything with `--hard` ought to give people a pause for thought. If you mistype it and nuke more than the last commit, that's also a bit bad - and fairly easily done.Some other examples include shenanigans around pushing and pulling remote br	rich_sasha	8.570176	-6.523926	comment	6.0	56.0	1634906715	-11.877475
29126115	Honestly, git is absolutely needless	"Honestly, git is absolutely needlessly complex. The worst aspect of git is the almost arbitrary naming of tasks that hardcore git users swear are obvious. E.g. ""cherry picking"", ""fast forward"", ""rebase"". Anyone not familiar with git will balk at the concept that the intent of these phrases are obvious.Note: I use git frequently every day, not by choice, but simply because it is the defacto version tracking system. I have grown to like it, but I miss the more straightforward every day use of Mercurial (which is rarely supported by any services anymore).Edit: ... and as a native English speaker, I can't help but feel bad for others who are expected to become familiar with these functions without familiarity with these colloquialisms."	loudthing	8.556939	-6.504064	comment	6.0	45.0	1636157678	-11.883777
29185261	I’m an imperfect human, but I don’t 	I’m an imperfect human, but I don’t always see the value in having 5 commits that say “fixes lint error” and another few “fixes typo” in the git log for every feature branch. Perhaps there is a middle way.	reilly3000	8.576891	-6.5284142	comment	6.0	21.0	1636614371	9.885193
29392739	Which git GUI do you recommend? The 	Which git GUI do you recommend? The one in VSCode I find even more confusing than the CLI.I do agree with you that some workflows are just easier with a GUI, since I used to use TortoiseSVN and it was much nicer for diffing two commits than the CLI is. But I haven't really dug into git GUIs.	carlmr	8.583031	-6.4840794	comment	6.0	18.0	1638284065	-11.8273735
29396636	Literally every git GUI I've used ha	Literally every git GUI I've used has screwed up a git repository at some point, requiring relatively-advanced CLI use to untangle it.  They're wildly untrustworthy IMO.  They also almost never perform reasonably on truly large repos, aside from gitk.Since using a GUI has inevitably required me to learn CLI in depth, and adds the complexity of figuring out what the hell the GUI actually did because of course it doesn't tell you, I'm basically 100% CLI as well.	Groxx	8.608154	-6.50831	comment	6.0	25.0	1638301982	-11.845746
29605895	It is funny, one of the things that 	It is funny, one of the things that has bothered me for quite a while is that diffs don’t understand code.For example if I add an additional usage to a global variable to a file, while someone else renames it in other files, git happily merges with no conflict.Tighter language integration can help with that.	rileymat2	8.705823	-6.5092244	comment	6.0	19.0	1639845784	-11.797421
34578179	It annoys me that every gee-whizz ne	It annoys me that every gee-whizz new language needs to have it's own package-management system.There's no reason why a package-management system needs to be language-specific; dependencies are often cross-language. Hell, even some blocks of code contain more than one language.The package-management system is responsible for deploying packages. The way a package is deployed should depend on the operating environment, not on the language. These language-specific packaging arrangements typically deploy into some private part of the file-system, organized in its own idiosyncratic way.Using git as a repository is just nuts. Git is privately-owned, and stuffed with all kinds of unaudited junk. You can't audit everything you install by hand; so these systems force you to install unaudited code, 	denton-scratch	8.5964775	-6.4656525	comment	6.0	23.0	1675076243	-11.845624
34592433	Why should the commit message explai	Why should the commit message explain why? I thought the point was to give a summary of the changes so that you don’t have to read the full diff.	huijzer	8.61512	-6.524276	comment	6.0	21.0	1675150938	-11.898224
34712345	Pull request merge queue (public bet	Pull request merge queue (public beta)	LazyMans	8.630363	-6.4608026	story	6.0	47.0	1675880513	8.323154
34734827	What exactly is a drawback of Trunk-	What exactly is a drawback of Trunk-based development for developers?	fallbackboy	8.62852	-6.554877	comment	6.0	34.0	1675995359	3.1990767
34738678	We have a main branch, and a develop	We have a main branch, and a develop branch. Feature branches are based on the main branch.When a developer is happy with their feature branch, they open a pull request to develop, which gets reviewed by another developer and, eventually, merged to develop.The code in develop gets deployed semi-hourly or on demand to a testing environment, where quality assurance takes on the feature branch.Eventually, when the testers are happy with the feature branch, it gets merged to the main branch. Main gets deployed to production daily, or on demand. There are no release branches or tags.Feature branches that take longer are periodically rebased on main (or main gets merged into the feature branch). On rare occasions, hotfix branches are merged directly to main (and immediately, possibly partially, 	morsch	8.656663	-6.5238476	comment	6.0	30.0	1676031359	-11.918144
34761200	No,its better to create a notebook w	No,its better to create a notebook with .py extension and use light Percent format for cells. This creates a text file notebook that can be git diff'd	wanderingmind	8.682487	-6.4868054	comment	6.0	19.0	1676192098	-11.65629
34959801	Ask HN: What Git branching strategy 	Ask HN: What Git branching strategy do you use in 2023, and why?	rufugee	8.570416	-6.514183	story	6.0	8.0	1677521217	-11.89946
34966029	Git's other (compounding) problem is	"Git's other (compounding) problem is how the CLI is an inconsistent mess.Why do you create a branch via the ""git checkout"" command? Why do you delete tags using ""git tag -d"" but delete stashes using ""git stash drop""? If you want to blow away local uncommitted changes, you can use ""git reset"", ""git reset --hard"" or ""git checkout (file)"" - which (I think) all do totally different things.Git's data model may be elegant, but its hard to appreciate it through the tangled mess of git command line options."	josephg	8.570929	-6.535527	comment	6.0	34.0	1677562583	-11.86992
34976053	How else would you support breaking 	How else would you support breaking up a change into multiple commits?	OkayPhysicist	8.592595	-6.5364995	comment	6.0	21.0	1677624625	-11.906131
35007763	You're using them wrong. I've been u	You're using them wrong. I've been using them for years and I have no issues with them, however I treat them as a read-only dependency.They have their use and it's not that hard once you figure out the exact sequence of git commands to use (but that applies to all of git)	pancrufty	8.548443	-6.471737	comment	6.0	34.0	1677838169	-11.891189
35014246	If you get a lot of value out of the	If you get a lot of value out of the pull request view, you might enjoy adding partial committing to your workflow. Rather than committing entire directories or folders at a time, you can page chunk by chunk through uncommitted changes, committing only the ones you select. You'll easily spot those stray logging statements you don't want to commit. (You can also discard chunk at a time by using partial checkout/restore.) If you have, for example, two pairs of backend/frontend changes that you want to commit logically rather than simply according to their directory structure, partial committing is handy.It's just `git commit -p` (and `git checkout -p`). It's not exactly a deep cut, but I encourage people who are familiar but don't use it to give it a try.	heydenberk	8.589255	-6.534414	comment	6.0	31.0	1677873415	-11.909376
37295378	Ah yes, I too have accidentally comm	"Ah yes, I too have accidentally committed  node_modules.Jokes aside, and coming from a place of ignorance, it's interesting to me that a file count that size is still a real performance issue for git. I'd have expected something that's so ubiquitous and core to most of the software world hasn't seen improvements there.Genuine, non snarky question: 
Are there some fundamental aspects of git that would make it either very difficult to improve that, or that would sacrifice some important benefits if they were made? Or is this a case of it being a large effort and no one has particularly cared enough yet to take it on?"	Alacart	8.570798	-6.465602	comment	6.0	32.0	1693235550	-11.900355
37514431	"Oh yeah, the Git internals...
I trie"	"Oh yeah, the Git internals...
I tried to find my way through them using visualization but did not progress much: https://github.com/smartmic/git2pic"	smartmic	8.557482	-6.4438195	comment	6.0	19.0	1694723377	6.387647
37560032	I don't understand one thing about G	I don't understand one thing about GitOps.Imagine 10 apps deployed. All are actively deployed let's say few times a day.You want to go back 10 days for App  A. But in doing so you would have reverted whole state and all apps as they were 10 days ago.Only way is to cherry pick particular commit and revert it.No? I mean how git can be useful in rolling back singel components back and forth?	wg0	8.581222	-6.5285892	comment	6.0	23.0	1695061667	-11.911248
24504392	Is this proof that regular git comma	"Is this proof that regular git commands are too difficult to use?I also wonder what this is going to do for folks not using Github as now CLI users are going to ""unlearn"" all their traditional git commands."	dberg	8.55115	-6.485135	comment	6.0	22.0	1600349672	-11.904123
24504936	Besides the obvious advantages of co	Besides the obvious advantages of command line user interfaces for a lot of use cases, I am not aware of any really good Git GUI. Can you name any for Linux or Mac OS? Commercial would be ok, as long as it can be installed locally and does not require a server.	_ph_	8.5747	-6.4579005	comment	6.0	24.0	1600352431	-11.898458
24586781	I recommend this site to people a lo	I recommend this site to people a lot, it's nice. What's not nice is people not being aware that Git comes with a graphical history viewer for your actual repositories, gitk, which should really be people's default go-to. (There's also log --graph if you want ASCII art, but an actual GUI is quite a bit better. There's also other GUIs that display the information gitk does, of course.)Git is truly the Dark Souls of version control systems - that is, it's wonderful and masterfully crafted but it has attracted this misguided cult following which spreads misinformation about how intractable and hardcore it supposedly is. Dark Souls doesn't have forge sites deliberately (?) adding to the confusion (maybe all those youtubers...), though.	juped	8.566151	-6.462247	comment	6.0	32.0	1601010965	-11.891724
24593162	I was digging into tutorials about G	I was digging into tutorials about Git internals recently and was surprised to learn just how straightforward the data structures are. Given how stupid-simple the data is, I'm all the more confused about how straightforward the CLI isn't.There are very few if any ways to accumulate and amplify errors in the system. It's no wonder Linus created a working prototype so fast. It's the simplest thing that could possibly work. But this simplicity is also the reason why binaries occupy so much space.A system can be so simple that there are obviously no errors, or so complex that no errors are obvious. In the middle ground we get progress by someone mathematically proving the soundness of a technique, and then a group of people working together to match the implementation verbatim to the proven te	hinkley	8.549025	-6.5397468	comment	6.0	75.0	1601061342	-11.903677
24676206	Git filter-repo: much easier/faster 	Git filter-repo: much easier/faster alternative to filter-branch	dmart	8.564509	-6.499404	story	6.0	60.0	1601780013	-11.883356
24688092	I wish git had a builtin notion of t	"I wish git had a builtin notion of two different types of commits: working commits and release commits.I really like making tiny, continuous commits as I work. It's a great flow. git-revert becomes a Ctrl-Z on steroids. I don't what to clutter up the ""official"" history, with all these tiny changes, many of which don't even compile. That breaks git-bissect and all kinds of other flows.So the only option is to squash commits. But there's something deeply uncomfortable and unsettling about permanently re-writing history. Plus, it's nice to have a history of those working commits as an artifact. If I'm trying to unpack the reason that I did something 9 months ago, then seeing a replay of the code changes is super-useful."	dcolkitt	8.577031	-6.551065	comment	6.0	18.0	1601908364	-11.91902
24856737	"""On the Git front, their transitioni"	"""On the Git front, their transitioning from Subversion to Git they hope to have a beta repository by the end of October.""Their migration from Subversion to Git also provided the motive for the murder mystery book ""git commit murder"" by Michael W. Lucas."	jasoneckert	8.555538	-6.4452567	comment	6.0	19.0	1603364554	-11.915866
25121657	I'm not an idiot, but I don't fully 	I'm not an idiot, but I don't fully understand git. I am coding for a living, and I use git every day. I probably could sit down for a couple of days and fully understand how git works, but I've never needed it, I understand how basic git operations work, and I stay away from commands that I don't understand. With GitHub desktop you don't need to open the command line for any standard operations, I only need to use the terminal for cherry picking.The reason I want to stick to the basics is because of one interesting thing I've noticed: a lot of engineers sincerely believe that they are git experts when they are nowhere close. And until I locked down the GitHub repo with admin privileges, that was a dangerous thing. So I'm trying to work a system where no one in a team where not everyone is	ramraj07	8.547248	-6.492712	comment	6.0	123.0	1605605046	-11.906988
25121881	I am limited by time on what I can l	"I am limited by time on what I can learn, every day I have five other things I'd rather spend my time learning about instead of git. The ""git experts"" that I know of are no more productive than me and more often than not do annoying things like rewriting commit histories after I made comments in their PRs, that I'm not convinced it's worth the day or two I need to learn it fully. In the end git is not in production, it's just a tool to manage code, I'd rather be an expert on the code than the coding tool. This is probably akin to trying to understand how your car works when all you need it to do is get you to work. Changing tires is about as much as anyone who's trying to be productive should know about their car. Call a mechanic for anything else."	ramraj07	8.540159	-6.4928503	comment	6.0	33.0	1605606672	-11.886593
25122436	+1These commands will get you 99% of	+1These commands will get you 99% of the way:- git status- git branch- git pull- git add- git commit- git diff- git merge- git push- git checkoutFor everything else there's StackOverflow, but the info in there comes with the risk of being stale.--------------Edit commit abaeb3b4: Add missing commands and improve formattingEdit commit 842babda: Add git checkout	secondcoming	8.577864	-6.5294585	comment	6.0	41.0	1605611985	-11.918082
25122509	“Git gets easier once you get the ba	“Git gets easier once you get the basic idea that branches are homeomorphic endofunctors mapping submanifolds of a Hilbert space.”— Isaac Wolkerstorferhttp://twitter.com/agnoster/status/44636629423497217	anotherevan	8.560816	-6.4993424	comment	6.0	66.0	1605612648	-11.89192
25123153	> Resisting GUI's is not a good idea	> Resisting GUI's is not a good idea.I disagree.  In my personal experience, learning git took a lot of trial and error, but now whatever terminal I sit down in front of, I know exactly which commands I have to run to do what I want in git.  When using a GUI, it's fine for the easy/common stuff, but if I want to do something more complex I have to figure out how to dig through the options provided by the tool to get the result I want.	skohan	8.601695	-6.477815	comment	6.0	36.0	1605617657	-11.889931
25124213	I've used git for ten years, at half	I've used git for ten years, at half a dozen organizations (I'm a consultant/contractor).  I have accepted that it's what we use now, so I use it.  But...Git is the bad boyfriend of the developer community.  If anything bad happens it was your fault.  If you ask it to do something and it does something else, it was your fault, and also you are stupid.  If you ever make a mistake, you will be punished for it with a long drawn out cycle of embarrassment.  No matter what happens, it was not git's fault, it was your fault.Good software is not like that.  Good software is the opposite of all of that.  Git is the industry standard, and I have just accepted that we aren't going to get anything better, but whereas it might  make sense for the Linux kernel dev community,  it is not good software, a	rossdavidh	8.552138	-6.4973364	comment	6.0	27.0	1605624103	-11.900489
25200770	Not trying to go off-topic here, but	"Not trying to go off-topic here, but has anyone here actually used git in the workplace? I'm 3 for 3 on jobs that don't believe in version control, and other companies in my city haven't known what it is, I'm constantly asked about having it on my resume skills section. I've been told everything from ""it's not enterprise ready and there's no SLA"" to ""open source is communism""."	PascLeRasc	8.545019	-6.445944	comment	6.0	22.0	1606239465	-11.873396
25309221	> Should CI create a merged branch b	> Should CI create a merged branch behind-the-scenes and run tests on that before allowing the branch to be merged?This is surprisingly difficult to get right, especially with projects with lots of concurrent changes. Gitlab merge trains[1] really help here.1. https://docs.gitlab.com/ee/ci/merge_request_pipelines/pipeli...	orf	8.474896	-6.4543257	comment	6.0	21.0	1607121325	8.822978
25333658	How do you guys handle managing mult	How do you guys handle managing multiple merge/pull requests that depend on the previous one?For example:Request 1: install dependenciesRequest 2: add scaffolding to application like adding a menu item, page layout, etcRequest 3: add feature ARequest 4: add feature BMy questions:1. Do you add all 4 Request reviews at once, or do you wait until the previous one has been approved before adding the next one?2. How do you communicate Request 2 is dependent on Request 1?3. How do you enable the reviewer to review Request 4 without reviewing duplicate code (since Request 4 has merged Request 1, 2, and 3)?	radihuq	8.601345	-6.448988	comment	6.0	25.0	1607358481	4.0099792
25442259	Git2graph: Generate a Git graph stru	Git2graph: Generate a Git graph structure from linear Git history	lemonspat	8.555954	-6.457651	story	6.0	51.0	1608125524	-11.89662
25443440	Tig is and has been my favorite util	Tig is and has been my favorite utility for browsing git logs for years now. Thanks tig developers and contributors!It's handy to know that the arrow keys are used for browsing the log messages, while return followed by either pgup/pgdn or j/k are used for scrolling the contents of a log message. And it's easy to search logs with /.Tig is also theme-able. For instance with:curl -so ~/.tigrc 'https://raw.githubusercontent.com/cbertoldi/dotfiles/master/...'Note that this may overwrite your ~/.tigrc, if you already have one. Colors are subjective, but I like how it looks in my terminal emulator.Tig is highly recommended. It just works and is one less thing to worry about.	xyproto	8.590634	-6.5325994	comment	6.0	21.0	1608131419	-11.784842
38809740	Our git workflow:master branch - cod	Our git workflow:master branch - code currently deployed to production. never used as the base branch except rare hot fixesstaging branch - the base branch for all feature branches. On prod deploy, staging is merged to master with a merge commit (probably could (should?) be a rebase)feature branches - always use staging as base branchMost critically: all feature branches are squashed and merged, so that each single commit in master corresponds to a single PR.Makes it easy to revert PR but difficult to cherry pick after squashing. Also keeps the hit history extremely clean and condensed. Not sure if this method will scale, but it’s working well at our company with 6 engineers with 20 or so feature branches open at any given time.Edit: one reason this works for us is we keep feature branches	cj	8.598433	-6.5386715	comment	6.0	20.0	1703881213	-11.95414
38844950	Moving Git commits between repos (20	Moving Git commits between repos (2017)	piinbinary	8.537604	-6.4387417	story	6.0	41.0	1704219696	-11.852174
38998786	Git branches are about as real as th	Git branches are about as real as the most significant bit in an IEEE 754 double's significand.> modern version control systems are a user interface to their underlying mathematicsWidespread (mis)understanding of Git is a direct result of programmers who don't understand library and information science refusing to accept that they're in the domain of library and information science but trying to slog through anyway without the prereq; repo operations comprise an algebra of publishing.  It gets really perverse in interdisciplinary settings when technical folks start trying to explain Git to people in the humanities who are better equipped to grok its fundamentals than the average programmer.	cxr	8.541498	-6.481472	comment	6.0	31.0	1705309999	-11.88336
32667986	They mention that they'd ideally wan	They mention that they'd ideally want a natural ordering on the commit hashes. Something to do with their zero-tolerence security policy.What's the background there? Why do they need a natural ordering?	sedeki	8.603685	-6.5140996	comment	6.0	39.0	1661978000	7.3827395
32668334	Funny story: my first task when I jo	"Funny story: my first task when I joined the original iPhone team was to merge our forked WebKit with master. It was a sort of hazing ritual slash ""when else would we do it but when someone new joins?"". Anyways, we used a tool called SVK[1] in order to get very primitive ""git-like"" abilities. It was basically a bunch of scripts that used SVN under the hood. For example, in order to get the ""local everything""-style behaviors of git, the very first thing it did was checkout every single version of the repository in question. For WebKit, this meant that the first day was spent leaving the computer alone and letting it download for hours. I made the mistake of having a space somewhere in the path of the target folder, which broke something or other, so I ended up having to do it all over again"	tolmasky	8.643607	-6.532955	comment	6.0	59.0	1661979882	6.2619977
32809157	The SQLite people not using git or h	The SQLite people not using git or hg is like the Bell Labs people and three-button-mouse heavy sam/acme: when you’re right about everything 99/100 times, that 100th time you’re really going to double down on some dumb-ass thing.In what possible world is telling the most successful set of design decisions about document management in the history of documents or management to get fucked not just “I’ve got goodwill to burn, let’s ride.”? SQLite is indeed badass, but cool it djb, I’m already stressing about the zero bugs ever thing.	benreesman	8.627958	-6.500125	comment	6.0	21.0	1662985846	9.909126
32874970	Analogies for Git (2016)	Analogies for Git (2016)	luu	8.49523	-6.515269	story	6.0	35.0	1663391946	-11.881082
32883331	I'm by no means an expert, but is it	I'm by no means an expert, but is it really that hard to remember clone, pull, commit -a, push and maybe something else you'd need. That you need a GUI? And even then you can either use the help or man or just Google it and you'll remember the right command sooner than later.Or am I missing some quite important? I've been using this for most of the stuff that I do in github and it seemed to be enough.I use these on my Chromebook, but on my stationary computer I just use the integration in VS Code.	LoveMortuus	8.590854	-6.452749	comment	6.0	20.0	1663463099	-11.874295
33044481	>> An eternal war rages between team	>> An eternal war rages between team “git log should be clean” vs. team “git log should have an accurate history.”Having a clean commit history makes it easier to utilize commands like git blame and git bisect.  I'm not convinced those who want to have an accurate history really understand what they want.  For example, if after every single keystroke, I saved the file, added it to the index and ran git commit -F - <(date), then I certainly could have a comprehensive history detailing every single keystroke I made as I edited the code, but the history would not be very useful when looking back on it.>> Team Clean>> Methods: git merge --ff-only or git rebase && git merge (extreme clean freaks add the --squash option)>>     Pros: Linear history, git log is easy to read, git revert requires no	u801e	8.573012	-6.5448027	comment	6.0	57.0	1664606474	-11.922052
31984652	> I saw the pain points of gitWhat a	> I saw the pain points of gitWhat are these? Asking for real: it’s the second time I read a similar sentence on HN this week, without finding any specifics, so I’m curious	stellalo	8.547021	-6.468346	comment	6.0	59.0	1656998927	-11.8786335
31984731	On the surface:- Git is slow on larg	On the surface:- Git is slow on large repos, even on an SSD.- Git has trouble with large objects; git-annex and git-lfs sort of help, but are bolted on, not integral.- Git's submodules are unergonomic at best.- Git's CLI is a mess.Deeper:- Git has no idea of a conflict as a first-class object; hence merges and rebases with the user fixing the same conflicts multiple times (and `git rerere`). Compare this to Pijul.- Git is line-oriented and has no notion of semantic diffs and semantic merges. This makes it a raw tool when working with, ironically, source code.Don't get me wrong: the data structures and ideas on which git is based are beautiful and reliable. But something (even) better can be built on these ideas.	nine_k	8.585962	-6.5055103	comment	6.0	26.0	1656999720	-11.868049
32164423	I said this in another comment recen	I said this in another comment recently about git, but I find it odd that even after a decade of using git as a mandatory part of my professional life, I'm still learning new things.That's maybe not a good sign about the usability of git.That `@{'3 days ago'}` thing? That's incredible. Why didn't I know about that 8 years ago? Why wasn't it obvious, intuitive to me that this was possible?git is brilliant and I love it. But there are very few affordances that make it obvious what to do next, what is possible. There's few patterns in it where I can apply what I already know.The thing that replaces git will have most of the power of git, but an intuitive interface that makes learning everything about it easy.	mabbo	8.542724	-6.4797816	comment	6.0	43.0	1658318062	-11.9049225
32190696	Page mentions Subversion, anyone sti	Page mentions Subversion, anyone still using that vcs these days?	TheChaplain	8.620971	-6.452298	comment	6.0	22.0	1658488227	-11.834996
32262504	I wish people would just forget abou	I wish people would just forget about pre-commit, this thing is especially useless in a setting where a CI/CD pipeline exists. It's not that hard to write a simple Makefile or shellscript to run linters on push.Pre-commit is one of the most annoying tools that have come into existence in recent years that everyone seems to be cargo-culting. It doesn't play well with editors since in order to find the actual binary path, you'd have to open up a sqlite database to fish out the virtualenv pre-commit created. Pre-commit also increases maintenance burden, since its configuration is completely separate from your usual requirements-dev.txt/pyproject.toml/setup.cfg etc. If you have dev dependencies in one of these files because making your editors to find the pre-commit created binaries are hard, 	wyuenho	8.726686	-6.497666	comment	6.0	51.0	1659003358	-11.862152
32293944	I frequently do `git reset --hard`, 	I frequently do `git reset --hard`, knowing what I am doing, until I found that I probably need the code a few days later.Perhaps I just need a tool to intercept this and backup the affected files somewhere. The files can be deleted after some time (a week? or never?). And when I regret doing resetting the files, I can just dig through the backup and try to find it.	pca006132	8.564033	-6.5290055	comment	6.0	30.0	1659253031	-11.906506
22234845	You can't change past commits to add	You can't change past commits to add that hash (without changing all commit hashes), so this method could only protect new commits. For any existing repo this would lead to a very weird security model: We admit that sha1 hashes are broken, and only guarantee that commits made by git versions newer than git x.x.x are safe from after-the-fact modification (or alternatively only commits made after date X).	wongarsu	8.60851	-6.5059	comment	6.0	25.0	1580819986	7.1580267
23464155	Slightly off topic.What is this deal	"Slightly off topic.What is this deal about commit small and often?I usually work on problems that requires a lot of thought, a lot of back and forth between solutions, a lot of a reach this state where stuff kinda work but it is not what I need yet and I am not sure it is gonna be in the final version.Eventually I reach the final version and I commit all together, but the commit is rather big.Do you guys come back and fix everything after? Like re-code the solution from scratch committing at the right moment.
Do you just add pieces related from the final version in multiple small commits?
And how do you make sure that each commit is correct? Do you re-run the test suite after each commit? While developing?I must say that in smaller and simpler codebase than the one I usually work with it m"	siscia	8.644122	-6.545191	comment	7.0	31.0	1591682998	-11.909268
23740858	Yep, no one ever reads them and the 	Yep, no one ever reads them and the cost to benefit ratio is extremely low.Writing good comments is far more important. Don't explain what the code does - that's what the code is for, explain the why and the background information in the code. Additional, explain what the code does at the function level or at the module level - at a much higher abstraction level basically than the line of the code.No one ever looks at the commit messages when trying to figure out what the code does as it convolves history and state of the repository, having to contextually wrap your head around when and how this commit was added.Inline documentation? Perfect.	systemvoltage	8.602586	-6.50467	comment	7.0	43.0	1593974388	-11.837928
23954469	How many applications are left that 	How many applications are left that still use Mercurial? I can only think of two big ones, the JDK and Mozilla's entire code base. Are there still others around? Seems like everyone's moving to Git these days, which is great considering I never did get the hang of Mercurial.	AbacusAvenger	8.5155945	-6.5390835	comment	7.0	37.0	1595738071	-12.014043
24135860	Git: Deletion of merged branches tak	Git: Deletion of merged branches taken beyond shell hacks	spyc	8.585244	-6.534005	story	7.0	81.0	1597260870	-11.891761
20746541	I've lost a day's work to a mistyped	"I've lost a day's work to a mistyped ""git revert HEAD~n""; my colleague blew away his month's work with a mistyped attempt at a squashed commit.Neither of us knew about Reflog at the time, so that didn't even get onto the list of things to try.Management asked ""what if you do that with Mercurial?""Answer is, well, it won't let you do it without installing an extension. And the Wiki page for that extension contains a bunch of warnings about how you really should think long and hard about what you're trying to achieve -- and make as many backups as you can.TRWTF of course is that my colleague hadn't pushed upstream for a month. Like I said -- former Subversion user. He didn't want his commit to mean someone else had to do a merge, and he didn't want anyone to see it until it was done."	philpem	8.581047	-6.5721	comment	7.0	33.0	1566306622	-11.924299
20746578	> I started with CVS then moved to s	> I started with CVS then moved to svn.When I was your age we used RCS and SCCS, in the snow, up hill, in both directions. :)Seriously, I have no doubt git has an awesome on-disk format, but whenever I use the git(1) command I want to slit my wrists. I'm sure if a developer uses it many times a day it's possible to get used to it, but as a sysadmin that only uses it sporadically, I basically do:* git clone* vi repo/some/file/blah* git add/commit/push* rm -rf repo/	throw0101a	8.604753	-6.4650354	comment	7.0	37.0	1566306826	-11.861377
20874858	When I first read the often-repeated	When I first read the often-repeated advice NEVER change public history or something along those lines I was like 'yeah, 'duh'. My opinion on that changed a bit though and I reckon this advice follows the standard pattern of good guidelines being falsely wrapped as strict rules which must never be broken.In practice: I only work in smaller teams and we use feature branches which get merged into master after review, having the netto effect pretty much no-one is ever working directly on master. So it if happens someone does something like pushing a commit only to figure out 2 days later it has a typo or even needs a small code change or anything which would improve the commit with trivial changes not really worth creating another commit, we just go ahead and fixup/rebase/force push i.e. rewr	stinos	8.583187	-6.549379	comment	7.0	40.0	1567582777	-11.909987
25461233	This makes me sad. Subversion is suc	This makes me sad. Subversion is such an elegant and simple versioning system. I really wish something would come along that does for git what subversion did for CVS.	Maledictus	8.612882	-6.4664645	comment	7.0	31.0	1608243323	-11.849442
25515487	Sadly the inconsistent and baroque c	"Sadly the inconsistent and baroque command line interface of git for basic stuff is the least of its problems -- learning it is just a one time sunk cost every developer has to pay these days.What's more troubling is that git can't do some very basic stuff well, like merging branches. I mean you can do the merge, but good luck trying to revert it[+] or trying to get git to deal intelligently with non-linear history in general.Another fun thing is that every git repo starts its life with an off-by-one error: there is no canonical (and identical) first ""root"" commit, a NIL commit if you will. This is unfortunate for two reasons:1. A lot of common scripting idioms will break on the first actual commit (e.g. finding changed files via  git diff --name-only A A^ will not work if A is the first c"	patrec	8.573123	-6.5431356	comment	7.0	58.0	1608710218	-11.915176
25527048	I use SVN at my job and I gotta say 	I use SVN at my job and I gotta say I kind of prefer it to Git. Feels much lighter and the commands make a lot more sense to me	peanut_worm	8.574451	-6.484109	comment	7.0	48.0	1608814559	-11.883885
25536197	The biggest and weirdest commits in 	The biggest and weirdest commits in Linux kernel Git history (2017)	rwmj	8.580787	-6.4847755	story	7.0	147.0	1608901021	-11.870447
25537078	Git will be replaced by something th	"Git will be replaced by something that uses intuitive metaphors like ""save"", ""load"", ""undo"", ""go back to old version"", ""update my work with work from colleague"", ""update the official state with my work"" and others. It will likely come as part of an integrated work environment (some collaborative cloud workflow thing) in order to bypass git's role as gatekeeper/rite of passage for developers."	UweSchmidt	8.55919	-6.4740615	comment	7.0	42.0	1608911312	-11.8639345
25794659	Fast Commits for Ext4	Fast Commits for Ext4	lukastyrychtr	8.589284	-6.536744	story	7.0	164.0	1610736934	-11.917256
25960356	You know what pages I'd like to be f	"You know what pages I'd like to be fast and performant on github? The PR discussion and diff page. When a PR gets really large (thousands of LOCs and hundreds of comments) (yes I know it's bad to do that, that doesn't help me a lot when it happens), despite them hiding everything so you need dozens of clicks in order to be able to actually read and search through it's slow as hell and it's a mess.This is not helped by some really counter-productive events being logged interspersed with discussions e.g. any time a label is updated, that's a new line in the discussions log. Is that useful? Almost never! I can't remember wondering ""wow when was this PR marked as E-Easy?"" It could be useful to have a unified history of all events on the PR in a separate tab, which would include things like com"	masklinn	8.580177	-6.4487357	comment	7.0	30.0	1611943704	2.254429
26083012	Seems to be popular at Facebook.[1]W	"Seems to be popular at Facebook.[1]Where I work Mercurial has been an option for some time now (no Git unfortunately) and coming from Git I must say I really love how it does some of its things:- hg split: split a commit into as many different commits as you like using an interactive patch editor (you can fold/collapse hunks, can edit them textually, can select which lines of the hunk should be applied). It will automatically rebase all the commits on top of the commit being split, ofc- hg histedit: a sort of ""git rebase -i"" where you get a list of commits that you can manipulate by reordering them, merging, dropping- hg amend -i/commit -i: interactive commit or amending of a commit, it's using that awesome interactive patch editor I mentioned earlier to select what exactly gets committed/"	d1zzy	8.575187	-6.549305	comment	7.0	27.0	1612908374	-11.937045
26193382	Commiting frequently also has a subs	"Commiting frequently also has a substantial cost of needing to think of a commit message.If you don't think of a commit message, you'll never be able to find this version again.  If you think up a message every 2 minutes, you'll quickly find you spend more time thinking of commit messages than writing code.I wish there was some kind of auto generated commit message.  Things like:""Added function xyz()"" or ""Adjusted constant FOO to 27"" or ""Made lots of changes in file a.c,, b.c and c.c"".These could be auto generated, and then commits could happen in the background every time the code is compiled.It would be nice for git to have some kind of ""commit of commits"" which allows a hierarchical representation of commits.  Ie. the ""Add new printscreen feature"" could have as subcommits ""Create print "	londons_explore	8.586803	-6.5199723	comment	7.0	27.0	1613744347	-11.877877
35626698	Review of James Coglan’s Building Gi	Review of James Coglan’s Building Git	teleforce	8.550337	-6.4626412	story	7.0	49.0	1681902185	-11.902559
35709637	Curious question: why do you think g	Curious question: why do you think git sucks? From my perspective is one of the fundamental tools behind modern software engineering. brilliantly designed and yet so simple to use. I’ll even go ahead of myself to believe you’d be able to make a successful tech company just providing a “git for X” where X is another industry	henry2023	8.541923	-6.47788	comment	7.0	28.0	1682483246	-11.851707
36370902	I support this fully. Juniors and in	"I support this fully. Juniors and intermediate engineers I work with still struggle with git quite often and I personally know how that feels firsthand.Not sure if this solves the issue.  I personally recommend using git, but keeping it simple by limiting the allowed operations.- git switch
- git checkout
- git add
- git commit
- git pull
- git push
- git rebase
- git resetNote the absence of merge and and cherry pick. Most often when a junior has messed something up it seems to be because of merging in a weird order or cherry picking the wrong thing before merging or rebasing.Either my juniors have stopped asking me for advice (totally possible) or this recommendation helps. As I find myself very seldom needing those commands I hope  and believe it's the latter :)"	cupofjoakim	8.571039	-6.537071	comment	7.0	56.0	1687014878	-11.883357
28844952	SHA-1 will still work fine for the p	SHA-1 will still work fine for the purpose of git. It is just no longer considered secure for cryptographic operations, such as digital signature, that doesn't mean that you can't use it for other purposes, like git does. Using it is still fine and will ever be fine.Making the hashing algorithm exchangeable would have introduces complexity in a software that is already complex, and also less efficient (one of the reasons git was created was speed for large project like the Linux kernel) for no real purpose. If you want to change the algorithm, given that you will break compatibility with all existing repositories, tools, and clients, you make a fork of git because you are changing too much.I don't see why migrating to SHA-256. The collisions are still very unlikely to generate accidentally	alerighi	8.679449	-6.52015	comment	7.0	48.0	1634072115	7.1912937
28988346	Blamer.el: A Git blame plugin for Em	Blamer.el: A Git blame plugin for Emacs inspired by VS Code’s GitLens plugin	hprotagonist	8.575398	-6.456496	story	7.0	59.0	1635172938	-11.85366
29329941	worst is git by far.i'm used to it n	"worst is git by far.i'm used to it now but when I was learning, ""what the fuck did `git reset --hard` do? where is --soft? Is there a no-flag version? What the fuck did I leave mercurial for. God damn I miss svn.""I still kind of miss Mercurial and TortoiseHG."	sergiotapia	8.536682	-6.51528	comment	7.0	21.0	1637762042	-11.903889
29330064	Nearly everything that packs or unpa	Nearly everything that packs or unpacks stuff. tar, gunzip, and else. I can never remember if they are going to unpack everything into a subdirectory or spill everything into my home, and conversely I never know if after zipping there's gonna be a directory inside or not. Luckily dtrx and atool do the thing you want most of the time.From the time I was a teen I think I remember that mount was difficult to use, and mounting a CD image required passing some arcane options, though maybe I just didn't know how to use it (on the other hand I didn't know how to use Daemon Tools either, and it just worked).I don't have a problem with git though. I don't think it's the command-line interface that's hostile, it's git itself if you don't know what you're doing. After taking some time to learn it I a	urxvtcd	8.546756	-6.43869	comment	7.0	32.0	1637762845	-11.882888
12612874	My personal favorite two:    jschroe	"My personal favorite two:    jschroeder@omniscience:~$ git config alias.up
    pull --rebase
    jschroeder@omniscience:~$ git config alias.down
    push

They can be used thusly:   git up && git down"	SEJeff	8.579458	-6.536216	comment	7.0	30.0	1475248016	-11.87014
12735949	I had no idea Google and FB were dab	I had no idea Google and FB were dabbling with Mercurial.I checked it out years ago, but pretty much settled on Git.What are the advantages?	the_duke	8.513854	-6.5370693	comment	7.0	61.0	1476807559	-11.933464
12943565	We wanted to switch to Git from Merc	We wanted to switch to Git from Mercurial because we wanted something like Gitlab. The only reason we didn't was that there wasn't any app for Git which was as user-friendly as TortoiseHg.	egeozcan	8.514514	-6.541857	comment	7.0	28.0	1479049068	-11.965705
13071435	If you have some pointers to Git int	If you have some pointers to Git internals explanation, similar to what you're looking for PGP/GnuPG, can you provide them? That would be useful and illustrative :) .	avmich	8.547467	-6.4954743	comment	7.0	21.0	1480519579	-11.906805
13162392	On my team I've found that it's incr	On my team I've found that it's incredibly useful to commit the merge conflicts and conflict markers, then immediately resolve the conflicts in the next commit. This gives you one commit that shows exactly how the two branches merged together, followed by a commit that shows exactly how the conflicts were resolved. The resolution commit can then be code reviewed independently for a nice clean view of the conflicts introduced in the merge. It also allows you to easily reset to the merge commit and resolve the conflicts differently.The standard git workflow (and this github feature) seems to promote resolving the conflicts alongside all of the other changes in the merge working copy. This make me nervous, as there's no way to differentiate the new lines that were introduced to resolve merge 	pkamb	8.613048	-6.5298233	comment	7.0	43.0	1481580341	8.982609
13162096	Resolve simple merge conflicts on Gi	Resolve simple merge conflicts on GitHub	moby	8.625139	-6.487975	story	7.0	228.0	1481578245	-11.873537
13178471	I think that while Git would be grea	"I think that while Git would be great as a library, as a front-facing program it's UX could do an improvement:A good UX is simple things should be simple, but complicated things should be possible, but now look at the following ""basic"" git workflow:1. Add. I want git to track this file. Yes, sometimes I need to add certain lines, files, etc. Keep git add, commit, and push. But have a ""git update"" or something for beginners (and for 99% of use)2. History - How can I go through a file to see its history? ""git show REV""? What if I want a wikipedia style history? What if I want to go through the history of a file? There should be something like ""git history main.c""3. Undelete file - This is fairly common, yet, the command isgit checkout $(git rev-list -n 1 HEAD -- ""$file"")^ -- ""$file""A command"	dispose13432	8.577035	-6.5240746	comment	7.0	40.0	1481740821	-11.942146
13418175	The biggest difference, I think, was	"The biggest difference, I think, was leaving the hunting for a head for a second moment, or even not doing it at all.Commitment would be very different if people were being asked to help while some heads were rolling. Because you're a real team when everybody is going in the same direction. Any call on ""people, work hard do recover while we're after the moron who deleted everything"" wouldn't have done it.You just commit to something when you know that you won't be under the fire if you do something wrong without knowing it."	woliveirajr	8.592009	-6.5337496	comment	7.0	121.0	1484666176	-11.91817
13514603	> Trunk Based Development is a key e	"> Trunk Based Development is a key enabler of Continuous Integration, and by extension Continuous Delivery.Quite false. How do you expect developers to take you seriously when you essentially say ""you can't properly do CI/CD with your current approach""? I sure am enjoying CI/CD right now.Trunk-based development seems to rely heavily on feature flags, which are a huge source of complexity and inconsistency. Even when useful, they're liabilities; not assets.git-flow (and variations) is simple, enables consistent codebase state, makes no assumptions about your codebase/infrastructure, and allows you to know the exact state of production/staging.Finally, as it happens so often with open source projects and initiatives, first thing I should see is a big ""Why"". Why do I want this? Why are the al"	vemv	8.61001	-6.520882	comment	7.0	46.0	1485704897	-11.887267
27580115	> Here’s my theory: novice and inter	> Here’s my theory: novice and intermediate users would significantly improve their understanding and efficacy with Git if they weren’t afraid of making mistakes.Here's something that happens when people are encouraged to make more mistakes: they make more mistakes.The piece where people are encouraged to learn from these mistakes is missing from the author's equation. Without that, this tool becomes a crutch at best, and a disaster waiting to happen at worst.Can we do better?*Edit*: Let me answer my own question. We can do better - for example - simply by adding the Git commands this program would run, aside from the human readable explanation. Not sure what people replying to this comment were aiming for, since they clearly did not offer up a single suggestion.Let me go a bit further and	sombremesa	8.543696	-6.49224	comment	7.0	25.0	1624289311	-11.905742
27580478	I understand how git works, and I st	I understand how git works, and I still can't use it.  There are three problems:1.  Despite the claim that git never loses data, there are actually some dangerous operations that will irretrievably nuke your work with no warning.  Git checkout is the canonical example.  This makes me very gun-shy about doing anything that I'm not intimately familiar with.2.  Git's merge is not smart enough to realize that identical changes in two branches are not actually a conflict.  I've often ended up in situations where a small bug has been fixed in two branches which then won't merge without manual intervention.  This is incredibly annoying.  (To be fair, this is not unique to git.  But because git encourages branching more than other systems, I encounter it more when using git in idiomatic ways.)3.  	lisper	8.569406	-6.52351	comment	7.0	61.0	1624291400	-11.913422
27580486	Every single time we are discussing 	Every single time we are discussing git this comment shows up.But why is one popular when the other one is so much better? I guess we will never know	zibzab	8.540756	-6.4777308	comment	7.0	30.0	1624291475	-11.883734
27643608	> At a previous company, there was a	"> At a previous company, there was an “infamous” commit in our main repository. The commit was about 10 years old, and it replaced every tab with 4 spaces.If have commits like this, add the ids to a file `ignorerevs`, and then tell git about it:   git config --local blame.ignoreRevsFile ignorerevs

Then at least `git blame` will still give useful results. (This is a relatively new git feature, added a year or two ago.)"	pdw	8.571358	-6.5159607	comment	7.0	42.0	1624727047	-11.912012
27722975	This is possible by doing this:  git	"This is possible by doing this:  git checkout feature
  git rebase main 
  git checkout main
  git merge --no-ff feature"	Phlogistique	8.586114	-6.5653253	comment	7.0	24.0	1625331254	9.263104
27723435	In my organization we kind of do thi	"In my organization we kind of do this. We use one merge commit per pull request, without squashing. However, we also rebase before merging, which results in a commit graph that looks like a cactus:      o-o-o   o-o   o-o-o
     /     \ /   \ /     \
    o-------o-----o-------o-->"	ufo	8.584623	-6.547564	comment	7.0	31.0	1625334677	-11.942365
27738216	This is obviously written by someone	"This is obviously written by someone who's never done any sort of review-based workflow.  Trying to review the ""what you did"" with all the random false starts, bug fixes, and who knows what, would be a nightmare; as would just reviewing the megapatch squashed from the end of the series.  Presenting the final result of your  ""feature branch"" as a series of self-contained changes in a logical order is the only sustainable model for a project of any size.EDIT: I really wanted to like Fossil when I first heard about it -- having it based on SQLite (which is AWESOME), having issue tracker / wiki / whatever built in, etc. sounded great.  When I learned that it was basically incapable of rewriting your development branch into something more logical for someone to review because the author had nev"	gwd	8.511636	-6.5601687	comment	7.0	50.0	1625494450	-11.924938
12378589	There's a number of startups doing s	"There's a number of startups doing some variation of this.What many don't seem aware of is that plain pull requests, in combination with CI, entirely kill the need for a deploy app/bot.This is how I do it at my current company:  * use plain git flow (master/develop, hotfixes, etc)
  * use additional explicit branches per deployment target (e.g. master-spain for http://myapp.es, master-mexico for http://myapp.mx).
  * Protect these branches using github/bitbucket 'protected branches'.
  * open a PR from master to master-spain for performing a deploy of said target, detailng nicely what is being deployed and why.
  * instruct CI to deploy my app on each build of master-spain. master and develop are never deployed.

This setup has the same benefits (and then some more) than competitors:  * Ex"	vemv	8.668719	-6.470741	comment	7.0	29.0	1472419099	-11.87648
33108780	Every PR we have in GitHub is merged	Every PR we have in GitHub is merged with a squash, so I'm kinda missing the value proposition here. Is it really crucial for each commit to be a nice clean unit of work?	dbbk	8.57772	-6.549728	comment	7.0	50.0	1665067141	-11.927495
19082432	Git reset vs. Git revert	Git reset vs. Git revert	github-cat	8.558274	-6.532371	story	7.0	54.0	1549330922	-11.909993
19909459	> I’m torn. Practically Mercurial fe	> I’m torn. Practically Mercurial feels like it should be the winner. The commands are more uniform and predictable.I think that's true if you're coming from something like Perforce or Subversion and have some notion of what the expectations are around those environments. It's much easier to translate that model into Mercurial commands.But in the end it's deceptive; git, ugly as it is, reflects the underlying data model. Once you understand that data model, and how the basic commands manipulate that model, then it becomes a very natural language for manipulating the commit chain.If there's a downside, it's that git doesn't let you get away for too long without learning the data model, while Mercurial lets you live in blessed ignorance until the first time it doesn't work like svn does, and	andrewla	8.510032	-6.573876	comment	7.0	35.0	1557842193	-11.946075
15952188	In three years of using git I believ	"In three years of using git I believe there is a single bad command that I could not undo: `git checkout -- somefile`
The second worst thing I did is losing a commit in a `git rebase -i` but I was able to find it back with `git reflog`.
Which makes me think that git is really well designed."	herogreen	8.573105	-6.5388875	comment	7.0	42.0	1513610435	-11.915148
16454662	I seem to remember that a reason why	I seem to remember that a reason why Git wasn’t popular with game dev (and why it wouldn’t be with designers, besides usability) is that it handled binary diffs terribly (ie it would store the whole updated file, even if just a few bits had changed). Am I remembering correctly? If so, is that now addressed?	GuiA	8.601887	-6.488139	comment	7.0	26.0	1519498523	-11.864984
16535623	Four rules for effective collaborati	Four rules for effective collaboration – Guidelines for better commits	deiwin	8.579659	-6.455404	story	7.0	50.0	1520420517	-11.921749
16757107	"I had the ""pleasure"" of attending an"	"I had the ""pleasure"" of attending an OOP course at uni taught by Stéphane Ducasse. I didn't learn much OOP but i learned that pharo is an utter piece of garbage.The IDE randomly crashes, corrupts images (all your work is in the persistent image) and randomly ignores clicks making it insanely frustrating to use. Git integration is ""WIP"" which means it sometimes silently deletes files or you just don't get it to work at all. Branches are not implemented, glhf resolving conflicts on a team project. Oh, and it saves your passwords in plain text.Error messages will keep opening until you kill the ""IDE"" and undo will sometimes delete half your code with no way back (maybe that's why you're supposed to keep methods small?). It's a bit ironic that Mr. Ducasse calls himself an ""expert on software q"	martin-t	8.555851	-6.49825	comment	7.0	26.0	1522864003	-11.92198
16806234	I'm a big fan of Fossil myself. But 	I'm a big fan of Fossil myself. But  the SQlite people have something that I don't really have within the teams I operate : the authority to dare and speak out against Git and not be laughed away like a hipster that is just trying to be different.	neals	8.495174	-6.566223	comment	7.0	72.0	1523399940	-11.97479
16807290	The day I got over what I feel was t	The day I got over what I feel was the end of the steep part of the learning curve, everything made so much sense. Everything became easy to do. I've never been confused or unsure of what was going on in git since.What git needs is a chair lift up that hill. A way to easily get people there. But I have no idea what that would look like. Lots of people try, few do very well at it.	mabbo	8.544798	-6.515326	comment	7.0	95.0	1523410032	-11.879246
16897707	I wish I could understand the value 	"I wish I could understand the value add of yet another IDE. The whole reason for tech to exist is to improve things around the world, and yet brilliant minds are still spending years building one IDE after another.""Switching branch and remembering branch names..."" is a simple git status. On vim, you can get a file browser on the left by using nerdtree plugin, and to write commit messages on the right side you simply just have another tmux window open for git or other unix commands. Building a new IDE is solving a very marginal problem that could potentially create new problems. Why not spend the same amount of time creating educational videos instead on how to use existing tooling that is already readily available?Other than this rant, I really like gitlab product (we self host at our codi"	songzme	8.604235	-6.4446826	comment	7.0	28.0	1524422152	-11.76744
17579528	People saying they wouldn't use git 	People saying they wouldn't use git don't know git.  I admit it does take investment to learn but once you are over the hump it is insanely easy and useful (yes even easier than rsync and 10x more useful).  Especially when you consider that using rsync precludes your from collaborating even with one other person which is crazy easy if you use github (for example).  People not using git: get over the hump, it is worth it, even on little side projects.	eagsalazar2	8.549544	-6.4879894	comment	7.0	44.0	1532125884	-11.869348
21290157	> I don't want your entire life stor	"> I don't want your entire life story in my commit log.I[1] want enough debug information in the commit log to be able to reproduce the issue without having to go on web hunts to understand the problem. Especially when the change appears to be trivial on the surface, because these are the ones that can turn out to be rabbit holes.I don't want to have to interrupt you to get this information because you didn't write a good enough commit message, and you probably don't remember anyway. I don't want go look at an external issue tracker that i may not have access to, or may not even exist anymore.[1] Where ""I"" is: me, your future self, a future maintainer, a junior dev, an open source contributor."	leejo	8.590954	-6.5139213	comment	7.0	39.0	1571394813	-11.911268
21392800	Well, the biggest UX fail for me on 	Well, the biggest UX fail for me on git was the ambiguous and counter intuitive use of the command `checkout`. I've heard the latest versions of Git mitigate this with `git switch` and `git restore` but seriously `git checkout` is the most confusing command ever. Just attempt to describe to an SVNer what `git checkout` does in one sentence or less.I haven't used Hg, but I'm guessing it doesn't have anything as bad as checkout.	umvi	8.550815	-6.5330653	comment	7.0	91.0	1572388200	-11.9168215
21418946	Wow, that is a beautiful post, thank	Wow, that is a beautiful post, thank you for writing it out that way...it makes me pine for VCS in my job.Can you or someone else reflect on my file system? I work for the government doing statistical analysis of healthcare data, and there is no VCS where I code, other than how you name the files and where you put them in folders and how you back them up manually.I am facing a major data-branching event where I'm going from ~40 scripts (R, SQL, STATA) on one dataset, to then three overlapping but different datasets and having ~100 scripts. I just don't know if my brain and wits are up to the task of maintaining these 3 branches with 3 different languages, given all I have is  folder/file names and my knowledge reservoir and memory...I know this is a perfect use case for git, but I've never	WhompingWindows	8.5865	-6.4936986	comment	7.0	43.0	1572617151	-11.877411
39218724	Is it great for historical research?	Is it great for historical research? I feel like the format and tooling around it is uniquely _not great_ for historical research. I think it's optimized for discussions before integration, which is largely what PR descriptions and comments are largely used for now.I feel like given great commit messages, determining a story and useful history around any block of code given the Git tooling is incredibly difficult even if there are _amazing_ commit messages.Like say you are trying to determine why a 10 line function is the way that it is. You blame it. Not even with the stupid-simple GitHub UI that _I_ originally wrote, but with the more expensive CLI interface that follows renames and ignores whitespace changes, etc. Now you get a list of SHAs of commits and the first 50 chars of commit me	schacon	8.614965	-6.5550427	comment	7.0	23.0	1706809197	-11.867741
39218857	> Even if you're _very good_ at Git,	"> Even if you're _very good_ at Git, finding the correct invocation of ""git blame"" (is it ""-w -C -C -C""? Or just _two_ dash C's?) to even find the right messagesI am terrible at git on the terminal, but with IntelliJ or emacs and magit, I can trivially find every commit ever to change a file, and easily navigate the commits to see every full commit message. It's not hard when you use a proper tool, and I have a feeling almost everyone has something like that?! Do you really try to stick with the git CLI and memorize hundreds of commands and flags?? Why?!"	brabel	8.580736	-6.511029	comment	7.0	35.0	1706809792	-11.855241
18413173	Disclosure: small-ish company (~100 	"Disclosure: small-ish company (~100 employees) in FranceYou know, I kind of went through the same questioning: at my current company we have an employee that has his niche/historical role on one of the key infrastructure of our product.The guys works from his home and whatever hours, commits 300+ lines per commit (90% of which is unrelated to the commit name, just commenting things or uncommenting others). The code is a spagetti of if else if else, it has monstruous ""client specific"" code (like: if the current client is this guy, then do that, otherwise for all other clients do this).There's even a load of ""if the program runs in test, answer what the test expects, otherwise in prod send something else"".Every time I look at the commit tree (a balance of wanting to have fun and wanting to s"	xgbi	8.585009	-6.5303364	comment	7.0	24.0	1541753543	-11.9012985
29912343	This is a good idea, but in practice	"This is a good idea, but in practice after a few commits you learn all the principles and don't need a wall of text in your commit template. Getting feedback in your PRs about your commit messages helps quickly reinforce learning these best practices. (you do review the commit message when doing PRs, right? ;)I'm a big fan of Conventional Commits[1], so my commit template reminds me of the types and provides an actual template to describe my change:    <type>(optional scope):
    # type: build ci chore docs feat fix perf refactor revert style test
 
    Problem:
 
    Solution:
 
    Testing:
 
    Issue:

Where Problem describes why this change is needed, Solution is what this change delivers, and Testing is how this change was validated. Issue is the JIRA/Github issue related to this cha"	jasonpeacock	8.610514	-6.523061	comment	7.0	31.0	1642019603	-11.897777
29995817	Am I the only one that actually like	Am I the only one that actually likes git? Everyone here says it's a hodgepodge of broken things but I really struggle to see how.What does Pijul do that Git can't? What does it do better?	junon	8.582218	-6.540411	comment	7.0	35.0	1642609783	13.877617
30399268	> It combines features from Git (dat	"> It combines features from Git (data model, speed), Mercurial (anonymous branching, simple CLI free from ""the index"", revsets, powerful history-rewriting), and Pijul/Darcs (first-class conflicts), with features not found in either of them (working-copy-as-a-commit, undo functionality, automatic rebase, safe replication via rsync, Dropbox, or distributed file system).You lost me at ""free from the index"".  The index is one of the most important parts of Git that makes my life easier.  Opinionated DVCS UIs make my life harder -- all of them.> The working copy is automatically committedRight, so, the reason the index is powerful is that I get to do `git add -e`, `git commit`, and repeat until I'm done or ready to throw remaining changes away.  I very much want the index / workspace distinctio"	cryptonector	8.569055	-6.522334	comment	7.0	53.0	1645295364	-11.90417
30436291	GitBOM	GitBOM	pabs3	8.52818	-6.4609632	story	7.0	25.0	1645578882	-11.903083
30677483	Ask HN: Is anyone using lock-based v	Ask HN: Is anyone using lock-based version control?	wcerfgba	8.668899	-6.4594007	story	7.0	14.0	1647288206	-11.804102
30711482	Whew, glad I decided to scroll HN ri	"Whew, glad I decided to scroll HN right now. I've been puzzling over why I'm getting ""! [remote rejected] master -> master (Internal Server Error)"" as well while trying to push and decided to take a break."	Wavelets	8.668979	-6.450132	comment	7.0	36.0	1647526896	4.4663825
30711755	I'm finding that pushes do go throug	"I'm finding that pushes do go through eventually, this is probably grossly irresponsible, so I don't recommend its use, but I remembered I had this old alias to ""push harder"" in my ~/.gitconfig:    [alias]
    thrust = ""!f() { until git push $@; do sleep 0.5; done; }; f""

I've done a few pushes so far, and found that it's going through in <10 tries or so."	avar	8.562799	-6.4799066	comment	7.0	31.0	1647528391	-11.894658
33342202	Ask HN: Would more apps build with G	Ask HN: Would more apps build with Git back-end if there’d be a solid SDK?	hannes_paul	8.533707	-6.454101	story	7.0	9.0	1666783952	-11.899984
33388115	My definition of a perfect commit is	My definition of a perfect commit is any commit that goes to production because only shipping matters.	pkrumins	8.588984	-6.525932	comment	7.0	25.0	1667078826	-11.902072
33533057	What's the deal with squashing commi	"What's the deal with squashing commits anyways? I'm genuinely asking, because I've only worked with ""squash everything before you put it up for review"" but have never really figured out why past ""it's what we've always done""."	alexb_	8.566018	-6.569991	comment	7.0	49.0	1668008145	-11.948704
33538959	Modern Git workflow is very simple o	Modern Git workflow is very simple on its own:1. Your codebase has a `main` branch which is write-protected2. Devs submit changes to `main` from their own branches using PRs3. Devs can do whatever the fuck they want on their own branch4. PRs are merged one at a time5. When merge happens a dev's PR is squashed into one commit that gets appended to `main`6. If next dev wants to merge their PR with a conflicting change they have to resolve the conflict first and then they merge7. The end result is that `main` is a linear history of all PRs with the time they were committed to the `main` branch i.e., when they could've started to break prod.This is a solved problem and it works great in industry. Why break it? If you want interactive rebase then make 2 PRs.	throwaw20221107	8.581826	-6.556352	comment	7.0	41.0	1668032900	-11.904557
33613944	> There is no staging area.That's ac	> There is no staging area.That's actually a deal breaker to me. Effectively using Git's staging area has become so integral to the way I work with repositories that I don't think I can ever go back to the old style.	chungy	8.7000265	-6.561657	comment	7.0	57.0	1668541247	-11.930314
33706449	I fail to see the point of this, in 	I fail to see the point of this, in fact, I think this is a fundamentally flawed approach to dealing with your revision history. The problem is that rebasing commits has the potential of screwing up the integrity of your commit history.How are you going to deal with non-trivial feature branches that need to be integrated into master? Squash them and commit? Good luck when you need to git bisect an issue. Or rebase and potentially screwing up the integrity of the unit test results in the rebased branch? Both sound unappealing to me.The problem is not a history with a lot of branches in it, it is in not knowing how to use your tools to present a view on that history you are interested in and is easy for you to understand.	blux	8.578798	-6.5693994	comment	7.0	25.0	1669128863	-11.913527
34033040	Ask HN: Is Sapling, the new SCM/DVCS	Ask HN: Is Sapling, the new SCM/DVCS, getting any traction in the wild?	profwalkstr	8.542773	-6.474308	story	7.0	9.0	1671316890	-11.930351
26583414	I consider a version control system 	"I consider a version control system to be a history of a project.  If you change the history to something that is materially different, which rebase does, then you are lying about the history.  You cannot white-wash this fact.The history Git and in Fossil is only precise to the transaction level. A key-stroke or backspace is not a transaction.  A single iteration of the edit-compile-test cycle is not a transaction. A transaction is created by the ""commit"" command. Git and Fossil make no record of the stuff that happens in between two commits.  They only record what is in each commit.  So you can backspace and edit and change all you want to before typing ""commit"".  But once you type ""commit"", all that you've done since the previous commit becomes part of the permanent record.  Rebase viola"	SQLite	8.512455	-6.5754657	comment	7.0	44.0	1616695452	9.538113
26710079	 > git init --bareAha, '--bare': wha	 > git init --bareAha, '--bare': what does that do?  I always just type 'git init'.Let me do a little git bashing, OK?  Sorry for this, but it so nicely documents my initial problems with git when I started a few years back.  And it still occasionally (like right now) makes me shake my head in disbelief:> man git-initSearching for --bare gives me:>  --bare>    Create a bare repository.  ...and how GIT_DIR is set...You don't say!!I search for other occurrences of 'bare' in that man page, but after skipping those in the synopsis and the help text, it says:> Pattern not foundSo bare = bare. Tautological documentation. It's all obvious, right?What --bare really does is to put what git would normally put into the '.git' subdir into '.'.  I tried what it does, that's how I found out.Git is great	beeforpork	8.552804	-6.5098534	comment	7.0	31.0	1617703739	-11.864883
26962296	> the elimination of the staging are	> the elimination of the staging area was enthusiastically received as a major reduction in complexityWell, that'd be a huge negative to me… it is much easier to build up a commit piece by piece, verify that it's correct, and then commit it. The only two alternatives I can imagine are worse: disallowing partial commits (I use this feature all the time; I guess I could replace it by a temp commit on a branch and then so long as cherry-pick -p still exists, use that) or specifying it to git-commit (that would be one gnarly set of flags…)Sure, a git without a staging area is less complex. But it removes essential complexity, and would no longer solve my problems.(And in systems that lack it, like Perforce, I've sorely wanted it, and there was just not a good workaround. But yeah, that aspect 	deathanatos	8.648119	-6.563128	comment	7.0	51.0	1619560866	-11.913908
26998418	Do people here have examples of some	Do people here have examples of some bugs for which they had to resort to VCS history to find the cause? I'm struggling to picture a single bug in my whole career where this would have been quicker than just following the logic of the code. If there's information in commit messages that isn't evident in the code itself, that seems a terrible way to live.	thom	8.587051	-6.483222	comment	7.0	36.0	1619812224	-11.905481
27305916	I read through the getting started g	I read through the getting started guide and I have a hard time seeing how this differs from an existing workflow I use with just pure git.Basically, having a stack of patches as commits in my local branch.  Edits to older commits saved via fixup commits, and occasionally merging in the fixups and/or rearranging the commits with rebase when its convenient to have a different commit on top of the stack or when I'm pushing a patch out from the bottom of the stack.	veilrap	8.57792	-6.517406	comment	7.0	39.0	1622137677	-11.906909
27492158	I ran across this little gem recentl	I ran across this little gem recently:> Git gets easier once you get the basic idea that branches are homeomorphic endofunctors mapping submanifolds of a Hilbert space.* Isaac Wolkerstorfer, https://twitter.com/agnoster/status/44636629423497217	throw0101a	8.567166	-6.4999304	comment	7.0	53.0	1623588723	-11.8981495
37812008	Back in a day, late 00s, early 10s, 	Back in a day, late 00s, early 10s, Git had alternatives.- Bazaar- Mercurial (Hg)Both had superior user experience compared to git, including command line and GUIs. They were not as fast, but no slow either if you came from Subversion world. They were not as flexible, but still very very flexible.What caused Git to win was not rants of Linus Tolvards, but Github. Github gave Git a semi-understandable web user interface. Early days, Github itself had a lot of competition. Bitbucket (now Atlassian) was the same but for Mercurial. However, Github, as a good American startup, won over the world, popularising Git along the way.(Also Stackoverflow helped a lot. There isn’t a day I won’t Google how to do basic things in Git.)	miohtama	8.567151	-6.500971	comment	7.0	26.0	1696783230	-11.9079685
38116440	"""Your branch is up to date with orig"	"""Your branch is up to date with origin/master"" is the biggest lie i am being told on daily basis. I just ""pull"" every time"	dgan	8.557611	-6.5447054	comment	7.0	55.0	1698943992	-11.8138485
38120493	ML Experiments Management with Git	ML Experiments Management with Git	shcheklein	8.561694	-6.4858303	story	7.0	112.0	1698960803	-11.876139
38165718	There is a giant benefit to it being	There is a giant benefit to it being messy. And that is that the mess is the actual history.Every time you do a git rebase, you are literally asking your source control system to lie about history. If you mess up, and you eventually will, you're then forced to manually figure out what the history really was despite being lied to. If you mess it up, well, good luck.I used to work at a company where someone (we never figured out who) in another group would rebase every few weeks. We didn't find out about it until their stuff was pushed then released. The result was that features which we'd written, QAed, and released to production would simply disappear a few weeks later. With no history suggesting that it ever existed.Have you ever been pulled off of a project to go fix a project from a mon	btilly	8.566864	-6.5370784	comment	7.0	42.0	1699291996	-11.963002
38168357	Frankly, people lately spend more ti	Frankly, people lately spend more time managing commit history then using it. Like, commit history is useful once in a year little bit, maybe, but we spend absurd amount of time trying to make it look nice.	watwut	8.579535	-6.5305476	comment	7.0	48.0	1699301916	-11.898682
38372981	I don't understand why so many peopl	I don't understand why so many people seem to dislike git. But maybe in actuality it is not many people, as usually people who are discontent are the loudest.I used Mercurial in the past for a bit, and it was fine. But for me it doesn't seem to have any huge advantages over git, if any. And after so many years of experience using git, I know what workflows work well, how to resolve merge conflicts, how to revert to an old commit if something really gets messed up, etcetera.I don't see any other DVCS really being able to replace git in the short run and I wouldn't be surprised if git will stay number 1 for the following decennia, as in my opinion it's really great software. A DVCS really has to provide substantial benefits over git in order to replace git as the number 1 DVCS.	wsc981	8.539576	-6.4966617	comment	7.0	46.0	1700614086	-11.91637
38394836	For years I was deeply annoyed by th	For years I was deeply annoyed by the terrible name “branch” for something that acts more like a bookmark (or “wandering tag” indeed!).And then I learned that git branches are branches in exactly the same way that the first element of a linked list in C “is” the linked list. Git was made by C people and they’re used to referring to entire data structures by way of some root element.I mean that doesn’t make me dislike the name any less but at least now I see where they were coming from.	skrebbel	8.524966	-6.5670943	comment	7.0	36.0	1700758885	-11.933464
15044883	Ask HN: Looking for a tool	Ask HN: Looking for a tool	szatkus	8.605829	-6.49557	story	7.0	4.0	1503050713	-11.9038
15341717	Why type out `git status`? I use `gs	Why type out `git status`? I use `gst`, and lots of other great aliases provided by the [oh-my-zsh git plugin](https://github.com/robbyrussell/oh-my-zsh/blob/master/plugin...)	bowmessage	8.583998	-6.5046535	comment	7.0	25.0	1506453734	-11.886555
12460337	"""Not the friendliest of beasts"" is p"	"""Not the friendliest of beasts"" is putting it mildly.Git is basically Linus in a nutshell: abrasive, unforgiving, and behaving like an absolute asshole to any non-expert struggling user.Sure, engineers should probably get to know its quirks and learn to work around them because it's now ubiquitous in the field, but let's not pretend that there's something virtuous about it. This is a piece of truly terrible software with an even worse UX that just happened to win the PR battle against its superior foes, because...Idunno, Linux, I guess?"	ewjordan	8.550962	-6.443546	comment	7.0	56.0	1473407783	-11.901761
12481134	I disagree. VCS use in an early stag	I disagree. VCS use in an early stage of a project can lead to less elegant and coherent systems, because you treat everything as a series of patches from day 1.The greatest works of humanity were written without a VCS (novels, operas). Using a VCS is only mandatory for multi-person projects.	0xcafecensored	8.630351	-6.446299	comment	7.0	25.0	1473698047	-11.852626
35191663	This is awesome, can't wait to get a	"This is awesome, can't wait to get api access to the 32k token model. Rather than this approach of just converting the whole repo to a text file, what I'm thinking is, you can let the model decide the most relevant files.The initial prompt would be, ""person wants to do x, here are the file list of this repo: ...., give me a list of files that you'd want to edit, create or delete"" -> take the list, try to fit the contents of them into 32k tokens and re-prompt with ""user is trying to achieve x, here's the most relevant files with their contents:..., give me a git commit in the style of git patch/diff output"". From playing around with it today, I think this approach would work rather well and can be like a huge step up from AI line autocompletion."	ftufek	8.683557	-6.448702	comment	7.0	45.0	1679016890	-11.690381
35274651	Ask HN: What is your shortcut for 'G	Ask HN: What is your shortcut for 'Git commit'?	gajus	8.5733385	-6.494087	story	7.0	1.0	1679578946	-11.898573
28025578	My git productivity hack is `git dif	"My git productivity hack is `git diff --color-words`. Instead of showing the line-by-line diff, it shows only the words that changed. Especially useful if you have long sentences where only a comma changed or some other typo. With git diff, the two lines are shown, with --color-words, only the changed symbol is highlighted. The option --color-words also works with git show. I even made aliases for them: git cshow and git cdiff.Other than that, I recommend that people learn to use git properly. In my work, I often have problems with people overwriting their commits and trying to handle merge requests of commits where one commit message is ""did some updates"" and the other commit is ""some fixes"". Getting to know git for an hour, may have prevented both issues. But I am biased, since I use git"	hkopp	8.66984	-6.526562	comment	7.0	81.0	1627818129	-11.806813
28027147	> My job isn’t to use git, it’s to w	"> My job isn’t to use git, it’s to write specialist software. If I get the software written and the customer is happy, it doesn’t matter whether I use <ide> or not. Imagine having 100 complex things bouncing around your head and having to make that 101 when you forget the order of arguments to merge.Imagine if you knew a cabinet builder who said:""My job isn't to use a table saw, it's to build beautiful cabinets. If I get the cabinets built and the customer is happy, it doesn't matter whether I use a japanese handsaw or a CNC controlled laser. Imagine having 100 different pieces bouncing around around in your and having to then remember the assembly order.""Now, you might argue that this supports your point, by claiming that it actually doesn't matter whether the carpenter uses a japanese ha"	PaulDavisThe1st	8.546642	-6.4662876	comment	7.0	47.0	1627833004	-11.841933
28168632	Rebase Considered Harmful	Rebase Considered Harmful	jerodsanto	8.583304	-6.5714946	story	7.0	30.0	1628861651	9.366285
28167260	I get the argument but I disagree. G	I get the argument but I disagree. Git is meant for software developers on projects complex enough to warrant using SCM.Using SCM for teaching development to newbies is already adding unnecessary complexity (even in a collaborative setting, flows are complex enough to distract from more fundamental topics).If you're a software developer getting to the point where using git is needed you should absolutely know the core concepts behind public key cryptography, it's going to come up everywhere and you can fuck up big time by publishing the wrong part.	moonchrome	8.567989	-6.4929442	comment	7.0	28.0	1628849698	-11.921675
28630998	The case of the curious commit messa	The case of the curious commit message	ingve	8.590046	-6.527934	story	7.0	37.0	1632412640	-11.9286
22603121	This is a nice tutorial, but I’m a l	This is a nice tutorial, but I’m a little sour on gitbook because their project really pushes their service, that seems really expensive to me.	prepend	8.55307	-6.457133	comment	7.0	24.0	1584436802	-11.89014
22735082	Git succeeded because of Linus.Sure 	Git succeeded because of Linus.Sure as hell wasn't because of the UX, else Mercurial would have won, or even DARCS.99.99999% of projects are not the Linux kernel	TylerE	8.564316	-6.5119405	comment	7.0	40.0	1585631546	-11.927966
29349635	I think many developers treat PRs as	I think many developers treat PRs as an opportunity to gatekeep. I'm not a very politically correct or emotional person but I think gatekeeping/nitpicking is extremely demotivating and it should be avoided wherever possible.When I review PRs, I'm looking at the big picture. I'm looking to see if it introduces security issues or diverges from standard practice. I don't care if there's a slightly better way which reduces the number of branches - if I see it as worth changing I'll do it myself after the merge. I'm not looking for all the reasons why it can't be merged, I'm looking for the minimum changes needed to make it comply with the codebase's existing standards.This post also highlights one of the reasons I fell out of love with Rust. There's too many ways to do things.	c7DJTLrn	8.62373	-6.4871426	comment	7.0	28.0	1637929610	-11.837853
34306260	Branchless Workflow for Git	Branchless Workflow for Git	modinfo	8.567862	-6.508611	story	7.0	54.0	1673233935	-11.913201
34660646	A specification for adding human and	A specification for adding human and machine readable meaning to commit messages	nikolasavic	8.587433	-6.5348	story	7.0	42.0	1675560858	-11.898247
34837721	Am I a curmudgeon? Not to take away 	"Am I a curmudgeon? Not to take away from this cool writeup, but I'm familiar with a few CI/CD tools, particularly QuickBuild, Jenkins and Spinnaker. So this jumped out at me:> Our CI process was pretty standard: Every commit in an MR triggered a GitLab Pipeline, which consisted of several jobs.me: nodding silently> Those jobs would run in an auto-scaling Kubernetes cluster with up to 21 nodesme: what the actual deuce?Is this really ""pretty standard""?"	teach	8.715384	-6.4950438	comment	7.0	24.0	1676655560	9.043262
34945276	I like ve magit, but I often enough 	I like ve magit, but I often enough find that I end up in a sticky situation that I can't resolve without retreating back to the CLI. I don't know if that's a deficiency in magit or just a matter of me not knowing well enough how to use it. Typically I just call the magit equivalent of whatever git base command I want and helm gets me the rest of the way with setting parameters.	Y_Y	8.602828	-6.490398	comment	7.0	32.0	1677417342	-11.868794
13669467	Genuinely curious: Why do you need r	Genuinely curious: Why do you need rebasing?I'm mostly a mercurial person, where doing a rebase is highly discouraged and nontrivial. After all these years on mercurial, I've never found a need to do it. Why is it so popular amongst git users?	BeetleB	8.57812	-6.5633917	comment	7.0	31.0	1487349199	9.39388
13713641	Big things affected:* DHT/torrent ha	Big things affected:* DHT/torrent hashes - A group of malicious peers could serve malware for a given hash.* Git - A commit may be replaced by another without affecting the following commits.* PGP/GPG -- Any old keys still in use. (New keys do not use SHA1.)* Distribution software checksum. SHA1 is the most common digest provided (even MD5 for many).Edit: Yes, I understand this is a collision attack. But yes, it's still a attack vector as 2 same blocks can be generated now, with one published, widely deployed (torrent/git), and then replaced at a later date.	anilgulecha	8.6932125	-6.526046	comment	7.0	57.0	1487856420	-8.326026
14134435	Amen.My bashrc has so many of these,	"Amen.My bashrc has so many of these, and they're probably among the most common commands I use daily!:    alias gs=""git status""
    alias gb=""git branch""
    alias grh=""git reset --hard""
    alias gcdf=""git clean -df""
    alias gf=""git fetch""
    alias gp=""git pull""
    alias gdom=""git diff origin/master""
    alias gdomn=""git diff --name-status origin/master""
    alias gd=""git diff""
    alias gl=""git log""
    alias glm=""git log --author <my_name>""
    alias gc=""git checkout""
    alias gcm=""git checkout master"""	madmax108	8.616552	-6.5224895	comment	7.0	25.0	1492463234	-11.84116
14285434	Please don't do that. Development hi	Please don't do that. Development history like frequent commits and merges has enormous value, for bisecting and debugging. Once detroyed, it's never coming back.What's the purpose of git commit tree at all if it doesn't truthfully represent the development process?	golergka	8.572893	-6.544154	comment	7.0	24.0	1494164886	-11.899025
31007351	I'm also happy with git, but there's	I'm also happy with git, but there's 3 main things that could improve on git IMO:1) Better handling of large files than git-lfs. As in 10+ GB repos. This is needed for game development (currently they tend to use Perforce or PlasticSCM)2) Sparse checkout via file system integration (like Eden has)3) Build system integration, so unchanged files and modules don't even need to be fetched to be compiled, because cached builds can be fetched from a build server instead (requires proper modularization, so e.g. C++ macro expansion doesn't just prevent anything from being cacheable)These are all features that primarily have value for repos that push the limits on size, like big monorepos (with a huge amount of files) or game development (with big asset files). But get it right, and you could massi	m12k	8.575254	-6.466643	comment	7.0	32.0	1649792474	-11.893222
31105227	The 3-way diff in JetBrains products	The 3-way diff in JetBrains products, like IntelliJ, are the best, IMHO, because it helps you edit the resolved result, while updating both left and right diffs.Their diff tool also has a magic-wand icon, which resolves trivial conflicts automatically. I still wonder why git doesn't do that by default... It's such a pain to resolve conflicts without that feature.Also, you get syntax highlighting, structural editing, help, definition quick-lookup and similar IDE features available, while working on the resolved version of the code, which is syntactically correct usually, because there are no explicit, textual conflict markers in the resolved text.	onetom	8.6826	-6.502477	comment	7.0	27.0	1650505655	-11.789072
31123868	Reminds me of when GitHub stopped us	"Reminds me of when GitHub stopped using ""master"" for the default branch because it was somehow offensive."	olalonde	8.5020075	-6.528343	comment	7.0	79.0	1650645060	-11.714168
31187091	I don't get this logic, that's what 	I don't get this logic, that's what .gitignore is for. I've been using .env files for years and never mistakenly checked one into a repo.	dvt	8.613502	-6.458541	comment	7.0	29.0	1651102092	-11.850435
31635848	The learning curve on git is absurd.	The learning curve on git is absurd. It's just so long ago we've mostly forgotten.	JonChesterfield	8.536801	-6.5121646	comment	7.0	36.0	1654472213	-11.90552
39648643	How HEAD works in Git	How HEAD works in Git	guiambros	8.551829	-6.5049663	story	7.0	59.0	1709948421	8.908473
36744743	I remember how I promoted Git over a	I remember how I promoted Git over a decade ago, and I heard from the lead guy that “SVN does the same” and “there are no benefits of using branches” (he never used them). Please listen to your coworkers and don’t be that guy. Technology moves forward, make it great, but it’s time to move on.	kmac_	8.5688505	-6.4847364	comment	7.0	32.0	1689495620	-11.881379
36831922	>Git focuses on individual branches,	">Git focuses on individual branches, because that is exactly what you want for a highly-distributed bazaar-style project such as Linux. Linus Torvalds does not want to see every check-in by every contributor to Linux: such extreme visibility does not scale well. Contrast Fossil, which was written for the cathedral-style SQLite project and its handful of active committersUgh...so after all that fanfare of how amazing fossil is, the author admits it just doesn't scale well.  I was wondering how that ""see it all"" approach worked for a busy repo, and now I know, it just doesn't.I love SQLite, and glad the primary author is happy working on it with fossil.  I think if he published it's largest downfall first, it might gain more adoption to folks that could actually use that feature."	somenewaccount1	8.527466	-6.4930983	comment	7.0	25.0	1690077974	-11.895217
36924751	The other day I was trying to work w	The other day I was trying to work with git LFS. I was very surprised to find out git-lfs, as in the binary, CLI application is the only (open) implementation in existence. There is nothing else. And even it itself does not offer itself up as a library; so even native Go code (the implementation language) has to fall back to shelling out to the CLI git extension! Not even bindings are possible. Such a painful loss of interoperability: IPC via return codes and parsing stdout/stderr.It seems a similar story with the rest of git. I have hopes for gitoxide aka gix, and think the approach of library-first is correct going into the future. A CLI is then simply a thin wrapper around it, mapping argv to library operations basically.	diarrhea	8.565017	-6.4549546	comment	7.0	42.0	1690665607	-11.918846
37043982	I wonder why mercurial didn't win.I 	I wonder why mercurial didn't win.I think it was the performance.	paulddraper	8.478943	-6.5751863	comment	7.0	25.0	1691463593	-11.954713
37515760	That was very informative, but I won	That was very informative, but I wondered if there is an easy-to-read reference somewhere about WHY git works the way it does?I am old enough to have used SCCS, RCS and CVS extensively.  Each had their faults, but Git is the only VCS I have used where dealing with merge conflicts is unintuitive enough that I sometimes end up with the repository in an unusable state.  I am sure I am doing something wrong, but I would like to understand why.The VCS that maps closes to the way my brain works is ClearCase.  You essentially have a versioned file system, and you can set up a view to present any previous state of that file system.  Of course, administration is a nightmare, it is not distributed, it is expensive, yada, yada. But when using it I always felt I knew exactly what was going on under th	deepspace	8.582427	-6.479035	comment	7.0	70.0	1694731308	-11.866311
24522519	GitHub Default Branch Changes	GitHub Default Branch Changes	surfer7837	8.500008	-6.5365367	story	7.0	13.0	1600468597	-11.796944
24644690	> Fossil also supports bug tracking,	> Fossil also supports bug tracking, wiki, forum, and technotesThat sounds great, but I'm scared of checking these features out because I'm currently looking at the quick start guide[0] and am immediately put off by how awful the CSS is. Formatting running text such that a single line can be ~500 characters wide[1] results in very low readability. There's a difference between ‘themeable’ and ‘configuring a custom theme is mandatory because the default option makes you feel sick’.In case someone working on Fossil sees this: I just bookmarked the site because the project seems very attractive in most other respects. I hope that when I eventually re-visit that link, I'll be able to go on a significantly deeper dive. A somewhat sane style sheet would certainly help.[0] https://www.fossil-scm.o	n3k5	8.50317	-6.509123	comment	7.0	29.0	1601504397	-11.932688
24688639	I can only sit in amazement as I rea	"I can only sit in amazement as I read this thread, watching seemingly smart people advocating throwing away history for the sake of tidiness. It's maddening.Those are four commits.  That's what happened.  It does not matter that it's untidy.  It's your history.Just leave it.  It will save you a lot of work some day when you need to find the error you introduced when you accidentally removed one too many lines on that ""remove debug logging"" commit."	jasonkester	8.577924	-6.5413365	comment	7.0	21.0	1601911989	-11.940394
24688697	"I usually understand ""squash"" to mea"	"I usually understand ""squash"" to mean ""bundle everything in a PR into a single commit"". Which can indeed break bisect workflows.There's a middle ground though: rebase your commits, but not necessarily into a single one. Before I submit a PR, I rebase my branch (which has lots of small commits, some of which undo previous work or are a work-in-progress), and make sure that every commit is as small as it can be without including work that is halfway done (so all tests still succeed), and have a clear description of what they're doing.I then have both a nice history, and I can bisect to find a problematic commit, or inspect the commit history of a single line to get more context about it."	Vinnl	8.576288	-6.5582275	comment	7.0	41.0	1601912328	-11.925082
25034242	I've been keeping an eye on Pijul fo	I've been keeping an eye on Pijul for a while, but assumed that (when it eventually stabilised) it personally wouldn't be worth the effort to switch from git.I've changed my mind now that they're tracking byte ranges instead of lines, with ranges decided in a customisable way at commit time. Semantic/format-aware versioning would be really nice. The easiest plugins to write would be s-expressions and JSON, and I could definitely see myself choosing Pijul for such repos in the future. If the patch-based approach is truly as nice as it appears, that might push me to use it more generally.In fact, making an s-expression plugin which is robust across various Lisp dialects might be a good way to bootstrap the user community.It would be nice to have for other languages too (C, Python, etc.), but	chriswarbo	8.607659	-6.5347667	comment	7.0	30.0	1604926550	13.8917885
25044515	> I use git almost exclusively from 	"> I use git almost exclusively from the command line in a terminal.Is certainly key. Most git frontends seem to be really quite bad for many reasons. Though ""Push failed, want to pull, merge and push again? [Yes]"" => constant ""merged ssh://upstream.server/foo/bar/repo.git merged into branch master"" commits being added to the history certainly irks my OCD the most. These frontends also seem to try and hide what git does, which leads to incorrect and confused mental models and much more frustration down the line than just learning to do it the git way directly. Yes, git is a ""my way or the high way"" tool, that's not great or something to emulate, but it is what it is. Trying to work around that only results in more pain.Only use the git command line, use gitk for browsing history graphically"	formerly_proven	8.561447	-6.4952583	comment	7.0	34.0	1605005025	-11.879393
25081634	Why renaming Git’s master branch is 	Why renaming Git’s master branch is a terrible idea	nmj	8.5231905	-6.523562	story	7.0	27.0	1605272064	-11.709211
25122687	> I’ve used it since GitHub was in b	"> I’ve used it since GitHub was in betaThis is the root of the author's issue. As another commented, git is born in a world where computers are mostly offline, people are highly technical, and will spend a lot of time manually crafting the messages they will send to the numerous collaborators. It is an alone-first software. What the author wants (and exactly what I want as well: https://news.ycombinator.com/item?id=25002318) is the complete opposite: a system that knows it's connected to other people, where changes are instantly propagated and easily visible, where the differentiator between ""branches"" is not ""what computer does it reside on"" but ""who did it"". That's the model behind GitHub, after all.git is complex because it's working with a very complicated model that is not in line wit"	rakoo	8.521265	-6.4396777	comment	7.0	98.0	1605614092	-11.902299
25123193	You really believe that git stores -	You really believe that git stores -- in full -- every version of a tracked file? Every commit that deletes the whitespace from an otherwise empty line in a 30KB file is another 30KB of hard drive space gone?	thaumasiotes	8.586785	-6.4916406	comment	7.0	39.0	1605617901	-11.879352
25124322	You forgot log, cherry, stash, blame	You forgot log, cherry, stash, blame, which are also daily use commands. You also have to learn a lot of concepts to even understand the help and error messages for these commands - the worktree, the index, the stash, HEAD, ours vs theirs, conflicts, remotes, tracking branches, when it is safe to push -F, etc. Depending on the project you joined, you may also have to immediately learn about git LFS, submodules, squashing, fast-forwards, tags.You have to understand a lot of things before you can somewhat comfortably use git, much more than something like P4.	simiones	8.564554	-6.4926877	comment	7.0	89.0	1605624703	-11.8875065
25124497	How can you pull without using stash	"How can you pull without using stash? Do you always commit everything before pulling?You also need the log daily to know things like ""what changes made it into this build"", or almost everytime I fix a merge conflict, to understand why something is the way it is.I can grant that cherry-pick & blame are more rarely used, though blame is often on by default in many editors, and cherry-pick is something my team does daily around every release (since we don't want to merge the trunk into the release branch the day of the release for 1 bugfix)."	simiones	8.591237	-6.532559	comment	7.0	39.0	1605625497	-11.894384
25330018	Is that why people are always saying	Is that why people are always saying you should squash commits? To help with collecting metrics?!I view it as a clear antipattern (since the history within a branch can be valuable later if you need to cherry-pick apart a feature or find a bug with git-bisect) and have asked superiors in numerous places why they require it, and the response is usually a vague mention of “it cleans things up” and “history isn’t important”. It feels like the kind of practice that was mentioned on a screencast and just got cargo-culted, but I have to think it originally had some purpose.	Uehreka	8.568937	-6.5631137	comment	7.0	24.0	1607325135	-11.958693
38826997	Ask HN: Onboarded and overwhelmed by	Ask HN: Onboarded and overwhelmed by new code base	zarathustra333	8.546579	-6.4794974	story	7.0	6.0	1704052580	-11.8966465
38832169	I think I would prefer this style.An	I think I would prefer this style.And also the discourse around commit messages and their various flavors may be one of the biggest wastes of time in terms of ROI in our industry.I’ve been doing this for 14-15 years and can probably count on two hands the number of times I’ve needed to look at historical commit messages.	rco8786	8.58239	-6.531068	comment	7.0	51.0	1704120877	-11.921912
32628112	When I'm evaluating an open-source p	"When I'm evaluating an open-source project, I always check the quality of its commit messages. I don't care about following a specific format or something, all that matters is whether they are informative or not.Sadly, Odin doesn't seem to pass the test. It's full of commits labeled with just ""fix <thing>"": https://github.com/odin-lang/Odin/commits/masterA few examples of projects with better commit messages:Linux kernel: https://github.com/torvalds/linux/commits/mastergcc: https://github.com/gcc-mirror/gcc/commits/masterPerl: https://github.com/Perl/perl5/commits/bleadWayland: <a href=""https"	greaterthan3	8.586859	-6.534587	comment	7.0	27.0	1661692064	-11.931155
32637643	Git’s database internals I: packed o	Git’s database internals I: packed object store	todsacerdoti	8.575807	-6.465183	story	7.0	216.0	1661778063	-11.876378
32683649	What is the best git gui client?	What is the best git gui client?	Git_Guru	8.562817	-6.4641376	story	7.0	3.0	1662068401	-11.845288
31852845	This is one of the reasons why Go ha	"This is one of the reasons why Go has its own versioning system.  From a project's `go.sum`:example.com/example v0.0.0-20171218180944-5ea4d0ddac55 h1:jbGlDKdzAZ92NzK65hUP98ri0/r50vVVvmZsFP/nIqo=Where ""h1"" is an upgradeable hash (h1 is SHA-256).  If there's ever a problem with h1, the hash can be simply upgraded.Git's documentation describes how to sign a git commit:$ git commit -a -S -m 'signed commit'When signing a git commit using the built in gpg function the project is not rehashed with a secure hash function, like SHA-256 or SHA3-256.  Instead gpg signs the SHA-1 commit digest directly. It's not signing the result of a secure hash algorithm.SHA-1 has been considered weak for a long time (about 17 years).  Bruce Schneier warned in February 2005 that SHA-1 needed to be replaced.  Git de"	Zamicol	8.661421	-6.516741	comment	7.0	45.0	1656007187	7.195501
31924334	Fwiw a branch isn't a named sequence	Fwiw a branch isn't a named sequence of commits, it's just a label that points to a single commit. It's exactly the same as a tag except that git moves it when you make a new commit.Mercurial calls these bookmarks which IMO is a much better name because it works exactly like real bookmarks (in books, not browsers). A git branch feels a little bit like a branch of a tree because each commit points to their parent. Therefore, you don't need to track the entire sequence of commits in the branch but just the commit at the tip. I think if they'd had named only this concept better, Git would've been way easier to grok.I wouldn't usually nitpick like this but given that the entire point of this article is it matters to get the basic concepts right, I figured the author might want to get this basi	skrebbel	8.540492	-6.563695	comment	7.0	67.0	1656529254	-11.91921
32351956	This actually gives me insight into 	This actually gives me insight into why one contributor I worked with was crazy about squashing all commits into one when merging into main. I still think that's not good, because you loose the commit message history, and why have history at all if you squash it away. But maybe this was why they preferred it.I find commit history is important if you have a long running client project with evolving context, so you can figure out why something was changed, not just what.	ehnto	8.5857525	-6.5452905	comment	7.0	30.0	1659676026	-11.966795
32352968	Recently git bisect gained got a new	Recently git bisect gained got a new capability that was mysteriously missing before: bisect —first-parent. With that, it became possible to bisect also in repos where all commits on feature branches may not be buildable or passing tests, but commits on the development/main/integration branch does.A feature I’m still missing is to bisect using a new test. That is, I have discovered a bug in the program that there is no test for, so I author a failing test. Now I want to find out when this failure occurred but I can’t bisect because even the previous commit is green as the test didn’t exist. It’s possible to work around by placing the test outside the repo root and bisecting with a script that “authors” the test (e.g copies the file) at each step, but it’s cumbersome and feels like somethin	alkonaut	8.606902	-6.534647	comment	7.0	25.0	1659685588	-11.907246
23566414	Why don’t we just check ASTs in to g	Why don’t we just check ASTs in to git instead of text files ?	kristo	8.623402	-6.4602933	comment	8.0	31.0	1592506787	-11.836478
24289643	Can someone enlighten me as to the a	Can someone enlighten me as to the advantage of sticking with Mercurial? I've tried hg many times and personally found nothing compelling about it compared to git workflows.Git is ubiquitous, there's no really important feature set that hg offers over git, and it's super trivial to convert repos from hg -> git. So why go through this effort?Note: I'm not trying to start a flamewar; genuinely curious.	BluSyn	8.506038	-6.569513	comment	8.0	42.0	1598495843	-11.937017
20412220	Literate Commits (2016)	Literate Commits (2016)	pcorey	8.58084	-6.496235	story	8.0	52.0	1562858543	-11.872484
20746016	And yet people overwhelmingly chose 	And yet people overwhelmingly chose Git. Why is that?	ChrisSD	8.544269	-6.4727077	comment	8.0	33.0	1566303491	-11.8398
20746042	It would be interesting to read a br	It would be interesting to read a breakdown of why Mercurial failed against Git. It is superior to Git in every way except performance and adoption. Git won because GitHub won, and I bet GitHub chose Git over Hg's Python implementation because it was too slow.I wonder if Mercurial would have won if it was implemented in C or Rust (had it existed then).	pgt	8.496087	-6.5648165	comment	8.0	39.0	1566303579	-11.904138
39595633	>Let's take an example. Let's say yo	">Let's take an example. Let's say you are working on a feature. Your boss interrupts you (, bosses, right?) and says ""we need this bug fixed"". Or maybe you just notice the bug as you're working. Whatever it is, you need to switch contexts while in the middle of something. Now you have a few options.- You can fix the bug and commit it into your feature branch and try to get them both deployed together.- You can stash everything, create a new branch, switch to it, fix the bug, commit and push it, then switch back to what you were working on.- You could locally clone the repository to a new directory and work on the other branch there, then push it back into the main one and then push from there back upstream. --What?Why couldn't you, like, create another branch off of main, switch to that, a"	coldtea	8.60603	-6.5631943	comment	8.0	56.0	1709584237	-11.917944
39657499	Git from the Bottom Up (2022)	Git from the Bottom Up (2022)	tempodox	8.535379	-6.452715	story	8.0	45.0	1710057584	-11.866846
36833481	Made a list of all the revision cont	"Made a list of all the revision control tools I've used over the
decades, the year they were created, and the year I last used them:    sccs            1973    2000
    rcs             1982    2000
    cvs             1990    2004
    clearcase       1992    2004
    perforce        1995    2011
    subversion      2000    2015
    mercurial       2005    2015
    git             2005    present

So, at least for me, they last around 15 years or so.But often time when I tell juinors that when they're my age, git will
be distant a strange memory to them, they look at me funny.  It's a
wonderful tool and earned its success, but I'll be sad if it's our
final take on the problem."	anon35	8.586799	-6.4819274	comment	8.0	84.0	1690100125	-11.8990135
36953914	"""working copy is automatically commi"	"""working copy is automatically committed"" seems like a good idea at first glance, but there are many situations where this is not a good idea:- when new artefact files are added and you have not yet added them to .gitignore, they'll be automatically committed- when you have added ignored files in one branch and switch to another branch, the files will still be in your working copy but not listed in your .gitignore file, and would then be automatically committed- staging only some files and comitting is much easier than splitting a commit after the fact"	awestroke	8.615836	-6.519022	comment	8.0	41.0	1690880381	-11.918945
36954306	Sometimes you have changes that are 	Sometimes you have changes that are permanent to your repo (ie local workflow), that you always want to keep locally, but never push to the remote.In git you would always leave the changes unstage, does that mean with jj you would always have to remove them before pushing? I haven’t found an answer on the linked page.Side note: I really wish git had a way to mark commit has ‘no-push’ so they never leave your local copy, as an upgrade of the unstaged workflow.	KolmogorovComp	8.572948	-6.5221195	comment	8.0	56.0	1690884729	-11.929263
25121547	Git is one of those technologies whe	Git is one of those technologies where it's super important to get a good grasp of how to internals work. Once you got that, it get easier to answer git questions for others or yourself, and to read the documentation or man pages, as you know what is happening.With how software devs use git, it's 100% worth it to read a good book on it.	remirk	8.543397	-6.4891195	comment	8.0	35.0	1605604119	-11.902805
25122526	>But IMO it isn't because Git is har	">But IMO it isn't because Git is hard, but because they don't have to truly understand Git to use it. That's how easy it is.A copy&paste of my previous comment:Everybody's brain is different but I actually understand all of git's internals (the ""plumbing"") but it doesn't help me with the git CLI (the ""porcelain"").Yes, I know that Git is a DAG (Directed Acyclic Graph), and that HEAD is a pointer, and the file format of BLOBs and SHAs, etc. If I were to implement a DVCS, I would inevitably end up reinventing many of the same technical architecture decisions that Linus came up with. But none of that insider knowledge really helps me remember git syntax if I haven't been using it in more than a month. Even though I grok git's mental model, I still can't answer the top-voted ""git"" questions on "	jasode	8.552498	-6.508166	comment	8.0	49.0	1605612774	-11.890082
25124606	As I said to the other commenter - I	As I said to the other commenter - I don't even know how to use git without the stash, since you need everytime when you have some local changes but want to pull from the remote - the only alternative I know of is committing your local changes instead of stashing them.Also, git lfs and git submodules and their associated commands are necessary or not based on the project, not on your personal level of proficiency.I also don't know of any workflow where you don't need to look at the log at least once every few days, even as a junior dev, to confirm if a bug is fixed in a build or not if for no other reason.	simiones	8.575077	-6.538694	comment	8.0	36.0	1605625993	9.398168
25123017	+1. The very first question:>Oh, I j	+1. The very first question:>Oh, I just pushed a change. I really didn’t wanna push that, so how do I undo it?Is a Github problem, not a git problem. You might as well ask how to unsend an email. If you don't know what git push means, you shouldn't be using it and are playing with intellectual property fire.The conflation of Github with git is responsible for a lot of confusion. Having Github be your first interaction with git is a disaster.Regardless, there's no shortage of blog posts complaining about git being hard. But there is a shortage of effective, popular competitors. I think that, actually, many-chefs many-branch differential version control is just a hard problem and creating a simple model for it is much harder than complaining about git.	thrwyoilarticle	8.518013	-6.5192676	comment	8.0	79.0	1605616543	-11.920986
25151732	I know isomorphic-git has been usefu	I know isomorphic-git has been useful to a variety of projects. But may I ask what advantage does being pure JS have over writing a wrapper around the git executable?	O_H_E	8.485152	-6.4586573	comment	8.0	24.0	1605806355	-11.904234
38810253	> rebasing creates a cleaner, more u	"> rebasing creates a cleaner, more understandable history & state of the world without the clutter of merge commits""Cleaner"", for some definition of ""clean"". In this case, pretty, not accurate.I just can't understand the draw of rebase based workflows. It seems to be an expression of a preference for aesthetics over accuracy. What is the point of source control, other than to reliably capture what actually happened in history? As soon as you start rewriting that, you compromise the main purpose.Using merge commits preserves what you actually committed. If you ran tests before you committed, rewriting that commit invalidates that testing. If you need to go back and discover where a problem was introduced or what actually happened, with certainty, in a commit history, rebase undermines that,"	wandernotlost	8.578405	-6.564394	comment	8.0	60.0	1703884380	-11.90653
38810408	The fact that rebase would ever be p	"The fact that rebase would ever be preferred over merge just shows how bad Git really is under the covers. It's insane that everyone is re-writing their development history to avoid issues with their source control system. There's no reason that should be necessary at all. Manually intervening and re-writing history should be completely antithetical to a good source control system.And squashing should never be preferred by anyone if the tooling was actually any good. For PRs? You should be able to define a group of commits and look at it as a whole, not just operate on a single commit. For clutter? You should be able to ""zoom"" in and out, or collapse/expand branches in your UI. For disk space? If the size of each commit was O(size of change + small constant), then squishing wouldn't help, "	feoren	8.579456	-6.5583053	comment	8.0	55.0	1703885339	-11.963135
38835651	TBH, at least at every company I've 	"TBH, at least at every company I've worked at recently, the style of the commits is more or less irrelevant to me save for one very important piece: The commit starts with the ID of the ticket for the code change (or some placeholder for very small commits where a ticket wasn't necessary, e.g. [no-tix]). The biggest benefit of this is that these commits can then be automatically linked to the ticket which often has a lot more detail and conversation.99% of the time when I'm looking at commit history, I'm not just generically scanning. I'm usually looking for a particular change, or when something touched a particular file, etc. Even the example given in the linked page isn't really relevant to me, because I'm rarely ""quickly scanning"" a whole commit log for something in particular - I'd al"	hn_throwaway_99	8.587903	-6.5219746	comment	8.0	52.0	1704145850	-11.889725
38888847	> is “how Git implements it” really 	"> is “how Git implements it” really the right way to explain it?Of course not, and nowhere outside of software engineering will you find such widespread confusion between concepts and their implementation.Do we think of pressing the gas pedal in a car as ""accelerate"", or as ""regulate the intake manifold""?Commits are one of the most high-level concepts in Git. If an explanation for them resorts to implementation details, it's a bad explanation."	p-e-w	8.545678	-6.5104594	comment	8.0	52.0	1704520661	9.691557
33042018	GitHub's Missing Merge Option	GitHub's Missing Merge Option	thcipriani	8.600114	-6.480568	story	8.0	91.0	1664580408	-11.873688
31813128	One big advantage not mentioned in t	One big advantage not mentioned in the article particularly relevant to this audience:  git diffs (or your VCS of choice).  One sentence per line means diffs will operate per-sentence, rather than per-paragraph.  This way the diff can capture the restructuring of the paragraph (adding/removing/replacing a sentence), which gives much more insight than swapping out the paragraph wholesale.  It also means minor changes (e.g. typo fixes) will only add+delete a single sentence, making it much easier to identify what has actually changed from one commit to the next.I take this a step further and will often split out a single sentence into a clause per line, but this is a judgement call rather than a hard and fast rule.	luhn	8.585095	-6.5113907	comment	8.0	37.0	1655746550	-11.794006
31924447	> But if you try to understand the c	> But if you try to understand the commands without the model, you will suffer, because the commands do not make sense.I've read this about git several times and certainly felt it. My question is why hasn't anyone come along and fixed it? Git has the plumbing vs. porcelain separation. Why hasn't someone written new porcelain that makes git as intuitive as mercurial, subversion, etc? This seems like a similar situation as dpkg/apt. The underlying design has been settled but we desperately need a better interface.> Git has an elegant and powerful underlying model based on a few simple conceptsMy second question is, if the underlying model is so f*cking elegant, how did it lead to such a confusing interface? This isn't so much me griping about git (although I am) but more a curious case for d	intrepidhero	8.539961	-6.5229225	comment	8.0	49.0	1656529843	-11.904489
31933934	> refusal to use Git[1] due to its c	> refusal to use Git[1] due to its complexityI kind of like this friction. If a software developer finds git too complex, that’s an important signal that I should minimize my exposure to them. I’d never work in a team that dumb, and I wouldn’t want any dependencies on their code.Of course there are other reasons not to use git, but complexity is not one.	prepend	8.528841	-6.4687405	comment	8.0	49.0	1656603228	-11.8894615
31985964	For you to enjoy using this tool you	For you to enjoy using this tool you had to change the model your brain use, and you call that good UX? And using aliases means that your git is now different from you co-workers git. And when teaching the new guys you throw all these aliases at them that they have no idea what is or how work?	R0flcopt3r	8.604123	-6.5145764	comment	8.0	28.0	1657011491	-11.754939
32097443	Ask HN: How to Teach Git Rebase	Ask HN: How to Teach Git Rebase	poplarstand	8.571189	-6.5633454	story	8.0	18.0	1657813091	9.3165045
32370675	These days it might be better to tea	These days it might be better to teach new users about ‘git switch’ and ‘git restore’ (added in Git 2.23, released 2019-08-16) rather than the two overloaded meanings of the confusing ‘git checkout’ command.https://git-scm.com/docs/git-switchhttps://git-scm.com/docs/git-restore	anderskaseorg	8.552038	-6.5339565	comment	8.0	65.0	1659812648	-11.906098
22233723	I don't understand the practical att	I don't understand the practical attack vector for breaking SHA1s in Git. Not only are objects checksummed by SHA1, they also encode the length. Finding a SHA1 collision is plausible, but finding a SHA1 collision that both lets you do something Nefarious, and is the length you need, seems really really unlikely	anaisbetts	8.672535	-6.5139847	comment	8.0	26.0	1580807997	7.143559
22298260	The History of Git	The History of Git	wickwavy	8.55857	-6.4696684	story	8.0	124.0	1581427657	-11.872113
13671817	Ask HN: What's your Git workflow for	Ask HN: What's your Git workflow for production systems?	whitepoplar	8.547593	-6.4785795	story	8.0	28.0	1487366719	-11.881943
13889622	My personal, subjective impression: 	"My personal, subjective impression: Commits are getting smaller and smaller nowadays. As in: In the subversion days,  many people commited only few times a day, sometimes not for several days. SVN commits of course involved a sync with the server (a ""push"" in git lingo), and thus usually represented a much larger increment with a substantial change to the code base [X]With git, it became very common to structure changes to a code base in many, very small commits. Rename a variable? Commit. Write some docs? Commit. Of course, the overall changes when developing a feature did not become smaller, they are now just distributed over many more commits. So I'd argue that a SVN commit was often conceptionally closer to what we now have  with a git pull-request.Why does this matter? Because It is k"	data_hope	8.589427	-6.5160246	comment	8.0	47.0	1489701792	-11.862865
31073657	On a related note, I seriously recom	On a related note, I seriously recommend everyone to set their merge.conflictStyle to diff3 (or even zdiff3 on newer Gits).  It shows you all of your version, thier version, and the original, common-ancestor version.  It really should be the default, and, as far as I know, the only reason it isn't is because there are some older diff(1) implementation that don't support three-way diffs.See https://blog.nilbus.com/take-the-pain-out-of-git-conflict-re... and https://stackoverflow.com/q/27417656.	ainar-g	8.675162	-6.5050664	comment	8.0	35.0	1650302290	-11.853707
31115111	My previous employer still uses svn.	My previous employer still uses svn. It created so much headaches and frustration due to unproductivity because e.g. someone pushed a bug without testing and you unknowingly downloaded it. No way to easily reverse of course. It was my first job after University and taught me that CRUD b2b Java enterprise jobs are to avoid at all costs in the future. For what it's worth though, I had some very funny-sad stories to tell when I interviewed to get out of there after just 6 months. Never tought a versioning system could burn me out. Git is standard for very obvious reasons.	ThereIsNoWorry	8.640052	-6.4525013	comment	8.0	44.0	1650574805	-11.888231
31150336	Ask HN: How to view UI changes befor	Ask HN: How to view UI changes before & after a pull request?	seestraw	8.658777	-6.447868	story	8.0	13.0	1650855113	2.6751614
31173824	For those who write multi paragraph 	For those who write multi paragraph commit bodys, is there a tool you use to format them?Example commit on the React repo [1]. It just seems like a lot to type in the command line.[1] https://github.com/facebook/react/commit/ec52a5698e2dfea7050...	themanmaran	8.587782	-6.525971	comment	8.0	24.0	1651011218	11.078904
31176087	I'm a heretic who prefers informatio	I'm a heretic who prefers information in the PR.That's where the long-form back and forth arguments happen over the edge conditions.Periodically a few days after a PR has been merged I'll have a discussion with someone and realize some context was never captured, so I'll just add it at the bottom of the closed+merged PR for posterity.Yeah that means all the important information is in GH but if you migrate to GitLab or bitbucket or whatever they've got tools to pull all that info along with you when you migrate.I don't really care about individuals commits other than to find the gitsha to find the PR that they were merged into in order to find the full context.	lamontcg	8.587218	-6.5295606	comment	8.0	26.0	1651031268	-11.946825
31414179	Forgit: A utility tool powered by fz	Forgit: A utility tool powered by fzf for using Git interactively	kdheepak	8.562524	-6.4746814	story	8.0	99.0	1652810059	-11.877392
31420509	Additionally git supports a global g	"Additionally git supports a global git ignore.    $ git config --global core.excludesfile ~/.gitignore

Then you can put all the standard things you want to ignore into it:    $ cat ~/.gitignore
    .DS_Store
    ./drafts/
    *.swp

And it will apply to all git commands on your computer."	Dobbs	8.613599	-6.4808936	comment	8.0	108.0	1652863316	-11.838786
31635499	I feel like an SCM would have to be 	I feel like an SCM would have to be WAY better than git to make it worth using. The entire developer community is on git, so you are still going to have to know how to use git in order to access other open source projects. If you are already going to have to be using git for many things, why add a second SCM you have to learn to use?	cortesoft	8.551849	-6.4379926	comment	8.0	78.0	1654468752	-11.903903
31683086	One of the achievements is 'YOLO': '	One of the achievements is 'YOLO': 'merged without a review'.We really shouldn't be encouraging this.	david_allison	8.692074	-6.4688773	comment	8.0	31.0	1654791347	2.2750676
25459054	Git is the leakiest abstraction in t	"Git is the leakiest abstraction in the history of abstractions.Diffs are a ""natural"" object for version control yet got doesn't actually use them and as we can see in this article, multiple git commands leak this implementation detail."	oblio	8.618443	-6.5002766	comment	8.0	50.0	1608232039	-11.82196
25536008	Git still works great.Why would it n	Git still works great.Why would it need to be replaced, just because it's 15 years old? I can think of a zillion things that are over 15 years and still very much working.	aspyct	8.558884	-6.4945064	comment	8.0	44.0	1608898159	-11.89524
25538046	Some Git internals	Some Git internals	ingve	8.552165	-6.458925	story	8.0	183.0	1608920389	-11.882238
25910530	Stash is a Go app which organizes an	Stash is a Go app which organizes and serves your porn	azalemeth	8.706968	-6.521539	story	8.0	52.0	1611618254	10.113627
26141047	Is This a Branch?	Is This a Branch?	wheresvic4	8.608012	-6.542472	story	8.0	136.0	1613382727	-11.812756
26284039	Git is what happens when a technolog	"Git is what happens when a technology is born out of hardcore engineering. Most of the world could greatly benefit from its functionality but it’s too hard for non software-engineers to learn. I hope the next era of version control thinks about the problem from a less technically inclined user’s perspective.
 Out of curiosity, does anyone know of any good alternatives that make version control easy? I personally love git, but want to see it’s benefits brought to a wider base of people. Projects like Bit are a step in the right direction."	srich36	8.590249	-6.456965	comment	8.0	30.0	1614423907	-11.849162
36178895	If git was simply too hard an easier	If git was simply too hard an easier (probably centralised)  alternative would have taken over by now.Ergo git may be hard to it's clearly not hard enough for market forces to displace it.	jpgvm	8.5397215	-6.4617796	comment	8.0	37.0	1685815087	-11.884141
36185256	> We cram our secrets into gitExcuse	> We cram our secrets into gitExcuse me?!	justizin	8.542888	-6.4612393	comment	8.0	37.0	1685883485	-11.882707
36371189	If you’re including rebasing, then I	If you’re including rebasing, then I can believe this (rewriting history is nuanced and complex), but I’m not sure I’d be teaching that straight away. My recommendation is usually only to start using rebase once you’re already very familiar with the rest of git, since it’s almost never necessary to achieve what you want.Also, bisect is definitely not common, and the vast majority of my colleagues wouldn’t know it exists; I’d place it into the look-it-up-if-needed category.	rmccue	8.5768	-6.5336566	comment	8.0	62.0	1687016568	0.85411745
28671147	`git` generally doesn't work with li	`git` generally doesn't work with lines of text. Mostly it works with opaque file blobs and directory trees.`git diff` and `git merge` work with lines of text by default - but they don't have to. You can supply your own `diff` and `merge` tools with the `difftool.*` and `mergetool.*` config options, try them out with `git-difftool` and `git-mergetool` commands, and set the default with the `git.diff` and `git.merge` config options.If someone wanted to create AST-based diff and merge tools for a given language, they could be plugged right into the existing `git` infrastructure and it would work with them absolutely fine.	Karellen	8.670798	-6.4965134	comment	8.0	28.0	1632753435	-11.798225
28735425	Ugit - DIY Git in Python	Ugit - DIY Git in Python	rohithkp	8.578118	-6.450682	story	8.0	194.0	1633248738	-11.849532
28757317	Ugh. One of my pet peeves is the gen	"Ugh. One of my pet peeves is the generation of release notes from commit messages. Commit messages and PR descriptions have a different audience (i.e. contributors) from release notes (i.e. users).For example, take a look at ESLint's autogenerated changelog [1]:    67c0074 Update: Suggest missing rule in flat config (fixes #14027) (#15074) (Nicholas C. Zakas)
    cf34e5c Update: space-before-blocks ignore after switch colons (fixes #15082) (#15093) (Milos Djermanovic)
    c9efb5f Fix: preserve formatting when rules are removed from disable directives (#15081) (Milos Djermanovic)
    14a4739 Update: no-new-func rule catching eval case of MemberExpression (#14860) (Mojtaba Samimi)
    7f2346b Docs: Update release blog post template (#15094) (Nicholas C. Zakas)
    fabdf8a Chore: Remove targe"	Vinnl	8.613741	-6.4794874	comment	8.0	44.0	1633428244	-11.8944645
28864912	GitHub's CI pipelines are behind Git	GitHub's CI pipelines are behind GitLab? My lord, here I was thinking about moving to GitHub Enterprise when our subscription expires because everything in GitLab feels like an unfinished weekend project. Seems like nobody can get anywhere near the functionality of Jenkins.	vultour	8.523799	-6.4444084	comment	8.0	40.0	1634222452	11.985522
29185052	I feel that having a default merge s	I feel that having a default merge strategy to squash and merge all commits in a branch is a version control anti-pattern. This discourages thoughtful and frequent commits that express the intent of a change because all the commits are just smashed together anyway so why bother. I think context and intent is lost when looking through git history of large smashed commits.I prefer using a precommit hook to automatically prepend a Jira ticket number to each commit so when you look at the history you'll see multiple commits grouped together with the same ticket prefix, but the commits still retain the intention of the commit. Knowing that commits will not be squashed promotes devs to make meaningful commits. I still advocate for cleaning up and squashing your own commits as you see fit with an	mrinterweb	8.581233	-6.558346	comment	8.0	46.0	1636612099	-11.924523
34302411	>I will award honorary negative poin	>I will award honorary negative points for any client which dares to treat git rebase -i as if it were a fundamental primitive.If you think that a git rebase is overcomplicated, rather than a fundamental primitive, then you missed an important part of the tool. And phrasing it this way is an insult to anyone who really tried to understand the tool - kind of like the nerd badge in schools.Git rebase is fundamental to Git in many ways. It is also easy in many ways. At the minimum, it makes it easy to make mistakes while experimenting much less of a hassle, since the commit chain can be cleaned up later.However, the point here is that git rebase is more similar to what the kernel developers and git developers intended to do with the tool, compared to the commit-merge workflow. There are two a	goku12	8.572669	-6.570972	comment	8.0	81.0	1673207357	-11.921438
34458429	The one thing I really miss about sv	"The one thing I really miss about svn is the central,authoritative, auto-incrementing revision numbers. Git hashes are less friendly to use - in the svn days it was easy to tell at a glance if you had an earlier or later version.Yes, I know the many ways that git is better in practice, and would miss some of the workflows git's nature allows if they were gone. But we really did lose something too, especially when running git in ""quasi-centralized"" mode such as on GitHub."	thaeli	8.575377	-6.4772224	comment	8.0	32.0	1674242886	-11.874524
34793416	I used to think commit messages were	I used to think commit messages were important. Now I don't, or more specifically I believe the importance should be shifted to ticket titles.In the workflow I was introduced to all commits backing a PR get squashed and merged with the commit message for that merge being the ticket number and title of the ticket the PR resolves.This creates an incredibly clean commit history that is easy to trace back to tickets and their associated work items (like product docs). It also frees coders from any burden of writing good messages as they progress.	wantsanagent	8.565762	-6.511164	comment	8.0	28.0	1676398237	-11.978038
19105885	Off topic: but is there anything for	Off topic: but is there anything for life-long git CLI user to gain from by going GUI?	amingilani	8.576053	-6.484455	comment	8.0	26.0	1549554458	-11.86264
19382018	Honestly, for personal projects wher	Honestly, for personal projects where I'm the sole developer, I only use git nominally.  I mean, it's there, and sure, I commit; but it's not like I'm spawning feature branches or anything like that.  It's a rather linear set of commits, functionally almost equivalent to having a zip of the source every now and then.  I'm sure many people are the same.	danielbarla	8.560973	-6.4906754	comment	8.0	25.0	1552502590	-11.878642
19384633	I've used git when I've contributed 	I've used git when I've contributed to open source projects. It's an over-complicated mess of a system when you're just one or two devs. Regular backups and notes are more than sufficient and never require you to google how to unfuck your branch.	AnIdiotOnTheNet	8.555782	-6.4448695	comment	8.0	42.0	1552516416	-11.870153
19389438	The rebase command is only safe if y	The rebase command is only safe if you never share a branch. Most people use a distributed revision control system to work with others and if you do work with others then rebase is dangerous and should not be used.Almost every rebase user I've spoken with has no idea what the danger is despite it being clearly discussed in the manual page for rebase and despite rebase being listed as dangerous every time it is mentioned in any manual page.For the sake of new users everywhere, please stop recommending rebase.	ectospheno	8.57331	-6.5777335	comment	8.0	36.0	1552573319	9.3291445
19545161	I remember having this debate many y	I remember having this debate many years ago. Would it be better to introduce a team with no source control knowledge to something like svn first or straight to git?Svn is easier to understand and use, but then you’d have to break some existing habits to get to git. But going straight to git might be a big step and cause reversion back to whatever system was already there.	yibg	8.581021	-6.4630084	comment	8.0	28.0	1554136611	-11.886103
19817764	Legit: Git Commands as an Esoteric P	Legit: Git Commands as an Esoteric Programming Language	signa11	8.576034	-6.4674997	story	8.0	92.0	1556886386	-11.853623
19907088	Git is not hard. It's very simple. B	Git is not hard. It's very simple. But people learn it the wrong way. You have to learn it from the DAG up. If you cannot grasp how the DAG works you'll forever be reading and writing articles like this one which do not help you to learn.This is a horrible article. You should not bookmark it or use it. If you're not a programmer, you shouldn't use git. If you are a programmer, do yourself a favour and spend a day going through something like this: https://wyag.thb.lt/It will make you better at git and better at programming. Git is a powerful tool and you need to learn how to use it. Imagine if people read articles like this one instead of learning how to drive.	rich-tea	8.5408	-6.496804	comment	8.0	47.0	1557813207	-11.897454
15952297	We pushed large binaries into our gi	"We pushed large binaries into our git in the past. This was fine-ish as long as Git was hosted inhouse, but now that it's SAASed out, they are a huge pain in the rear.I've browsed through a few git guides, but can't seem to find anything that would let me:1) Do something like ""du -s *|sort -n"" for the entire Git history2) Let me ""rm -rf --from-history-too"", that would cause the remote repo to actually shrink in size."	nikanj	8.5732975	-6.472853	comment	8.0	25.0	1513611525	-11.901922
16014333	Using git-flow to automate your Git 	Using git-flow to automate your Git branching workflow	CarolineW	8.565226	-6.507118	story	8.0	25.0	1514377362	-11.893364
21191359	I know this has been mentioned a mil	I know this has been mentioned a million times on here, but for the off chance that someone hasn't heard about it before I'm going to completely disregard that and say that Magit for Emacs is an incredibly helpful tool for interfacing with git repositories that I couldn't imagine working without it. It's by far the best interface to a version control system that I've ever used. It has helped me understand how git works behind the scenes, and allows me to effortlessly work with branching, stashes, merging, rebasing, remotes and much more, without remembering a bunch of arcane git commands.	Munksgaard	8.590696	-6.4647117	comment	8.0	31.0	1570536944	-11.76243
21195177	I will never understand why people u	I will never understand why people use a UI for git. 99% of the time people who do that don't understand how git works. When something deviates from the normal workflow they struggle.	mav3rick	8.546508	-6.493496	comment	8.0	30.0	1570558144	-11.901405
21418810	It's a shame how poor the command-li	It's a shame how poor the command-line usability of the git client is.  Commands are poorly named and often do the wrong thing.  It's really hard to explain to new users why you need to run `git checkout HEAD *` instead of `git reset` as you'd expect, why `git branch [branchname]` just switches to a branch whereas `git checkout -b [branchname]` actually creates it, etc.I really wish he'd collaborated with some more people in the early stages of writing git to come up with an interface that makes sense, because everyone is constantly paying the cost of those decisions, especially new git learners.	CydeWeys	8.552636	-6.507991	comment	8.0	67.0	1572616641	-11.907477
39136895	I disagree entirely.  A new feature 	I disagree entirely.  A new feature or bug fix should be a single commit on the main branch.  There's no need to see previous attempts to fix a bug or implement a feature in the git history.  Especially commits that merely fix formatting.	Sohcahtoa82	8.584662	-6.529402	comment	8.0	34.0	1706225239	-11.902798
39219037	As someone who has contributed to Gi	"As someone who has contributed to Git since before GitHub existed and who maintains legacy code, I simply cannot disagree more. I use `git blame`, `git log`, and `git show` in the terminal all the time. It's trivial to follow the history of a file. It takes me seconds to use `git log -G` to find when something was added or removed.Nothing pains me more than to track down the commit and then find a commit message that's of the form ""bleh"" or ""add a thing"" when the developer could have spent 60 second to write down why they did it.Nothing gives me more joy than to find a commit message (often my own) that explains in detail why something was done. A single good commit message can save me hours or days of work.Let me also just say, and this is a bit of shot: GitHub contributes to the problem "	js2	8.582979	-6.5201283	comment	8.0	49.0	1706810494	-11.900416
39237055	I can't stand Git. The points the au	"I can't stand Git. The points the author makes in the intro are true. Developers learn just enough Git to do their jobs, which is unfortunately more Git than they actually understand. I'm including myself in this. I've been using Git for nearly 20 years (since the very beginning), and I still can't accomplish anything more than the most basic things without reading documentation and hitting up the net for help. Even if I stick with simple operations, I can get in over my head. WTF is ""detached HEAD""? I've looked it up dozens of times, and as soon as I get past whatever I'm working on, I forget what it means. I don't know what the reflog is, other than that it has to do with some dark internals. Resolving merge conflicts during a rebase is a clusterfuck. And on any team I've ever worked on,"	caymanjim	8.534458	-6.5027714	comment	8.0	49.0	1706927002	8.938132
39326367	Ask HN: What's your Git workflow lik	Ask HN: What's your Git workflow like at work? What could be improved?	lifeisstillgood	8.581339	-6.546279	story	8.0	6.0	1707575472	-11.917372
18128316	I'm trying to set up a deployment pi	"I'm trying to set up a deployment pipeline, quite from scratch. That also includes picking source repository software. Self-hosted is a must for every component. So I chose gitlab and after that I dived into it. Oh boy was I in for a surprise. For CI/CD one needs docker, kubernetes and whatnot: https://docs.gitlab.com/ee/topics/autodevops/
But the alternatives don't look better either.So, fellow hn'ians. My requirements ATM are quite simple: Submit code via git, run automated test, if all good, put the files into the live system. Pull-requests are must and everything must be self-hosted because cloud is just another persons computer. Code is written in python. What would you recommend?
Edit: grammar."	ratiolat	8.711944	-6.511455	comment	8.0	32.0	1538553035	9.015573
18483893	I use git so much that I made these 	"I use git so much that I made these aliases in zsh:    alias g=""git show""
    alias gh=""git show HEAD""
    alias gs=""git status""
    alias gl=""git log""
    alias gco=""git checkout""
    alias gd=""git diff""
    alias gbl=""git branch -v""
    alias gbd=""git branch -D""
    alias gri=""git rebase --interactive""
    alias grc=""git rebase --continue""
    alias gra=""git rebase --abort""
    alias gst=""git stash""
    alias gsta=""git stash apply""
    alias gx=""gco -- \*; git reset HEAD \*""
    alias gcp=""git cherry-pick""
    alias gcpc=""git cherry-pick --continue""
    alias gcpa=""git cherry-pick --abort""

A few hundred instances of ""gs"" in my .zhistory :)"	adtac	8.610764	-6.5211253	comment	8.0	28.0	1542595835	-11.838029
18699251	Git quick statistics	Git quick statistics	arzzen	8.551434	-6.4577584	story	8.0	114.0	1545058302	-11.8708515
18920956	`git log` on its own (with no flags)	"`git log` on its own (with no flags) isn't that useful, as it's missing a lot of important information. I prefer `git config --global alias.lg ""log --color --graph --oneline --decorate""`. Then you can just type `git lg` and get a much more useful overview of the state of your current branch."	Ajedi32	8.586765	-6.513512	comment	8.0	41.0	1547647953	-11.8665495
30190955	Getting Started with Git Bash	Getting Started with Git Bash	brlnwest	8.559244	-6.478795	story	8.0	46.0	1643885870	-11.885402
30247909	Using 'Git rebase' to Perfect Commit	Using 'Git rebase' to Perfect Commits	adamjhawley	8.568715	-6.563726	story	8.0	48.0	1644254475	-11.913617
30401530	Maybe I'm too brainwashed by git, bu	Maybe I'm too brainwashed by git, but it seems to me one of its benefits is the way the index works. You're encouraged to be fairly explicit about what you're adding to a commit, which encourages making a nice version history. Why would I want everything I do to automatically be added to a commit by default? Doesn't this encourage me to either put all kinds of unintended, not-ready crap in my commits, or constantly manage the equivalent of .gitignore? What am I misunderstanding about the benefits of how this works?	uses	8.565678	-6.534909	comment	8.0	27.0	1645313044	-11.877373
12734888	Mercurial 4.0 Sprint Notes	Mercurial 4.0 Sprint Notes	steveklabnik	8.499157	-6.5599184	story	8.0	148.0	1476801921	-11.966939
12886329	Slightly meta: Turning off the synta	Slightly meta: Turning off the syntax highlighting entirely seems a bit hardcore to me, however, I always read each commit I do via git diff / pull request view, which does not have syntax highlighting (other than red/green for removals/additions), and I always strive to make the diff look good for each commit (which means, doing one thing at a time in each commit, and making sure it reads well).Unfortunately, not everyone I work with reads their code (yep, they write-commit-push-and-forget!) which sometimes makes code review a not so nice experience.Please, please, read your diffs before sending code for review.	jakub_g	8.67001	-6.4510546	comment	8.0	75.0	1478456615	-11.827772
13514492	You must not understand what CD real	"You must not understand what CD really means then, because full CD is impossible with feature branches. 
CD means every commit gets built and delivered all the way prod if it passes all tests. The key word is ""continuous"" as in, every single commit. Branch based means you only deliver once you merge. Merging is a manual step, so your not doing full-CD. The merge is basically your ""trigger"" and your doing ""delivery when I am ready"""	nhumrich	8.624052	-6.5593953	comment	8.0	52.0	1485703756	-11.876221
13563439	Scaling Git, and some back story	Scaling Git, and some back story	dstaheli	8.547479	-6.462449	story	8.0	143.0	1486156935	-11.884642
27580196	"How hard is`git reflog`
`git reset -"	"How hard is`git reflog`
`git reset --hard <SHA of commit you want >`Or if you just want to move back 1 commit`git reset HEAD@{1}`"	max_hammer	8.557393	-6.5261865	comment	8.0	30.0	1624289813	-11.906907
27580591	The most painful mistakes beginers e	The most painful mistakes beginers endure with git are irrevocable code removal from the current working directory because of bad usage of `git clean`, `git reset` (or `git merge` if you're brutish enough). This problem cannot be solved by using git, because git doesn't have any reference to such code.	OhNoMyqueen	8.556202	-6.4875317	comment	8.0	31.0	1624291901	-11.88986
27643355	Storing changes as text is a fundame	Storing changes as text is a fundamentally bad idea. Not only does it make merge conflicts more likely to happen, as transforms (me adding a function, you renaming something I use in the function) more likely to occur, it also means that formatting is committed and discussed rather than being a matter of personal preference.Hopefully the next item in this RCS CVS Subversion Git chain is just storing ASTs and transforms on top of them so we can spend less time fixing basic conflicts and discussing formatting.	nailer	8.645937	-6.5439405	comment	8.0	40.0	1624725414	-11.913883
27723602	I agree with the author's sentiment.	"I agree with the author's sentiment. The way this problem is typically framed is as a dichotomy between preserving a ""true"" history of what really happened on the micro/commit scale VS presenting a ""clean"" history that makes the story of the change easy to follow on the macro/PR scale.This is a false dichotomy. I'm greedy, I want BOTH. Give me story mode when I'm just browsing the repo, but offer me the option to switch into commit-by-commit mode when I want more detail."	infogulch	8.580208	-6.5675287	comment	8.0	70.0	1625336087	-11.916117
27859100	Really dumb question while I'm tryin	Really dumb question while I'm trying to decide whether to use something like git vs. CRDTs to handle version control for user changes made in an app I'm working on: why do we even use git anymore for source code version control if we want behavior like this?Nobody likes merge conflicts. We all want versioning. So long as we have versions at all why isn't the ideal interface for developing in teams something more like editing in Google docs? Why aren't we just doing that? Why are we still using systems that produce merge conflicts?Hoping for insight from folks who have either done this themselves or looked into it.Edit: one particularly nice feature of Google docs over Confluence is that in Google docs I can suggest changes that is somewhat akin to branches with git. I don't need to force 	eatonphil	8.696477	-6.4657536	comment	8.0	29.0	1626458128	-11.772608
12358149	Git already has `git branch` which d	Git already has `git branch` which doesn't in fact do any kind of branching but creates a label which follows commits when it's checked out.	Mchl	8.565602	-6.542464	comment	8.0	24.0	1472123816	-11.913414
35335324	nitpick: As it’s a platform and mach	nitpick: As it’s a platform and machine specific thing, technically it shouldn’t be in .gitignore but in .git/info/excludePeople working on Linux or Windows do not need to know about garbage your dev env leaves on your machine.I’m saying this half-seriously as I fully understand that these are so common, it’s more convenient to have the exclusion synced between clones.That said, as a purist, none of the repos I’m watching over have .DS_Store in their gitignore	pilif	8.618239	-6.4520874	comment	8.0	42.0	1679972333	-11.793046
28108950	"""Every commit should be runnable, th"	"""Every commit should be runnable, that is we should be able to git checkout any commit and get a functional code base. This means no “WIP” commits...""
I strongly disagree with this."	Josh5	8.57847	-6.5209684	comment	8.0	47.0	1628447677	-11.910902
28392988	I read most of this long article, an	"I read most of this long article, and I found it useful, but:It's unsurprising that people's mental model of git is incorrect. Git is not something people study at a conceptual level, it's something they learn recipes for in order to work on some project. Recipes like ""how do I save all this work I just did"" and ""oh shit, everything is hosed, please give me a magic spell I can paste into my terminal to fix it"".I don't really blame people, since git itself does nothing to teach you how it works. Git it is the definition of something you have to deal with in order to do something more important to you. Some people want to dig deep and understand how the system works: it's nice to sit near that person and ask them for help sometimes.Saying ""you should really understand more about git"" is like"	karaterobot	8.535346	-6.5066414	comment	8.0	49.0	1630595334	-11.920364
28393565	Ugh. So many concepts. So many thing	"Ugh. So many concepts. So many things to remember. Why? Git is simple. SIMPLE. But only, IMO, if you go bottom-up and not top-down. There are only 6 critical concepts in Git and each is simple enough to be described in a single sentence.1. Commits are immutable blobs that have one or more parents. Graphs, not trees. Anyone who uses trees for git commits misses the whole point and makes their (and their collaborators) lives complicated.2. Tags are (mostly, best practice) immutable pointers to commits. Tag are ""this is this thing FOREVER*.""3. Branches are named, mutable (by design) pointers to commits. Branches are ""this is this thing FOR NOW. Later it'll be something else.""4. HEAD is special ""branch"" that moves around automatically.5. Origin is the local snapshot of the remote. Origin is ""w"	bironran	8.560628	-6.53505	comment	8.0	45.0	1630597737	-11.876874
28576576	Exactly. I use basic git daily, but 	Exactly. I use basic git daily, but I'm still confused about rebase.	shimonabi	8.56978	-6.557838	comment	8.0	30.0	1631975687	9.286489
22488177	I have two long lived branches, deve	I have two long lived branches, develop and master.* major features are done in feature branches, w/rebasing prior to merge* minor stuff directly in develop* master is auto deployed following successful CI, whenever we merge develop in to it* we merge frequently, but not automatically* we tag releases manually when we do mergeIt's a more minimal version of git flow.  Small teams so not much problem.We could probably just drop the develop / master split and still be fine, but would force all changes to be in feature branches instead.	elyobo	8.613863	-6.5389767	comment	8.0	33.0	1583356289	-11.901184
22497364	I tried using Gitflow on our team, b	I tried using Gitflow on our team, but there was too much complexity for me. We ended up switching to Trunk Based Development (TBD)[1] which I and my team found to be much simpler.[1] https://trunkbaseddevelopment.com/	umvi	8.582213	-6.5087023	comment	8.0	43.0	1583437618	-11.867875
33101574	What's the purpose of this?  I can t	What's the purpose of this?  I can think of ways to use/abuse it, but there has to be a specific reason that it was added as a feature to git.	mywittyname	8.569044	-6.4825335	comment	8.0	27.0	1665006159	-11.847038
33108829	If I've already reviewed a PR and th	If I've already reviewed a PR and the author makes further changes, I definitely prefer to review an add-on commit. If the history is rewritten/rebased, then IME the entire PR needs to be re-reviewed from scratch. If we're talking about a <10 line change, then, by all means, rebase to your heart's content. With anything more complicated than that, rebasing a branch that's already been looked at can be disruptive and I'd strongly recommend against it (though squash-and-merge after review is fantastic).	jbergknoff	8.574173	-6.5457134	comment	8.0	30.0	1665067383	-11.914569
33141046	"""Git making me want to pull my hair "	"""Git making me want to pull my hair out yet again. One of the most unintuitive, clunky interfaces of any software I've ever used.""  Emphasis mine.The link has a bad title.The CTO's problem isn't Git.  It's the design of the Git CLI commands.Which, to be frank, I think is pretty reasonable.Git as a version control system is great, but it desperately needs an ""apt style"" revamp."	urthor	8.566753	-6.490197	comment	8.0	37.0	1665323732	-11.8837595
33542465	IMHO the single most important idiot	"IMHO the single most important idiot proof of git should be a universal ""undo"" command.- Committed wrong? Undo- Switched to wrong branch? Undo- Pushed wrong? Undo- Merged wrong? Undo- Wrong reset? UndoThere should be a ""idempotent"" undo for every action in git. If not, warn the user for possible outcomes.In this way, we can safely learn git via trial & errors."	est	8.569232	-6.5253477	comment	8.0	43.0	1668056755	-11.899656
33710794	> I know git can be tricky but it ca	> I know git can be tricky but it cannot be that difficult to teach people from non technical departmentsThis is far more difficult than you're suggesting. Git still confuses a lot of junior and mid level devs the second anything deviates from their memorized command workflow.If you're expecting non-technical people to have to learn git just to edit the documentation, they're just not going to use it at all.Writing and aggregating good documentation needs to be easy and simple. Gating documentation behind git is the opposite of that for non technical people.	PragmaticPulp	8.541117	-6.4889755	comment	8.0	43.0	1669147979	-11.88306
33944936	This is interesting. I wonder if he’	This is interesting. I wonder if he’s actually working on it:Q: If you magically had enough extra time to do one additional thing at work that you’re not doing now, what would it be?A: Oh, I’ve got a long list. But my #1 thing right now I think would be a new version control system which the working name is Fit, it’s a combination of Fossil with Git. Uses the Fossil user interface but it uses the low-level file format of Git. So that then you can work with Fossil’s interface but push and pull to legacy Git users. And I think that would be huge.	andrewl	8.527769	-6.4893966	comment	8.0	52.0	1670778133	-11.875538
34014520	Ask HN: Is it me or Git rebase is ki	Ask HN: Is it me or Git rebase is kind of hard to understand?	Akcium	8.578424	-6.5728283	story	8.0	6.0	1671199306	9.296384
34062891	> I recommend using two tools togeth	> I recommend using two tools together: Black and isort.Black formats things differently depending on the version. So a project with 2 developers, one running arch and one running ubuntu, will get formatted back and forth.isort's completely random… For example the latest version I tried decided to alphabetically sort all the imports, regardless if they are part of standard library or 3rd party. This is a big change of behaviour from what it was doing before.All those big changes introduce commits that make git bisect generally slower. Which might be awful if you also have some C code to recompile at every step of bisecting.	bombolo	8.576681	-6.5255604	comment	8.0	93.0	1671522729	-11.871071
26622961	Fixing a typo as you work on somethi	Fixing a typo as you work on something else is not bad - that's called Boy Scouting[1] and it's totally acceptable to sprinkle small improvements/cleanups in a change.As for getting distracted and refactoring something else - you're context switching. When you do that, you can also context-switch your repo by stashing your current changes (git stash) while you work on that tangent. Or commit your current changes to their local branch (you're liberally using branches, right? Branches are cheap in Git) and switch to a new branch for refactoring.If you really want to write your commit first (which is a great idea, because you should know what changes you're planning to make before you start working on them!), then you can create an empty commit when you switch to your new feature branch:    g	jasonpeacock	8.584349	-6.537482	comment	8.0	45.0	1617030852	-11.922386
26742215	This blog post is the most compellin	This blog post is the most compelling argument I've yet seen for pijul.Git should work the way we think it does! It's confusing that snapshots are being converted into a few different forms of change object, which can be reconciled with merges or rebases or applying patches.Pijul (and darcs before it) actually works on the basis of patches, pijul with a robust theory of patches.  A cherry-pick just moves a patch from one history-of-patches (branch) to another history-of-patches. One can share just a patch, and applying it is guaranteed to be the same action everywhere if that's possible, which it often is.I'm patiently waiting for pijul to be mature enough that I can move everything over to using it, it's one of the more exciting projects in the last ten years.	samatman	8.601141	-6.5575504	comment	8.0	46.0	1617907201	13.899789
26743212	Why have so many people written long	Why have so many people written long thoughtful explanations about how the author is wrong to suggest snapshots are a better mental model, and that you think all abstractions are leaky, but you find diffs a better mental model?The entire article is literally about how commits are literally snapshots. I would say people didn't read TFA, but a lot of people are quoting lines from TFA and then going on to argue with/expand on them in a way that is directly contradicted by the next few lines.I think it's because most of the people here have spent years working with git, and are so deeply attached to their understanding that they didn't hear most of what the article said.(Some commentators have pointed out specific oversimplifications the author makes like glossing over pack files, I'm referrin	iudqnolq	8.564295	-6.507319	comment	8.0	46.0	1617912964	10.390201
27291697	Does anyone know of a nice git inter	Does anyone know of a nice git interface for Neovim? I would love to get off of emacs, but it's hard to beat Magit.At the very least something that lets me view the repo status and stage selections would be good.	faho	8.678445	-6.4590893	comment	8.0	28.0	1622042547	-11.727588
38166536	"how often is ""understanding your pro"	"how often is ""understanding your project history"" something that actually comes up for you? In all my years of working with projects in git, I will occasionally look at my history to help me find a change that may have led to a bug, but it really only comes up for me once or twice a year and even then, it is rarely an extensive deep dive and never very far back in time."	jjeaff	8.577733	-6.526093	comment	8.0	25.0	1699295060	-11.897103
38373422	Mercurial also missed the window on 	Mercurial also missed the window on performance and safety. If you started using it around 2009 or so, Hg was notably slower for daily use and a lot of people recommended using extensions to match Git features but those extensions were not stable (Hg and RCS are the only VCSes I’ve seen require data to be recovered from a backup due to normal usage).There’s a meme that Git is hard to use but I think it’s conflating the challenges of getting used to version control at all, distributed version control, and any specific tool. I watched a number of developers do that and it was about as much work to go from SVN to either Git or Mercurial, and if they learned the other DVCS it was always easier since they were mapping concepts rather than learning them for the first time. The marginal returns o	acdha	8.535192	-6.543818	comment	8.0	38.0	1700616811	-11.923182
14907168	Stagit – A static Git page generator	Stagit – A static Git page generator	raldu	8.585711	-6.4571366	story	8.0	106.0	1501637442	-11.864885
15105009	New implementation of Git in OCaml	New implementation of Git in OCaml	tosh	8.561232	-6.467385	story	8.0	245.0	1503746908	-11.885516
15755188	Look, our lives (not just software l	Look, our lives (not just software lives, our entire lives) are dominated by crappy de facto standards. They are everywhere. They imposed themselves through inertia, laziness and by virtue of being just a tad more useful than anything else at a time where everything else was terrible. Cable companies, Internet providers, social networks, foods, they surround us.But once in a while, we get stuck with a de facto standard that's actually quite good in its category.I happen to thing git is one of those. It took a while to get there, we had to suffer through decades of crappy source control systems until we eventually stumbled upon a good one.I'm happy with git. It has a terrible UI but beyond that, it's been an incredible force for progress not just in the open source world but increasingly in	hota_mazi	8.571063	-6.453554	comment	8.0	44.0	1511338689	-11.881527
23469453	My life was also improved with some 	"My life was also improved with some additional aliases in my git config:[alias]
    dfif = diff
    idff = diff
    grpe = grep"	tych0	8.634935	-6.5112944	comment	9.0	41.0	1591728415	-11.825888
23620401	I submitted feedback over it but, as	I submitted feedback over it but, aside from the over-reliance on rounded corners, and making pills and buttons hard to separate, the single worst change is that you can't see the latest commit status from the repo screen. Instead, you get the commit hash, and have to click a tiny ellipsis button to get the commit message and the status indicator.When I'm browsing on github and not using git directly, the commit short-hash is the last thing I care about. You cannot see if your default branch has passed CI/status checks now. Those things should be first class citizens, that's why we put status badges all at the top of our readmes to make that info more visible with what we have.It follows the trend of designing with lower information density. This trend IMO is not appropriate for developer 	ljm	8.56477	-6.4677997	comment	9.0	101.0	1592946937	-11.877496
23730519	Gitqlite: Query Git Repositories wit	Gitqlite: Query Git Repositories with SQL	sebazzz	8.577902	-6.4914265	story	9.0	166.0	1593843493	-11.884805
23803752	`git`. I mean, its so popular that y	"`git`. I mean, its so popular that you get used to it eventually but the commands never make sense or map well to the mental model of what you're doing. And ""getting used to it"" is a seriously low bar for software IMHO."	javajosh	8.568239	-6.446933	comment	9.0	61.0	1594487944	-11.854741
23969993	I'm a somewhat advanced user of Git.	I'm a somewhat advanced user of Git. My coworkers use me as a reference when they have a problem of a difficult merge to solve.I don't follow each Git release, but I also didn't notice a great productivity enhancement for a long time. Sure it is a sign of a mature project, but I'd like to know:What's the somewhat recent Git feature that you really improved your productivity?	neves	8.557668	-6.469674	comment	9.0	45.0	1595887706	-11.904923
24374337	The issue with git is that no matter	"The issue with git is that no matter how well documented,  the user interface is horribly designed. For starters, how many different things does ""git checkout"" do, and how many of them actually reflect an intuitive meaning of ""checking out"" ?"	FartyMcFarter	8.546492	-6.499604	comment	9.0	55.0	1599222654	-11.863181
20470189	Personally, I’d be very cautious abo	Personally, I’d be very cautious about assuming that commit time has anything to do with work time.For at least 15 years I’ve had a policy - and so have the people on my teams - to avoid merging or committing to public branches at night or just before & during weekends so that you don’t accidentally hose other people on the team, who rely on automated builds & testing. We write code at all hours, but wait to commit/push/merge to master until the morning when everyone’s there.I realize that not everyone has policies like that, but these are high profile programmers who are likely to have their own complicating factors. Linus, for example, commits a lot of merges that other people depend on; his code reviews and code writing might be on separate schedules.	dahart	8.590678	-6.524623	comment	9.0	82.0	1563460357	-11.904657
20745798	Doesn't this mean BitBucket will die	Doesn't this mean BitBucket will die? Slowly, sure, but Mercurial support seemed like a key differentiator relative to GitHub.	jzwinck	8.459779	-6.49191	comment	9.0	38.0	1566301718	-11.967814
20776781	Serious questions...What does mercur	Serious questions...What does mercurial offer that git doesn’t?  Is the transition to git difficult for projects currently housed in a mercurial repository?	ulkesh	8.511289	-6.539929	comment	9.0	60.0	1566563252	-11.946347
18978591	Yeah, I've been seeing lots of peopl	Yeah, I've been seeing lots of people switch to circle-ci or gitlab over the past year.Not totally sure why. Travis does what I need and I know how to use it, and I don't particularly want to learn something new for CI myself, I just want to code!	jrochkind1	8.581002	-6.4388247	comment	9.0	61.0	1548255343	-5.3854995
19007761	I have no idea what use case is sati	I have no idea what use case is satisfied by git worktree, based on that blog post.   In the case that you desperately needed to have two branches checked out, why not just clone twice?	randallsquared	8.584976	-6.5091443	comment	9.0	33.0	1548529019	-11.894792
19388261	I have an admission to make: I don't	I have an admission to make: I don't understand git. By this I mean I have a few simple commands I use (status/add/commit/push/pull) and if I try to do anything more complicated it always ends up with lots of complex error messages that I don't understand and me nuking the repository and starting again.So I think: there must be a better way.I have often thought about implementing a VCS. The idea behind one doesn't seem particularly complex to me (certainly it's simpler than programming languages). If I did I would quite probably use WYAG as a starting point. My first step would be to define the user's mental model -- i.e. what concepts they need to understand such that they can predict what the system will do. Then I would build a web-based UI that presents the status of the system to the 	cabalamat	8.568778	-6.4860673	comment	9.0	53.0	1552563121	-11.890738
19881977	You're lying about the path that you	You're lying about the path that you took to get to that point, and you're creating a lot of (public) nonsense commits on the way there (unless you're very careful, and/or overly squash-happy).Whether you've published the true history earlier is irrelevant to that discussion.	Nullabillity	8.577439	-6.5425596	comment	9.0	51.0	1557520571	-11.904553
19907146	Honest to god, I don't know how peop	"Honest to god, I don't know how people who find `git` hard to use manage to write code. Everyone on the Internet acts like the concepts are impossible to grasp and it's like really easy to grok.Honestly, it faded into the background of code from the beginning. I mean, I know ""Forward-port local commits to the updated upstream head"" means nothing to anyone not already familiar with `git rebase` but a practical mastery of the tool is very easy to achieve.I honestly think this is a pedagogical lack. We tell everyone it's this complex thing and that they should be scared of rebase and the reflog and they believe it. Maybe if we didn't, it'd be easier."	scarejunba	8.564097	-6.566935	comment	9.0	43.0	1557813946	9.345034
15903436	Coming from someone who learned hg w	Coming from someone who learned hg well before git, and who's now being more or less forced to use git long after developing comfortable hg workflows, the staging area feels like a half-baked implementation of what it's supposed to be doing.I'm used to thinking of commits as atomic commits--roughly, each commit is the smallest change that atomically makes sense. So you should be able to use the staging area to build up that commit as you find more pieces to make it in. But while I'm slowly hacking away at this commit, I talked with someone else and decided to try an idea which turns out to be a small commit. But I've already got this half-built-up commit that's staged, so I need to commit that to make the new commit, and then somehow reverse the patches and restage the commit (which is som	jcranmer	8.589151	-6.56159	comment	9.0	41.0	1513060363	-11.922141
15903582	One personal anecdote:In a decade of	One personal anecdote:In a decade of using Mercurial, I've managed to get a repository in such a confused state that I had to blow it up and start from scratch just once. In the same time, I've had to do the same for git repositories at least 5 or 6 times--and I never really used git all that much. Even nowadays, where I'm more or less forcing myself to use git [1], I'm incredibly hesitant to try any sort of complex git operation because of the risk that I might lose my in-progress commits.While the problems of git's UI is well-known, I don't think it's as appreciated that git's complexity generally discourages people from trying things out. I'm never really sure what could cause me to lose unpushed commits or uncommitted working files, especially with git's predilection for reusing the sa	jcranmer	8.556861	-6.5337033	comment	9.0	71.0	1513062451	-11.943472
16677497	For those increasingly rare times I'	"For those increasingly rare times I'm not using Magit[0], I have a ""git lg"" alias I found once through HN[1]:  git config --global alias.lg ""log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit""

I strongly recommend both.--[0] - https://magit.vc/[1] - https://coderwall.com/p/euwpig/a-better-git-log"	TeMPOraL	8.608447	-6.5174313	comment	9.0	46.0	1522053256	-11.8364315
16771854	New features from the last few versi	New features from the last few versions of Git	fanf2	8.549582	-6.4588294	story	9.0	107.0	1523004183	-11.911661
17475392	Git Is Not Revision Control (2017)	Git Is Not Revision Control (2017)	Daviey	8.56444	-6.485994	story	9.0	29.0	1530913609	-11.877004
17483514	This article makes in seem like anci	"This article makes in seem like ancient history, but there are still projects around that use CVS or very similar VCS like for example ClearCase. My software engineering career started after git got popular, but I had to work with ClearCase. I wouldn't wish it on anybody.The inability to go back to old states of your project unless you happened to tag them makes finding the cause of bugs extremely hard. I don't know how it is in CVS, but in Clearcase you can tag only a subset of the files and what you check out from the server is determined by a complex configuration file (""the configuration specification""). This is an additional hurdle to reconstructing old states of your software because now you need to know the config-spec to do so. Even if you have the old config spec, it might contain"	adrianN	8.611862	-6.4645014	comment	9.0	34.0	1531054159	-11.85616
21131681	> feat: a commit of the type feat in	> feat: a commit of the type feat introduces a new feature to the codebaseinstead of 'feat:', why not 'feature:'?I dislike partial abbreviation because it is confusing; yes doc for document and max for maximum make sense but in this case feat is literally a different word?	house9-2	8.6586275	-6.507303	comment	9.0	50.0	1569969930	9.29912
21289949	Should this go into a commit message	Should this go into a commit message, instead of an issue/ticket?	Chris2048	8.57733	-6.5182395	comment	9.0	43.0	1571392369	-11.915156
21317605	Git Tricks: Avoiding merge when deal	Git Tricks: Avoiding merge when dealing with remote conflicts	danzanzini	8.599376	-6.499741	story	9.0	59.0	1571693228	-11.881572
21352284	Nth commit must have commit hash wit	Nth commit must have commit hash with N leading zeros	lifthrasiir	8.602022	-6.508576	story	9.0	133.0	1571983185	7.387056
18023313	Why does Martin Fowler not understan	Why does Martin Fowler not understand feature branches?	philliphaydon	8.631548	-6.513479	story	9.0	21.0	1537355298	-11.841439
18029959	It's GitLab, not MercurialLab. Hope 	It's GitLab, not MercurialLab. Hope they realize this and refuse to merge. I really like shared tooling and knowledge, so if Git dominates everywhere, all you have to do is learn git and that's it. It's a significant overhead to learn yet another VCS just because it is a little nicer. I hate wasted efforts.	Walkman	8.540002	-6.544053	comment	9.0	63.0	1537420621	-11.941182
18141098	Node.js Foundation and JavaScript Fo	Node.js Foundation and JavaScript Foundation Announce Intent to Merge	dankohn1	8.648367	-6.448451	story	9.0	156.0	1538669037	-11.825
18310426	Git is the VCS most suitable for bot	Git is the VCS most suitable for bottom-up learners. Which is the VCS most suitable for top-down learners?	frou_dh	8.570021	-6.4690547	comment	9.0	46.0	1540569526	-11.868882
18663301	Question: I use past tense instead o	Question: I use past tense instead of present tense because I explain what changed. But I see a lot of commits written in present tense. Is one better than the other? Which one?	tqkxzugoaupvwqr	8.58161	-6.5336328	comment	9.0	37.0	1544617563	-11.904697
18753495	Something I've been wondering for ye	Something I've been wondering for years: I understand the rift between 2.x and 3.x.. But what is the rationale for maintaining multiple 3.x branches? And how do I choose the right branch for a fresh project? From experience, it seems like it doesn't really matter.	fromthestart	8.611468	-6.519044	comment	9.0	38.0	1545676333	-11.844573
18922972	This is nice, but I'd like a 201-lev	This is nice, but I'd like a 201-level handholding on git. I've been using it for 5 years and I'm still just a clone/commit/merge/(bang head)/push user yet I know there is tons more it can do that would probably make me more effective. (I'd also like to switch my team of SVN. Someday....)	iheartpotatoes	8.5659485	-6.458369	comment	9.0	42.0	1547660712	-11.873684
29999221	What a waste of time and effort. Squ	What a waste of time and effort. Squash when merging to master and be done with it. Every PR/commit merged to master should be a clean logical unit. That means not fixing a bug in a branch where I'm doing something else. Those will be two separate PR's. The second problem shouldn't exist IMO.	_hao	8.608801	-6.5685563	comment	9.0	55.0	1642622709	-11.913237
30588162	Another example of a vulnerability t	Another example of a vulnerability that is purposefully obfuscated in the commit log. It is an insane practice that needs to die. The Linux kernel maintainers have been doing this for decades and it's now a standard practice for upstream.This gives attackers an advantage (they are incentivized to read commits and can easily see the vuln) and defenders a huge disadvantage. Now I have to rush to patch whereas attackers have had this entire time to build their POCs and exploit systems.End this ridiculous practice.	staticassertion	8.599951	-6.459442	comment	9.0	77.0	1646663187	-11.834034
12622414	This is not objective. Git CMD has t	"This is not objective. Git CMD has terrible flaws that are easily spotted as soon as you start teaching git, because you can see people struggling on difficulties purely created by a bad design.As a professional trainer, here are the most commong problems:- git checkout does so many different things. Git check file, git checkout branch, git checkout commit all do different stuff, and don't get me started on the option flags.- git is context dependant. If you don't know the context, espcially the state your repo is in, you will struggle. And nothing in the tool gives you enough context if you don't explicitly ask for it, which supposes you need to know you need it, and what ""it"" is.- branch switching is a hard. see article.- stashing is dangerous. I've seen many students loosing work with a"	sametmax	8.568226	-6.5364647	comment	9.0	38.0	1475417795	-11.904372
13358110	Really? I'm pretty happy with it. De	Really? I'm pretty happy with it. Definitely better than Github desktop, and more full featured than the light git extensions you find in most editors.What Git GUI do you prefer?	edraferi	8.564831	-6.445713	comment	9.0	34.0	1483984089	-11.869378
13517486	Git-recall - Simple and handy tool t	Git-recall - Simple and handy tool to easily recall what you've done	Fakerr	8.578901	-6.5080967	story	9.0	105.0	1485732607	-11.877896
27522707	Some people advocate putting lots of	Some people advocate putting lots of stuff into commit messages, which makes me think I'm missing something -- commit messages are much less visible/accessible than comments in my workflow, so I don't expect my commit message to be seen.Do you always read the whole git history of a file before editing it? What interface do you use for that?	neolog	8.587708	-6.522204	comment	9.0	34.0	1623797976	-11.897257
27580335	I know (or, at least, have known) ho	I know (or, at least, have known) how git works, in the way most people mean that (the data structures & on-disk layout, what a commit is, what a tag is, what a branch is, what HEAD is, staging, et c.). What I can't keep straight is WTF the commands are actually doing, in that low-level sense, which is a different thing, and there's approximately a 0% chance I'm ever going to use more than a tiny fraction of the commands often enough to remember that information.	handrous	8.557722	-6.5057015	comment	9.0	103.0	1624290493	10.154865
27580353	Are you using Git via GUI(s)?Between	Are you using Git via GUI(s)?Between my colleagues, there is a strong correlation between using a GUI, and messing up the repository.I agree that Git's UX is pretty bad (checkout overloading; overlapping between checkout and reset; push overloading... yikes!), however, I believe that in contexts where using Git is a constraint, stop using GUIs is the best strategy one can apply to improve the understanding.	pizza234	8.559361	-6.5153046	comment	9.0	72.0	1624290608	-11.889336
27581016	I'm sorry, but how many bits of git'	"I'm sorry, but how many bits of git's UI do we have to force users to manually replace before we realize that the entire problem is git's UI?Between the tone deaf responses here about ""using a GUI client is the problem,"" to the tone deaf responses of ""you just have to learn it's internal architecture,"" it should be obvious what the problem is. The problem is not just being able to undo a mistake (though that's certainly one of the problems). Git is an incredibly user-hostile experience, and someone needs to fix or replace it. Can we just say it out loud and stop pretending that the problem is the literally thousands of users who have problems using it?"	thewebcount	8.5457535	-6.5002375	comment	9.0	55.0	1624294512	-11.905881
27738422	I have to admit, in my career so far	I have to admit, in my career so far, I've never had to, or seen anyone have to, interact with a commit more than a sprint or two old. Almost all my workplaces enforced the usual standards regarding linear history, squash/rebases before PRs and commit naming, and then did absolutely nothing with the results of that effort. It probably means that I've had an atypical career, but I still wonder if all these ceremonies are as meaningful as we hold them to be.	Jsone	8.577666	-6.5416327	comment	9.0	27.0	1625495779	-11.943735
12290039	GitTips	GitTips	gkst	8.510881	-6.437499	story	9.0	166.0	1471265213	5.095473
12480198	We hired a new grad last year... he'	We hired a new grad last year... he's very sharp, though of course inexperienced when it comes to working as part of a team on a large project (but time will fix that).Now, I have no idea how this is possible, but he has deeper knowledge of Hg and Git than anyone I've ever met (If your experience is limited to school and solo personal projects, how in the world do you develop advanced knowledge of version control?  On my personal projects, I rarely need anything more than git add/commit/push/pull and basic branching).I'm over 10 years older than this guy, but I find myself asking his advice whenever I need to do something advanced or out of the ordinary with Git.	jcadam	8.539574	-6.4904447	comment	9.0	48.0	1473692227	-11.908348
35372942	I agree with the just learn git part	I agree with the just learn git part.However, a first year college student building something and putting it out in public is a great achievement and something to be condemned.	noufalibrahim	8.537697	-6.490093	comment	9.0	40.0	1680185370	-4.8023124
22420231	Isomorphic-git v1.0	Isomorphic-git v1.0	kjhughes	8.540337	-6.4410443	story	9.0	149.0	1582690657	-11.932128
22489278	It's honestly crazy how much time we	It's honestly crazy how much time we as a community of software developers spend thinking about Git. We spend time training new engineers how to use it, we spend time researching how to un-wedge ourselves when we run into problems, we spend time standardizing preferred workflows and giving feedback when someone doesn't follow them, and we seem to spend time debating the proper branching workflows within each team or company once every couple years. When all those costs are added up, I felt more productive using svn. I can't be the only one.Ultimately I think the problem is that Git solves too many problems - it provides a very general data structure that can be used in a lot of different ways, but the tooling itself is mostly agnostic to how you want to use that data structure. Teams can d	alexhutcheson	8.574509	-6.479334	comment	9.0	91.0	1583364466	-11.897692
22516834	Frequently. Just this evening I was 	"Frequently. Just this evening I was looking in the HN repository for the last version of the code that pg wrote, to remind myself how he used to do something.One of my favorite tricks is to make a file out of all the changes in the history:  git log -p > bigass

and then grep through the file (edit: which I like to do in Emacs—hence the file) to see every appearance of some construct. There's a lot of knowledge in there. It's particularly useful when you remember that you did something, but forget how you did it.In fact, I use git proactively this way, to store things in the version history that I might want to remember later. For example, if I write exploratory code to test out a feature or throwaway code to do some analysis—anything I might want to use again, but don't want to commit to "	dang	8.580176	-6.5216417	comment	9.0	44.0	1583653288	-11.943398
22540440	Why I dislike the rem unit (2013)	Why I dislike the rem unit (2013)	matthberg	8.684267	-6.444351	story	9.0	23.0	1583878839	9.362086
22976084	Git wishlist: aggregate changes acro	Git wishlist: aggregate changes across non-contiguous commits (2019)	luu	8.577724	-6.5237575	story	9.0	72.0	1587795602	-11.915362
23040767	One thing that bugs me with developm	"One thing that bugs me with development workflow tools is how they never really integrate with the true workflow of developers. Once you have a development workflow with Pull Requests, Code reviews, QA etc, it would be nice to be able to encode it into theWhat's the true progress of an issue (ticket, work item...)? Why do I need to remember to set a ticket to ""resolved"" after a PR completes, and so on.Every place has a different workflow and they are usually very complex, but these tools (Jira, YouTrack, GitHub issues, Azure DevOps, ...) are complex. They are often configurable, yet they still (as far as I'm aware) fail to integrate the process part of things with the code part of things. At best you have some loose integration between version control and process e.g. ""this ticket has thes"	alkonaut	8.608518	-6.4736896	comment	9.0	28.0	1588329547	-11.927467
23311528	Sublime Merge seems to want to run a	Sublime Merge seems to want to run as a git client, fully controling the behavior.I wanted to use it as a difftool as I already am fine with the git cli. I don't think it can do it? Maybe I could not find the documentation.The thing is, I used https://www.kaleidoscopeapp.com/ on mac, which is just pure joy. Recently I'm trying to migrate into Windows with WSL and a decent graphical diff / merge tool is my pain point.Any suggestions (or a way to use SM via CLI)?	eknkc	8.6816	-6.478074	comment	9.0	35.0	1590503161	-11.783025
23315936	I learned to program years ago in hi	"I learned to program years ago in high school. Git was one of the things that I just never got. I remember used git as a ""staging"" platform and struggling so hard to resolve all the problems that kept coming up (I'm sure they were actually relatively simple to anyone who knows git, like a merge conflict or detached head or something) so much I eventually wrote a script to use rsync to copy and paste files that had changed since I last ""pushed"" to prod. Now that I understand how it works inside and out, I can appreciate how amazing git is, but I don't think it's the kind of thing that should (or even could) be taught to teenagers. I hope github keeps this mainly focused on web IDE with automatic grading and turn-in instead of trying to get kids to learn Git"	chipperyman573	8.554616	-6.4786687	comment	9.0	40.0	1590524416	-11.899634
33389070	Is there a way to add only certain l	"Is there a way to add only certain lines of a file to a commit? Sometimes it'd be nice to say, ""only these changes"" make it to this commit, while ""those changes"" will be for another. Easy enough to do when they happen to be in different files, but sometimes that doesn't work out."	jonnycomputer	8.620541	-6.548775	comment	9.0	29.0	1667086668	-11.89732
33532432	Big fan of Git style guides in teams	Big fan of Git style guides in teams. We had one at Thread. It was common for engineers to come in and find we didn't do rebasing and find it weird, but we took the opinion that history should be exactly what you actually did, not some clean and idealised version of what you wish you had done. There are advantages and disadvantages to this, but having a defined approach was the most important aspect.Also the fact that we didn't rebase and used merges everywhere was a major contributor to no one ever breaking their git repos, something that git seems notorious for elsewhere.	danpalmer	8.551487	-6.5410633	comment	9.0	102.0	1668005762	-11.901514
33532665	Obviously what works for you works f	"Obviously what works for you works for you, but I respectfully disagree with everything you said.The ""history should be exactly what you did"" argument - which many people make - is really funny to me because a pull/merge-only strategy only preserves the _wrong_ history. As a tech lead, for example, I absolutely do not care one bit about the date of a commit, or when the developer started working on it, or what was the commit they started working on top of. That may be ""what really happened"", but it's worth nothing in the grand scheme of things. When a commit _has made it into the product_ is the only "" what really happened"" there is, and that is what I care about. And a linear history makes this much easier to analyze and understand, reducing cognitive load considerably.Also, it's strange "	idop	8.590142	-6.580255	comment	9.0	65.0	1668006620	-11.877784
33947364	Information that can be automaticall	Information that can be automatically extracted from the delta is the least important part of a good commit message. I can figure that part out from looking at the commit later. Instead, what I really want to know is why you made the change. What is the context? What problem were you solving? Why this way and not other ways you might have solved the problem?A summary of what the change does is still useful, and I'm glad this can now be automated, but it's not the main benefit of a well written commit message.	jefftk	8.588619	-6.527113	comment	9.0	66.0	1670791915	-11.895123
26704938	In almost every database-backed appl	In almost every database-backed application I've ever built someone, at some point, inevitable asks for the ability to see what changes were made when and by whom.My current preferred strategy for dealing with this (at least for any table smaller than a few GBs) is to dump the entire table contents to a git repository on a schedule.I've run this for a few toy projects and it seems to work really well. I'm ready to try it with something production-scale the next time the opportunity presents itself.	simonw	8.628069	-6.468935	comment	9.0	82.0	1617658035	-11.864505
26884318	Git from the Bottom Up (2008)	Git from the Bottom Up (2008)	sharjeelsayed	8.543428	-6.4618254	story	9.0	205.0	1618968181	-11.940716
27015277	This really speaks to the reliabilit	This really speaks to the reliability of Git.Are there any examples of projects with 1kk+ commits that use SVN, Mercurial, Perforce, or some other SCM?	DecoPerson	8.573168	-6.479811	comment	9.0	46.0	1619963479	-11.903158
37622357	I don't know Fossil. However, the fi	"I don't know Fossil. However, the first entry in the comparison table puts me off.""VCS, tickets, wiki, docs, notes, forum, chat, UI, RBAC""I don't want my version control system to be a wiki. Or a chat app, or any of that."	bradley13	8.512204	-6.5134463	comment	9.0	54.0	1695469254	-11.955385
37720280	I agree. As a way to minimise the pa	I agree. As a way to minimise the pain on GitHub today, we disallow force pushing and enforce squash merging. Force pushing is a nightmarish behaviour, once a Pull Request is opened the branch must be append only.	oldtownroad	8.577103	-6.556255	comment	9.0	49.0	1696110974	-11.947011
37798599	By random chance I ended up in the g	"By random chance I ended up in the git internals doc^1 today, also lovely refered to as plumbing and porcelain. It's a fantastic read, very well explained. I wish all doc was written with such explicit care to be understood. It reads like a good friend is trying to explain you something.What got me into that was a 51Gb "".pack"" file that I wanted to understand. If you wonder about that, they're pack files, and what that ""delta compression"" message when you commit is about^2. The 51Gb file though I don't have an explanation for as of yet, I'm guessing something terrible happened before I joined, and people didn't find the courage to forego the history just yet. But at least I got an entertaining read out of it.^1: https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Po...^2: https://git"	charles_f	8.573986	-6.472906	comment	9.0	33.0	1696646881	10.295854
38153309	See the History of a Method with Git	See the History of a Method with Git log -L	caleb_thompson	8.568633	-6.4693313	story	9.0	116.0	1699205327	-11.879214
38160557	Sad to see another Mercurial holdout	Sad to see another Mercurial holdout switch to Git.The latter is ahead in network effects in a massive way - but I always preferred Mercurial.  I'd have used it more but - network effects! - used git because of the projects I was working on.The main thing was that the mental model of Mercurial fit in my head and the CLI was predictable and regular, whilst the tool still scaled to large codebases.I find Git wants me to think about its implementation details and internal terminology at unpredictable moments during use.  It still gets the job done but it feels like doing random CAPTCHAs in the midst of my work.	mark_undoio	8.514062	-6.5450172	comment	9.0	92.0	1699264361	-11.9596815
38165271	Squash merges cut down the noise con	Squash merges cut down the noise considerably.	recursive	8.575718	-6.5723915	comment	9.0	167.0	1699290422	-11.95029
38166242	I think squash merges are a last res	I think squash merges are a last resort heavy-handed tool for dealing with developers who refuse to clean up their commit history before merging. Most developers can do better by hand.Git history should tell a simple, understandable story of each change. For example: 1) refactor existing code, 2) add feature. Or 1) add missing tests, 2) refactor existing code, 3) add feature.But since you're working on the fly with imperfect knowledge, it doesn't happen in such neat steps. Refactorings and behavior changes end up interleaved in your raw git history, so you need to do a little bit of cleanup by hand in order to present a simple story in the commit log.Of course if you have developers that don't do that and instead merge dozens of commits that just say wip, wip, wip, lol, fml, wip, wip, lol,	dkarl	8.576048	-6.5634007	comment	9.0	93.0	1699294088	-11.948172
15044526	You're blaming the victim. Yes, it's	You're blaming the victim. Yes, it's better to know git than not knowing it, but the developer was merely tossing around with the various options of the IDE. It shouldn't be that easy to make an operation with such disastrous results. It is the responsibility of the product designers to prevent this.	sashagim	8.563288	-6.4880595	comment	9.0	32.0	1503045368	-11.777485
31696940	Fossil versus Git	Fossil versus Git	thunderbong	8.498403	-6.547405	story	9.0	56.0	1654881497	-11.96896
25466380	I think his argument is fairly simpl	I think his argument is fairly simple:1. Learning (fundamental) stuff deeply is the way to become great.2. But knowing how stuff works fundamentally at an abstract level (e.g. being able to write your own toy OS) is not directly economically useful (and/or very time consuming to get to that stage). So it won't get you a job.3. So for starters learn just one thing that people actually use (say git) deeply at a concrete level. That is economically useful, because most devs will only have fairly superficial git skills, so you becoming the go-to person for git will provide economic value to the company.4. At the same time, this is an effective way to bootstrap a more abstract deep understanding. E.g. if you really master git, you will also learn a fair amount of abstract concepts that go beyon	patrec	8.544031	-6.49783	comment	9.0	56.0	1608294070	-11.897893
26239735	Quite a few people are suggesting th	Quite a few people are suggesting that, when it's time to share your code with others, maybe you should squash/rebase it to clean things up.  That's totally up to you... but just know that not everyone thinks rebasing is a good idea.  See [1], for example.[1] https://fossil-scm.org/home/doc/trunk/www/rebaseharm.mdI think we often feel the urge to rebase and squash not because it actually makes our code changes easier to understand, but because it makes us feel better about ourselves. That's a red flag. Understanding how you got to the goal -- encoding all the fumbles and disoriented thoughts right in the commit history -- that can be a genuine benefit to the reader. Who do we really help by pretending that we're more organized, coherent, and linear than we actually were?	gmfawcett	8.572393	-6.5594473	comment	9.0	66.0	1614100028	-11.926934
36498484	Tinyx – Resurrected Xvesa from the d	Tinyx – Resurrected Xvesa from the depths of Git history	peter_d_sherman	8.550452	-6.4644995	story	9.0	118.0	1687899225	-11.887125
28669891	Semantic Git Commit Messages	Semantic Git Commit Messages	samrohn777	8.58967	-6.536429	story	9.0	20.0	1632746160	-11.876608
28673181	Reading this article, I feel as thou	Reading this article, I feel as though the author doesn't deeply understand git.git works on blobs of data, not files, and not lines of text. It doesn't just happen to also work on binary files- that's all it works on.Now, if the author is suggesting that git-diff ought to have a language specific mode that parses changed files as ASTs to compare, now I'm interested. Let's do that. I'll help!But git does not need to change how it works for that to happen. Git does not even need git-diff to exist to serve it's main purpose.	mabbo	8.646884	-6.4897037	comment	9.0	38.0	1632761913	-11.807104
28800229	Git as a Storage	Git as a Storage	todsacerdoti	8.571827	-6.459997	story	9.0	134.0	1633706234	-11.855893
28889992	I'll never get why people complain a	"I'll never get why people complain about git being confusing when ""man gittutorial"" and ""man giteveryday"" are top-notch entrypoints into the git documentation."	mid-kid	8.54483	-6.4826956	comment	9.0	70.0	1634407811	-11.886331
29232400	I've got some patches in this releas	"I've got some patches in this release. If anyone's got question that someone who contributes to git might be able to answer I'd love to help.Are there any specific things that git does that you wish were done better? I probably won't be able to help with very generic things like ""it's complex"", but if there's specific drawbacks in some particular commands I might be able to fix them.Or anything else, I'll monitor this thread while there's interest."	avar	8.553198	-6.472663	comment	9.0	48.0	1637008762	-11.88684
29586217	Isn't there a middle ground here? If	"Isn't there a middle ground here? If you have CI/CD, you can eliminate release branches by just making PRs directly into main.The idea of post-merge code review is horrifying to me. I guess this is the ""move fast and break things"" attitude in action.Deploy now, catch bugs...sometime, maybe (TM)!"	gsk22	8.640046	-6.518631	comment	9.0	65.0	1639702149	-11.879553
29672113	I write my comments in commit messag	"I write my comments in commit messages because those are valid forever. A lot of times somebody will write a code comment, the code will be changed, but the comment not. This is a huge waste of time on so many fronts: writing the comment in the first place, and then confusing the subsequent developers with the wrong information. If you truly want to understand something, you can always check the change log, and find out why things are how they are.Exceptions are e.g. if it's something exceptionally tricky or a hack of some kind that is kind of important. It doesn't happen all that much because the stuff I work on is simple. If I was going to do a lot of ""commenting"" I would prefer to write and update good documentation that gives an overview of how different things work together. The nitty"	locallost	8.585893	-6.519983	comment	9.0	63.0	1640339142	-11.911129
34479735	This looks promising as a teaching a	This looks promising as a teaching aide. At my previous company, I transitioned our project from Clearcase to Git to save us licensing and administration fees. Many of the senior developers, who had never used Git, had a hard time understanding it, and I spent many whiteboard sessions explaining by drawing similar graphs. This would give those developers more autonomy, and stop the “let me blow it away and start over”, which would drive me nuts. Devs spent a lot of time and frustration performing that operation.I believe the core issue is devs like above never take the time to “grok” Git. I believe part of this is due to the lack of a tool like above to teach easily, but also because devs want to ignore the “how” of their tool working to find out the exact commands they need to run in thei	lumb63	8.546817	-6.4921994	comment	9.0	139.0	1674408265	3.2386885
34734721	I know its hardly fashionable...but 	I know its hardly fashionable...but what's really wrong with release integration branches?	convolvatron	8.629692	-6.536958	comment	9.0	29.0	1675994491	-11.832545
39453139	> Can someone give me a real world e	> Can someone give me a real world example (person a makes X change, person b makes y change etc. etc.) that would work better in Pijul than Git?Simplified example:Persons A and B check out master branch.Person A adds a.txt, commits and pushes.Person B adds b.txt, commits and tries to push and...1) git will not accept the push because it's not on top of current master branch, person B needs to fetch and merge/rebase before pushing again.2) pijul will accept the change (after a pull, but no rebase) because patches A and B are independent of each other and does not matter which order they are in the history (keyword: commutation).The value of Pijul will only start to show when you get into big three way merge scenarios. Which git users avoid like the plague because they are so nasty to deal 	exDM69	8.601575	-6.562994	comment	9.0	57.0	1708519827	13.899298
36605135	I'm always wondering about the, I do	I'm always wondering about the, I don't even know what to call this, etiquette? of proposing PR's to projects like these that add a feature or a demo or whatnot to the main branch of a very focused project by adding something that is very different in interface, language, set and setting etc.So in this case, Tobi made this awesome little web interface that uses minimal HTML and JS as to stay in line with llama.cpp's stripped-down-ness.  But it is still a completely different mode of operation, it's a 'new venue' essentially.What if GG didn't want such a thing?  When is something like this better for a separately maintained repo and not a main merge?  How do you know when it is OK to submit a PR to add something like this without overstepping (or is it always?)I see this with a few projects	mk_stjames	8.602865	-6.4766326	comment	9.0	32.0	1688582571	13.726088
36831568	I think the explanation does not mak	I think the explanation does not make any sense in 2023, if 99.99% of dev use Git you have to use Git, using your own solution that no one else uses or know or need to know is bad.If you want to make your project more open to contribution you have to use what the rest of the industry is using.Edit: After reading some responses, I'm really surprised that sqlite does not accept contributions.	Thaxll	8.616478	-6.4965606	comment	9.0	40.0	1690074058	9.8644085
37041853	Git is one of those things that peop	"Git is one of those things that people (including myself) have frequently derided for being ""unintuitive"", ""full of footguns"", etc.But after looking at other source control options, I find it to be an absolute joy to use -- even for very complex tasks. The VC problem itself is where the complexity lies. Any tool that deals with collaborative working on document will present the same issues that Git does. Maybe worse.Be thankful that you can use any tool you want to create plain-text diffs; that git performs operations quickly; that resets, undo's, etc are possible; that the precise history (both of the actual state and the steps taken to get there) is entirely legible; that each command performs a single, well-defined, and well documented atomic operation; that the tool is extensible, comm"	mlsu	8.588125	-6.4757133	comment	9.0	88.0	1691447553	-11.861724
37516007	Git could be a lot better in a lot o	Git could be a lot better in a lot of ways, particularly from a developer experience perspective. I’m a little surprised we haven’t seen a meaningful successor.One example is how git will deceive you and tell you you’re up to date with your remote (e.g. origin/main). What it means is that your local branch is up to date with its local concept of remote, and makes no statement guarantees about the actual state of the remote. Which is really a nonsense concept that does not need to exist.Similarly the whole concept of needing to specify “origin” at all is a bit bonkers and does no favors. Why is it that I can pull from a remote branch, commit some changes, run ‘git push’ and git has no idea what branch I want to push to. Another example: if main is a protected branch, don’t let me accidental	appplication	8.555195	-6.5091033	comment	9.0	48.0	1694732913	-11.897143
37559862	Trunk-based development vs. long-liv	Trunk-based development vs. long-lived feature branches	freedude	8.614098	-6.530011	story	9.0	22.0	1695061010	-11.863611
24489700	I mean this with the utmost respect,	I mean this with the utmost respect, but why is squash so damn popular with wealthy middle aged tech dudes?	p1necone	8.560794	-6.5833817	comment	9.0	34.0	1600232615	-4.370224
24654711	I will probably get down voted about	I will probably get down voted about this, but I don't care. There are almost no downsides to what they're doing and the people complaining are complaining for silly reasons.The new term is neutral, it's shorter, the downside of renaming a branch is negligible for git.A tempest in a teapot.	oblio	8.525099	-6.491987	comment	9.0	50.0	1601578210	-11.762622
24674183	Responding in hopes some Git non-nov	"Responding in hopes some Git non-novices are here and can give some quick advice.I have a fairly large Git repo with 5 years of commits from numerous team members including a bunch of non-technical people who had never used Git before.There were two major issues:1. We started off storing binary files -- mostly images, but also a ton of raw data files that got versioned every day or two -- in this repro and it spiralled out of control size-wise. I ended up using ""BFG"" to nuke the binary files and I think that worked, but it still feels like the repo is way too large in terms of file size. Is it possible that orphaned old versions of files are floating around somewhere in .git/? What are the best practices here?2. The branching strategy was badly wrong. We used two branches: production and d"	notafraudster	8.572295	-6.5121837	comment	9.0	37.0	1601753946	-11.891619
24883667	Heh, I didn't expect to get much att	Heh, I didn't expect to get much attention for this. I thought it would be funny to push a merge commit between the 2 repo's latest commits. As a result, the git history is accessible from the dmca repo if you know the commit hashes. Since I didn't rebase, all the commit hashes were preserved with signatures. Another fun discovery is that deleting my fork of github/dmca didn't affect the PR like I thought it would, so it seems a mirror of youtube-dl's commits are stuck in the ether until GH deletes my PR and garbage collects the repo.	Stephen304	8.617251	-6.544474	comment	9.0	221.0	1603597082	-11.847132
25122863	While the above is tecnobabble, ther	"While the above is tecnobabble, there /is/ a simple way to state what git is. It's an API to interact with a torsor.We have files, which are inert objects and form a ""file space"". We have diffs. Diffs can ""act"" on a file to produce a new file or a conflict --- we call this as ""applying a patch"". Mathematicians would call it a ""group(oid) action"". Diffs are a groupoid because (1) there's an identity diff that does nothing, (2) diffs can be smashed together, (3) if the smashing of diffs succeeds, the operation of concatenation is associative, (4) all diffs are invertible. If we were to delete added lines and add the deleted lines, this inverts the diff.Finally, we have a rooted DAG where each node is a diff, and the root is the empty diff. Git queries enable to manipulate paths in the DAG, w"	bollu	8.646675	-6.5484815	comment	9.0	62.0	1605615393	10.305648
25217812	Git Commands You Should Never Use	Git Commands You Should Never Use	kiyanwang	8.563484	-6.482314	story	9.0	23.0	1606376546	-11.886252
38809930	Intentionally buggy commits for fame	Intentionally buggy commits for fame and papers (2021)	mmsc	8.578686	-6.5060077	story	9.0	42.0	1703882344	-11.893922
38810331	This is a great write-up and I love 	This is a great write-up and I love all the different ways they collected and analyzed data.That said, it would have been much easier and more accurate to simply put each laptop side by side and run some timed compilations on the exact same scenarios: A full build, incremental build of a recent change set, incremental build impacting a module that must be rebuilt, and a couple more scenarios.Or write a script that steps through the last 100 git commits, applies them incrementally, and does a timed incremental build to get a representation of incremental build times for actual code. It could be done in a day.Collecting company-wide stats leaves the door open to significant biases. The first that comes to mind is that newer employees will have M3 laptops while the oldest employees will be on	Aurornis	8.631088	-6.445775	comment	9.0	44.0	1703884826	1.920184
38889280	Ok so I think I at least understand 	Ok so I think I at least understand now that “git diff” isn’t just showing me some stored information in the repo’s metadata.But still, I can’t reason about how so many changes to a repo can be recorded in a way that’s so efficient that it’s almost imperceptible in time cost. And I’ve yet to see a satisfactory answer to this question. I need concrete examples.	dclowd9901	8.595953	-6.5009823	comment	9.0	27.0	1704525973	-11.872494
38905822	Has anyone made a click-and-drag UI 	Has anyone made a click-and-drag UI for git? Where you can do operations on branches by just dragging them around.	abdullahkhalids	8.572448	-6.4781365	comment	9.0	33.0	1704666409	-11.858769
32519340	The Merge	The Merge	night-rider	8.729307	-6.4725757	story	9.0	102.0	1660905109	9.202503
32638880	One of the things that surprises me 	One of the things that surprises me about Git is that it doesn’t store diffs. It just stores the full content of every file every time it’s modified and committed.I work on concurrent editing systems (using CRDTs). People always ask about how we deal with the problem that if we store changes forever, the filesize grows indefinitely. Modern CRDTs are massively more space efficient than git but nobody seems to notice or care about the size of our git repositories. I think git supports shallow clones but I don’t know anyone who bothers with them.	josephg	8.591296	-6.4896884	comment	9.0	65.0	1661784089	-11.861179
32809104	I really like the notion of having t	"I really like the notion of having the whole repo including issue tracking in a single file that can be easily copied around. But Fossil's stance on history - specifically, the deliberate refusal to implement history-editing functionality like squash and rebase - is a showstopper, and their rationale for it reads very much along the lines of ""you're holding it wrong""."	int_19h	8.518336	-6.5536423	comment	9.0	124.0	1662985411	9.520409
33047789	A surprising way to lose your file i	A surprising way to lose your file in Git	kazinator	8.592249	-6.533427	story	9.0	7.0	1664641730	-11.88258
31874535	Git was built with a very specific u	Git was built with a very specific use case and aimed at an extraordinarily technical subset of users.It dominated the world despite the UX flaws, which suggests they really aren't that bad.	petepete	8.539153	-6.457627	comment	9.0	46.0	1656158767	-11.905221
31876283	I'd really like to know what mess pe	I'd really like to know what mess people make when they don't rebase.I've found that using merge gives a readable trail of when something was merged, whether that be from a branch's original branch, or if you're merging into another branch.Rebasing just seems to cause a lot more headache when something doesn't go perfectly correct in between commits.	canaus	8.576515	-6.5637264	comment	9.0	34.0	1656172742	9.300698
31964814	Git from the Inside Out	Git from the Inside Out	furcyd	8.541683	-6.457105	story	9.0	178.0	1656819251	-11.899506
32045651	> 11. Do you include ticket IDs in y	> 11. Do you include ticket IDs in your commits or branches?This is one of the things that sound 'good' on the surface and are totally worthless in practice (especially when practicing minimal commits).In the wild this devolves into a meaningless umbrella issue (Deliver Feature Foo) or 1 liner issues that sometimes did not even match the pr contents.Just use the commit message and in pr review enforce commit message norms.	bhawks	8.55229	-6.4991755	comment	9.0	36.0	1657467124	-11.99651
32215238	One thing I wish git did (maybe it d	"One thing I wish git did (maybe it does and I don't know how?) is to be able to say that a new branch is based off an old branch (not a commit that used to be that branches head).  so I can branch a single pr in progress to start the next.  Then if I change the base pr in progress (say via rebase or via squashing or the like), I can easily rebase my new commits in the new pr on top of the current state of the branch.Currently, one can just do it by never modifying the underlying ""branch"" (i.e. just adding new commits), but in practice that doesn't always work, as many times you have to rebase against one's master/main branch to pull in changes, which even if no conflicts, will reflow your ""base"" branch"" changing all the commits.TLDR: Basically, want to be able to state that branch depends "	compsciphd	8.575688	-6.5504866	comment	9.0	30.0	1658681530	-11.897048
22039612	What’s up with Git’s peculiar usage 	What’s up with Git’s peculiar usage of ‘learned’ in their release notes? For example:> Git learned the ability to execute a “partial” clone...> ..In Git 2.25, --format learned the verb l/L...I’ve never run across another piece of software that talked about itself this way. I’ve tried to research it in the past, to see if it’s part of some software engineering philosophy, but have always come up short.Anyone have any insight?	jslabovitz	8.544525	-6.5054994	comment	9.0	31.0	1578955715	-11.914027
23805642	Disagree strongly on git.  On the su	Disagree strongly on git.  On the surface the syntax is ugly, but the data model is brilliant.Once you wrap your mind around what commits, heads and remotes are and learn to rebase you get an incredibly simple and fine-grained control.  I never use stash because it's trivial to create a WIP commit and rebase later into the chunks I want to ship to permanent history.Git is like a chef's knife: extremely powerful tool that's dangerous in untrained hands.	dasil003	8.569626	-6.574315	comment	10.0	89.0	1594499380	-11.925867
20777066	There are a few good things about it	There are a few good things about it compared to git (and a few bad ones). One I like is that it has an excellent GUI that is cross platform, called TortoiseHg. I know hackers can be a bit snobbish about GUIs but I really think a GUI is essential for version control: flicking through the revision graph in one pane while looking at the modified files in another and a file's changes in a third is much more efficient than anything on the command line. And picking source and destination commits for a rebase is much easier visually on the commit graph than making note of hashes on the command line. Plus, at our company we do have a few people who use version control but are a bit less compsci focused.Related question: does anyone know of a good git GUI that works on Windows and Linux? (Ideally,	quietbritishjim	8.588451	-6.4468246	comment	10.0	39.0	1566565473	-11.868385
20860822	Avoid Most Rebase Conflicts	Avoid Most Rebase Conflicts	kantord	8.580758	-6.573125	story	10.0	55.0	1567447777	9.329716
14104903	Gut Driven Development	Gut Driven Development	nevatiaritika	8.673338	-6.438327	story	10.0	56.0	1492068889	2.847399
31686511	Gitsign	Gitsign	semiquaver	8.542704	-6.4608655	story	10.0	104.0	1654807018	-11.8933115
25514238	Git Koans (2013)	Git Koans (2013)	mmettler	8.542936	-6.4529767	story	10.0	197.0	1608695992	-11.824346
36371995	I’ve used git successfully professio	I’ve used git successfully professionally for almost 10 years and I’m not lying when I say I’ve used rebase about 5 times. We just merge. We squash sometimes. I think it must be because I’ve always worked in smaller orgs but rebase just seems to always be over complicating something simple (a merge). I get that there’s a benefit of a cleaner history but to me the benefit of simplicity merge offers makes it superior	willio58	8.575478	-6.5567937	comment	10.0	49.0	1687020972	9.260954
28670930	I do kind of love the idea of Git us	I do kind of love the idea of Git using ASTs instead of source code. It makes a ton of sense.Even just in the immediate term I wish I could make Git(hub) tabs/2 spaces/4 spaces/whatever agnostic. Seems crazy to me that in 2021 we still have to make opinionated choices across orgs about what to use... why can't we pull the code down, view it in whatever setup we want, then commit a normalized version?[whispers] this is actually something tabs allow you to do natively by setting custom tab widths in text editors but I've given up trying to sell people on tabs at this point and just want to be able to do my own thing	afavour	8.579414	-6.48654	comment	10.0	100.0	1632752325	-11.807255
28839182	I scaled to millions of users as a s	I scaled to millions of users as a solo founder and still run the whole show myself. AMA if you like.Here is what works for me:CI: From the terminal, I run my tests and commit to git.Deployments: rsyncRollbacks: Never did one. If something breaks, I fix it and rsync the fix to production.DB: MariaDBk8s: I don't use it. Computers are very fast these days. A cheap single VPS will get you a long way.Nightmare: Not really. I spend about 30 minutes per week on DevOps.	TekMol	8.598558	-6.4700837	comment	10.0	40.0	1634044197	-12.039818
29126153	What I still can't believe is that t	What I still can't believe is that the world chose git over hg.Why would you use git if you could use Mercurial instead?	37ef_ced3	8.508283	-6.540737	comment	10.0	41.0	1636157971	-11.939075
29634897	Pre-commit: framework for managing/m	Pre-commit: framework for managing/maintaining multi-language pre-commit hooks	ingve	8.668431	-6.5040283	story	10.0	84.0	1640071508	-9.125412
34487826	The single best command that made wo	"The single best command that made working with `git rebase` infinite times easier is    git reflog

At the very least it will stop you from ""oh I fucked up the <rebase/merge/cherrypick/whatever> so bad that I must delete and clone the repo again"".At best you can salvage commits that have been rebased out, get back whatever you happened to checkout and basically it's the best command I found that does true to the ""it's almost impossible to lose something in git once you've commited it"""	sakisv	8.5741415	-6.555841	comment	10.0	40.0	1674475178	-11.902004
34672760	"The examples given are more ""what"" c"	"The examples given are more ""what"" changed than ""why"" it was changed.  These are low-value commit messages because they are redundant with the content of the commit itself.It is almost like signing all your commits with your name or the current date.  (Yes, I had a coworker who did this.)Better commit messages tell you what the situation was around the commit:  Ticket number, or who wanted the change, or any other context that might tell you why the code was changed the way it was.Consider the dev accessing your commit through ""blame"".  What does that user need to hear?  Not which file or subsystem was changed.  But the reason there is a change in the first place.My habit has been to prepare longer commit messages, a paragraph or two of explanatory text for that future developer, who is mo"	markrages	8.585222	-6.5205994	comment	10.0	50.0	1675652491	-11.892582
34966025	The comments in this thread are very	"The comments in this thread are very interestingly making the Author's point.Yes, you can be ""technically correct"" saying branches are just refs, but it's not a useful statement for most users.I believe the author makes a very valid point, and we could do with a bit less ""technically correct"" and more with language targeting the usage rather than technical implementation.Git is confusing enough for many people, and we don't have to make it more confusing for them."	vhab	8.566791	-6.5330124	comment	10.0	57.0	1677562554	-11.883165
36787418	Interesting project... in the hopes 	Interesting project... in the hopes of maybe nerd-sniping you (or having someone tell me where it already exists), I'll tell you the story I'd really like a solution to but can never seem to find time to build:I have 5 un-pushed commits. I missed a 1-line change to that first one. I add that one line change to staging (gitui/lazygit/whatever), then I want to `git commit --fixup=COMMIT`. Finding that COMMIT is always a manual process for me for two reasons.First I have to find the commit to which it applies. This commit is almost always the commit that changed the same line, or added lines around it, or something similar. I guess you could say it's the commit with the closest proximity to the change I'm adding.Second I have to find the hash of that commit. If I've since done something like 	kenmacd	8.583408	-6.5551343	comment	10.0	35.0	1689778379	-11.90034
24593599	I absolutely love, and recommend to 	"I absolutely love, and recommend to any new team members, GitX [0] and other similar Git visualizers. It's incredibly valuable to be able to instantly see the Merkle Tree drawn out and say ""oh, the reason my current HEAD isn't picking up thing X that I thought I'd merged in, is because thing X isn't visually an ancestor of my HEAD even though temporally it might have happened earlier than my most recent commit.""I see newer engineers struggling to memorize ""what Git command corresponds to my current situation"" all the time, and they're missing the intuition that it's all a very simple graph under the hood. Github, I think, does a disservice by trying to present commits as a linear list - while certainly it's easier to code a linear visualization, it makes people feel like Git is impenetrabl"	btown	8.568112	-6.5030584	comment	10.0	55.0	1601064274	-11.894569
25124013	I don't think memorizing commands is	I don't think memorizing commands is really the problem. Learning just 8 git commands (clone, pull, checkout, checkout -b, commit, push, merge, rebase) will cover like 99% of situations average dev will ever encounter. And when you need something more exotic you usually can google it, usually in under 5 mins.The problem, at least for me, was the complexity of the model which makes the whole thing super scary when you've just started using it. That's where GUI tools come useful, as people are generally less scared of GUI tools - they make you feel there's less of chance of making a mistake because you put the trust in the tool to stop them doing something obviously stupid. However IME that trust is not really deserved as most of the GUI tools will just as happily let you mess up your reposi	ivanhoe	8.582246	-6.490517	comment	10.0	119.0	1605623028	-11.880393
25151253	A JavaScript implementation of Git	A JavaScript implementation of Git	okokok___	8.563473	-6.4516053	story	10.0	92.0	1605804081	-11.835977
25189504	I abhor comments like these. It says	"I abhor comments like these. It says that it needs to allocate 5 more bytes, and I can see that in the code, but it doesn't say why the magic number is 5. The comment explains the what but not the why. The commit message is equally as useless: https://github.com/DaveGamble/cJSON/commit/65541b900c740e1d5...What needs to be fixed so that this ""+5"" can be removed? What happens if something changes and the magic number needs to be 6? Also, where's the unit test?"	cbsks	8.628791	-6.489429	comment	10.0	48.0	1606154144	-11.868784
38888928	"One issue with the ""diff"" model is t"	"One issue with the ""diff"" model is that in GIT (and most all VCs these days) there is no ""one true answer"" to the question ""how did this old file change to become this new one"".Instead, what is stored is ""what is the smallest/fastest/simplest way to create new file from old file"".(depends on tradeoff)Which is not the same as what you may have actually done to change old file into new one.One result is that the textual representation you see in ""diff"" is just one interpretation of how the file changed - since it is reconstructing it from first principles.I mention this because the author mention the  following positive of the diff mental model:
""most of the time I’m concerned with the change I’m making – if I’m just changing 1 line of code, obviously I’m mostly thinking about just that 1 li"	DannyBee	8.675362	-6.495904	comment	10.0	93.0	1704521532	-11.769046
32669063	I don't understand any developer's t	I don't understand any developer's that aren't willing to put in the time to learn how to use Git - to me, it's the single greatest tool available to enable productivity and confidence in changing code. There's no shame in using any one of the many GUI interfaces for Git that make the process simple and intuitive but even with the CLI, there are only a small handful of commands that I regularly need to use to do all the work of managing branches, merges, rebases and resets; and a lot of the time, there's more than one way to do any particular operation.	taberiand	8.549143	-6.503453	comment	10.0	46.0	1661984270	-11.898319
31965769	It seems like a core argument is the	It seems like a core argument is the pre-commit tests that runs as commit hooks on the developers computer.I have worked in a place where they did that, and I think the cons heavily outweighed the pros. I can not push incomplete work to a remote, I can not separate feature development and chores (eg. linting) because I _need_ to fix stuff in order to commit an push, etc.> Continuous Integration is a model thats tightly tied to how we run version control.I would say that a pre-commit testing world is much tighter. CI, as many know it, as a passive observer. When stuff fails, it will let you know. You can still merge.One thing that would be nice, however, would be the ability to run the entire pipeline locally. For GitHub actions, it indeed seems like there are viable options to do that.	madsbuch	8.709113	-6.4881015	comment	10.0	38.0	1656832675	-11.9063
31984734	My main issue with Git, other than t	My main issue with Git, other than the terrible UX of the CLI, is just how common it is for one to want to rewrite the commit history - an operation for which there's no version control.You better get it right, or otherwise you get to nuke the whole repository.	torginus	8.546629	-6.5074425	comment	10.0	43.0	1656999747	-11.877917
31987240	GitDB, a distributed embeddable data	GitDB, a distributed embeddable database on top of Git	fiatjaf	8.559059	-6.44138	story	10.0	98.0	1657023103	-11.880512
39635936	Why Facebook doesn't use Git	Why Facebook doesn't use Git	fosterfriends	8.501314	-6.4417076	story	10.0	46.0	1709854288	-11.872153
32370985	as a noob trying to pick up coding j	as a noob trying to pick up coding just to experiment with some ideas, I always found Git to be surprisingly confusing. I feel that a lot of the command names  aren't very intuitive.Or am I just an idiot?	spaceman_2020	8.565854	-6.516452	comment	10.0	35.0	1659815325	-11.874019
22281486	Blender GIS	Blender GIS	ryannevius	8.54979	-6.457735	story	10.0	240.0	1581245505	-11.893479
19081005	RFC: linear history vs merge commits	RFC: linear history vs merge commits	jupp0r	8.577643	-6.555492	story	10.0	53.0	1549317251	-11.94453
19548437	Ask HN: Anyone else write the commit	Ask HN: Anyone else write the commit message before they start coding?	xkapastel	8.576756	-6.499846	story	10.0	25.0	1554153958	-11.900375
16587393	A lot of people simply don't underst	"A lot of people simply don't understand why source control isn't a problem solved 100% by tooling in a way that requires little to no interaction at all. To them, hearing that they need to read a chapter about the internals of a source control system before working on a project is like hearing they need to understand the details of how a transmission works before they go and drive an automatic - it's inane detail about a workflow they shouldn't even have to deal with because technology has solved the problem, or should have by now.I was on a team that was forced to transition from TFS to git. Among those who weren't excited about it, the majority of the questions, challenges and issues weren't even as far down the road as how to use git, they were mostly along the lines of ""why do we have "	nlawalker	8.557921	-6.4872947	comment	10.0	93.0	1521054340	-11.909918
17579261	I am not convinced that git is easy.	I am not convinced that git is easy... I believe it's very powerful if you put the time into learning it, but anything with 50,000 separate guides on the internet must be somewhat unintuitive, right?	nlowell	8.540568	-6.497398	comment	10.0	33.0	1532123390	-11.894032
21191131	I feel the list of useful for comman	"I feel the list of useful for commands should be much shorter:    git add/rm/commit/status/push
    git branch/checkout/merge/rebase
    git tag/push --tag

Anything else should be handled by policies. If you get bad PR, reject it instead of trying to fix it using some complex sequence of git commands."	panpanna	8.565408	-6.5671606	comment	10.0	44.0	1570535037	-11.922386
21290600	I use the following convention to st	"I use the following convention to start the subject of commit(posted by someone in a similar HN thread):    Add = Create a capability e.g. feature, test, dependency.

    Cut = Remove a capability e.g. feature, test, dependency.

    Fix = Fix an issue e.g. bug, typo, accident, misstatement.

    Bump = Increase the version of something e.g. dependency.

    Make = Change the build process, or tooling, or infra.

    Start = Begin doing something; e.g. create a feature flag.

    Stop = End doing something; e.g. remove a feature flag.

    Refactor = A code change that MUST be just a refactoring.

    Reformat = Refactor of formatting, e.g. omit whitespace.

    Optimize = Refactor of performance, e.g. speed up code.

    Document = Refactor of documentation, e.g. help files."	navinsylvester	8.591459	-6.538327	comment	10.0	57.0	1571400306	-11.911775
39088826	I have not analyzed the full potenti	I have not analyzed the full potentials and benefits of Diversion but I would not agree with the statements you made about the Git. I think you should not focus on Git in your pitch.>>it was built for a very different world in 2005 (slow networks, much smaller projects, no cloud)Slow network: why is this a negative thing? If something is designed for a slow network then it should perform well in a fast network.Mush small project: I do not agree. I can say that it was not designed for very very large projects initially. But many improvements were made later. When Micorosoft adopted Git for Windows, they faced this problem and solved it.  Please look at this https://devblogs.microsoft.com/bharry/the-largest-git-repo-o...No cloud: Again I would not agree. Git is distributed so should work per	rajeevk	8.548115	-6.451727	comment	10.0	137.0	1705927074	-11.859684
39217952	I think the disadvantage with this s	"I think the disadvantage with this style of documentation is you can't really alter the commit message after it's written.(I mean you could obviously with ""rebase"" but are you really going to alter something written one year ago, already merged to ""main"", and cause a bunch of pain with everyone's feature branch etc.?)Compare that with documentation stored in a .md file, or even a Wiki or even Confluence. My colleague can write something and if I see a way to improve it I can go ahead and do that, and other colleagues can improve on what I've written.In this particular case I suppose the bug is fixed and won't come up again. But I also myself find it tempting to describing the design of a particular component when I commit that component, and that's something I now avoid. What about when th"	adrianmsmith	8.601079	-6.5268173	comment	10.0	40.0	1706805967	-11.917274
30673282	Ask HN: Can anything make Git as pop	Ask HN: Can anything make Git as popular as Subversion?	lkrubner	8.564388	-6.451058	story	10.0	11.0	1647270305	-11.874578
12614797	While I don't think git couldn't be 	While I don't think git couldn't be improved, especially in terms of ux, I do feel like losing staging area altogether is quite significant sacrifice, like throwing the baby with the bathwater. The ability to build up and massage the commit in staging is really powerful method, and I think it makes git actually easier to learn once you get beyond the initial hump due its interactive nature.	zokier	8.689545	-6.5269814	comment	10.0	103.0	1475264832	-11.933349
12621955	To me the really bad thing about git	To me the really bad thing about git is its command-line interface.It has extremely verbose messages (writes out a lot of stuff that you don't need to know) and common use cases often requires multiple steps (ie. add, commit, push if you just want to send a change from your work machine a github repository).Compare this to subversion which is much less verbose, and in general just have one operation pr. use case.	chvid	8.552031	-6.5133414	comment	10.0	77.0	1475409277	-11.861176
27493634	I just think of git as a graph and b	"I just think of git as a graph and branches/tags as text pointers to nodes in the graph. Doesn't seem that complex to me...Maybe I ""got gud"" though and can no longer empathize with git beginners"	umvi	8.546781	-6.5027924	comment	10.0	48.0	1623599816	-11.88664
27998431	Why would that be surprising? For a 	"Why would that be surprising? For a single programmer working alone Git is an incredibly complicated tool.P.S.: A lot of you are confusing ""complicated"" with ""difficult""."	AnIdiotOnTheNet	8.545671	-6.4881597	comment	10.0	59.0	1627576949	-11.912186
12290458	My number one git tip for day to day	"My number one git tip for day to day use rather than specific scenarios is setting up aliases for everything.Along with the ones provided by the git oh-my-zh plugin I have these[0].Some examples+ gco - git checkout+ ga - git add+ gc - git commit+ gp - git push+ gl - git pull+ gpc - Pushes current branch to origin+ gpcfl - Force pushes the current branch to origin using --force-with-lease+ glc - Pulls curent branch from originThis is my favourite thoughfunction goops { git add -A ""$@"" && git commit --amend --no-edit && gpcfl }Used like this `goops file`, it adds the file, amends the last commits and force pushes the branch. Super useful because I tend to realise I forgot something just after I push. Don't do this on shared branches though, force pushing should only happen to branches were y"	K0nserv	8.582475	-6.5277247	comment	10.0	43.0	1471269584	-11.865661
12459974	I don't know if this post was intend	"I don't know if this post was intended as humour or a way to vent out some frustration but in my experience, this path of treating git as ""spell X solves problem Y"" will always break down.Version control systems are an important part of the programmers toolkit and it's worth investing a little time to get the fundamentals right.Sure git is not the friendliest of beasts but what it lacks in interface, it more than makes up in internal consistency and trying to learn it ""inside out"" is a better long term investment than having a list of ways to solve ""git problems""."	noufalibrahim	8.564391	-6.4743156	comment	10.0	92.0	1473401742	-11.888138
28026027	> Other than that, I recommend that 	"> Other than that, I recommend that people learn to use git properly.Sorry to be harsh here, but that is completely useless advice.  It's a tautology.  Of course people should learn to use git ""properly"".  What's the alternative, that they should learn to use it improperly?  Everyone should learn to use everything properly.  It's like telling someone dealing with a crisis that they should ""take appropriate action"", as if taking inappropriate action was something that someone would actually seriously consider absent this advice.The problem is that no one knows what ""properly"" means when it comes to git.  Git itself provides no clue, and everyone and their second cousin has an opinion.  That makes the advice to use git ""properly"" utterly vacuous.  Figuring out what ""properly"" means is the wh"	lisper	8.545512	-6.4923377	comment	10.0	74.0	1627823453	-11.918621
22497865	Reading the comments, I realize I'm 	"Reading the comments, I realize I'm a git neophyte (limited experience working on some open source software, didn't know ""gitflow"" was a thing) so excuse me for my naive question. But what about this simple workflow. Developers submit PR on top of a master branch (developer is in charge of rebasing, PR must pass integration test). Administrator is in charge of merging, maintains a linear history. Releases are just tags on master. Has this workflow a name? anything wrong with it?"	yodsanklai	8.565686	-6.5162845	comment	10.0	50.0	1583440436	-11.893714
22689301	How different are different diff alg	How different are different diff algorithms in Git?	aw1621107	8.652612	-6.5110974	story	10.0	152.0	1585177891	-11.813311
33266400	Ask HN: How to ease in Git to someon	Ask HN: How to ease in Git to someone with Git PTSD	lastdong	8.572178	-6.48382	story	10.0	9.0	1666205778	13.831484
26500729	Correct Git commits with git-autofix	Correct Git commits with git-autofixup	tosh	8.574397	-6.5315757	story	10.0	92.0	1616057714	-11.907551
38124845	Hidden manuals: gittutorial, gitever	Hidden manuals: gittutorial, giteveryday, gitglossary, gitworkflow	divbzero	8.556487	-6.490887	story	10.0	182.0	1698988895	-11.873728
38165970	I find it fascinating that people ta	"I find it fascinating that people talk about ""Having a history of what people did"" in such emotive terms - ""Cluttering"", ""Polluting"".What matters is that you end up with working systems.  That a lot of change happened is just, well, what happened.  It doesn't need to be prettied up and made to look like your development occurred in a clockwork march of cleanliness.  It literally does not matter unless you spend a lot of time doing git-bisect.Let it go.  Accept that coding is not a smooth, robotic, endeavour, where everything is always tidy.  And that's just fine."	AndrewDucker	8.563533	-6.4963007	comment	10.0	58.0	1699293066	-11.88594
38370377	Interesting, given that Google and F	Interesting, given that Google and Facebook [2], at least, eventually moved to have their repositories offered via Mercurial interface, instead of git.I also would expect that Github eventually will also offer mercurial repos.p.s. And let's not talk about abomination that is GitLFS (starting from the fact that it requires separate subcommand).[2] https://engineering.fb.com/2014/01/07/core-infra/scaling-mer...	galkk	8.476316	-6.4765515	comment	10.0	116.0	1700601741	-11.894428
14814306	Why it is better than offline editor	Why it is better than offline editor (like TeXnicCenter) and code repository (like Git)?	mk321	8.561486	-6.457895	comment	10.0	40.0	1500570375	-11.785466
23768214	I'm not sure I've _ever_ used the -m	I'm not sure I've _ever_ used the -m flag to write a commit message. Naked `git commit` defaults to vim for me, and that's how I like it. Multiline messages, text turns from yellow to white when you go over 80 characters, summary of changes when you're writing the message, the ability to abort with :q! — I can't say the number of times I've realized I left a bug or forgot to tweak something or stage a change while writing a commit message, and bailed out to fix that before committing — the list of advantages goes on and on. I'll never not write my commit messages in vim, and I encourage everyone to do the same.	twicetwice	8.610023	-6.5240726	comment	11.0	57.0	1594199435	-11.862944
23803771	People who champion git, how do you 	People who champion git, how do you counter this?	yewenjie	8.549602	-6.466114	comment	11.0	47.0	1594488042	-11.9083395
24174342	If y'all think git is hard, wait 'ti	If y'all think git is hard, wait 'til you hear about computer algorithms!Git isn't hard, it might be complex, but how it works and how to use it is simple as far as applications and/or processes go.I find myself constantly trying to dispel the idea that git is too difficult to understand in depth. The problem has always come down to the missing attempt to understand the issue, over trying to ^c, ^v a solution.Seriously, if you think git is hard: don't ask for it to be easier, ask instead to be stronger. (Or in this case smarter, something you surprisingly have control over)	grayhatter	8.542168	-6.501742	comment	11.0	74.0	1597544755	-11.900382
20004421	There's an article like this every w	There's an article like this every week or so.. I don't get it.  Git isn't that hard.. You can pretty much get by 99% of use cases with like four or five commands.	jc_sec	8.5666685	-6.4809914	comment	11.0	59.0	1558724892	-11.8841095
20874240	Linus’s rules on keeping Git history	Linus’s rules on keeping Git history clean (2009)	jjuliano	8.575743	-6.498764	story	11.0	229.0	1567574676	-11.892755
13713574	What's the impact to something like 	"What's the impact to something like git that makes extensive use of SHA-1?In their example they've created two PDFs with the same SHA-1. Could I replace the blob in a git repo with the ""bad"" version of a file if it matches the SHA-1?"	koolba	8.69534	-6.5297675	comment	11.0	47.0	1487856002	7.176618
13720694	Pertinent facts for the worried:1) G	"Pertinent facts for the worried:1) Git doesn't rely on SHA-1 for security. It relies on HTTPS, and a web of trust.2) Even if git did rely on SHA-1, there's no imminent threat.  What happened today was a SHA-1 collision, not a preimage attack.  If a collision costs 2^n, a preimage attack costs 2^(2n).3) Even if someone managed to pull off a preimage attack, creating a ""poisonous"" version of one your git repository's objects, they'd still have to convince you pull from their repo. This requires trust.4) Even if you pulled it in, your git client would simply ignore their ""poison"" object, because it would say, ""oh, no thanks, I already have that object"".  At worst, the code simply wouldn't work.  No harm would be done.When it comes to git, an attacker's time is better spent creating a secret b"	notfed	8.665854	-6.5146623	comment	11.0	114.0	1487907208	7.1649203
14412242	Windows, because of the size of the 	Windows, because of the size of the team and the nature of the work, often has VERY large merges across branches (10,000’s of changes with 1,000’s of conflicts).At a former startup, our product was built on Chromium. As the build/release engineer, one of my daily responsibilities was merging Chromium's changes with ours.Just performing the merge and conflict resolution was anywhere from 5 minutes to an hour of my time. Ensuring the code compiled was another 5 minutes to an hour. If someone on the Chromium team had significantly refactored a  component, which typically occurred every couple weeks, I knew half my day was going to be spent dealing with the refactor.The Chromium team at the time was many dozens of engineers, landing on the order of a hundred commits per day. Our team was a doz	js2	8.633709	-6.534005	comment	11.0	76.0	1495650200	-11.886358
30947791	This best practice of committing oft	This best practice of committing often never made much sense to me. I find it typical that we as developers come up with such practices that start to control how we work instead of us focusing on getting work done. This practice makes even less sense when we make PRs that once merged are squashed into one commit?!I try to make my commit history nice but the way people obsess about it, I don't think is productive.	DogLover_	8.586611	-6.5373793	comment	11.0	60.0	1649353077	-11.90303
31751730	A Git Origin Story (2018)	A Git Origin Story (2018)	revorad	8.5489235	-6.457975	story	11.0	188.0	1655294674	-11.884506
28899661	Fast rebases with git-move	Fast rebases with git-move	jdorfman	8.583597	-6.5761385	story	11.0	89.0	1634503676	9.356542
28955359	For the sake of discussion, can we g	"For the sake of discussion, can we get some contrarian views?I'm using magit, along with tig, plain git and sometimes (!) even plain ""vc"", depending on context. I'm in the camp that thinks it's ok and it's pretty comfortable to use within emacs, but I don't see the earth shattering praise I see every time it's mentioned here.Tig for example is so much faster for history and blame perusal that I find it faster to keep it open in another terminal and just switch to it.Altenatives? Contrarians?"	bsdubernerd	8.546248	-6.5025	comment	11.0	71.0	1634896542	-11.878226
29062679	Visual Git	Visual Git	todsacerdoti	8.549921	-6.4685097	story	11.0	177.0	1635736155	-11.865713
39594164	Git Worktrees and GitButler	Git Worktrees and GitButler	chmaynard	8.572057	-6.5052547	story	11.0	104.0	1709577525	-11.901326
37039907	Git is one of those tools that expos	Git is one of those tools that exposes so much of the underlying infrastructure that people just can't help diving in and making their own lives so much more difficult.After using git for well over a decade, I'm completely convinced that if you find yourself frequently rebasing/cherry-picking/reflogging you're using git wrong.	jkubicek	8.551867	-6.504465	comment	11.0	77.0	1691437480	-11.900417
24671638	Git Exercises	Git Exercises	harsilspatel	8.514541	-6.443128	story	11.0	350.0	1601728929	-11.890284
38814492	Committing Without Git	Committing Without Git	matheust	8.597436	-6.471735	story	11.0	216.0	1703936725	-11.866426
12581710	Rebase and merge pull requests	Rebase and merge pull requests	dwaxe	8.591951	-6.518351	story	11.0	181.0	1474897333	8.308015
12622196	When people say they don't like git,	When people say they don't like git, I lose a little faith in them as a programmer and/or engineer. This is probably due to my own biases of having worked with folks that just don't want to invest the time in learning it. That or they are afraid of branching/merging. To me this indicates intellectual laziness which isn't the kind of laziness that makes a good programmer (as is with the quote from Larry Wall and the kind of laziness he speaks of).	rplst8	8.5418415	-6.4844947	comment	11.0	65.0	1475414561	-11.9070635
19704845	This is one of those interesting bit	This is one of those interesting bits where things feel more like personality types as opposed to ways to create maintainable software. I have yet to see a project fail because commit messages were or were not in imperative form or if the first letter was capitalized. I have no problem doing it if someone in the team finds it important, and I have no issue if someone on the team does not do it.The same is generally true about rebasing etc.Due to the high visibility of commit messages, a lot of details certainly look pretty bike shed-ish.What can be important is simply a general concept of meaningful messages when they make sense. For example, bug fixes that may not be obvious by looking at the code, should probably have a reasonably detailed description of the bug. Commits implementing a b	areyouseriousxx	8.584845	-6.5275116	comment	11.0	79.0	1555735411	-11.893132
15837323	Mercurial with Largefiles: Why it is	Mercurial with Largefiles: Why it is not a solution for game development	noch	8.51683	-6.550794	story	11.0	50.0	1512304639	10.453499
16441049	Show HN: git self-blame – Blame your	Show HN: git self-blame – Blame yourself for others' mistakes	jacobevelyn	8.558967	-6.5036116	story	11.0	74.0	1519331055	-11.906015
16616589	Beyond CI/CD: GitLab's DevOps Vision	Beyond CI/CD: GitLab's DevOps Vision (2017)	FooBarWidget	8.568462	-6.4373665	story	11.0	256.0	1521443184	8.930545
17690017	If you editor has a correct git supp	"If you editor has a correct git support, you never need to do git status because it will show you which files had been edited since the last commit.Every time I hear people saying how much they prefer the git command line is because they never seriously tried to leverage the git features of their IDE.Vs code with git lens or intellij idea have excellent git integration. Everything is one shortcut away.
The git commands that are used are log into a console if you want to check.At the end of the day both methods work, it's just a matter of preference but it is worth trying a good git UI.Also if you ever try to teach someone git, it's not as intuitive as you think [1]. Having a consistent UX can help.That's why there is definitely a space for this kind of git UI as presented in the article. 
"	hv42	8.581825	-6.496812	comment	11.0	41.0	1533450562	-11.865209
21392747	For those of us who don't know Mercu	For those of us who don't know Mercurial -- how is the UX better than git's? Are there examples you can use to illustrate? (I've heard this frequently but never had a chance to really learn it.)	mehrdadn	8.50666	-6.550852	comment	11.0	145.0	1572387770	-11.929568
21419475	Quoting myself from yesterday:https:	"Quoting myself from yesterday:https://news.ycombinator.com/threads?id=miohtama""Git is what a version control UX would look like if it were written by kernel developers who only knew Perl and C""Back in a day we had Subversion, Mercurial, Bazaar, some others. I used all of these. All of them were more coherent than Git. However they were slower - but not much - and they were not used by the most popular software project in the world. Then, GitHub popularized git and Github become well funded enough to take over the software development world.Bitbucket, now Atlassian, started as a hosted Mercurial repos. Bazaar was DVCS for Ubuntu, developed by Ubuntu folks.Will we see another DVCS ever again? I hope yes. Now all software developers with less than 5 years of experience are using Google and Gi"	miohtama	8.5727825	-6.454111	comment	11.0	62.0	1572620162	-11.874825
21729597	A walk through the Magit interface	A walk through the Magit interface	rohitpaulk	8.7397375	-6.4441633	story	11.0	194.0	1575716130	-11.560609
21745709	"Don't miss ""Staging parts of a hunk"""	"Don't miss ""Staging parts of a hunk"", which is Magit's killer feature, IMO.  You can easily go through your current diff (from staged) and add/remove single lines from the staged delta."	downerending	8.640966	-6.5241003	comment	11.0	63.0	1575920648	-11.888338
18663431	Writing good commit messages is one 	Writing good commit messages is one of those things that IMO make the difference between a dev who produces good code, and a dev who produces high quality work in general.The git log is one of the main entry points to an open source (or closed source, in fact) project. Following them tells a story, and can help you understand decisions made.Imagine you have two projects to bisect. One of them has clean, atomic and descriptive commits. The other has a git log that looks like this: https://github.com/pypa/pipenv/commits/master?after=d4d54eeb...I know which one I'd want to debug. This is also the primary reason why I highly dislike merge commits: They make git logs extremely unreadable.The thing is that writing clean commits is something that is extremely easy to do. Unlike docs and tests, it	scrollaway	8.585378	-6.532956	comment	11.0	91.0	1544619022	-11.911857
29992302	Seems like an interesting project. I	Seems like an interesting project. It's probably impossible to fight against git nowday though. The first mover advantage of git is just too hard to overcome despite all the flaws of git.	gbersac	8.551757	-6.4741354	comment	11.0	75.0	1642591304	-11.889789
12803104	Certain systems can best be understo	Certain systems can best be understood as black boxes. You put some commands in and magic happens. Git was not designed to be such a system and early users of git know this.During the last 5 years, many GUIs have filled in this gap, making it increasingly likely to find people completely stuck because they miss knowledge of the foundations.Git is a utility to manage an append-only repository of tree-objects, blobs and commits. To help humans, git adds- human-readable pointers (branches, HEAD, stash)- an method to incrementally add changes (staging/index/working area)- a method to append tree-objects, blobs and commits from repository to another- some commands which alleviate steps in common tasksThese last set of commands cause pain, as users without foundational knowledge, do not realize 	edejong	8.557719	-6.5120625	comment	11.0	96.0	1477546004	-11.907137
12094487	Merging vs. Rebasing	Merging vs. Rebasing	nns	8.5929	-6.5776052	story	11.0	59.0	1468508985	9.332907
35372305	Maybe it's just morning, or maybe I'	"Maybe it's just morning, or maybe I'm a luddite, or both, but my knee-jerk reaction to this was ""why does anyone need this? Just learn git."" But then I saw the ""explain"" command, and then I read that you're a new CS student.That got me thinking about the first time I really screwed something up and had to figure out how to use git rebase, and the first time I tried to create a git submodule (back when submodules were new and there wasn't much help to be found on StackOverflow). I must have let the Stockholm syndrome set in, because the ""explain"" feature is a wonderful idea for students.The dead-simplicity of it is very desirable in certain spaces. Back when I was in college, I wrote code for some indie visual novel games, and I was always the only person with a software development backgro"	ryukoposting	8.538914	-6.490164	comment	11.0	84.0	1680182633	-11.888917
28026074	"> I say ""just rebase your branch"" an"	"> I say ""just rebase your branch"" and I can see the panic grow in their eyes.The irony of that is that resolving conflicts in a complicated multi-commit rebase is much more easily/efficiently done in a good GUI than on the command line. Not all GUIs support it though (I think SourceTree gives up if there's a conflict), in fact it's a bit of an acid test for a Git GUI. The Jetbrains IDEs (PyCharm, CLion, IDEA, etc.) work very well. (So does TortoiseHg but obviously not for Git!)"	quietbritishjim	8.581315	-6.542283	comment	11.0	42.0	1627824103	-11.928818
28106981	Cleaning Up Git History	Cleaning Up Git History	asicsp	8.564492	-6.4903746	story	11.0	48.0	1628433163	-11.878947
22490556	The approach that has worked best fo	The approach that has worked best for me is pretty simple.Master should always be in a deployable state.Any commit that lands on master must include unit tests that demonstrate that it works (or at least doesn't break anything).Incomplete features that will take more than a week or so to develop should be merged to master early protected by feature flags. This avoids long running branches.I like squash commits: build a feature iteratively in a branch + pull requests, squash to master once it has the tests and documentation bundled together with the implementation. This gives you linear history.People who prefer to review smaller commits can do so in the pull request - it's only the finished item that gets squashed into a larger commit.	simonw	8.61093	-6.5417967	comment	11.0	96.0	1583377246	-11.964132
22943804	I don't like GUI git tools as they a	I don't like GUI git tools as they always have issues with edge cases. git is a complicated system and you can have multiple weird configurations in your repo/system.Most of the GUI tools just focus on the MVP workflow and often they crash/bug out on the weird cases.This is not really an argument against it, but just an observation I made through the years.Sourcetree is one of the oldest GUI git clients and it has the most stuff handled correctly, and this basically looks like open-source source tree.	thealistra	8.566287	-6.4683976	comment	11.0	71.0	1587548366	-11.889178
37833131	"Is it fair to say ""ls"" is dead? No c"	"Is it fair to say ""ls"" is dead? No commits in 15 years"	lopkeny12ko	8.591683	-6.4523	story	11.0	38.0	1696950860	-11.873798
38115814	I was having a similar hard time to 	"I was having a similar hard time to remember most of these (the remaining ones I just don't use often, so I still haven't quite grasped).The single thing that made everything ""click"" together is that most things are just pointers to commits: branch names, HEAD, tags, all of them are pointers.HEAD is pointing to the commit you're currently looking atThe name of each branch (e.g. `my-feature` points to the latest commit of that branch)When you're on main and you `git checkout -b my-feature` then you have at least 3 pointers to the latest commit on main: `main`, `my-feature` and `HEAD`.Every time that you make a commit on `my-branch`, then both the `HEAD` and `my-branch` move to point to the new commit.""detached HEAD"" means that the the `HEAD` (the commit you're looking at) is not pointed at "	sakisv	8.565544	-6.5318007	comment	11.0	67.0	1698941966	-11.9217615
38165320	I’ve never understood the tradeoff o	I’ve never understood the tradeoff of rebasing, squashing or otherwise “keeping a clean history”. It always seemed like tons of sometimes highly error prone work (sometimes you can wipe out a colleague’s work with it! Wtf!), for almost no gain (why does it matter that the git history is “clean”?).	davedx	8.574172	-6.548346	comment	11.0	89.0	1699290579	-11.91321
23479941	I've worked for 10 years across 20 d	"I've worked for 10 years across 20 different commercial codebases. None of this stuff about writing good commit messages really matters. No one reads old commits. The ""truth"" is what the current code is doing and it doesn't really matter how it got there.I'm sure someone will say ""but I use the history ALL THE TIME to source dive and paragraphs of context are super helpful"". This is not the case for 95% of developers or projects so I can't really endorse spending time learning this ""best practice"".It's fine to be aspirational, but it's such a shame if people see posts like this and think they are failures or ""bad"" developers or that this is a widespread practice.If it helps you personally or you have an open source project and you want to help with a changelog, knock yourself out. But ther"	swanson	8.582831	-6.5316715	comment	12.0	54.0	1591811301	-11.912356
23739437	> So commit messages to me are almos	> So commit messages to me are almost as important as the code change itself.Why commit messages rather than code comments?	statquontrarian	8.5830965	-6.518858	comment	12.0	41.0	1593963279	-11.906704
23751380	"So many times this.""Clear code shoul"	"So many times this.""Clear code shouldn't need comments"" - clear code can make it easy to see what but it can never say why. Let me know what corner cases you thought about when you wrote this.""The comments are in the commit messages"" - almost nobody ever goes looking for them there, they're effectively invisible from `git blame` when they remove lines, people rarely make fine grained enough commits to be able to target specific lines or blocks sufficiently with context.""Nobody ever updates comments, so they're always out of date"" - don't hire such people. It is an crucial task resolving the meaning of comments to make sure everything still makes cohesive sense. Neglecting to do this will often lead to commits that don't quite grok any subtleties of the original design. Don't make the reade"	ris	8.571183	-6.5125356	comment	12.0	59.0	1594061664	-11.880348
23968417	I wonder about which primary branch 	I wonder about which primary branch naming convention they’ll arrive at. “primary” is my personal favorite ;)	pojntfx	8.518915	-6.533031	comment	12.0	73.0	1595877488	9.271753
23968600	Someone please give me the missing l	"Someone please give me the missing link here:1. I do `git log` which helpfully pipes to `more` where I can use vim-stsyle search to find the commit I'm interested in.
2. I find the relevant commit.
3. Now I want to `git show` that commit.Currently I double click on the human unreadable commit, copy it, quit `more` to get back to the command line, type `git show`, then paste the commit. Navigate, click-click, shortcut, 'q', type a command, paste. That's six pieces of business.That seems very wrong and time-consuming.How do I go gracefully from browsing git log to git show without retyping/pasting the human unreadable commit? Preferably with fewer than seven steps."	jancsika	8.553987	-6.518784	comment	12.0	53.0	1595878613	-11.886139
20004935	There's one of these articles at lea	"There's one of these articles at least once per week that makes it to top of HN. When are we collective going to come to the realization that Git is a corded drill in a battery-powered drill world?Don't get me wrong, version control is necessary. Obviously. But if a plumber, a word-worker or some other artisan used a tool that required a weekly ""It's okay, you'll catch on eventually"" article, we would have never got out of the Dark Ages.It's time for an intervention. It's time to take seriously the friction and frustrations it creates. Yes, it has redeeming qualities. But it's time to stop looking past those and do something about them (other than another article such as this one)."	chiefalchemist	8.548185	-6.475235	comment	12.0	59.0	1558729311	-11.893661
31634560	Why I'm using Fossil SCM instead of 	Why I'm using Fossil SCM instead of other source control systems (2016)	thunderbong	8.507515	-6.499316	story	12.0	100.0	1654461105	9.457381
26082833	I've never heard of mercurial until 	I've never heard of mercurial until this post, I've been using git for version control and it does the job really well.To those who use mercurial over git, why?	talhah	8.516093	-6.5456376	comment	12.0	103.0	1612907529	-11.94038
35932074	DIY Git in Python	DIY Git in Python	auraham	8.60485	-6.4397173	story	12.0	162.0	1684007704	9.265753
36334957	Ask HN: Should commit summaries desc	Ask HN: Should commit summaries describe the change, or the intent?	csnover	8.585735	-6.5135975	story	12.0	21.0	1686789830	-11.900323
28844831	Git was created 16 years ago. The im	Git was created 16 years ago. The impending breakage of SHA-1 was known even at that time, just like how MD5 had been broken before it.I'm honestly still shocked that updating the hashing algorithm wasn't built into Git from day one. I really wonder why. Did people think this wouldn't happen? Were they so in love with the performance of C/C++ being able to pass around 20 byte hashes on the stack without worrying about a more complicated structure (eg a collection of variable length hashes)?It just seems like such a massive and foreseeable oversight that's going to cause pain for some time to come for really no reason at all.	cletus	8.66798	-6.5157046	comment	12.0	85.0	1634071459	7.1685734
29396504	Exactly the opposite for me. I absol	Exactly the opposite for me. I absolutely do not trust GUIs to do the right thing. I don't trust text area to use correct line endings consistently across platforms, I don't trust them to be up to date with new options for `commit` or `checkout`, they never show examples what result will be (--dry-run). None GUI is ever up to date with documentation and contains all functionality which I can autocomplete with [tab][tab] in zsh.Does any GUI offer `-p` in `git commit` and `git stash`? I literally use it 10s times per day, can't live without it once I started using it.	agilob	8.628112	-6.4827323	comment	12.0	63.0	1638301306	-11.891165
34733805	Trunk-Based Development: Game Change	Trunk-Based Development: Game Changers	cpeterso	8.616315	-6.5333486	story	12.0	111.0	1675988590	3.1066327
36956242	I haven't really used git on the com	I haven't really used git on the command line for years now, except for some special cases. In my daily usage, I rely on the built-in IDE integration (IntelliJ, FWIW), and I don't understand why anyone would put up with doing it manually. I can do partial commits by selecting individual lines right in my editor. I can view all branches, merge them, cherry-pick from them, commit stuff or amend it, pull updates, edit tags - everything at once, with keyboard shortcuts.Apparently, I'm in the minority here (also considering all the talk about git being such an essential skill that real programmers can issue commands blindfold). Why is that?	9dev	8.587691	-6.502115	comment	12.0	57.0	1690899530	12.631408
24453758	Scaling Mercurial at Facebook (2014)	Scaling Mercurial at Facebook (2014)	based2	8.505572	-6.5359106	story	12.0	31.0	1599929768	-11.913541
24957280	Visualizing Git Concepts with D3	Visualizing Git Concepts with D3	gilad	8.5652895	-6.453108	story	12.0	265.0	1604205827	4.715104
38809696	I'm a big fan of the rebase workflow	"I'm a big fan of the rebase workflow, but not of squashing. I wrote it as several separate commits for a reason: documenting each step, making each step revertible, separating refactors from from semantic changes, etc. Squashing makes the diffs much more painful, such as by burying an important change in a sea of mechanical ones when they were originally in separate commits.(A workflow that preserves those commits requires actually having useful commits, and obviously if you have PRs with commits like ""fix it"" and ""fix it more"" then it might as well get squashed.)"	JoshTriplett	8.500263	-6.6405587	comment	12.0	82.0	1703881002	-11.931132
38943420	Metahead – An enterprise-grade, Git-	Metahead – An enterprise-grade, Git-based metarepo	grokx	8.573133	-6.4408345	story	12.0	53.0	1704922048	-11.88935
31874446	Git is a reminder why even the best 	Git is a reminder why even the best minds in software development sometimes really should talk to UX/UI people.	danjac	8.546925	-6.4825063	comment	12.0	94.0	1656157796	-11.900725
32215225	I've usually kept a rule that you sh	I've usually kept a rule that you should avoid stacking, and if you must only one level deep. The fact that you have to stack in the first place typically suggests that PRs aren't being merged fast enough. Stacking in my personal experience usually leads to merge conflict hell as changes and PR suggestions get merged underneath you.	is0tope	8.664293	-6.4559965	comment	12.0	108.0	1658681456	-11.875885
19878396	About 99.9% of the time when people 	"About 99.9% of the time when people talk about rebase they talk about ‘editing’ history or ‘rewriting’ history as in the first sentence of the article.I find that terminology terribly misleading and when I was learning git and rebase it confused the heck out of me.No commits are harmed in the operation of `git rebase`. All the commits you had in the repo before the rebase are still in the repo. Git rebase creates a new sequence of commits and after doing its work relocates the branch name to the tip of the new sequence but you can easily access the previous commits if need be:    $ git co feature-branch
    $ git rebase develop
    $ git co -b before-rebase-feature-branch feature-branch@{1}"	gwright	8.5693445	-6.5711784	comment	12.0	142.0	1557500397	-11.913368
16590104	Git Magic	Git Magic	polm23	8.541037	-6.470871	story	12.0	238.0	1521081808	-11.899536
16807206	"""Nobody really understands git"" is t"	"""Nobody really understands git"" is the truest part of that. While hyperbolic, it really has a lot of truth.It's always a bit frustrating when working with a team because everyone understands a different part of git and has slightly different ideas of how things should be done. I still routinely have to explain to others what a rebase is and others have to routinely explain to me what a blob really is.In a team of the most moderate size, teaching and learning git from each other is a regular task.People say git is simple underneath, and if you just learn its internal model, you can ignore its complex default UI. I disagree. Even just learning its internal model leads to surprises all the time, like the blobs that I keep forgetting why aren't they just called files."	jordigh	8.551066	-6.5175667	comment	12.0	206.0	1523408779	-11.909136
17689472	> are YOU tired of typing every git 	> are YOU tired of typing every git command directly into the terminalI'm not. Are there many people that are? Is this not just a matter of learning to use shell keybindings effectively? That and aliases does wonders to avoid repetitive typing. Many times I type `git s` (alias for `git status -s`) out of reflex when I really meant to do `ls`.When I forget to add `-a` to `git ci -m ...` (`ci` being `commit`) and get an error because the index is empty, I just `<caps>kF-aa<enter>` (<caps> being <esc>) to add it and re-execute. It's muscle memory; I do it before I even realize I did it.	jolmg	8.646483	-6.5457015	comment	12.0	72.0	1533438914	-11.842832
21004193	Git Blame-Someone-Else	Git Blame-Someone-Else	dcminter	8.560406	-6.4793215	story	12.0	225.0	1568806525	-11.884136
21193478	Maybe my workflow is a lot easier th	Maybe my workflow is a lot easier than others, but I work on a team of 10+ engineers and my Git usage is dead simple. I do everything from a GUI (Fork for macOS) and very rarely have to deal with any complicated issues that require a terminal.- Always pull w/ rebase for the current branch.- Always merge other branches into your current branch, eg master -> feature.- Always stage individual chunks of code one at a time to make sure I'm committing the right stuff.- Always squash feature branches into a single commit when merging back.- Stash changes if needed when switching branches.- Cherry-pick one-off commits if needed.- Append a previous commit that I haven't pushed yet if I happened to forget something.- For complicated merge conflicts I switch to Visual Studio Code which also has a gre	trevor-e	8.584738	-6.509748	comment	12.0	77.0	1570549329	-11.884541
21624739	Legit: A CLI tool to make Git more a	Legit: A CLI tool to make Git more accessible	pcr910303	8.574544	-6.441171	story	12.0	55.0	1574644838	-11.880254
17987033	Interactive Git Cheatsheet	Interactive Git Cheatsheet	taatparya	8.559971	-6.473347	story	12.0	179.0	1536931966	6.337466
18504948	Learn Git Branching	Learn Git Branching	gerbilly	8.565925	-6.497795	story	12.0	300.0	1542825897	-11.882908
18823119	What I don't understand is how they 	"What I don't understand is how they accomplish larger collaborative changes. The paper says:""Almost all development occurs at the 'head' of the repository, not on branches.""Googler Rachel Potvin made an even stronger statement in her presentation about ""The Motivation for a Monolithic Codebase"" [1]:""Branching for development at Google is exceedingly rare [..]""In the related ACM paper she published with Josh Levenberg there is the statement that:""Development on branches is unusual and not well supported at Google, though branches are typically used for releases.""I my world when we have to make a bigger change we create a branch and only merge it into the trunk when it is good enough to be
integrated. The branch enables us to work on that change together.
I don't understand how they do this "	weinzierl	8.6121645	-6.544125	comment	12.0	99.0	1546599021	13.790913
30450592	If I had a penny for every time some	"If I had a penny for every time someone on HN responds with something like this - ""just become more disciplined and you don't need X"" - I'd be a millionaire. Doesn't matter what it is, type systems, memory safety, a better UI for Git… there's always someone ready to chime in with how their workflow means these problems don't happen, or, even better, asking the question why would anyone need this?Yes, why would anyone need better search or a faster, easier to organise file system? I can't think why."	brigandish	8.547083	-6.4767075	comment	12.0	113.0	1645679697	-11.904961
30712896	The only problem I have with this wo	The only problem I have with this workflow in the command line is that I would like to be able to split changes to the same file across multiple commits.  I think some GUI tools enable this, anyone know about it?	matticusrex	8.594123	-6.532271	comment	12.0	43.0	1647534268	-11.902897
12612333	Purposes, Concepts, Misfits, and a R	Purposes, Concepts, Misfits, and a Redesign of Git	ingve	8.535809	-6.4811773	story	12.0	161.0	1475242792	-11.953632
12738044	Ask HN: GUI Git client for macOS rec	Ask HN: GUI Git client for macOS recommendations	petecooper	8.590306	-6.4453797	story	12.0	7.0	1476820271	-11.838365
12886511	I just don't understand why people u	I just don't understand why people use the git CLI. Git is too powerful a tool, using the CLI limits one of two things: your capabilities, or your productivity.Often times I see my coworkers screwing around with git trying to review diffs and commit their changes. One of two things happens: they spend longer than they should doing it, or they do it haphazardly. Sometimes they get it wrong.Just use a GUI.I use SourceTree and often find myself committing individual lines or chunks in my files instead of the whole file. I'm confident the average git CLI user doesn't even know this is possible. I can do massively complicated commits with ease because I can see every single line that has changed right in front of me.I just don't understand the fetishization of source control via CLI. In all lik	iLoch	8.581282	-6.5012727	comment	12.0	47.0	1478459115	-11.8267
12304359	Git Workflow Basics	Git Workflow Basics	igor_marques	8.553148	-6.4753866	story	12.0	187.0	1471439371	-11.888063
28392566	Picturing Git: Conceptions and Misco	Picturing Git: Conceptions and Misconceptions	nimeshneema	8.550127	-6.4741435	story	12.0	145.0	1630593243	-11.885505
33615072	Thank god.I have been waiting ten ye	Thank god.I have been waiting ten years (https://www.google.com/url?q=https://stevebennett.me/2012/02...) for someone to develop a better CLI for git, someone with the scale and clout to do it well and gain mindshare. It's not that useful to learn a new workflow if no one you ever work with will be familiar with it.This looks incredible. A simple command to uncommit or unamend makes you further realise what a disaster the Git CLI is.	stevage	8.596507	-6.498468	comment	12.0	88.0	1668546704	-11.8968115
33705416	Unfortunately, git rebase has a very	Unfortunately, git rebase has a very very annoying limitation that git merge doesn't. If you have a branch with, say, masterX + 10 commits, and commit 1 from your branch is in conflict with masterX+1, then when you rebase your branch onto masterX+1, you will have to resolve the conflict 10 times (assuming all 10 commits happen in the same area that had the original conflict). If instead you merge masterX+1 onto your branch, you will only have to resolve the conflict once.Even though I much prefer a linear history, losing 1h or more to the tedious work of re-resolving the same conflict over and over is not worth it, in my opinion.	simiones	8.583632	-6.5642886	comment	12.0	93.0	1669123159	-11.915537
33948062	From my experience people rarely rea	From my experience people rarely read the commit message s, so it is better to put the why part into comments in the code, not git history. I mostly write the detailed why part in the commit only for refactoring changes.	_0w8t	8.578987	-6.522193	comment	12.0	41.0	1670796249	-11.916164
26944860	Git repository of Plan 9 History, fr	Git repository of Plan 9 History, from 1992 to 2015	0intro	8.555941	-6.4810452	story	12.0	154.0	1619456255	-11.888325
37653838	Everyone does this. Otherwise you'd 	"Everyone does this. Otherwise you'd go bat sh*t crazy trying to remember every intricate details of common tools.also using ctrl+r and filter through older commands (ctrl+r to cycle) is also necessary for good mental health.for example    alias ll=""lsd --icon never -l""
    alias lla=""lsd --icon never -l -a"" # all
    alias llr=""lsd --icon never -l -r -a"" # reversed
    alias lls=""lsd --icon never -l -r -a -S"" #by size
    alias llt=""lsd --icon never -l --tree"" #tree
    alias lld=""lsd --icon never -l -d -a --tree"" #directories tree

    alias m='micro'
    alias ss=""git status""
    alias diff=""git diff --color | cat""
    alias log=""git log --graph --pretty=oneline --abbrev-commit""
    alias lz=""lazygit""
    alias dc=""docker-compose""

    # rust
    alias cr='RUST_BACKTRACE=1 cargo run'
   "	keyle	8.607285	-6.5250278	comment	12.0	72.0	1695697711	-11.858439
38073512	Kart: DVC for geospatial and tabular	Kart: DVC for geospatial and tabular data. Git for GIS	starkparker	8.570365	-6.458254	story	12.0	133.0	1698690138	-11.884224
38151185	Run Gitlab pipelines 2x faster and 5	Run Gitlab pipelines 2x faster and 5x cheaper without changes in .gitlab-ci.yml	NikPuashkin	8.372798	-6.440131	story	12.0	33.0	1699192932	9.019248
38160219	Is there a reason why they used Merc	Is there a reason why they used Mercurial as opposed to git? Did it provide some benefit?	mgd	8.493485	-6.545815	comment	12.0	96.0	1699261138	-11.937359
38394117	I don't use git at work, but in my p	"I don't use git at work, but in my private hobby projects my friends usually get mad when they watch me juggle changes and branch pointers with git reset --hard and git stash...How do you undo a merge that you didn't mean to do/did wrongly?    git reset --hard <last commit before merge>

Have some cosmetic fixups on your local branch that really should go into main (or a separate branch) first before merging a bigger feature?    git stash
    git checkout main
    git stash apply

By thinking about branches as pointers, the commit graph existing independently, and stashes just being temporary commits, I feel I'm working much more directly with the underlying abstraction. Yes, git has commands for specific combinations of actions, but for an occasional user it's harder to remember every suc"	MauranKilom	8.5735655	-6.5458684	comment	12.0	65.0	1700754921	-11.944395
15291809	How to Quickly and Correctly Generat	How to Quickly and Correctly Generate a Git Log in HTML	foob	8.549025	-6.4376435	story	12.0	94.0	1505897563	-11.845037
23621607	How to Rename Your Master Branch to 	How to Rename Your Master Branch to Main	justswim	8.521649	-6.5303397	story	13.0	18.0	1592954076	-11.674911
24303451	My SaaS deals primarily with legal d	"My SaaS deals primarily with legal documents that for years had been maintained with Word. The pain of emailing documents is real, but the comfort level with how Word works is also real. Over the years, most organizations have developed internal workflows to share and send documents around that bypass the pains, and while they may not be perfect, they work.The funny thing is that the document authors like these ways of working. It is the tech people who don't. I've seen ""Git for Word"" proposed many times a year for a while now. And all of the ideas are interesting, but none of them appeal to my audience because they don't care about git's feature set. Nobody wants to branch and merge. Nobody wants a straight version history. (""Nobody"" meaning nobody in my market, not nobody in the world.)T"	codingdave	8.635386	-6.448277	comment	13.0	65.0	1598612253	-11.877237
13889587	My team uses a git commit message co	My team uses a git commit message convention that helps us read fast and also is parsable by toolchains.We agree on a short list of leading active verbs:Add = Create a capability e.g. feature, test, dependency.Cut = Remove a capability e.g. feature, test, dependency.Fix = Fix an issue e.g. bug, typo, accident, misstatement.Bump = Increase the version of something e.g. dependency.Make = Change the build process, or tooling, or infra.Start = Begin doing something; e.g. create a feature flag.Stop = End doing something; e.g. remove a feature flag.Refactor = A code change that MUST be just a refactoring.Reformat = Refactor of formatting, e.g. omit whitespace.Optimize = Refactor of performance, e.g. speed up code.Document = Refactor of documentation, e.g. help files.	jph	8.58731	-6.524346	comment	13.0	48.0	1489701542	-11.905342
29126041	"""The mental model for Git is needles"	"""The mental model for Git is needlessly complex""News flash: Many programmers love complexity.Complexity == popularity == profitProve me wrong, please  (I seek simpler stuff)"	1vuio0pswjnm7	8.545646	-6.4904895	comment	13.0	48.0	1636157018	-11.896162
29126050	"""The mental model for Git is needles"	"""The mental model for Git is needlessly complex""This, in a nutshell, sums up my feelings about git."	throwawayboise	8.538871	-6.480015	comment	13.0	119.0	1636157160	-11.900664
29162234	Git techniques	Git techniques	jamescun	8.56593	-6.490434	story	13.0	86.0	1636468436	-11.8879175
34193244	Whatever happened to SHA-256 support	Whatever happened to SHA-256 support in Git	simonpure	8.680003	-6.52133	story	13.0	176.0	1672457620	7.184839
34631275	Git archive generation meets Hyrum's	Git archive generation meets Hyrum's law	JamesCoyne	8.576594	-6.461775	story	13.0	136.0	1675363649	8.479333
39358955	Not sure this is something I need. O	"Not sure this is something I need. One thing I do need though, maybe someone knows a solution:Often I find myself maintaining a handful of ""local"" changes. I make some changes that only make sense in my local environment, that I don't want to push.What I end up doing is maintaining these changes as a commit, committing on top of them, and using `git rebase -i` to periodically move them up. Then before I push, I have to temporarily rewind the branch to remove them, push, then cherry-pick them again.It's all a bit awkward and I would love a tool that maintains a kind of ""virtual branch"" that isn't shown but is automatically re-based on top every time I make a commit, maybe letting me resolve conflicts or even telling me ahead of time if I've created one, before committing.Someone must have a"	radarsat1	8.575092	-6.5518713	comment	13.0	44.0	1707840285	-11.914824
37428726	This was terrible at the time and it	This was terrible at the time and it remains terrible now. Extremely few teams need this level of complexity and some parts of it – like the redundant long-lived develop branch – are pointless safety blankets. It seems to have only caught on because a lot of people felt adrift when it comes to Git and this was written far too authoritatively for what it is. I’ve seen so many small teams tie themselves up wasting time working for Git Flow that I think this might actually be the worst thing to ever happen to version control. I’m glad the author has mostly walked it back, but unfortunately the damage has been done.If you are putting a team together and haven’t picked a Git workflow and are unsure what to do, start with something simple like trunk-based development and add complexity if and wh	JimDabell	8.566765	-6.48975	comment	13.0	66.0	1694142326	-11.884568
19617589	Announcing Building Git	Announcing Building Git	griffinmb	8.534003	-6.448733	story	13.0	291.0	1554834347	-11.908667
19779664	"""Easy"" like:    git diff master..bug"	"""Easy"" like:    git diff master..bugfix > bugfix.patch # or `format-patch`
    # now attach/upload bugfix.patch

Instead of:    # make sure you click around github.com to create third fork
    git remote add unnecessary-third-fork $THIRDFORK
    git push unnecessary-third-fork bugfix
    firefox $THIRDFORK # now click around to file a PR
    # now wait for your PR to be merged
    # now click around on github.com to delete $THIRDFORK
    # ... unless you just leave things laying around

What makes the second sequence easier than the first?"	colbyrussell	8.602045	-6.4620214	comment	13.0	93.0	1556554335	-11.879806
19907283	Git is pretty nice, but I'm sure the	Git is pretty nice, but I'm sure there is something much better waiting to he invented. The CLI in particular could use a ton of improvements.And I feel it in my bones that there is a revolutionary GUI waiting to be invented. Why can't I drag a commit or set of commits from one branch to another? With safe, easy undo (reflog doesn't count) and super smooth conflict resolution? Etc etc.And of course there is the interesting rabbit hole of semanitc / language aware diff. Line diffs suck in many ways.It's one of the hundreds of of problems that I'd love to work on one day, but probably won't get a chance to. Sigh... :)	dwaltrip	8.576051	-6.4896135	comment	13.0	70.0	1557815758	-11.847334
15987047	GitPlex – browse code in Git reposit	GitPlex – browse code in Git repository like in IDE	robinshen	8.561494	-6.473048	story	13.0	105.0	1513946775	-11.777041
16806334	Some time back, some GUI design firm	Some time back, some GUI design firm asked on HN for a suggested open source program that needed a GUI developed. They had some developer time free and wanted something that would get them visibility. I suggested they do a GUI for Git. Several such things exists, but they're just buttons hooked up to the command line; they have no useful visual outputs.  A good GUI for Git, where you could look at branches and such graphically, would get attention.Too hard, they said. They wanted something which just needed to be pretty, not something with tough human interface problems.	Animats	8.572792	-6.468686	comment	13.0	73.0	1523400551	-11.839005
17408985	Supercharging the Git Commit Graph	Supercharging the Git Commit Graph	ethomson	8.583946	-6.5163994	story	13.0	227.0	1530113685	-11.87645
21307136	Git Internals, Techniques, and Rewri	Git Internals, Techniques, and Rewriting History	mxschumacher	8.560648	-6.49731	story	13.0	162.0	1571605559	-11.895636
21384800	Mercurial RFC of a new extension to 	Mercurial RFC of a new extension to directly operate on Git repositories	luu	8.501725	-6.543779	story	13.0	141.0	1572333002	-11.968374
21420062	""". . . unlike every single horror I'"	""". . . unlike every single horror I've ever  witnessed when looking closer at SCM products, git actually has a simple design, with stable and reasonably well-documented data structures. In  fact, I'm a huge proponent of designing your code around the data, rather than the other way around, and I think it's one of the reasons git has been fairly successful. . . .""I will, in fact, claim that the difference between a bad programmer  and a good one is whether he considers his code or his data structures more important. Bad programmers worry about the code. Good programmers worry about data structures and their relationships.""--- Linus Torvalds, https://lwn.net/Articles/193245/"	combatentropy	8.54558	-6.484353	comment	13.0	119.0	1572623362	-11.90287
39140330	I've had to dig through the history 	I've had to dig through the history of a 5 year old project - it was much nicer when the commits were focused, the PRs has nice descriptions and even better if associated with ticket.I will defend merge squash forever - low effort, good results. You do whatever you want in your feature branch, then merge squash. Everyone can do it. You want to split it in multiple commits? Then it probably should have been split in multiple PRs .I need to write an article about this so I can just link to it instead of writing the same comment evrytime :)	pnt12	8.577727	-6.56061	comment	13.0	68.0	1706259754	-11.922886
39217623	I have felt that pride in writing a 	I have felt that pride in writing a great commit message, but I am less sure of the value to others. I don’t think most people search commit messages when they encounter an unusual error message, or when adding a new feature, or really almost ever.It’s a bit sad, but I have a growing suspicion that beautiful commit messages are a bit of vanity by the programmer. The person primarily impressed is often the author; others will walk on by without noticing.There is room sometimes for those aesthetic flourishes but I am not convinced they have much practical value, and I have stopped really being bothered by commit messages of “fix whitespace issue” from others. I think I am a better colleague for that.Things might be different on a project like Git or Linux with huge distributed teams and tons	spenczar5	8.585795	-6.5392275	comment	13.0	55.0	1706804537	-11.89043
39218709	I know the OP didn't mean it this wa	"I know the OP didn't mean it this way, but after reading HackerNews for the last decade or whatnot, it never ceases to surprise me how often developer complaints stem from developers just not doing their damn job.""Almost nobody ever sees it.... nobody reads anything other than the first 50 chars of the headline.""On the one hand, I get it.  If a tool makes something difficult, people are less likely to do it, and as engineers we want to make tools to cause people to fall into the pit of success.  So, improving this part of git makes sense.On the other hand, just do your damn job.  If a coworker doesn't understand a code change, because they didn't bother to read the commit message, they're a bad developer.  If they didn't write a git commit message because ""no one is going to read it anyway"	ep103	8.560532	-6.5057154	comment	13.0	71.0	1706809144	0.22835219
18215588	Stop cherry-picking, start merging, 	Stop cherry-picking, start merging, Part 1: The merge conflict	kiyanwang	8.733188	-6.4752903	story	13.0	87.0	1539553423	9.185676
30112830	This commit in the PRhttps://github.	"This commit in the PRhttps://github.com/obsproject/obs-studio/pull/5875/commits/8...provides an excellent example of why commit messages matter. This is more than 1000 lines diff to the build system (and thus potentially very dangerous because of possible supply chain attacks) which has the commit message of""CI: Update build scripts and Github actions workflow""Never say what you ware doing (it's obvious this commit is updating build scripts). Say why you are doing it, especially when your commit feels unrelated or at most very tangentially related to the objective of your PR."	pilif	8.58266	-6.5011115	comment	13.0	96.0	1643365168	-11.884715
13178221	Git Cheat Sheet	Git Cheat Sheet	akras14	8.583021	-6.472414	story	13.0	182.0	1481739203	-11.929403
13379572	Git Koans (2013)	Git Koans (2013)	oxplot	8.53402	-6.454931	story	13.0	194.0	1484190832	-11.890908
27788238	Generate a Git repository with 2^28 	Generate a Git repository with 2^28 commits—one for every 7-character shorthash	breck	8.598189	-6.4593325	story	13.0	232.0	1625863189	-8.644786
12218622	Show HN: Git Confirm. Git hook to ca	Show HN: Git Confirm. Git hook to catch accidentally committed code (TODO/Skip)	pimterry	8.568928	-6.445339	story	13.0	51.0	1470237995	-11.852093
28584422	The Elements of Git	The Elements of Git	todsacerdoti	8.562719	-6.4699817	story	13.0	139.0	1632060444	-11.872453
33377421	Every day, I commit a new and more c	Every day, I commit a new and more complicated version of some simple code	simonpure	8.588541	-6.479172	story	13.0	84.0	1666988793	-3.9761512
33647342	Meta:> At Meta we call an individual	Meta:> At Meta we call an individual set of changes made to the codebase a “diff.”GitHub:> Pull requestAmazon:> Change RequestGitLab:> Merge RequestGoogle:> ChangelistNitpicking, but jesus christ, why can't we stick to a single term?	andreygrehov	8.661085	-6.475259	comment	13.0	60.0	1668726969	-11.807681
34001569	SHA-1 is still perfectly fine for so	SHA-1 is still perfectly fine for some applications like detecting duplicate files on a storage medium (and it's less likely to produce a false positive than MD5) but it's been a bad idea for anything security related for a decade.The biggest issue is that git still uses it, which presents a problem if you want to protect a repo from active integrity attacks.	dreamcompiler	8.69135	-6.5185113	comment	13.0	121.0	1671120300	7.2142086
38222596	How Git cherry-pick and revert use 3	How Git cherry-pick and revert use 3-way merge	hasheddan	8.627029	-6.5558257	story	13.0	211.0	1699641045	-11.871966
14712269	Two Commits and the User Experience 	Two Commits and the User Experience of Git	dfabulich	8.5850935	-6.527108	story	13.0	117.0	1499363108	-11.911579
15376841	A successful Git branching model (20	A successful Git branching model (2010)	gandalfar	8.568004	-6.527901	story	13.0	127.0	1506844003	-11.886531
24686888	The reason to squash commits is more	The reason to squash commits is more than just keeping your commit history read-able, it's about making easy to revert a feature and being able to keep history in a way that makes it simple to revert a change if you run into issues.If I rollout a rewrite of an endpoint and run into a weird issue in the QA environment, I'm a simple git revert away from fixing the issue.  If I had spread that endpoint across 25 commits, I'd have to actually debug the issue in QA and figure out what I broke.  Reverting quickly lets me debug the issue on my time instead of keeping our test suite broken.It's not always feasible, and I try not to be a stickler when people on my team don't do it but the fact is, if you're working in a world when you're delivery code quickly into real environments, having a back-o	davewritescode	8.587789	-6.553969	comment	13.0	105.0	1601899344	-11.933812
38844053	Git Branches Have No Rules	Git Branches Have No Rules	hasheddan	8.571286	-6.51933	story	13.0	41.0	1704215725	-11.881545
23528154	Discussion on renaming master branch	Discussion on renaming master branch gets heated, then shut down	jansan	8.530589	-6.536969	story	14.0	33.0	1592234149	-11.7232275
23584971	A step-by-step guide for your compan	A step-by-step guide for your company's Git master to main migration	marcua	8.555854	-6.4892044	story	14.0	16.0	1592672263	-11.919627
23887068	Post-Commit Reviews	Post-Commit Reviews	henrik_w	8.591677	-6.489666	story	14.0	46.0	1595133931	-11.858118
20126034	> code that I wrote myself is hard t	> code that I wrote myself is hard to readThis has happened more times than it probably should:1. Arrive upon some code I wrote at some point in the near or distant past.2. Review it to get some idea of what I was trying to do3. Laugh at my young self for being so naive4. Refactor or Rewrite5. Re-realize the edge-cases and difficulties6. Remember this being a problem7. Refactor And Rewrite8. Either `git reset --hard HEAD` or end up with a similar solution, but with better commentsOnce in a while, I end up with a [simpler | faster | clearer | otherwise better] version, which makes this process worth while - even with the false positives.	enobrev	8.56741	-6.5311337	comment	14.0	95.0	1559923866	-11.925621
13647927	The Biggest and Weirdest Commits in 	The Biggest and Weirdest Commits in Linux Kernel Git History	gary_bernhardt	8.57263	-6.4858203	story	14.0	394.0	1487111765	-11.883044
30816500	Does Fossil have a unique or killer 	"Does Fossil have a unique or killer feature that makes it a good alternative to git, other than ""simpler to use""?I don't like the monoculture either, but at this point some knowledge of git is an essential skill. In fact pretty much the only chance you have of avoiding git would be to build your own stuff on something else, hire/collaborate only with others who share the same view, and never interact with basically any other open source.So given some git knowledge is necessary anyway, there are alternatives interfaces to git that solve the simplicity problem, and any other tool is going to have friction (small ecosystem, few integrations, smaller community), why use something else? (I mean this genuinely)I just don't see the dominance of git changing for the next decade, especially if ther"	gregmac	8.50343	-6.528125	comment	14.0	66.0	1648339618	-11.994253
31480306	Proper use of Git tags	Proper use of Git tags	da-x	8.555623	-6.478765	story	14.0	256.0	1653319856	-11.876722
28844325	Random collisions in 160-bit space a	"Random collisions in 160-bit space are incredibly unlikely. This is talking about intentional collision, and means that it's entirely feasible for someone with significant compute power to create a git commit that has the exact same hash as another git commit. This could allow someone to silently modify a git commit history to e.g. inject malware or a known ""bug"" into a piece of software. The modified repository would be indistinguishable if you're only using git hashes.Git's uses SHA-1 for unique identifiers, which is technically okay as long as they are not considered secure. If git were designed today it would probably use SHA2 or SHA3 but it's probably not going to change due to the massive install base.Edit: anyone know if git's PGP signing feature creates a larger hash of the data in"	api	8.660691	-6.515634	comment	14.0	76.0	1634068701	7.2056084
28956873	I've never seen the upside.  I use E	"I've never seen the upside.  I use Emacs as my primary editor, and I regret it every time I say ""today is the day I start using Magit"".  It is exceedingly invasive, triggering itself even when you don't ask for it (like running ""git rebase -i"" on the command line).  The invasive stuff changes how the text editing itself works, but doesn't add deep features.  In the interactive rebase case, I lose the ability to treat the interactive rebase text as text, but I also don't gain anything.  I can't just navigate around, kill a line, and put it somewhere else.  Well, I can do that, but the usual keybindings don't work, they just made their own for no reason.  And, for example, if I do use their UI and pick ""reword"" as the operation for a certain commit, I should be prompted for the desired rewor"	jrockway	8.719006	-6.589333	comment	14.0	50.0	1634908917	-11.88923
29298017	Git ls-files is Faster Than Fd and F	Git ls-files is Faster Than Fd and Find	todsacerdoti	8.672401	-6.438068	story	14.0	156.0	1637516019	-11.807669
34965662	I wish we had a version control syst	"I wish we had a version control system that can be used without worrying, or even knowing, about its technicalities and implementation details.Working with Git for version control is as if your photo management tool required you to learn about inodes and b-tree superblocks in order to save a JPEG file. I just want to keep source code history, and allow multiple people to collaborate on the same project. I don't want to know anything about ""refs"" or whatever else is happening behind the scenes, yet it appears Git can't be used unless you are (at least occasionally) willing to look at the plumbing layer."	p-e-w	8.607527	-6.4489503	comment	14.0	130.0	1677558891	-11.872337
39356254	I do not want to learn git tricks. I	I do not want to learn git tricks. I just wanna use it as simple as possible. Just let me push my code and be done with git and keep on working.Kudos to all who love git, for me, it's just a tool I have to use.	patatino	8.536344	-6.48383	comment	14.0	81.0	1707819430	-11.896759
39657816	Slightly off-topic: why does git hav	Slightly off-topic: why does git have such a near-monopoly on VCS? Mozilla might use something different, but I haven't come across a new project that used something other than git in at least years.Usually there are at least a few choices with different compromises. Browsers, OSes, languages, editors, all have multiple actually popular choices.Does git win because of the decentralized, everyone-has-a-local-repo aspect? Or the staging area, which I understand other VCSes don't have? Or just speed or reliability? Or just being in the right place at the right time?	ralphist	8.546114	-6.44665	comment	14.0	46.0	1710062788	-11.878614
36831650	I'm glad Fossil works for them, but 	"I'm glad Fossil works for them, but this line is bothered me:> In contrast, Fossil is a single standalone binary which is installed by putting it on $PATH. That one binary contains all the functionality of core Git and also GitHub and/or GitLab. It manages a community server with wiki, bug tracking, and forums, provides packaged downloads for consumers, login managements, and so forth, with no extra software requiredgit, for all its issues, is not bundling the kitchen sink. I do prefer the ""do one thing and do it well"" approach."	ohthatsnotright	8.499041	-6.4747124	comment	14.0	224.0	1690074850	-11.908435
24586436	Visual and interactive way to learn 	Visual and interactive way to learn Git	selva93	8.552844	-6.488378	story	14.0	342.0	1601006285	-11.903231
38693276	The World Before Git	The World Before Git	janvdberg	8.542242	-6.4672337	story	14.0	35.0	1702975417	-11.898089
32864036	GitUI: Terminal UI for Git	GitUI: Terminal UI for Git	stillicide	8.564882	-6.4669485	story	14.0	187.0	1663320756	-11.865925
31875591	I find people are religious about be	"I find people are religious about being git cli purists and only interacting with it in this black box (the terminal). On top of that a lot of people stop learning git after add commit push pull branch and merge so concepts like rebasing and cherry picking are scary.
In this day and age we have state of the art GUI tools that change the game and allow git users to see and interact with the state of a git repository in real time. It's a great way to demystify things like rebasing and interactive rebasing because they show you what's happening in a modern UI designed specifically for git.
I often suggest git CLI purists to get something like git kraken and just use it as a visual dashboard. Watch what happens when you run git commands. You can see everyone else's remote branches and have a m"	gpspake	8.574149	-6.5190964	comment	14.0	72.0	1656167453	-11.891239
19698282	Show HN: Why you should not use feat	Show HN: Why you should not use feature branches	jpdel	8.635086	-6.5303135	story	14.0	13.0	1555668718	-11.784368
19907242	I’m torn. Practically Mercurial feel	I’m torn. Practically Mercurial feels like it should be the winner. The commands are more uniform and predictable.That’s not all it has going for it either. Mercurial has a concept of commit stages to make history rewriting safer. It has a commit model that enables you to work on and manipulate branches of commits seamlessly, without needing named branches. It has not just a tree of commits but also each commit tracks its own history through rewrites. You get cool commands like absorb and evolve. It’s easier to extend than Git.The only downside to modern Mercurial I can think of is it’s still slower than Git, by at least a bit. But it can scale incredibly far with its extensibility. For example, what Facebook did:https://code.fb.com/core-data/scaling-mercurial-at-facebook/So why does it ne	jchw	8.513058	-6.5554523	comment	14.0	85.0	1557815256	-11.943114
15885829	Git is a purely functional data stru	Git is a purely functional data structure (2013)	eisokant	8.570965	-6.4962335	story	14.0	227.0	1512828265	-11.88822
15952709	I use the git CLI.  I do it for one 	"I use the git CLI.  I do it for one reason.  I know exactly what i'm doing on it.  I have nothing to prove to anyone, I'm not trying to impress anyone with my ""hacker"" skillz.When I've tried GUI's, I'm not 100% sure what's going on under the covers.  Sometimes they try to obfuscate things. While I'm probably not the worlds most advanced user, I know enough to know what I want to do, and how to do it.  The CLI let's me do it.  The GUI get's in my way."	swalsh	8.593116	-6.4866757	comment	14.0	116.0	1513614094	-11.8399
16587174	So many people have a hard time with	So many people have a hard time with git. I have yet to meet someone who understands git and uses it proficiently.What I tell every new programmer joining my team is to read chapter 10 (Git Internals) section 10.2 and 10.3 of the amazing online git book[0][1][2].I can not insist enough on how important it is to understand the fundamental design of git, and it is really not complicated.This is what made me understand git and changed it from a hard tool to use, to this amazing productivity software that I love.The kicker for me was to realize that in git (mostly) everything is a reference to a commit id.What's a branch? It's a human readable string, made for humans, by humans, that ultimately simply references a commit id. What is a new branch? It's just a new human readable string pointing 	gouggoug	8.560852	-6.5333447	comment	14.0	171.0	1521052612	-11.886957
21418781	To me the beauty of git stems from t	"To me the beauty of git stems from the fact that it is an implementation of a functional data structure. It‘s a tree index that is read-only, and updating it involves creating a complete copy of the tree and giving it a new name. Then the only challenge is to make that copy as cheap as possible - for which the tree lends itself, as only the nodes on the path to the root need to get updated. As a result, you get lock-free transactions (branches) and minimal overhead. And through git‘s pointer-to-parent commit you get full lineage.
It is so beautiful in fact that when I think about systems that need to maintain long-running state in concurrent environments, my first reaction is ”split up the state into files, and maintain it through git(hub)“."	cmarschner	8.571942	-6.49549	comment	14.0	233.0	1572616515	-11.899009
21584144	Successfully Merging the Work of 100	Successfully Merging the Work of 1000 Developers	rom16384	8.734699	-6.4439845	story	14.0	339.0	1574259952	1.7763278
39139616	Nobody Cares About Your Git History	Nobody Cares About Your Git History	ingve	8.560528	-6.482963	story	14.0	60.0	1706251994	-11.879649
18029498	Adding Mercurial support to Gitlab	Adding Mercurial support to Gitlab	testcross	8.440167	-6.4997306	story	14.0	277.0	1537413357	-11.976182
18029821	I still don't understand why git bec	I still don't understand why git became so popular in comparison to Mercurial. Mercurial seems like a much more friendly and sane system. I hope adding it to Gitlab will help its popularity.	maxxxxx	8.517464	-6.5334005	comment	14.0	93.0	1537418266	-11.93848
18309596	The Architecture of Git (2012)	The Architecture of Git (2012)	wheresvic1	8.5587225	-6.4671717	story	14.0	355.0	1540564774	-11.89958
18921313	And here is something to take the ga	"And here is something to take the garbage quality of Git manpages with some humorhttps://git-man-page-generator.lokaltog.net/""git-eliminate-head eliminates all downstream heads for a few forward-ported non-counted downstream indices, and you must log a few histories and run git-pioneer-object --pose-file instead. [...]"""	ahartmetz	8.560063	-6.497349	comment	14.0	49.0	1547650598	-11.898548
13070261	Ask HN: Is there a “ground-up” expla	Ask HN: Is there a “ground-up” explanation of PGP/GnuPG?	kqr	8.554711	-6.50032	story	14.0	121.0	1480510199	-11.900187
27556183	How to end up with 500k commits in y	How to end up with 500k commits in your log	benhoyt	8.596071	-6.5280933	story	14.0	88.0	1624058929	-11.916069
27683059	Ignoring bulk change commits with Gi	Ignoring bulk change commits with Git blame (2019)	noway421	8.581347	-6.52272	story	14.0	111.0	1625009111	-11.93599
27989912	Finding a kernel regression in half 	Finding a kernel regression in half an hour with git bisect run (2018)	10000truths	8.558701	-6.474892	story	14.0	209.0	1627507412	0.8751601
28423843	Git-cliff – Generate changelog files	Git-cliff – Generate changelog files from the Git history	ducktective	8.572072	-6.492678	story	14.0	223.0	1630845072	-11.911124
22496724	A note of reflection after 10 years 	A note of reflection after 10 years of “A successful Git branching model”	nilsandrey	8.574553	-6.5075665	story	14.0	199.0	1583434350	-11.891239
22575775	Git partial clone lets you fetch onl	Git partial clone lets you fetch only the large file you need	moyer	8.575188	-6.454303	story	14.0	229.0	1584198261	-11.898325
33532829	Rebase should never be used. Or, if 	Rebase should never be used. Or, if it is used, it should be treated as a dangerous thing to do that’s well outside the norm.Most of the arguments in favor of rebase are by people fanatical about having a git history organized just so. It’s not worth the headache and effort. PRs are a better unit of work than commits in practice.Configure GitHub or whatever you use to squash merge only and you’ll be good.Since moving to this workflow I’ve had zero issues losing data due to a confusing git situation.	andrewvc	8.578048	-6.5687222	comment	14.0	71.0	1668007258	-11.928068
33615242	Ah, there it is. I was wondering whe	Ah, there it is. I was wondering when this would happen.Facebook used to be involved with the Mercurial community, but it was difficult to work with them. They always wanted to do things their way, had their own intentions, and started to demand that the Mercurial project work the way that Facebook wanted. For example, they demanded that we start using Phabricator and started slowly removing sequential revisions from Mercurial in favour of always using node hashes everywhere, arguing that for their gigantic repos, sequential revisions were so big as to be useless.Eventually the disagreements were too great, and Facebook just stopped publicly talking about Mercurial.I figured they would emerge a few years later with their fork of it. They love doing this. HipHop VM for PHP, Apache Hive, MyR	jordigh	8.476662	-6.5569997	comment	14.0	122.0	1668547551	-11.935574
33802251	Minimum Viable Git for Trunk-Based D	Minimum Viable Git for Trunk-Based Development	elischleifer	8.577171	-6.508059	story	14.0	48.0	1669822922	-11.880632
26997927	> Developers should be required to s	"> Developers should be required to submit _clean_ PRs, that is, PR's whose git history has been organized and refactored in such a way that it removed ""clean up commits"", ""typo fix"", etc.A complete and utter waste of time. You spend more time messing about with rebase than solving problems.When you're digging through VCS history due to a bug you often ignore the commit message anyway - if the code did what it seemed to do you wouldn't be there."	calpaterson	8.579271	-6.5499034	comment	14.0	94.0	1619809868	-11.904501
38160161	Firefox Development Is Moving from M	Firefox Development Is Moving from Mercurial to Git	l0b0	8.509375	-6.469933	story	14.0	223.0	1699260604	-11.937725
38443608	GitMounter: A FUSE filesystem for Gi	GitMounter: A FUSE filesystem for Git repositories	goranmoomin	8.596725	-6.4437213	story	14.0	192.0	1701160185	-11.838788
38501733	I like the idea, and I like sql, but	"I like the idea, and I like sql, but I feel like this is a lot more typing for the same information you could extract using just git commands. Am I missing something? Take for instance:The commit example:    select name, count(name), from commits group by name

is actually:    git shortlog -sn

The tag example:    select * from tags

is actually:    git tag

The branch example:    select * from branches

is actually:    git branch"	bastardoperator	8.609343	-6.554373	comment	14.0	45.0	1701548857	-11.887097
38591669	A lot of people these days have just	A lot of people these days have just been thrown into the fire with Git as the first and only VCS they’ve ever seen.I’m not that old, but I’m old enough to have used RCS, CVS, SVN, then finally Git. I started using Git super early, before GitHub existed. You may not believe me, but Git was the answer to all my prayers. All those previous systems had fundamental architectural flaws that made them a complete nightmare to use on a team for any serious work.Git has no such problem. There’s nothing it can’t do. Instead, the only limitation is on the user being able to know how to get Git to do what they want it to do. Thankfully, that’s always solvable with a quick read of the documentation or web search.I understand that people might want to make it easier, since the UI is complex, but that’s 	Apreche	8.547064	-6.4919324	comment	14.0	127.0	1702218015	-11.907753
23954780	It bothers me that they repeatedly w	"It bothers me that they repeatedly write about a migration ""from Mercurial to GitHub"", rather than ""from Mercurial to Git"". It seems to imply that GitHub hosting is the only way to run Git.It's perfectly fine to say that they are moving to GitHub hosting, but not to put it on the same level as Mercurial: Mercurial and Git are applications/protocols, while GitHub is a hosting service. You should compare application with application and hosting service with hosting service."	giomasce	8.507146	-6.5394654	comment	15.0	76.0	1595743115	-11.943747
13906804	The beginning of Git supporting othe	The beginning of Git supporting other hash algorithms	_qxtl	8.643977	-6.5142217	story	15.0	427.0	1489928441	-11.836131
31006562	I think it's a tall order for anothe	I think it's a tall order for another SCM to challenge git. I can't imagine how it could be any more entrenched in the industry.Further, I'm happy with git. I played with Mercurial years ago, long enough to work with it day-to-day, and just didn't find any relevant advantages versus git.I love that people are still out there trying to improve things, and certainly don't want that to stop, but it's difficult for me to imagine switching at this point.	Ancapistani	8.52765	-6.5085526	comment	15.0	71.0	1649788197	-11.928836
31173708	"I prefer Github's method of ""git com"	"I prefer Github's method of ""git commit messages don't matter, pull requests do"".Nowadays, you can easily enforce that the ultimate commit log looks rather nice by doing this:1. Make it so the only merge strategy allowed on a repo is ""Squash and Merge"", so each PR = 1 commit in main branch2. Have engineers care about the pull request quality rather than commit messagesIt's easier to be more expressive in a pull request, and intermediate changes while working on a PR aren't super interesting to me."	carlosdp	8.576642	-6.5119405	comment	15.0	76.0	1651010411	-11.940572
31420432	This is my favourite feature of giti	"This is my favourite feature of gitignores.
Everytime I need ""drafts"", sample code, etc, in a repo, I create a folder in that repo, but then I have to remember to not add it to commits, and I don't want to add it to the .gitignore that is versioned, so I do ""mkdir drafts && echo '*' > ./drafts/.gitignore"", and it ignores my drafts without having to add a new ignored dir in the versioned .gitignores.And obviously, it also ""ignores"" the .gitignore itself because it matches ""*"", while still taking it into account, which is what I need."	rpigab	8.609211	-6.4798865	comment	15.0	187.0	1652862473	-11.840688
28956254	> stash some of my changes, switch b	> stash some of my changes, switch branch, cherry pick a commit, switch branch, do an interactive rebase reordering commits and dropping one, pop one of my stashes> working with code becomes a fluent experience, rather than fighting with your toolsI also do this regularly, but on my terminal. I don't feel like I'm fighting the git tools. Is this a common experience?I enjoy using git GUIs as well, especially for visualizing branches, commits and diffs. I just don't understand why the git commands seem to cause so much trouble.	matheusmoreira	8.600483	-6.520296	comment	15.0	118.0	1634904518	-11.890218
34592312	This creates precisely the kind of c	"This creates precisely the kind of commit messages that I regularly scold junior developers for :)""In my opinion, commit messages should clarify the intent of WHY you changed things. I can already see WHAT you changed from the diffs.But of course, any tool can only work with the what, they cannot know that these lines are related to a bug report filed in a technically unrelated system."	fxtentacle	8.584139	-6.5238156	comment	15.0	84.0	1675149959	-11.91078
36777600	What is a merge queue, and does your	What is a merge queue, and does your team need one?	dbalatero	8.6822605	-6.507229	story	15.0	69.0	1689706859	9.246184
25044088	>Never stashEr, no. Right tool for t	>Never stashEr, no. Right tool for the right job.Whilst I agree that the idea of putting differing lines of work into different branches is great, that's not what stash is for. That's what checkout is for.Stash is used to record the current state of the working directory and index while also returning to a clean working state.I guess for the author, stash is used to preserve changes when pulling in upstream changes you missed. It can, but it does waaaay more.What happens if, like many people, you're working on a few branches at a time. Could be a monorepo, could be a couple long living branches, w/e. What do you do if you've done work against a branch and want to lift and shift to another branch?You could commit and rebase and all sorts of clever mangling of the history.OR you could use th	smokey_circles	8.57643	-6.5468493	comment	15.0	68.0	1605000130	-11.912101
38998175	Git Branches as a Social Construct	Git Branches as a Social Construct	ingve	8.569993	-6.5080767	story	15.0	69.0	1705302411	-11.889759
31875953	Dangit, Git?	Dangit, Git?	todsacerdoti	8.547416	-6.468876	story	15.0	85.0	1656170405	-11.890025
32091955	Ask HN: Recommendations on how to be	Ask HN: Recommendations on how to become a Git expert?	telman17	8.558239	-6.5188046	story	15.0	19.0	1657772281	-11.885827
15819033	Git hash function transition plan	Git hash function transition plan	vszakats	8.63794	-6.514229	story	15.0	215.0	1512072446	-11.874995
16586811	Key Git Concepts Explained the Hard 	Key Git Concepts Explained the Hard Way	ingve	8.564901	-6.522435	story	15.0	361.0	1521050184	-11.885309
29978336	Learn the workings of Git, not just 	Learn the workings of Git, not just the commands (2015)	philonoist	8.561847	-6.486555	story	15.0	130.0	1642510760	-11.893884
13228790	The author concludes by saying:>I th	"The author concludes by saying:>I think I've written before that this profusion of solutions is the sign of a well-designed system. The tools and concepts are powerful, and can be combined in many ways to solve many problems that the designers didn't foresee.I disagree. I consider this to be a failure of Git. The set of different options (normal merge, rebase, filter-branch, etc) is complex and not cleanly orthogonal which makes for a very messy ""mental model"". Even experienced experts would have difficulty finding the clear, simple way to solve this problem and those less experienced would have little chance of proceeding cleanly.I really wish some tool other than Git had ""won"" the version-control race; I honestly believe Git to be the worst of the contenders in the most recent generation"	mcherm	8.5770445	-6.4976826	comment	15.0	177.0	1482325925	-11.882358
27643057	When it comes to Git history, less i	When it comes to Git history, less is more	maximilianroos	8.562669	-6.4874682	story	15.0	250.0	1624723760	-11.908517
28161973	I also have found teaching someone h	"I also have found teaching someone how to be even marginally capable of contributing to a Github project from scratch to be a very time consuming and frustrating thing. Think, having your graphics designer able to make commits, or having someone who only wants to update docs.The worst part is the ""easier"" solutions are actually just footguns in disguise, as soon as they accidentally click the wrong thing and end up with a detached HEAD, a few commits ahead and behind the REMOTE, and halfway through a botched merge, you have to figure out how to bail them out of that using a GUI you've never actually used. Knowing all this, you either teach them git (high short term pain, high chance of them just giving up immediately) or you tell them to download the first result for ""windows foss git gui"""	BeefySwain	8.553824	-6.4833097	comment	15.0	102.0	1628804872	-11.894061
28578896	Visual Git Cheat Sheet	Visual Git Cheat Sheet	SiggyF	8.552072	-6.465872	story	15.0	191.0	1631995829	6.1818056
22777164	Git commands to know just after you 	Git commands to know just after you get the basics	mdziubek	8.551271	-6.4815965	story	15.0	104.0	1585991854	-11.8679495
22796640	Git alias for printing recently-used	Git alias for printing recently-used branches	ses4j	8.595437	-6.5289307	story	15.0	96.0	1586199230	-11.841491
26742171	From a storage perspective, describi	"From a storage perspective, describing commits as snapshots seems like a bad mental model. Suppose I have a directory that is 100MB in size. If I take a snapshot of it, my snapshot would be 100MB in size. If I take a 2nd snapshot of it tomorrow, my 2nd snapshot would also be 100MB in size. My total storage needs would now be 300MB.Whereas if I had used git, and created 2 additional commits, each making a change to a small text file, my total storage size would be barely larger than 100MB. Describing the commits as a diff, as opposed to a snapshot, leads to a better intuitive understanding of why this would be the case.Not to mention other features the article discussed, such as cherry-picking. What does it even mean to ""cherry-pick a snapshot""? In comparison, cherry-picking a diff and appl"	whack	8.593402	-6.536571	comment	15.0	117.0	1617906991	10.300699
27491286	Git for Computer Scientists (2010)	Git for Computer Scientists (2010)	thanato0s	8.56186	-6.450318	story	15.0	259.0	1623578773	-11.885497
37792097	What is in that .git directory?	What is in that .git directory?	Ivoah	8.572366	-6.4597955	story	15.0	269.0	1696606174	-11.85784
38286299	Why SQLite Does Not Use Git	Why SQLite Does Not Use Git	sarupbanskota	8.681962	-6.5504837	story	15.0	66.0	1700115493	9.911475
23577746	Updating the Git protocol for SHA-25	Updating the Git protocol for SHA-256	chmaynard	8.655023	-6.5096397	story	16.0	217.0	1592593033	-11.834624
23659451	HonKit: A Fork of GitBook	HonKit: A Fork of GitBook	matsuu	8.557899	-6.4518237	story	16.0	100.0	1593230996	-11.902148
31075608	Take the pain out of Git conflict re	Take the pain out of Git conflict resolution: use diff3 (2017)	harporoeder	8.640914	-6.496835	story	16.0	191.0	1650311604	-11.868361
26236677	Show HN: Test your Gitlab CI Pipelin	Show HN: Test your Gitlab CI Pipelines changes locally using Docker	damnhotuser	8.416374	-6.444134	story	16.0	83.0	1614084474	9.067866
28771841	A Git Implementation in Awk	A Git Implementation in Awk	rohitpaulk	8.68256	-6.5031404	story	16.0	274.0	1633520200	-11.80547
39356184	Heya, author here.I have to admit th	Heya, author here.I have to admit that I learned a lot of these things fairly recently. The large repository stuff has been added into core piece by piece by Microsoft and GitHub over the last few years, it's hard to actually find one place that describes everything they've done. Hope it's helpful.I've also had some fun conversations with the Mercurial guys about this. They've recently started writing some Hg internals in Rust and are getting some amazing speed improvements.I'm also thinking of doing a third edition of Pro Git, so if there are other things like this that you have learned about Git the hard way, or just want to know, let me know so I can try to include it.	schacon	8.532001	-6.5466733	comment	16.0	85.0	1707818704	-11.923705
36894947	Ask HN: How to give a crash course o	Ask HN: How to give a crash course on Git?	scandingo	8.525786	-6.5115786	story	16.0	31.0	1690471302	-11.921617
37096358	I'm not familiar with Pijul, and hav	I'm not familiar with Pijul, and haven't finished watching this presentation, but IME the problems with modern version control tools is that they still rely on comparing lines of plain text, something we've been doing for decades. Merge conflicts are an issue because our tools are agnostic about the actual content they're tracking.Instead, the tools should be smarter and work on the level of functions, classes, packages, sentences, paragraphs, or whatever primitive makes sense for the project and file that is being changed. In the case of code bases, they need to be aware of the language and the AST of the program. For binary files, they need to be aware of the file format and its binary structure. This would allow them to show actually meaningful diffs, and minimize the chances of conflic	imiric	8.657797	-6.5222845	comment	16.0	92.0	1691807033	13.897156
32808229	SQLite Doesn't Use Git	SQLite Doesn't Use Git	bkq	8.622413	-6.507827	story	16.0	181.0	1662979461	9.896489
32033136	Toxic squash syndrome	Toxic squash syndrome	tosh	8.554229	-6.590737	story	16.0	64.0	1657355863	11.335897
19006283	I'm surprised git caught on despite 	I'm surprised git caught on despite mercurial being much superior (hadn't heard of fossil before). Git has the following shortcomings which are major (some shared by other VCS too)1) UI- terrible, terrible UI2) Unncessarily complex data model3) Doesn't scale well to large repos (until Microsoft's VFS- windows only)(and many others...)	fxfan	8.5189085	-6.5290794	comment	16.0	89.0	1548510827	-11.936254
17265151	The Biggest and Weirdest Commits in 	The Biggest and Weirdest Commits in Linux Kernel Git History (2017)	swsieber	8.572869	-6.476015	story	16.0	326.0	1528464958	-11.881406
17968989	Slightly off topic but just thought 	"Slightly off topic but just thought I'd say, my favourite git shortcut is: ""git checkout -"" which toggles between the current and the previous branch just like cd - does with directories.What is your favourite git shortcut or feature!?"	andy_ppp	8.560801	-6.4916887	comment	16.0	81.0	1536761818	-11.900503
29839884	How to Squash and Rebase in Git	How to Squash and Rebase in Git	mooreds	8.570735	-6.5608115	story	16.0	38.0	1641567828	9.358845
30015693	Ask HN: Which version control system	Ask HN: Which version control system should a new business in 2022 use?	tomrod	8.690241	-6.4442215	story	16.0	18.0	1642715826	-11.814037
12613062	I've seen more stash accidents than 	"I've seen more stash accidents than any other kind with git. Stashing is more dangerous than committing or branching, and to me it doesn't seem to provide any advantages... do people actually find stashing easier than branching? Is it just because when you branch you have to name it, and that causes friction? I stay away from stash.Right from the man page: ""If you mistakenly drop or clear stashes, they cannot be recovered through the normal safety mechanisms.""https://git-scm.com/docs/git-stash--I do like shorty. My version:  alias gits='git status -sb'

--My next fave is rebase the current branch against it's upstream branch point:  [alias]
    rearrange = ""!git rebase -i $(git merge-base HEAD @{u})""

git rearrange ftw."	dahart	8.572469	-6.5490384	comment	16.0	92.0	1475249605	9.427228
13175081	A Git query language	A Git query language	bryanrasmussen	8.585699	-6.488377	story	16.0	352.0	1481712489	-11.891767
28025900	I wouldn't say I'm an expert but I'v	I wouldn't say I'm an expert but I've got about 10 years experience using git via CLI and whenever a noob does something weird and he's using an IDE I'm like... Sorry I have zero idea what this is trying to do and cannot help you	intellix	8.569177	-6.456504	comment	16.0	123.0	1627822086	-11.831594
33388869	I am a firm believer that a commit s	I am a firm believer that a commit should rarely be more than a couple minutes of work. When I go to git-blame, I want the commit message to be the why of this specific change. When I git blame and find a commit that's thousands of lines I wonder why we're even using git at that point and not just saving zips.The proponents of PR Squashes irk me. You're losing all the value of git. In the future when I'm hunting down a problem I almost never care about what feature or fix this was a part of - e.g. the PR - I care entirely about the context of the developers mind when he committed that specific line of code.In the rare case you do actually care what PR a commit is from, GitHub's search will tell you.[1]. There's no need to put that information in a commit at all.I was recently hunting down 	donatj	8.57062	-6.507604	comment	16.0	87.0	1667084953	-11.90556
26579186	Does anyone use Fossil? I'm consider	Does anyone use Fossil? I'm considering it for my personal projects. I like all it offers for the relatively low resource usage.The only use of it I've seen in the wild is Ripcord (https://dev.cancel.fm/issues), which is interestingly also relatively low resource usage compared to its competitor.	HeckFeck	8.502824	-6.5139093	comment	16.0	112.0	1616674010	-11.948011
38222996	Honest question - does git have to b	Honest question - does git have to be as complicated as it is for most usages? The number of times I got stuck fixing (mine and other people's) git issues is way more than seems necessary. I have not used a merge at a workplace for so long that I forget how it works, because rebases make so much more sense. Git provides a thousand features and I find myself using only three. And yet mercurial (which I remember having a more streamlined UX) went the way of the dodo.	vvpan	8.565011	-6.517974	comment	16.0	117.0	1699642848	-11.905608
14715493	What’s Next for Gitlab CI: Auto DevO	What’s Next for Gitlab CI: Auto DevOps	hardwaresofton	8.527545	-6.445898	story	16.0	135.0	1499392978	8.951929
15377175	I've got a much nicer branching mode	I've got a much nicer branching model- try not to have one. Everyone works off master, and you aren't allowed to check in code that won't run in production. Hide unfinished features behind feature flags, and never merge/push a change that won't pass tests/CI.The chaos of huge feature merges (a key source of bugs I've experienced) is minimized. You deploy fixes hourly, not weekly (or later monthly when it just won't seem to pass CI). The time between code being written and a bug being seen can be reduced to minutes and hours, making finding the root cause a breeze.Just my preference, but very open to debate.	mabbo	8.641853	-6.5309668	comment	16.0	91.0	1506853429	2.1573224
23624988	I don't quite understand why people 	I don't quite understand why people don't keep it simple. Use short lived branches, and merge to master. Need to do a release? Master is your release. Tag the release when it's ready. Need to make a hot fix onto the current deployed version? Create a release branch from the tag, and then create a new tag and merge back to master.This combined with semver gets you far. I've yet to find any downsides with this approach.	dastx	8.73532	-6.505714	comment	17.0	92.0	1592982681	-11.87875
13733812	Linus's transition plan seems to inv	Linus's transition plan seems to involve truncating SHA-256 to 160-bits. This is bad for several reasons:- Truncating to 160-bits still has a birthday bound at 80-bits. That would still require a lot more brute force than the 2^63 computations involved to find this collision, but it is much weaker than is generally considered secure- Post-quantum, this means there will only be 80-bits of preimage resistance(Also: if he's going to truncate a hash, he use SHA-512, which will be faster on 64-bit platforms)Do either of these weak security levels impact Git?Preimage resistance does matter if we're worried about attackers reversing commit hashes back into their contents. Linus doesn't seem to care about this one, but I think he should.Collision resistance absolutely matters for the commit signin	bascule	8.675702	-6.523179	comment	17.0	130.0	1488056686	7.172573
30828937	Ask HN: How do you stop forgetting t	Ask HN: How do you stop forgetting to commit or push?	bjourne	8.582641	-6.470961	story	17.0	10.0	1648461677	-11.904395
34487731	Git commands you do need:    git ini	"Git commands you do need:    git init
    git clone

    git add
    git rm

    git commit
    git push
    git pull

    git branch
    git checkout


If you use any others and you are a normal developer, chances are you are overcomplicating things and should rethink your way of using git.But how about logs you may ask. Well, that's what we have tig for:    sudo apt install tig
    cd repo
    tig"	kramerger	8.561711	-6.4992743	comment	17.0	74.0	1674474364	-11.887123
37009879	Lazygit Turns 5: Musings on Git, TUI	Lazygit Turns 5: Musings on Git, TUIs, and open source	jesseduffield	8.582074	-6.443099	story	17.0	211.0	1691221182	-11.833238
24828509	Better Git diff output for Ruby, Pyt	Better Git diff output for Ruby, Python, Elixir, Go	Lammy	8.647575	-6.498198	story	17.0	302.0	1603127782	-11.801519
32847141	Merge soon	Merge soon	yonilevy	8.720009	-6.4692807	story	17.0	133.0	1663217070	9.2018
32176554	Hg Init: A Mercurial Tutorial	Hg Init: A Mercurial Tutorial	captn3m0	8.531758	-6.521224	story	17.0	89.0	1658386558	-11.946901
17103126	Introducing Git protocol version 2	Introducing Git protocol version 2	robmaceachern	8.542109	-6.441351	story	17.0	547.0	1526663627	-11.897253
18229527	Flight rules for Git	Flight rules for Git	spenrose	8.54141	-6.474675	story	17.0	203.0	1539699320	-11.902121
13066455	Git 2.11 has been released	Git 2.11 has been released	stablemap	8.54447	-6.4457464	story	17.0	281.0	1480455383	-11.885156
27770227	Although I'm a heavy Emacs user, I n	Although I'm a heavy Emacs user, I never understood why is magit so praised.IMHO, source control just doesn't belong to IDE. Why learn how to use git with Emacs/magit, vim, IntelliJ IDEA, Eclipse, Visual Studio / Code, ... when you can just master the official command line client and forget about the rest? It's available and usable everywhere, while each of these IDE plugins is different and one need to learn and get used to all of them.	tut-urut-utut	8.623547	-6.501034	comment	17.0	74.0	1625740198	-11.762453
27850385	On the evilness of feature branching	On the evilness of feature branching	sam345	8.695107	-6.5506487	story	17.0	73.0	1626384657	-11.885102
12358189	I freely admit to being an Hg fan, b	I freely admit to being an Hg fan, but that this stuff is accepted as common practice kinda blows my mind.  What's so wrong with keeping an accurate picture of history that people do all kinds of manipulation to their history to keep from the VCS system from accurately reflecting history of development?	rjbwork	8.583619	-6.5455294	comment	17.0	102.0	1472124347	-11.906244
12460136	I can't believe no one has responded	"I can't believe no one has responded yet with ""use a GUI"". After gaining a basic understanding of how branches and merges work, and I do mean basic, I've never been able to screw up a local repo with a GUI client enough that I haven't been able to recover with the same GUI tools.I understand that people need to know how to use their tools, but for git most people can get away with the very basic usage that GUIs provide. If you've made some unrecoverable mistake with an important set of changes, you can always review the history in the same GUI and reimplement the important changes in a new branch."	eyelidlessness	8.577307	-6.493247	comment	17.0	81.0	1473404570	-11.872493
12480697	> The other thing I encountered for 	> The other thing I encountered for the first time at IBM was version control (CVS, unfortunately). Looking back, I find it a bit surprising that not only did I never use version control in any of my classes, but I’d never met any other students who were using version control. My IBM internship was between undergrad and grad school, so I managed to get a B.S. degree without ever using or seeing anyone use version control.I love this bit. This is extremely true even today. Most students at my university, and all of my university's classes, do not use or understand the benefits of a VCS systems. This is crazy on a different level. I hate to say this but it is in fact 2016 and it should not  be a question that git or something should be used on every project no matter how small.	gravypod	8.655223	-6.459073	comment	17.0	100.0	1473695245	-11.823421
35471420	Gource – Animate your Git history	Gource – Animate your Git history	hyperific	8.565785	-6.4620595	story	17.0	213.0	1680801310	-11.90482
23268911	Using `make` and `git diff` for a si	Using `make` and `git diff` for a simple and powerful test harness	chrismorgan	8.634736	-6.503385	story	17.0	239.0	1590125344	-11.814368
24329396	Git Sucks, What Am I Doing Wrong?	Git Sucks, What Am I Doing Wrong?	JacKTrocinskI	8.592159	-6.5196185	story	18.0	19.0	1598861515	-11.887434
30765350	On 2022-04-05, the default branch wi	On 2022-04-05, the default branch will be renamed from “master” to “main”	GvS	8.513415	-6.5310016	story	18.0	33.0	1647953069	-4.3038487
29635885	Whatever test runs during pre-commit	"Whatever test runs during pre-commit must also run during normal CI/CD run. In case of Python: black formatter.It must run during normal CI/CD because pre-commit hooks can be skipped.So now I have two different black calls: in the pre-commit hook and in the CI/CD. And they must be of the same version.Ad infinitum for all other tests.This is the reason I don't use pre-commit framework. It leads to ""double accounting"". I have to sync the pre-commit tests and the CI/CD tests. Or am I missing something? Can the framework run off the venv dir?"	LittlePeter	8.7237625	-6.4995127	comment	18.0	72.0	1640082048	-11.84693
34477976	Git-sim: Visually simulate Git opera	Git-sim: Visually simulate Git operations in your own repos	todsacerdoti	8.55806	-6.465103	story	18.0	447.0	1674399696	-11.911857
34690171	Ask HN: Best way to version control 	Ask HN: Best way to version control your notes or documents?	deafpolygon	8.579592	-6.4399133	story	18.0	19.0	1675758376	-11.875069
39356042	Git tips and tricks	Git tips and tricks	ChrisArchitect	8.552857	-6.484548	story	18.0	506.0	1707816913	-11.893984
39381505	How to commit part of file in Git	How to commit part of file in Git	thunderbong	8.589483	-6.523971	story	18.0	70.0	1707996916	-11.914059
24431216	Magit – A Git Porcelain inside Emacs	Magit – A Git Porcelain inside Emacs	tosh	8.58087	-6.4690514	story	18.0	177.0	1599737217	-11.91765
24751212	Bit – A modernized Git CLI written i	Bit – A modernized Git CLI written in Go	chriswalz	8.583504	-6.491856	story	18.0	274.0	1602474602	-11.875501
31985291	Every time I use Git, I see how bad 	Every time I use Git, I see how bad the UX is and marvel at how it ever became popular.Even a simple merge/rebase leaves one confused.  Which should I use?  What is incoming?  Why does incoming change as you progress?  I didn't change anything (on purpose) but Git won't let me change branches.  What the hell does stashing do?  How do I just unfuck what I did and go back to a branch? These are rather common use cases, and today people still just nuke a directory because they can't figure out the arcane arts.  I am one of those people, at times.  Because it's faster to do so than read heaps of manpages for a situation I may never hit again.Git might have awesome tech underneath, I really don't know or care.  But someone needs to really spend time in a typical dev's shoes to make it nicer to 	silisili	8.533433	-6.4921484	comment	18.0	138.0	1657005271	-11.91243
15952404	What GUI do you recommend?  My exper	What GUI do you recommend?  My experience has been that GUIs are the easiest and fastest way to make a mess that can't be corrected without dropping to CLI or re-cloning.  (I'm looking at you SourceTree). I've long recommended that everyone who uses git know how to use the CLI even if they don't use it regularly.	emeraldd	8.588511	-6.4580555	comment	18.0	82.0	1513612208	-11.858389
16056271	Fix All Conflicts: Easy-To-use CUI f	Fix All Conflicts: Easy-To-use CUI for Fixing Git Conflicts	ingve	8.602849	-6.522737	story	18.0	96.0	1514931089	-11.865759
18620661	There are some warts, but it seems n	"There are some warts, but it seems nice from afar.   The biggest wart is/was the ""FUCK FUCK FUCK"" git clean vs git reset UX error: https://github.com/microsoft/vscode/issues/32405 .  This is a fantastic demonstration of why i exclusively use git from a command prompt -- i know what will happen and nobody's going to reinvent terms to put on buttons that just confuse me.In my life:- I'm committed to emacs for org-mode and LaTeX editing and daily use.- I paid for sublime so i will use it -- and multiple cursors everywhere is a boon for quick and dirty data munging.- I write serious python code in pycharm.- I write serious c# in full blown Visual Studio"	hprotagonist	8.660183	-6.4558005	comment	18.0	101.0	1544120834	9.737522
29784698	Along similar lines, I've adopted a 	"Along similar lines, I've adopted a hyper-frequent commit pattern in git. I do a bunch of meaningless micro-commits as I'm making progress, and then rewrite them all into one or two meanginful commits once I've reached a working state of whatever I was trying to do.I find it's helpful for not losing work / easily backing up if as I'm going along I realize I want to change approach.(For the micro commit I have a git command ""git cam"" that just commits all changes with the message ""nt"". Then once I'm ready to do a ""real commit"", I have ""git wip"" which rolls back all the nt commits but leaves them in checkout; then I can make one or two ""real"" commits.)I wonder if dura would be even better, or if the commit frequency would end up being too fine-grained and obscure?"	dilap	8.572567	-6.5436244	comment	18.0	85.0	1641236114	-11.939263
29991417	Pijul 1.0 Beta	Pijul 1.0 Beta	Reventlov	8.614873	-6.549915	story	18.0	347.0	1642582986	13.883775
12622746	Git is, like many professional tools	"Git is, like many professional tools, something you simply got to learn.But like with many professinal tools, you don't need to know everything to get to work.I don't know all Photoshop or Ableton Live features, but I can improve my photos or create songs non the less.With these commands you can already start your own repo and work on it locally:    git init // crate new repo

    git status // show which files are changed and which of them are staged

    git add -p // add ""chunks"" of changed files to the stage

    git commit -m ""<commit_msg>"" // commit everything added to the stage with a commit message

    git log // show a list of commits

    git checkout <file> // throw away all changes since the last commit (one file)

    git reset --hard // throw away all changes since the last "	k__	8.555977	-6.4970155	comment	18.0	154.0	1475421649	-11.887846
13491879	What a good commit message looks lik	What a good commit message looks like (2011)	ziodave	8.589402	-6.5329676	story	18.0	96.0	1485442972	-11.909603
22519632	My favourite Git commit (2019)	My favourite Git commit (2019)	neo2006	8.566383	-6.490793	story	18.0	229.0	1583692112	-11.912047
26961044	What’s wrong with Git? A conceptual 	What’s wrong with Git? A conceptual design analysis (2016)	edward	8.539796	-6.486489	story	18.0	142.0	1619555085	-11.889241
37622064	Fossil versus Git	Fossil versus Git	susam	8.496169	-6.5605807	story	18.0	97.0	1695465928	-11.962871
14966545	Git: Using Advanced Rebase Features 	Git: Using Advanced Rebase Features for a Clean Repository	mtyurt	8.574538	-6.5633135	story	18.0	114.0	1502266740	9.372613
23739633	> commit messages to me are almost a	"> commit messages to me are almost as important as the code change itselfThis is high on my list of code craftsmanship points.  It's very difficult to explain to young programmers who have never worked on an old code base how valuable this is when done well.  In fact, often you hear complaints about how a code base ""is crap"", but more often than not I'd wager this is just a result of the context at the time not being known or appreciated.  Frankly, all code we write is heavily governed by context we take for granted at the time, but is in precious short supply 1, 5, 10 years later.  If you come back with a different use case later, the original code may very well be unsuited for that purpose.  We can argue all day about good judgement and YAGNI, but at the end of the day no one can see all"	dasil003	8.587168	-6.5317383	comment	19.0	179.0	1593964748	-11.915454
20746077	It's very sad to see bitbucket dropp	"It's very sad to see bitbucket dropping mercurial support. Now only Facebook and volunteers are keeping mercurial alive. 
Sometimes technically better architecture and user interface lose to a non user friendly hard solutions due to inertia of mass adoption.So a lesson in Software development is similar to betamax and VHS, so marketing is still a winner over technically superior architecture and ease of use. GitHub successfully marketed git, so git and GitHub are synonymous for most developers. Now majority of open source projects are reliant on a single proprietary solution Github by Microsoft, for managing code and project. Can understand the difficulty of bitbucket, when Python language itself moved out of mercurial due to the same inertia.Hopefully gitlab can come out with mercurial su"	dragonsh	8.491594	-6.528759	comment	19.0	161.0	1566303773	-11.957327
13998670	Reinventing the Git Interface (2014)	Reinventing the Git Interface (2014)	macmac	8.55094	-6.467287	story	19.0	86.0	1490906413	-11.876393
34557827	Merging with diff3: the “three-way m	Merging with diff3: the “three-way merge”	fortran77	8.704968	-6.5070252	story	19.0	127.0	1674916604	9.202913
32370234	Git In Two Minutes (updated after 8 	Git In Two Minutes (updated after 8 years)	garyrob	8.521725	-6.46018	story	19.0	351.0	1659808995	-11.88251
19070172	Pijul for Git users	Pijul for Git users	Volundr	8.600002	-6.5381417	story	19.0	105.0	1549208705	13.889311
17632762	Common Git Problems and How to Fix T	Common Git Problems and How to Fix Them	mzehrer	8.539292	-6.4674954	story	19.0	228.0	1532778832	-11.89278
21710368	Question for people who use these CL	Question for people who use these CLIs to start projects: Since there's so much prebaked functionality in the generated code, do you get distracted by it, when working on it?The CLI probably enables a few dozen features, of which you might use a handful of. So there's all these files and configuration code in your project that is never touched/used. I imagine it's a lot of white noise.Whenever I start new projects, I cleanroom start with an empty git repo. Every line, in every file, has a purpose. (With time, there is some slippage. A feature could get removed, and some code doesn't get eliminated that should, for example). But all in all, the vast majority of the code there serves a purpose.Little to no mental energy is spent worrying about side effects or filtering through code that's no	JMTQp8lwXL	8.62021	-6.5179353	comment	19.0	96.0	1575527147	-11.849509
18096511	Test && commit || revert	Test && commit || revert	grzm	8.626173	-6.5485783	story	19.0	96.0	1538164498	-11.919664
12785200	What’s wrong with Git? A conceptual 	What’s wrong with Git? A conceptual design analysis	colinprince	8.542907	-6.487059	story	19.0	92.0	1477368140	-11.901577
27727975	I kind of feel that this kind of git	I kind of feel that this kind of git advice is way beyond the point of diminishing returns. As a conscientious developer we have a lot of work. We write code of good quality. We refactor that code regularly. We write automated tests. We test the program manually. We use linters and type checkers. We talk to people to find out whether what they requested is actually what they need. But the day only has 24 hours. At some point one has to say that enough is enough. I really want to put the 'enough is enough' point before worrying about a good looking commit history. Some years ago we all went from svn to git and I am not really sure the improvement was worth it. Sure, git is objectively the better version control system. One can do a lot more things in git. But then the disadvantage is that o	cjfd	8.560111	-6.4930425	comment	19.0	99.0	1625384869	-11.895861
28549652	Version control without Git	Version control without Git	quickthrower2	8.603916	-6.442681	story	19.0	150.0	1631784462	-11.838659
22304416	Hiya HN. I was ranting on Mastodon e	"Hiya HN. I was ranting on Mastodon earlier today because I feel like people learn git the wrong way - from the outside in, instead of the inside out. I reasoned that git internals are pretty simple and easy to understand, and that the supposedly obtuse interface makes a lot more sense when you approach it with an understanding of the fundamentals in hand. I said that the internals were so simple that you could implement a workable version of git using only shell scripts inside of an afternoon. So I wrapped up what I was working on and set out to prove it.Five hours later, it had turned into less of a simple explanation of ""look how simple these primitives are, we can create them with only a dozen lines of shell scripting!"" and more into ""oh fuck, I didn't realize that the git index is a bi"	ddevault	8.556586	-6.5024505	comment	19.0	172.0	1581466353	-11.9035425
33705026	I want the 'merge' function complete	I want the 'merge' function completely deprecated. I simply don't trust it anymore.If there are no conflicts, you might as well rebase or cherry-pick. If there is any kind of conflict, you are making code changes in the merge commit itself to resolve it. Developer end up fixing additional issues in the merge commit instead of actual commits.If you use merge to sync two branches continously, you completely lose track of what changes were done on the branch and which where done on the mainline.	larschdk	8.645295	-6.52839	comment	19.0	170.0	1669120180	-11.900959
13742409	SHA1 collisions make Git vulnerable 	SHA1 collisions make Git vulnerable to attacks	wyldfire	8.671505	-6.517838	story	20.0	171.0	1488178706	7.1800504
34412793	“After 20 years coding I just realis	“After 20 years coding I just realised, commit messages are pointless”	wut42	8.578592	-6.539454	story	20.0	27.0	1673965951	-11.911425
34487201	Git commands you probably do not nee	Git commands you probably do not need	ingve	8.56617	-6.483612	story	20.0	190.0	1674469165	-11.87219
39588785	What comes after GIT?Nothing. I just	What comes after GIT?Nothing. I just don't see it, text based software development is at its best currently. Only thing nowadays is AI that helps you to figure out or speed up creating code in text. AI models are all about text based languages, all the low code or image based programming is not good base for AI models - generating images is obviously not going to generate block diagrams for working software as good as text generation.So text manipulation is going to stay, we might have additional tools like AI to quicker create/process text and GIT is already best model for keeping history of textual changes and yes we want that history, because we still need to be in control of complex systems that are described by textual representation in whatever language is used.People who find readin	ozim	8.567982	-6.495666	comment	20.0	127.0	1709547243	-11.894993
36565842	Disabled at 22 million commits	Disabled at 22 million commits	volongoto	8.568318	-6.481783	story	20.0	120.0	1688332548	-11.848751
36782018	Lazygit: Simple terminal UI for Git 	Lazygit: Simple terminal UI for Git commands	thunderbong	8.5802555	-6.483893	story	20.0	239.0	1689739628	-11.842636
37086022	"I have this ""one weird trick"" that I"	"I have this ""one weird trick"" that I think is great, but somehow no-one else wants to use:At one point I worked with a fellow dev where we did PR reviews just as commits on top of the branch. So you'd check out their feature branch, run the equivalent of 'compare working tree with <main>' for your editor and then look through the changes.Because you're comparing the working tree you can leave comments... by typing source code comments (we used '// RVW(jauco)' to mark them). You can fix typo's just by, well, fixing the typo and you share the review by pushing to the branch.I found it to have the following advantages- PR comments usually break when you rebase or merge (because they reference a line number). These obviously won't, at worst there will be a merge conflict that you handle the ob"	jauco	8.602869	-6.4869537	comment	20.0	128.0	1691738497	-11.88029
37415677	A successful Git branching model (20	A successful Git branching model (2010)	saaspirant	8.611936	-6.484606	story	20.0	70.0	1694070770	-11.883193
34790721	AI Commits – a CLI that writes your 	AI Commits – a CLI that writes your commit messages for you	feross	8.587525	-6.5378203	story	20.0	60.0	1676388726	-11.900707
19877811	Git rebase in depth	Git rebase in depth	ddevault	8.571117	-6.562708	story	20.0	633.0	1557497202	9.365416
18512854	Gitless: A simple version control sy	Gitless: A simple version control system built on top of Git	jackbravo	8.609652	-6.450413	story	20.0	181.0	1542924236	-11.843126
12304758	This workflow is scary. A rebase sho	This workflow is scary. A rebase should not be part of any everyday workflow and must be reserved _only_ for exceptional situations.Rebasing can cause the loss of history and developers should be as careful with it as system admins are with `sudo`. I can't recommend any workflow that includes it without treating is as a terrifying and scary thing. How easy is it to accidentally remove a line during interactive rebase and lose all work associated with it?This is why my team and I moved to squash merging. Sure it has it's own drawbacks, but they're far less worrisome than rebasing. If you screw up a rebase, the history is re-written or force-pushed by accident. If you screw up a squash merge, you can still check out the intermediate commits if you know the hash.We won a Ruby award for our wo	nhance	8.578673	-6.566467	comment	20.0	84.0	1471442791	-11.918829
26615938	Terminal escape sequences in Git com	Terminal escape sequences in Git commit email field	whack	8.580516	-6.4801726	story	20.0	322.0	1616974634	-11.900728
27305521	Stacked Git – manage commits as a st	Stacked Git – manage commits as a stack of patches	goranmoomin	8.576141	-6.4905114	story	20.0	146.0	1622135871	-11.898898
38498688	GQL – Git Query Language	GQL – Git Query Language	amrdeveloper	8.584831	-6.4898677	story	20.0	240.0	1701526008	-11.879625
23768096	Do people actually read commit messa	"Do people actually read commit messages? I don't have much experience working on large projects with a larger team, but I keep repositories both for personal things and work so I can look at older versions. I have however never actually looked at my own commit messages, even though I try to keep them informative. I instead search through commits based on strings added/removed or file paths touched.
As such, multiline commit messages (whether added on the command line or via the editor) seem doubly pointless to me.I would be curious to hear how others view this."	seventh-chord	8.583645	-6.5238643	comment	21.0	77.0	1594198010	-11.911529
13733481	Linus on Git and SHA-1	Linus on Git and SHA-1	dankohn1	8.658373	-6.4766088	story	21.0	550.0	1488052523	7.1190577
14385813	Git Town – A high-level command line	Git Town – A high-level command line interface for Git	tnorthcutt	8.571255	-6.4773097	story	21.0	159.0	1495343922	-11.862587
14585129	Git commit message styleguide	Git commit message styleguide	sheldor	8.583546	-6.5324316	story	21.0	44.0	1497856892	-11.906934
34458516	I'd love to hear from someone who's 	I'd love to hear from someone who's still using SVN professionally and can explain why they prefers it to Git.I used SVN very early in my career. I think the only good thing I can say about it is that it's easier to learn. It's quite easy to teach a junior dev how to use SVN. Git takes much longer to master.	kypro	8.573124	-6.483376	comment	21.0	90.0	1674243240	-11.891228
36707239	GitHub merge queue is generally avai	GitHub merge queue is generally available	ingve	8.622186	-6.494185	story	21.0	192.0	1689245233	9.075368
24592568	Pijul: A intuitive VCS unlike Git th	Pijul: A intuitive VCS unlike Git that's based on sound theory of patches	goranmoomin	8.567371	-6.4784017	story	21.0	269.0	1601057664	-11.864072
25032956	Pijul: Towards 1.0	Pijul: Towards 1.0	lelf	8.608608	-6.5495424	story	21.0	165.0	1604913854	13.888206
25123014	The underlying technology of git is 	"The underlying technology of git is great, but the UX is terrible. The commands are all named wrong. ""To create a branch, use git branch, but that doesn't check it out. If you want to create it and check it out at the same time use ""git checkout -b"", not ""git branch --checkout"" which would be 1000x more logical (and then there could be an option to make that the default behaviour)Resisting GUI's is not a good idea. The trick to learning is to always have `gitk --all` or a similar viewer open in another window.Also instead of `git add` / `git commmit`, use `git gui`, but for most other things stick to the CLI.Having said that use a GUI, github desktop is terrible. It tries to make things easier and as a result takes you away from git's standard terminology, so it's impossible to understand "	rjmunro	8.56539	-6.493578	comment	21.0	214.0	1605616527	-11.906791
19906972	Oh shit, git (2016)	Oh shit, git (2016)	IvarsIndriks	8.547794	-6.456401	story	21.0	412.0	1557811397	-11.929694
39084135	Trunk-Based Development	Trunk-Based Development	DLion	8.641062	-6.5465074	story	21.0	90.0	1705879642	3.217653
29911308	Using Git commit message templates t	Using Git commit message templates to write better commit messages	ingve	8.588888	-6.5269265	story	21.0	184.0	1642013923	-11.901924
27580234	"Damn, this is such a GREAT idea.
I'v"	"Damn, this is such a GREAT idea.
I've messed up repos a few times, and it's never good.
It's always -- ""what's the magic want I have to wave now""?The truth is, while we use git every day, most people really don't understand how it works.There I said it. And I'm not ashamed.I don't really know how Git works. And I think I'm not the only one.What does ""git reflog"" or ""git reset --hard ...."" do? What are the implications?We don't really know.I feel stupid. But hey, at least I'm honest."	eric4smith	8.554736	-6.5075297	comment	21.0	295.0	1624289994	-11.906219
23043881	Git Branch Naming Conventions	Git Branch Naming Conventions	sanketsaurav	8.532666	-6.521373	story	21.0	84.0	1588351290	9.023064
33740619	Ask HN: Where are the simple Git GUI	Ask HN: Where are the simple Git GUIs?	gcau	8.599271	-6.4940643	story	21.0	10.0	1669367410	-11.741715
38369433	I kind of killed Mercurial at Mozill	I kind of killed Mercurial at Mozilla	sylvestre	8.498531	-6.5604887	story	21.0	285.0	1700597761	-11.974635
23479465	How to write good Git commit message	How to write good Git commit messages	ashitlerferad	8.581618	-6.5238504	story	22.0	47.0	1591808866	-11.894613
23618102	"I often think of this as ""it's hard "	"I often think of this as ""it's hard to tell people the solution to a problem they don't have"", or don't know they have.I think it's one of the major problems in the entire structure of the educational system... it's all telling people solutions to problems they don't have yet. Sometimes this is just unavoidable; I'm not sure how to turn geography into a problem you have. (I mean, you can fake it, but people's brains know when it's a fake problem.) But a lot of times in math and science I think we'd be much better off leading off with the problems, and giving the students time to grapple with the problems without the answers, because then the answers would stick.I've mentioned on HN before the git training curriculum I have made for my workplace... it's an interactive tutorial, and rather t"	jerf	8.532461	-6.4992943	comment	22.0	128.0	1592936770	-11.907999
26282213	Bit (1.0) – a modern Git CLI in Go	Bit (1.0) – a modern Git CLI in Go	chriswalz	8.574168	-6.488385	story	22.0	191.0	1614394813	-11.849241
30311713	Git in one image	Git in one image	guptarohit	8.540472	-6.472203	story	22.0	173.0	1644662853	-11.858623
33947087	GPT based tool that writes the commi	GPT based tool that writes the commit message for you	guytv	8.5584	-6.492293	story	22.0	153.0	1670790281	-11.856143
26703808	Git as a NoSql Database (2016)	Git as a NoSql Database (2016)	EntICOnc	8.5527935	-6.442165	story	22.0	143.0	1617652512	-11.882743
26997833	I will always fight tooth and nail a	"I will always fight tooth and nail against squash merge.Squash merge has the major disadvantage of getting rid of valuable meaningful git history.Squash merge is not the proper solution for keeping your git history clean, it is a hack using the side effect of squash.Keeping your git history clean is a matter of policy, best-practices and education:Developers should be required to submit _clean_ PRs, that is, PR's whose git history has been organized and refactored in such a way that it removed ""clean up commits"", ""typo fix"", etc.When you squash merge a feature branch that has thousands of lines of code, and 6 months later you have a bug introduced by this feature branch, it becomes extremely hard to find which line introduced the bug.On the other hand, if you kept the history, and if this "	gouggoug	8.575105	-6.5634403	comment	22.0	172.0	1619809455	-11.9401
14948749	Does anyone here have suggestions fo	"Does anyone here have suggestions for git GUI? I used SourceTree for a few years, but a while back they started adding a bunch of tracking scripts, which I'm uncomfortable with. I can generally get by fine with the CLI, but whenever I need to do anything even slightly unfamiliar, I like being able to put on training wheels and have a GUI guide the way.I think git would benefit from a type of ""training wheels"" config, where no action is destructive or irreversible. I've had a few close calls where I almost lost some code due to a git screw-up. Luckily, my local Time Machine backups have always saved my ass."	TheAceOfHearts	8.55486	-6.474051	comment	22.0	77.0	1502123299	-11.87385
14987853	Critical security updates for Git, S	Critical security updates for Git, Subversion and Mercurial	mnw21cam	8.574659	-6.455884	story	22.0	366.0	1502442501	-11.871722
20004224	More Productive Git	More Productive Git	tosh	8.565925	-6.482754	story	23.0	205.0	1558723658	-11.902731
14409269	Little Things I Like to Do with Git	Little Things I Like to Do with Git	csswizardry	8.545355	-6.4609513	story	23.0	656.0	1495626600	-11.893211
25458230	Commits are shapshots, not diffs	Commits are shapshots, not diffs	todsacerdoti	8.620812	-6.515978	story	23.0	136.0	1608228143	10.257061
37094599	Pijul: Version-Control Post-Git [vid	Pijul: Version-Control Post-Git [video]	todsacerdoti	8.600817	-6.4980283	story	23.0	201.0	1691791325	-11.823168
24504490	I don't understand the appeal of usi	I don't understand the appeal of using a cli to manage commits, branches, remotes, merges with conflicts, and so on. To me all these things are so much better internalized and understood when presented visually. Git GUIs are aplenty (Sublime Merge being my latest discovery, SourceTree before that) and generally really good. Combined with the already amazing GitHub web GUI, it's a wonder what use case is better served by sticking to the cli, other than this misplaced notion that it's what the cool kids are doing.	shaky	8.583959	-6.492206	comment	23.0	109.0	1600350148	-11.856902
25043731	This is how I git	This is how I git	ingve	8.542983	-6.4673247	story	23.0	232.0	1604995709	-11.899757
38830194	Git Things	Git Things	nalgeon	8.544797	-6.4534802	story	23.0	196.0	1704093019	-11.887633
19386141	Write yourself a Git (2018)	Write yourself a Git (2018)	adamnemecek	8.536068	-6.450564	story	23.0	684.0	1552531845	-11.915358
27736980	Git vs. Fossil: what you should have	Git vs. Fossil: what you should have done vs. what you did	hasheddan	8.492836	-6.5583944	story	23.0	75.0	1625485908	-11.971767
12357837	Git Undo	Git Undo	dominicrodger	8.565826	-6.5241184	story	23.0	288.0	1472117904	-11.876308
28575524	Git Commands Explained with Cats (20	Git Commands Explained with Cats (2017)	tosh	8.571447	-6.483636	story	23.0	266.0	1631966489	-11.885154
22793512	My unorthodox, branchless Git workfl	My unorthodox, branchless Git workflow	corenting_	8.545197	-6.520037	story	23.0	54.0	1586179778	-11.933963
37810366	Things I just don't like about Git	Things I just don't like about Git	todsacerdoti	8.5453005	-6.47337	story	23.0	56.0	1696772470	-11.891009
24173238	Oh Shit, Git?	Oh Shit, Git?	auraham	8.568734	-6.4954386	story	24.0	302.0	1597533110	-11.904069
36371012	I'm teaching Git in University.For a	I'm teaching Git in University.For all those who think that Git is easy, it's not.It takes a student about 20-30 hours to really understand all usual Git commands. I'm not talking about something bizarre like ls-remote, but really understand merge, rebase, bisect. Not just syntax, but all the consequences. For instance, why rebasing something already pushed to public often leads to false merge conflicts, how does stash really work, etc.	adontz	8.556929	-6.512777	comment	24.0	195.0	1687015400	-11.890216
28838573	Magpie Driven Development (MDD)	Magpie Driven Development (MDD)	DeathArrow	8.714727	-6.4379334	story	24.0	53.0	1634039135	-11.627966
28888763	Git Command Explorer	Git Command Explorer	MakisH	8.569361	-6.4815283	story	24.0	289.0	1634399982	-11.855661
24532071	New GitHub repos to have default bra	New GitHub repos to have default branches named “main” instead of “master”	davecyen	8.511277	-6.53057	story	24.0	63.0	1600579509	-11.7500105
24654306	The default branch for newly-created	The default branch for newly-created repositories is now main	robbiet480	8.505404	-6.5352125	story	24.0	39.0	1601576170	-11.773291
32161247	Things I wish everyone knew about Gi	Things I wish everyone knew about Git (Part II)	emmelaich	8.540902	-6.4828677	story	24.0	268.0	1658289421	-11.890004
16677308	Git log – The good parts	Git log – The good parts	okket	8.566609	-6.4630404	story	24.0	338.0	1522050216	-11.878885
27858013	Launch HN: MergeQueue (YC S21) – Aut	Launch HN: MergeQueue (YC S21) – Automate rebasing and merging for your codebase	spriha	8.625648	-6.533904	story	24.0	122.0	1626453152	-11.89427
28510212	Ship / Show / Ask: A modern branchin	Ship / Show / Ask: A modern branching strategy	NicoJuicy	8.687265	-6.5490694	story	24.0	158.0	1631533262	-11.853745
26742012	I think it's a tragedy that just abo	I think it's a tragedy that just about every developer uses git but most learn add, commit, branch, and merge and then just stop learning.A lot of people are scared of rebase and cherrypick and shut down or get defensive when you mention them or try to encourage their use.The result is, because developers only have a hammer, they brute force merge everything which results in grotesque conflict resolutions and commit histories and makes it hard to untangle problems.At a previous job, another developer was kind enough to walk through rebasing on the command line with vim. I was receptive and in about 10 minutes, I realized there was a significant set of standard features and day to day Git use I was previously just oblivious to.These days, the UI for rebasing and cherry picking in Gitkraken 	gpspake	8.573469	-6.541762	comment	24.0	136.0	1617906056	-11.910668
37694701	Ask HN: How do your ML teams version	Ask HN: How do your ML teams version datasets and models?	skadamat	8.5780735	-6.450086	story	24.0	69.0	1695930079	-11.827113
15078368	Using Git Wrong	Using Git Wrong	aarohmankad	8.557754	-6.476615	story	24.0	49.0	1503459938	-11.881789
23528134	GitHub renaming default branch to “m	GitHub renaming default branch to “main”	Udik	8.502959	-6.534476	story	25.0	39.0	1592234056	-11.767985
31406550	Ask HN: Why hasn't Git been adopted 	Ask HN: Why hasn't Git been adopted outside of software engineering?	p-e-w	8.545752	-6.4765334	story	25.0	38.0	1652767369	-11.892432
34457130	GitHub Sunsetting Subversion Support	GitHub Sunsetting Subversion Support	mikece	8.573916	-6.4489226	story	25.0	319.0	1674238074	-11.883681
34959565	Show HN: Gitgpt – Natural Language G	Show HN: Gitgpt – Natural Language Git	OddMerlin	8.571427	-6.494732	story	25.0	108.0	1677520250	-11.870036
37434295	Did you know Git was originally crea	Did you know Git was originally created in 10 days?	rlnorthcutt	8.552136	-6.473774	story	25.0	75.0	1694184881	-11.890589
38942892	Conditional Git Configuration	Conditional Git Configuration	djha-skin	8.557839	-6.4671826	story	25.0	286.0	1704919775	-11.860482
21125669	Conventional Commits: A specificatio	Conventional Commits: A specification for structured commit messages	BenjaminCoe	8.588652	-6.534433	story	25.0	157.0	1569940145	-11.895981
27727501	Commit often, perfect later, publish	Commit often, perfect later, publish once: Git best practices (2013)	hidden-spyder	8.580796	-6.516134	story	25.0	261.0	1625377540	-11.889436
28271288	Conditionally setting your gitconfig	Conditionally setting your gitconfig	zdw	8.56493	-6.462785	story	25.0	236.0	1629680668	-11.85945
33140512	Git making me want to pull my hair o	Git making me want to pull my hair out yet again	vanilla-almond	8.541361	-6.4747696	story	25.0	32.0	1665319833	-11.873102
26997458	Two Years of Squash Merge (2019)	Two Years of Squash Merge (2019)	m_a_g	8.57632	-6.5726137	story	25.0	79.0	1619807670	-11.950207
37955617	Versioning data in Postgres? Testing	Versioning data in Postgres? Testing a Git like approach	h1fra	8.658014	-6.471557	story	25.0	178.0	1697808140	9.797347
38393429	I cannot be the only one that gets a	"I cannot be the only one that gets away with only knowing:  git pull
  git merge x
  git checkout [-b] foo
  git commit
  git push"	adaboese	8.577665	-6.536131	comment	25.0	94.0	1700751646	-11.910244
38466232	I don't know why so many devs avoid 	I don't know why so many devs avoid a GUI for Git	keybits	8.559682	-6.47842	story	25.0	24.0	1701297216	-11.869019
15263575	Don't use Git rebase	Don't use Git rebase	aslakhellesoy	8.572905	-6.558865	story	25.0	137.0	1505550182	9.387435
13668952	Fossil SCM	Fossil SCM	Tomte	8.538881	-6.5435266	story	26.0	139.0	1487346235	9.614934
13889155	How to Write a Git Commit Message (2	How to Write a Git Commit Message (2014)	deyton	8.5840845	-6.5389667	story	26.0	341.0	1489698198	-11.899572
14045787	Better Git configuration	Better Git configuration	scottnonnenberg	8.548503	-6.48462	story	26.0	388.0	1491427703	-11.880289
34439461	Show HN: A version control system ba	Show HN: A version control system based on rsync	zdgeier	8.67504	-6.4382653	story	26.0	249.0	1674130067	-11.815063
31985593	Am I the only one who thinks that Gi	Am I the only one who thinks that Git's UX is fine, and maybe even rather enjoyable? It has taken time to learn, and I am by no means a power user, but its model is now in my brain so, for better or worse, it's how I think and work now too (interactive rebasing for the win, all the time, and lots of shell aliases to shorten things). I do wish I had an easier way to split up a commit that accidentally included several unrelated changes though.What's the lesson, that you can learn anything eventually, or that familiarity means you will lose the ability to accurately evaluate something?	pdmccormick	8.562034	-6.5389977	comment	26.0	117.0	1657008036	-11.9093075
21189256	99% of the Git commands you'll need 	99% of the Git commands you'll need at work, demonstrated in a single script	carodgers	8.561593	-6.479107	story	26.0	659.0	1570514879	-11.864623
39135304	Git commit messages are useless	Git commit messages are useless	joshmarinacci	8.584647	-6.52505	story	26.0	35.0	1706216848	-11.896368
39232456	jj init – getting serious about repl	jj init – getting serious about replacing Git with Jujutsu	chriskrycho	8.548225	-6.471973	story	26.0	142.0	1706899225	-11.900495
29998227	A Better Git Flow	A Better Git Flow	dnilasor	8.564243	-6.486653	story	26.0	95.0	1642618249	-11.919157
13228490	A Git catastrophe cleaned up	A Git catastrophe cleaned up	asymmetric	8.556962	-6.466201	story	26.0	274.0	1482322218	-11.88379
23473387	Easily rename your Git default branc	Easily rename your Git default branch from master to main	GiorgioG	8.517578	-6.531789	story	27.0	65.0	1591757305	-11.824258
23519813	GitHub wil change default branch nam	GitHub wil change default branch name from 'master' to 'main'	drummer	8.510789	-6.5268774	story	27.0	47.0	1592157981	-11.7136755
23767866	Git commit accepts several message f	Git commit accepts several message flags (-m) to allow multiline commits	stefanjudis	8.621624	-6.4947944	story	27.0	339.0	1594195123	-11.881692
36571253	I prefer trunk-based development	I prefer trunk-based development	fagnerbrack	8.6216545	-6.5342774	story	27.0	84.0	1688382107	3.2425647
32122028	Git log is not a changelog	Git log is not a changelog	agateau	8.571251	-6.4931912	story	27.0	124.0	1658005924	-11.89323
13514289	Trunk-Based Development	Trunk-Based Development	solarengineer	8.615551	-6.5255933	story	27.0	199.0	1485700732	3.1232386
37799082	Why Git Is Hard	Why Git Is Hard	signa11	8.54473	-6.4806566	story	27.0	50.0	1696654099	-11.892088
14285040	Plan Your Commits	Plan Your Commits	ingve	8.588333	-6.4977536	story	28.0	85.0	1494158819	-11.874423
36178720	Git is simply too hard	Git is simply too hard	thunderbong	8.54984	-6.468867	story	28.0	50.0	1685813965	-11.892216
39357068	A Git client for simultaneous branch	A Git client for simultaneous branches on top of your existing workflow	sandgiant	8.57937	-6.5070634	story	28.0	211.0	1707828090	-11.897032
37038457	A beginner's guide to Git version co	A beginner's guide to Git version control	freedude	8.6006775	-6.4570756	story	28.0	277.0	1691432493	-11.861265
13260527	Things I hate about Git (2012)	Things I hate about Git (2012)	rbanffy	8.549258	-6.47168	story	28.0	68.0	1482798542	-11.889475
28025801	A lot of comments along the lines of	A lot of comments along the lines of ‘why do people use <ide> instead of learning the commands’.For me, I used to use the terminal git, and I still do occasionally. But I use Sourcetree now for most things because I make less mistakes seeing the tree visually all the time.My job isn’t to use git, it’s to write specialist software. If I get the software written and the customer is happy, it doesn’t matter whether I use <ide> or not. Imagine having 100 complex things bouncing around your head and having to make that 101 when you forget the order of arguments to merge.The guy who knows every command of git backwards is welcome to apply for a job managing a git repo or something if such a thing exists? But I could harp on the same way about his missing MATLAB or firmware skills.	aetherspawn	8.586882	-6.4809837	comment	28.0	296.0	1627821045	-11.81922
22303710	Shit – An implementation of Git usin	Shit – An implementation of Git using POSIX shell	kick	8.574567	-6.471192	story	28.0	814.0	1581460548	-11.846292
22437078	Ask HN: Why should my company use so	Ask HN: Why should my company use source control?	SamuelAdams	8.588826	-6.458475	story	28.0	18.0	1582833076	-11.822313
33107741	Take Advantage of Git Rebase	Take Advantage of Git Rebase	HieronymusBosch	8.567971	-6.566422	story	28.0	113.0	1665061668	9.39513
13719368	Linus' reply on Git and SHA-1 collis	Linus' reply on Git and SHA-1 collision	sampo	8.6686945	-6.4967394	story	29.0	704.0	1487895288	7.187353
25121558	I don't agree at all. Git is the sim	I don't agree at all. Git is the simplest version control system I've ever used. The concept of merging, rebasing, cherry-picking, and resetting works so naturally that I'm basically going to expect this level of ease of use from any VCS I use going forward.That being said, I know there are some who have trouble with Git. But IMO it isn't because Git is hard, but because they don't have to truly understand Git to use it. That's how easy it is.	dimgl	8.5616	-6.4762716	comment	29.0	284.0	1605604223	-11.883571
18999520	It’s Time to Move on from Two Phase 	It’s Time to Move on from Two Phase Commit	evanweaver	8.691787	-6.5344486	story	29.0	397.0	1548433869	-11.871472
19704486	Commit messages guide	Commit messages guide	walterbell	8.585075	-6.5332	story	29.0	385.0	1555727512	-11.911097
30522175	Another advantage to plain text file	Another advantage to plain text files: source control. You can check your writing into git and get a history of all your edits.It’s something programmers take for granted, but it would be amazing if this got more widely adopted outside of tech. The number of files with names like “Report Final Final draft v3.docx” is truly staggering.“Git for everything“ would be a multi-billion dollar startup easily.	imgabe	8.696299	-6.4479213	comment	29.0	170.0	1646182188	-11.584366
33766396	Git Notes	Git Notes	thcipriani	8.552306	-6.4481673	story	29.0	629.0	1669580279	-11.888144
38110286	Tracking SQLite Database Changes in 	Tracking SQLite Database Changes in Git	vldr	8.60488	-6.4889045	story	29.0	347.0	1698912102	9.884843
27963868	Git-blame-someone-else	Git-blame-someone-else	swyx	8.558396	-6.480259	story	30.0	230.0	1627326495	-11.90185
25535844	What comes after Git?	What comes after Git?	mariuz	8.544273	-6.452383	story	30.0	70.0	1608895492	-11.882198
36120972	I gave commit rights to someone I di	I gave commit rights to someone I didn't know (2016)	love2read	8.618908	-6.485634	story	30.0	382.0	1685418941	-11.890386
36830813	Why SQLite does not use Git (2018)	Why SQLite does not use Git (2018)	1vuio0pswjnm7	8.617533	-6.499057	story	30.0	314.0	1690067040	9.876554
24759265	Git is not a success story, but a fa	Git is not a success story, but a failure as a system with a bad user experience	ardit33	8.549135	-6.4643025	story	30.0	47.0	1602535620	-11.84536
