id	label	hovertext	author	x	y	type	relevance	size	year	umap1d
37755290	Can someone with familiarity with Ba	Can someone with familiarity with Bazel give any clues how to build? `bazel build` does something, but I end up with `bazel-build` and `bazel-build` with no obvious build artefacts.	afandian	8.808039	9.169181	comment	3.0	13.0	1696355739	13.673976
15017539	GTK drops Autotools in favor of Meso	GTK drops Autotools in favor of Meson	tpush	9.198092	9.040774	story	3.0	11.0	1502800214	13.495549
27792004	I think I had the best experience wi	"I think I had the best experience with Meson/Ninja so far. I am also interested in using Nix for building. As for Cargo, I did not like how it recompiled all dependencies when I changed a warning flag on my project. I also found it unusable because it provided no way to check for the hash or signature of the dependencies that it downloads.I don't think that I have ever been able to successfully compile a project that uses CMake. Its code is horrifying too, for example cmake-3.21.0-rc3/Modules/CheckFunctionExists.c contains  #ifdef CHECK_FUNCTION_EXISTS
  
  #  ifdef __cplusplus
  extern ""C""
  #  endif
    char
    CHECK_FUNCTION_EXISTS(void);
  #  ifdef __CLASSIC_C__
  int main()
  {
    int ac;
    char* av[];
  #  else
  int main(int ac, char* av[])
  {
  #  endif
    CHECK_FUNCTION_EXIS"	h_anna_h	9.198197	9.038859	comment	3.0	18.0	1625905839	13.517872
35286540	Question for an insider. Bazel code 	Question for an insider. Bazel code coverage seems to be one of the roughest edges. At least when running C++ tests.Only lcov is supported, and due to the sandboxing it's impossible to get other tools working since they always spit out extra instrumentation data that's neither cached nor available on the next sandbox.Does blaze support code coverage properly? Does Google just not care about code coverage? Am I just missing some obvious thing in the documentation?	carlmr	8.809788	9.168803	comment	3.0	12.0	1679647200	13.674902
35291640	Not just that it doesn't integrate w	Not just that it doesn't integrate well with external tools. Cmake works better here.We had a googler at our company switch everything to bazel and it just slowed everyone down.There really is something about Google engineers, this sort of subtle arrogance that the Google way is superior to everything else is existence. Maybe I'm the ass hole but I wonder if anyone can relate?	HervalFreire	8.810745	9.166377	comment	3.0	15.0	1679675859	-5.331535
35291667	I used bazel for a few internal repo	"I used bazel for a few internal repositories written in Rust and it's amazing .... until you hit an issue.Edge cases in Bazel are about as documented as any random fish you might find in a crack at the bottom of the ocean. And the most hilarious thing to deal with is ""yeah this was written for a Google project, that other use case didn't apply to our project"".When eventually after the Xth issue I was told ""why don't you just fork this standard package"" (it was for typescript support inside the Rust repo) I was like ""f*** bazel"" and never touched it again.It's amazing when it works. If it doesn't you're f******."	19h	8.813052	9.157724	comment	3.0	12.0	1679675934	13.657636
15515827	It does not satisfy all of the items	It does not satisfy all of the items on the author's wish list, but I have used and enjoyed Bazel[1] as perhaps the nearest build system in existence that provides a notion of package management to C++. It does not hold prebuilt binaries to satisfy dependencies. But it does cache builds.Nor does Bazel use C++ syntax to describe the build, instead using a variant of Python called Skylark, but this feels (to me) much less onerous to pick up than the custom scripting language CMake uses.Bazel also provides a notion of visibility of dependencies that allow you in effect to control which build targets are exposed to other targets as allowed dependencies. And allows the build tool to specify a toolchain (compiler, linker, etc.) and machine architecture. This information is used when building all	duality	8.81023	9.167107	comment	3.0	12.0	1508508245	13.661174
15700996	Hi! I’m one of the engineers on this	Hi! I’m one of the engineers on this. We’ve got some work we’re collaborating on - all of which is going upstream - and we wanted a shared place to stage it while we prepare PRs. I’ll be pushing a statement to our fork tomorrow.(I’m personally working on Bazel rules and contributions to lib/Syntax. If you find that exciting, please get in touch! :)	lexlash	8.808049	9.167152	comment	3.0	28.0	1510712167	13.691062
38198282	Projects that use Mesonhttps://meson	Projects that use Mesonhttps://mesonbuild.com/Users.htmlIncludes Gimp, Gtk+, nautilus, Postgres, qemu, Wayland…	wenc	9.198269	9.040106	comment	3.0	13.0	1699483408	13.538949
38551518	It would be nice if Biff weren't dep	"It would be nice if Biff weren't dependent on various ad-hoc scripts (some in bash, others in babashka), since it means newcomers to Biff (and especially newcomers to Clojure in general) have to install a variety of tools without clear purpose.Luminus, for instance, is able to handle project creation, development, and deployment all within Leiningen (a build tool) itself. All you need to get started is to install Leiningen (a single command to install on any popular package manager) then run  lein new luminus my-app
  cd my-app
  lein run

No Windows-specific quirks w.r.t. live reload or anything else. Yes, it sucks that you have to install a build tool, but it's still a much simpler experience IMO. Unfortunately, Luminus feels less like a framework and more like a template web app with a "	koito17	8.81032	9.16066	comment	3.0	13.0	1701910200	-9.773314
33725538	The weirdest part here is that the a	The weirdest part here is that the author worked on a migration from their NIH build tool to Bazel for 2 years and never once mentions why all of that was even happening, and by the end of his employment, it was still not done.He links the pants-devel announcement and here is what it says:> Twitter has made the decision to migrate from Pants to Bazel as our primary build tool, as we believe that we have unique needs that Bazel can better addressPants was your own fucking build tool that you invented, controlled and maintained! How on earth can it not meet your unique needs.	stefan_	8.809683	9.168701	comment	3.0	10.0	1669243926	13.666323
34057363	From the announcement:> One of Bazel	From the announcement:> One of Bazel's most powerful features is its ability to use remote caching and remote execution.What's the value proposition of Bazel when build systems like cmake support this out of the box with third-party tools like distcc and ccache?	simplotek	8.810277	9.166534	comment	3.0	20.0	1671482392	13.665575
34057853	Probably because building targets wi	Probably because building targets with tools outside of the workspace is an antipattern, as it violates hermiticity principles. In fact, Bazel generally makes it quite hard to do this, so anyone who ends up in this scenario must have jumped through many hoops to get there.I agree that the linked issue is legitimate, but I'd argue that this isn't a problem Bazel itself needs to solve--you should fix your build to be fully hermetic.	lopkeny12ko	8.809302	9.168661	comment	3.0	16.0	1671484692	13.681795
34110386	For me a little disadvantage of Meso	For me a little disadvantage of Meson is that it is implemented in Python. With my interest in minimal systems and bootstrapping I would hope that it would get to be reimplemented in something easier to bootstrap or (maybe preferable) Python environment/version problems would get solved before the wider adoption. I understand, that it may not be as much a problem for others.	hawski	9.199169	9.03948	comment	3.0	16.0	1671828123	13.547293
34110927	Why do many C/C++ projects have both	Why do many C/C++ projects have both Meson and Ninja commands in their install instructions? Shouldn't only one be necessary?	hackerbrother	9.19859	9.038692	comment	3.0	10.0	1671831798	13.546491
23122942	Embracing Modularity with Meson	Embracing Modularity with Meson	ingve	9.198243	9.040037	story	3.0	33.0	1589009498	13.5649395
23302768	Meson is excellent and would have ea	Meson is excellent and would have eaten CMake out of house and home if it weren’t for the stupidity of it targeting C/C++ but being written in Python. A lot of C/C++ developers cringe at the thought of requiring Python as a build dependency.	ComputerGuru	9.198054	9.038165	comment	3.0	11.0	1590425878	13.538238
28425857	I'm surprised nobody has mentioned t	I'm surprised nobody has mentioned trying out using Google's Bazel build system with the Rust rules. Bazel provides relatively straightforward 'remote caching' of build artifacts via Google Cloud Storage or S3.https://github.com/bazelbuild/rules_rust	jgavris	8.811682	9.152611	comment	3.0	13.0	1630861924	13.650947
27971496	I'm using Meson for a project using 	I'm using Meson for a project using C++ with Gtkmm, Libmicrohttpd, catch2 and other libraries. My experience is good neglecting some minor issues. Meson is fast, well readable if written well, uses system libraries by default and allows flexible usage.On the other side I'm using Java with Maven and it is - a big burden. It's build in dependency retrieval system also isn't helping. Maybe I just don't like XML - because it is not human-readable ;)	ho_schi	9.197348	9.04145	comment	3.0	13.0	1627388045	13.548867
13587041	I do use CMake as my build system, I	I do use CMake as my build system, It is like torture ! literally, I always liked waf, I am curious why not many people use it ? it is incredible, I have very high hopes for waf and Meson.	0xFFC	9.196949	9.034428	comment	3.0	12.0	1486441979	13.526949
21214137	Bazel is here to stay. Sooo many com	Bazel is here to stay. Sooo many companies are jumping on this bandwagon [1].Bazel is better than Maven, Pants... you name it.Think of this like Protobuf or Kubernetes. It's an open source tool used to build things at scale. There will be lots of users and contributors. A cottage industry will spring up, and this will grow well beyond Google.[1] https://github.com/bazelbuild/bazel/wiki/Bazel-Users	echelon	8.809697	9.168195	comment	3.0	11.0	1570714058	13.658339
21214430	I use bazel at work heavily in a ver	I use bazel at work heavily in a very large project. I’ve always worked with scripting languages so I’m much less familiar with build systems.I’m not sure I get what makes bazel so good. It seems pretty simple to me. You have a bunch of directories with BUIILD files that are each sort of like Makefiles.Am I missing something? It kind of just seems like a hodgepodge of scripts. I don’t dislike it, but I’m also not seeing anything amazing.	dickeytk	8.809361	9.168374	comment	3.0	22.0	1570715444	13.680328
21218275	I think for Java projects Bazel is a	I think for Java projects Bazel is a very bad choice. Last time I've checked it was not even able to resolve dependencies transitively. And I doubt that it's faster than recent versions of Gradle.	oweiler	8.863282	9.213676	comment	3.0	11.0	1570735543	13.610304
21253699	Bazel is a ground-up rewrite. Its no	Bazel is a ground-up rewrite. Its not related to Blaze apart from naming. There was a skylark project aiming to combine the two over time, not sure how the progress is going on for it.	hcnews	8.80836	9.168063	comment	3.0	11.0	1571093429	13.676097
21288906	In my opinion Bazel/Blaze and Buck a	In my opinion Bazel/Blaze and Buck are mainly useful to solve the problem of having too much code to build on one machine. Reproducible builds which can be done in a distributed fashion aren’t really useful when you can build your whole project in a minute or two on one machine. That being said, once you get the hang of it the overhead is not too high compared to simpler systems.	throwaway1777	8.809817	9.169388	comment	3.0	11.0	1571376108	13.6700325
21385655	Firefox will currently build on more	Firefox will currently build on more platforms than Bazel does. Getting fed up of the endless list of new build systems.	rjsw	8.810301	9.167942	comment	3.0	36.0	1572345754	13.659311
21386987	> Is it a bad thing?Yes. It makes ve	"> Is it a bad thing?Yes. It makes verifiability much harder.E.g. Debian put a lot of work into making a more trustworthy build chain by introducing reproducible builds.
There's no Bazel on Debian. And not on many other distros. Because getting Bazel to be built itself is a complexity nightmare.
""Here, download this big blob where you have no idea how it's been built"" doesn't exactly help."	hannob	8.80765	9.16927	comment	3.0	12.0	1572356417	13.678437
21457548	While I love these projects, neither	While I love these projects, neither one of these actually fix the problem of an ecosystem of dependencies.Buck and Bazel were created for complex internal dependencies.You'll have just as easy/hard of a time getting Boost installed with Bazel as you would for Make.Or publishing an accessible library that depends on Boost.	paulddraper	8.808406	9.164546	comment	3.0	18.0	1572993671	13.68356
39240814	Starlark seems to be overwhelmingly 	Starlark seems to be overwhelmingly bound to Bazel at the moment—searching for it, I had to follow a link from Bazel to the GitHub repo and then from there I got to the implementations and found this:> The implementations below are not fully compliant to the specification yet. We aim to remove the differences and provide a common test suite.This does not inspire confidence that I could use this in a project any time soon.Meanwhile, from what I can tell Pkl has a single Truffle implementation that currently supports 4 languages, it has a syntax that is more familiar to me as a non-Python dev, it has static typing, and it has a dedicated plugin in most IDEs (whereas Starlark just says to install the Bazel plugin). Maybe Starlark is more appealing to people writing Python or already using Baz	lolinder	8.809633	9.166971	comment	3.0	13.0	1706971723	13.673559
29719909	I suspect the experience varies pret	I suspect the experience varies pretty widely based on what languages you use and what you’re trying to do with it. If you’re just building Go binaries then I’m sure Bazel is great, but if you’re doing anything with Python 3 or if you’re doing something a little off the beaten path like code generation, it’s probably a frustrating experience.	throwaway894345	8.809985	9.166266	comment	3.0	10.0	1640736324	13.6582985
30232887	I feel like I’ve hit something reall	I feel like I’ve hit something really special with Bazel, but there’s almost no ecosystem around it.Im trying to use it for game development, the model fits so perfectly for large monorepo projects with explicit dependencies, but it seems like since there’s no ecosystem that I have to write a lot of my own rules from scratch; and the learning resources are many years old and in the conference format. It’s quite dense to get in.Even the slack requires an @google.com email to get in.	dijit	8.807158	9.167309	comment	3.0	14.0	1644158418	13.677165
18823290	Not worth a long discussion, but is 	Not worth a long discussion, but is the Blaze build system they are referring to in fact Bazel?	patothon	8.809734	9.168496	comment	3.0	13.0	1546601622	13.64503
24493957	Had to build bazel from scratch, you	"Had to build bazel from scratch, you need:- a previous version of Bazel- GCC/Clang- JDK- Python- Zip and UnzipNot sure I'd call that ""huge"". Perhaps the JDK?"	steeve	8.809798	9.167431	comment	3.0	15.0	1600272339	13.664018
24529865	I don't think a single build system 	I don't think a single build system is necessary or desirable. meson (as well as waf and scons) depends on python, which is not so nice for bootstrapping. Thus desktop applications and low level userspace plumbing could benefit from different build systems.That said, I hope waf and scons die off soon (only a handful of packages even use them). CMake and Meson are much better choices.	CameronNemo	9.200206	9.036993	comment	3.0	13.0	1600543961	13.537859
38829135	Context: I tried and failed at convi	Context: I tried and failed at convincing management in moving my work monorepo to bazel. We have around 5 core languages plus a bunch of dsls.If you don't mind sharing, what languages do you build in your bazel workspace? Were you able to use hermetic toolchains for these languages without any major hiccups? Finally, do you use engflow or buildbuddy atop bazel?Thanks!	kldx	8.792754	9.150639	comment	3.0	10.0	1704074092	13.712619
32134362	Blaze/Bazel actually sucks imo.  The	Blaze/Bazel actually sucks imo.  The only good thing about it is that all of google uses that one piece of shit, making things nice and uniform and consistent.There's a reason it isn't popular outside of elgoog.IRL, every project tends to do a little bit or a lot of its own thing.	metadat	8.809922	9.16842	comment	3.0	30.0	1658115546	13.682879
32134513	Bazel can be clunky, but not having 	Bazel can be clunky, but not having some bazel equivalent can have very significant costs that are easy to get accustomed to or overlook.Things like engineers losing time wondering why their node dependencies weren't correctly installed, or dealing with a pre-commit check that reminds them they didn't manually regenerate the generated files, or having humans write machine-friendly configuration that's not actually human-friendly because there's no easy way to introduce custom file transformations during the build.Bazel doesn't spark joy for me and I wouldn't say I look forward to using it, but personally I would still always choose it for a codebase that's going to have multiple developers and last a long time. It's vastly easier to go with bazel from the beginning than to wish you could s	dub	8.809799	9.1679325	comment	3.0	23.0	1658116928	13.67337
32134791	Bazel often comes up as an awesome a	Bazel often comes up as an awesome aspect of Google's tooling but as far as I can see it's open source and hasn't really caught on elsewhere. Is there something I'm missing about why?	technion	8.809595	9.168362	comment	3.0	11.0	1658119680	13.671885
39582055	The defining feature of Bazel is san	The defining feature of Bazel is sandboxing build steps so that you can't accidentally miss edges in the dependency graph. This has enormous benefits:1. Incremental/cached builds are reliable.2. You can reliably avoid rebuilding/testing artifacts that cannot possibly be affected by a PR.Neither of those are possible in build systems that don't do this sandboxing. If you're doing a big project you really need these, hence why Google came up with this technique.I'm not sure there's much value in a new build system that doesn't even get that right. We already have dozens.	IshKebab	8.808422	9.168472	comment	3.0	12.0	1709485009	13.670665
32805010	I'm confused.What sort of advantage 	I'm confused.What sort of advantage do you imagine a build system like Bazel would provide for you?Build systems for C are bandaids. You would not ideally want them. They are extra baggage that you just have to carry around because of legacy reasons. It's not something to want.	hsn915	8.810041	9.167319	comment	3.0	12.0	1662946961	13.674677
32830137	That's like saying you should never 	That's like saying you should never build a house with concrete foundations because they take so long to dig and pour and the first layer of bricks doesn't need them anyway!Get back to me when you work for a company with a monorepo that has to build and test everything in CI for every change (taking something like 200 CPU hours) because they didn't have the foresight to use Bazel.	IshKebab	8.772829	9.130931	comment	3.0	18.0	1663102925	13.72769
32830217	In general, if someone wants to beef	"In general, if someone wants to beef up the tooling in my project that I know is fine to begin with, I still say ""I don't mind, go ahead, but I will continue using my old tooling until yours works with no regression."" Half the time, they abandon it. I don't even know how Bazel works cause I've never felt enough pain with makefiles etc to research an alternative.Also, Google tooling knowledge doesn't transfer very well to outside projects. Everything is special on the inside there. They use an internal version of Bazel called Blaze that's totally integrated with everything, with entire teams dedicated to the tooling, and only a few officially supported programming languages, so of course it works smoothly."	hot_gril	8.808554	9.165849	comment	3.0	21.0	1663103419	13.676977
32831555	My experience with Bazel at a startu	My experience with Bazel at a startup (also used Blaze at Google):The good:- Amazing for Go backends. I can push a reproducible Docker image to Kubernetes with a single Bazel command. I can run our entire backend with a single command that will work on any developer's box.- Amazing for testing. All of our backends tests use a fully independent Postgres database managed by Bazel. It's really nice not having to worry about shared state in databases across tests.- We can skip Docker on macOS for development which provides on the order of a 10x speedup for tests.- BuildBuddy provides a really nice CI experience with remote execution. Bazel tests are structured so I can see exactly which tests failed without trawling through thousands of lines of log output. I've heard good things about EngFlow	sa46	8.806946	9.161175	comment	3.0	13.0	1663112749	13.668981
16483267	A significant hurdle for the univers	A significant hurdle for the universal adoption of Bazel is its too many dependencies.	netheril96	8.810137	9.168436	comment	3.0	19.0	1519828876	13.665319
16487447	This looks so similar to Bazel..What	This looks so similar to Bazel..What's the advantage of using Please?	egnehots	8.809562	9.169045	comment	3.0	26.0	1519854886	-4.6474123
16488053	"What's hard about ""brew install baze"	"What's hard about ""brew install bazel""?"	iainmerrick	8.809344	9.168787	comment	3.0	18.0	1519858865	13.668932
16528514	I have worked extensively with Bazel	"I have worked extensively with Bazel in the context of migrating a very large Java/Scala codebase from Gradle to Bazel.My impression is that it is a first-class build system _specifically for Java and C++_. There are specific properties of the compilation and packaging ecosystem around those languages and runtimes that make them uniquely in need of tools like Bazel. This is not true for Go, where build speed and large codebases were a consideration up-front (especially with the new build caching features that shipped in Go 1.10), and are almost completely irrelevant in the context of ""interpreted"" languages like Python, Ruby or JavaScript.There are plenty of other languages and runtimes that stand to benefit from a tool like Bazel, but just because Bazel is a fantastic tool in some context"	venantius	8.809776	9.167051	comment	3.0	13.0	1520340981	13.667673
19482838	Thanks for sharing your perspective.	Thanks for sharing your perspective. My comment was largely based on this discussion:https://github.com/mesonbuild/meson/issues/2173If you'd like to share a short summary of your thoughts, I'll update the article with your commentary.	ddevault	9.198403	9.039521	comment	3.0	28.0	1553525132	13.52979
19711777	Can anyone who's used both compare B	Can anyone who's used both compare Buck to Blaze/Bazel?	duality	8.809505	9.168376	comment	3.0	12.0	1555849720	13.673409
19796702	> A monorepo oriented build tool suc	"> A monorepo oriented build tool such as Bazel will make sure that you don't compile more than needed.Not at all true in my experience. I use Buck, which is very similar. It constantly recompiles stuff it doesn't need to by any standard. I've seriously considered avoiding Mercurial bookmarks in favor of manual patch management to see if I can avoid triggering the cases where it gets stupid. Maybe it's a problem specific to Buck, but my conversations with peers at other companies suggest not (and only a tiny percentage of developers at any of these companies get a choice of which tool to use).The other issue is that ""more than needed"" is subject to more than one interpretation. There's ""more than needed"" as code was actually written, and there's ""more than needed"" as code should have been w"	notacoward	8.793587	9.148123	comment	3.0	13.0	1556716469	13.664191
19797222	Wait what? As long as the build proc	Wait what? As long as the build process is reproducible, why do you care if it's incremental or not? If you don't trust bazel, people have been using distcc+ccache since forever.	yegle	8.8071165	9.16163	comment	3.0	14.0	1556720526	13.646251
24845370	I really don't think Meson and CMake	I really don't think Meson and CMake should be mentioned in the same breath here. I would be glad to know what you think makes Meson so bad.	dxuh	9.198045	9.039581	comment	3.0	16.0	1603263252	13.54431
24926065	I have never seriously used bazel. J	I have never seriously used bazel. Just looking at it, I found the the thought of manually mirroring all #includes to the build configuration in a big project pretty aggravating.Is that not really an issue in practice? Do people automate that away?	anarazel	8.808078	9.167645	comment	3.0	11.0	1603934400	13.643987
25240758	Good to know that you live in a priv	Good to know that you live in a privileged place and access a fast internet connection. Most of the places don't have that kind of bandwidth [1] to download 600 MB of file in 40 seconds. Also, Bazel needs a huge amount of RAM because of JVM and runs a daemon process in the background to speed up the build duration. Running a background JVM daemon process is a NO for me and Bazel wastes system resources.[1] https://en.wikipedia.org/wiki/List_of_countries_by_Internet_...	sercand	8.809649	9.168115	comment	3.0	11.0	1606599283	-10.472456
30947098	Is there, say, IntelliJ support for 	"Is there, say, IntelliJ support for Bazel? Do you need a central server?I've heard bazel is a bear...But... all mature build systems are, because they become essentially enterprise workflow engines, process execution engines, internal systems integration hubs, and schedulers. Why? Because that's what an enterprise/mature build system is, it only differs from other software packages with the same capabilities in that it concentrates on build / deploy / CI  ""business tasks"".My current employer uses Jenkins (which has workflows/pipelines, daemons) and then feeds into Spinnaker (which has a full DAG workflow engine and interface) and likely this is pretty close to a ""standard"" or ""best of breed"" cloud build CI system. Of course there is a dedicated team.Oh and of course the gradle code build i"	AtlasBarfed	8.808879	9.157587	comment	3.0	10.0	1649350319	13.669446
34886368	I'm not trying to be overly critical	I'm not trying to be overly critical here, in fact, I want to share the type of empathetic feedback I'd hope to receive as a founder.Have you actually talked to Blaze/Bazel users to understand what frustrations (if any) they have with their current build system? Have these users asked for a Bazel-lite? If so, and you still want to position yourself as Bazel-lite, then you should include some of their direct feedback and write your messaging accordingly.As a daily Blaze/Bazel user, I don't have a desire for a Bazel-lite. I've worked at a midsize company that used Bazel, and I'm working at the company that created Blaze/Bazel.Disclaimer: Opinions expressed are my own; not representative of my employer.	Denzel	8.80998	9.168564	comment	3.0	16.0	1677010252	13.666081
29016975	> The meson support is now fully mat	> The meson support is now fully mature. While autotools support will still be kept for this release series, it will be dropped afterwards.autotools delenda est.	woodruffw	9.198209	9.039672	comment	3.0	32.0	1635358697	13.5380945
29018021	Building X was already complex and a	Building X was already complex and annoying. While I hate autotools, I didn’t find Meson to be particularly better. If anything this is a lateral change. Instead of m4, shell, and makefiles, Meson has python, some python packages (managed with pip), and ninja. I guess Meson is faster, but I’m not convinced that justifies changing the build system especially since the speed up isn’t too significant.	eddieh	9.198245	9.03804	comment	3.0	12.0	1635363288	13.53324
29017615	Rather bad news. Meson introduces a 	Rather bad news. Meson introduces a rat-tail of build dependencies.	sprash	9.198029	9.040591	comment	3.0	16.0	1635361468	13.538797
29329296	I've never used bazel before. Is it 	I've never used bazel before. Is it that bad?	passerby1	8.810079	9.167677	comment	3.0	10.0	1637756748	13.667229
36148949	Is bazel build distributed? distcc l	Is bazel build distributed? distcc lets you use a lot of machines to speed up the wallclock-time of your compilation.	pjc50	8.806083	9.163115	comment	3.0	10.0	1685611056	13.676642
31231240	And yet, meson just routinely doesn'	And yet, meson just routinely doesn't work. Sure: if you are just trying to do some trivial local compile job it seems fine, but it keeps having issues with even trivial cross compilation cases (which are used even on Linux as you generally want to do a Linux-to-Linux cross compile to control your glibc target) and linker detection (as it is assuming way too much direct control over the linker that it should frankly be delegating to the compiler) that make you have to jump through ridiculous hurdles to make things compile (and that's assuming you aren't on one of the commonly-deployed semi-recent versions of meson where it is a truly lost cause). In contrast, autotools always works: I have never had a blocking or serious issue compiling something that uses autotools, no matter how complex 	saurik	9.198249	9.040903	comment	3.0	13.0	1651463161	13.525583
31763897	> questionable tools (with large sha	"> questionable tools (with large shadows) such as Bazel and gRPC,Bazel and gRPC, whilst both saddled with problems stemming from Google's inwardly-focused engineering culture (and also just some sub-optimal historical decisions) are not ""questionable tools"" in the sense that they solve the wrong problems or something else solves the same problems much better.Blaze/Bazel (and its various clones like Buck) are basically the only general purpose build systems out there that even attempt to do the basic tasks of a build system, namely actually figuring out what has changed and needs to be rebuilt. So of course they are gonna use it, nothing else comes even close (and the main downsides don't apply to them).Similarly, gRPC has a lot of warts in both how its encoding, type system, API and transp"	patrec	8.813805	9.154907	comment	3.0	21.0	1655370313	13.650001
31764140	">[Bazel and gRPC] are not ""questiona"	">[Bazel and gRPC] are not ""questionable tools"" in the sense that they solve the wrong problemsI disagree, and there is a huge philosophical gulf of understanding between my view and those who feel differently."	ddevault	8.811071	9.164439	comment	3.0	12.0	1655372634	13.661239
24204583	Bazel is the least bad build system 	Bazel is the least bad build system I've used too. Just wanted to note, though, it is not damn beautiful. Maybe its internal (idealistic) model is beautiful, but the outer parts are something else. It does have awesome features, but it has lots of bugs, rough edges, and weird behavior too. Try specifying your own compilers, or adding your own steps to the build process, getting things working on Windows, etc. and if you don't already know how to do it, you will probably hate your life trying to figure it out. And forget about putting your workspace into a path with spaces, even if your repo path lacks spaces inside it and you use relative paths everywhere -- it simply can't do that (while even Make can). There are lots of random issues with undeclared headers and ungenerated files that com	mehrdadn	8.808999	9.168356	comment	3.0	12.0	1597786238	13.698519
33334127	speaking of which, is it reasonable 	speaking of which, is it reasonable to use Bazel instead of webpack?	colordrops	8.809566	9.167539	comment	4.0	12.0	1666721204	13.640884
34110637	In my experience, CMake seems to be 	"In my experience, CMake seems to be more capable and easier to work with, both for the package author and for the person trying to build it. Also, more flexible in terms of how projects/packages depend on each other.Now CMake is certainly not great; it has a lot of warts and baggage; and some functionality is _not_ easy to use, like installation (you need a good hour of explanation to make heads from tails with that, and then you're supposed to write 4 or 5 different CMake commands even for the simple use-case of ""just install my damn plain-vanilla library""). But I'll choose it over meson any day of the week, and so would my users (i.e. the people who download and build my packages)."	einpoklum	9.198629	9.039251	comment	4.0	23.0	1671829717	13.539049
34110252	Are there any stories/articles on wh	Are there any stories/articles on why people chose meson, over say CMake (or others)? I do like meson much more than CMake for sure, sane syntax and all.	malkia	9.198696	9.040183	comment	4.0	25.0	1671827376	13.550513
34110300	2019 was the last time I looked into	2019 was the last time I looked into the CMake vs. Meson debate and while Meson looked 100% saner, cleaner, etc. the network effects of most of the popular C++ libraries using CMake made me end up picking CMake. I'd be curious how the landscape is today but I now have stockholm syndrome with CMake especially using vcpkg.	lazypenguin	9.198242	9.040588	comment	4.0	31.0	1671827685	13.54142
34111727	Yeah I don't see the value propositi	"Yeah I don't see the value proposition of Meson to be all that compelling. It's basically just CMake, but with a different DSL. I've never had a problem with modern CMake, and whatever minor productivity benefits there might be from Meson are far outweighed by the popularity of CMake.Even if Meson is more ""powerful"", there are other build systems out there that are better options than either of these."	bogwog	9.198475	9.040267	comment	4.0	17.0	1671837224	13.541939
26688549	> Dflat at the moment requires Bazel	> Dflat at the moment requires Bazel.Very few people use Bazel for Android or iOS. Anyone not from Google care to let us know if you're using Bazel for mobile development?	throw14082020	8.809907	9.16877	comment	4.0	15.0	1617535314	13.6577635
26719573	Also, how does Bazel compare to Grad	Also, how does Bazel compare to Gradle?JetBrains and it seems basically every library has support for Gradle and sometimes Maven, but not Bazel. Gradle is verbose and has a really steep learning curve, but it's battle-tested and does its job really well. I don't really see why anyone would use Bazel instead.	Jakobeha	8.809894	9.168134	comment	4.0	14.0	1617759232	13.646409
26719689	For me, the main advantage of Bazel 	For me, the main advantage of Bazel is speed, when properly structured and configured, a Bazel build can:* Perform incremental build a magnitude faster than Maven, zero changes build finishes immediately.* Can have global caches for all builds across organization, so that a workstation build can automatically build incrementally upon a standard build, massively reduces build speed for big monorepo.* Very fast, incremental tests execution: test results are cached, so only tests affected by the changed code are run. Test executions are parallel by default.Some other things:* Pull in dependencies directly from a git repository, without having to publishing it first like in maven, this can be a plus or a minus.* Cross-languages build: you can have each of your module programmed in a different 	dikei	8.803773	9.160521	comment	4.0	17.0	1617760269	13.644469
26730016	How does Bazel deal with different p	How does Bazel deal with different platforms? For example, run tests on Windows, BSD, Android, Raspberry Pi, RISCv5, or even custom hardware?	qznc	8.810067	9.167412	comment	4.0	13.0	1617824366	13.667344
27181988	I have been working with Bazel in my	I have been working with Bazel in my personal monorepo (~6 months now), and the fact that Justine, someone I believe knows Bazel/Blaze well, uses GNU Make, makes me re-think my decision: perhaps I should re-consider it. I have quite a few issues with Bazel, which require significant engineering hours to overcome, whereas I could just use gnu make and solve it quickly.Let's see if I can get some inspiration of how things can be built from this repo?`o/$(MODE)/depend`, a makefile-looking file with the full dependency tree. It is compiled using tool/build/mkdeps.c. So we have a Makefile generator (Justine, you mentioned elsewhere in this thread you didn't want to invent a build system? :)) The Makefile generator is very specific to this project: parses C files and creates that tree.It is damn	motiejus	8.807568	9.163023	comment	4.0	24.0	1621247704	13.682551
35471168	Hrmm, it makes performance claims wi	Hrmm, it makes performance claims with regard to Buck1 but not to Bazel, the obvious alternative. Hardly anyone uses Buck1 so you'd think it would be relevant.	jeffbee	8.809692	9.168995	comment	4.0	18.0	1680800263	13.655998
35472263	The fact that Buck2 is written in a 	"The fact that Buck2 is written in a statically-compilable language is compelling, compared to Bazel and others. It's also great that Windows appears to be supported out of the box [1,1a] -- and even tested in CI. I'm curious how much ""real world"" usage it's gotten on Windows, if any.I don't see many details about the sandboxing/hermetic build story in the docs, and in particular whether it is supported at all on Linux or Windows (the only mention in the docs is Darwin).It's a good sign that the Conan integration PR [2] was warmly received (if not merged, yet). I would hope that the system is extensible enough to allow hooking in other dependency managers like vcpkg. Using an external PM loses some of the benefits, but it also dramatically reduces the level of effort for initial adoption. I"	ihnorton	8.808458	9.163339	comment	4.0	14.0	1680805144	13.560951
22578500	Don't use cmake for new projects. Yo	Don't use cmake for new projects. You'll regret it. Try meson instead:https://mesonbuild.com/	ddevault	9.199941	9.038361	comment	4.0	16.0	1584218421	13.542011
19611191	Why migrate from CMake to meson?	Why migrate from CMake to meson?	ridiculous_fish	9.197515	9.04017	comment	4.0	27.0	1554776792	13.549132
18738853	I've used bazel pretty extensively a	"I've used bazel pretty extensively and I have to say it's not fully baked unless you're using it the way Google does internally (vendor all dependencies) and you're using a language Google does internally.Additionally, it wants to take over your entire build process end to end. Get used to prefixing every shell command with `bazel run` or `bazel build` because everything goes into a little sandbox and bazel likes to be in the middle of everything.These tradeoffs make sense at Google scale (the goal of bazel is to have very repeatable builds), but in my opinion it's a huge drag with not much benefit for smaller shops (to be clear, ""Oh you only have 200 developers?"" Still a small shop by these standards)"	habitue	8.808945	9.167689	comment	4.0	16.0	1545451750	13.671806
18846170	Thats besides the growing number usi	Thats besides the growing number using Meson instead.	zanny	9.1986475	9.039403	comment	4.0	12.0	1546876604	6.597451
29719417	I second Bazel. People keep on menti	I second Bazel. People keep on mentioning how steep the learning curve is, but   the conceptual model is really simple, elegant, and intuitive.What is steep is the technical know-hows:1. When things don't work as expected. For example, while it worked flawlessly with languages that it natively support such as Java, that wasn't the case for other languages such as Javascript or Python.2. When you have to do something advanced such as building custom Bazel rule. You'll need to understand Bazel internals and unfortunately the documentation isn't very intuitive and also somewhat sparse.	lolski	8.808168	9.1672735	comment	4.0	23.0	1640732814	13.669268
23181093	I wish they had spent more time desc	I wish they had spent more time describing how/why Go's built-in build tool stopped working. Or perhaps that's part of the basics of Bazel. Anyone able to share more on that?	wgyn	8.809115	9.169339	comment	4.0	12.0	1589471976	13.6653595
24618220	You don't have to build from scratch	You don't have to build from scratch if you have high confidence that an incremental build is correct. You get this from modern build systems like Bazel.	klodolph	8.805248	9.157574	comment	4.0	19.0	1601309578	13.681862
24925816	While Bazel design seems not bad, co	While Bazel design seems not bad, could they have used a build system that doesn't require Java? It's especially important for bootstrapping. CMake requires only C++ at least.	xvilka	8.8105955	9.168265	comment	4.0	50.0	1603931782	13.668634
24925876	In practice, this isn't generally no	In practice, this isn't generally noticeable. Bazel is pretty damn fast, and even ships with its own JVM so installing it is pretty much painless.I agree on the bootstrapping issues resulting from that, though.	q3k	8.8086405	9.169001	comment	4.0	42.0	1603932380	13.652909
25383452	In what universe Bazel is a critical	In what universe Bazel is a critical project for Java ecosystem?	EvilEy3	8.808704	9.168554	comment	4.0	12.0	1607673677	13.665003
38876170	Honestly Bazel and Java is actually 	Honestly Bazel and Java is actually a really nice experience. Pull in third party stuff from https://github.com/bazelbuild/rules_jvm_external. There is built in support for uber jar builds by adding a _deploy.jar suffix to binary jars. Protobuf and other codegen is super easy!	rockwotj	8.811723	9.170936	comment	4.0	14.0	1704434222	13.683801
15486837	Ask HN: How do you build your Golang	Ask HN: How do you build your Golang based repo ?	naanandtech	8.8084955	9.164561	story	4.0	3.0	1508189947	13.687767
21352739	You should definitely take a look at	You should definitely take a look at bazel. This is not say bazel is better than the one you wrote but cleary bazel is becoming a industry standard making other build tools obsolete.	troysand	8.808971	9.168462	comment	4.0	19.0	1571989251	13.674619
21389206	Hermetic declarative build systems l	"Hermetic declarative build systems like Bazel feel exactly like sound statically typed languages to me. It's really hard to get all of your dependencies precisely specified declaratively. The urge to hack in a little imperative code or jam in a build step that you just ""know"" needs to happen in a certain order is always there and it can be very difficult to satisfy the taskmaster that is the build system. When you have weird cases like a script that produces a variable set of output files based on the content of some input file, it's tough to get that working in the build system.But... if you climb that cliff, there are many rewards at the top. Like the article notes, you can reuse intermediate build artifacts between developers (because it's not possible for those artifacts to accidentall"	munificent	8.809058	9.159061	comment	4.0	72.0	1572367584	13.66441
39219407	Show HN: Makex Automation Tool	Show HN: Makex Automation Tool	nateskulic	8.809175	9.164226	story	4.0	4.0	1706812259	13.697467
32831169	Bazel is a fully reproducible and he	Bazel is a fully reproducible and hermetic build system. A lot of painstaking work goes into it producing the exact same artifacts build after build. And that provides some interesting properties that you can leverage for artifact caching, deployments, and CICD.We very happily runny a polyglot monorepo w/ 5+ languages, multiple architectures, with fully reproducible artifacts and deployment manifests, all deployed to almost all AWS regions on every build. We update tens of thousands of resources in every environment for every build. The fact that Bazel is creating reproducible artifacts allow us to manage this seamlessly and reliably. Clean builds take an hour+, but our GH self-hosted runners often complete commit to green build for our devs in less than a minute.The core concept of Bazel 	jsw	8.79607	9.147644	comment	4.0	40.0	1663109324	13.682558
39439788	I was skeptical of your claims about	I was skeptical of your claims about building it so I went ahead and downloaded skia and built it myself. It was simple and on my 4 year old desktop (8 cores) it took under a minute to compile skia after it had downloaded its dependencies. All I did was run 2 commands ./tools/git-sync-deps and bazel build //:skia_public. This was not painful at all.	charcircuit	8.807897	9.163867	comment	4.0	14.0	1708426302	13.699428
39641514	The recommended Makefile has several	The recommended Makefile has several issues, not least of which being that it relies on dependency fulfilment order which can be non-deterministic (e.g. if you pass -j).The project structure includes flavour-of-the-week litter like .devcontainer, .github, .vscode.compile_commands.json should be getting generated, not stored.Not sure if I would recommend anyone follow this information.The build system situation in the C world is dire. And I should know, given I write my own build systems for C.I would say, while I've never actually used it, Meson seems the least non-sensical out of the box experience.Ideal in some ways but not in others is designing and implementing your own build system because genuinely everything else out there has some major shortcoming or other.If you are insistent on 	Arch-TK	9.198539	9.037327	comment	4.0	18.0	1709909297	13.554401
23834879	Bazel is fucking awful. Most miserab	Bazel is fucking awful. Most miserable years of my career is when I was tasked with maintaining a build system based on it. Same for gRPC, which TFA also does a good job of shutting down.Google doesn't get credit for Go, Bell Labs does.	ddevault	8.810436	9.166831	comment	4.0	15.0	1594747479	-10.40743
23884079	I'm no blaze/bazel expert (hopefully	"I'm no blaze/bazel expert (hopefully someone will add their own thoughts), but:    1. build graphs are trees/acyclic : bazel enforces this, no cyclic dependencies allowed
    2. Compilers will always modify the timestamps on every file they are expected to output : if a write happens why not update mtime? nanosecond precision, what year is it?
    3. It's possible to tell the compiler which file to write its output to : makes no sense to me, we expect our compilers to be writing to the correct files in the correct directories.
    4. It's possible to predict in advance which files the compiler will update : yes it is, this is how caching works again see (1)
    5. It's possible to determine the dependencies of a target without building it : yes yes it's completely possible given (1)
    6."	sabujp	8.809169	9.166177	comment	4.0	15.0	1595100419	13.677457
20637020	Would have hoped they would use baze	"Would have hoped they would use bazel instead.
It's open-source, and so much easier to deal with than CMake."	halflings	8.816124	9.163166	comment	4.0	23.0	1565199987	13.661495
13806854	I'd give this a look: https://github	"I'd give this a look: https://github.com/GoogleCloudPlatform/cloud-builders/tree/m... (unfortunately key links to Bazel docs are 404'ing.)Bazel is a general purpose build system that focuses on reproducibility (same build inputs -> same build outputs) and strict dependency specification (at various levels: file, subsystem, external package fetching etc.) enforced by sandboxing which allows for fast incremental builds. Bazel is the open-source version of Google's internal build-system.More info here: https://bazel.build/How external resources are handled: https://bazel.build/versions/master/docs/external.htmlObviously Bazel requires some buy-in which may be unappealing (at least for existing projects:
 migration/supporting multiple build systems.) There are, however"	jacobparker	8.806235	9.158197	comment	4.0	13.0	1488841000	13.687077
31230797	I build a lot of cmake and meson pro	I build a lot of cmake and meson projects.  I was an expert at cmake for quite some time (bleh), but now I use meson for everything I can.The end user experience is in every aspect superior to autotools.  There is a small downside for cmake compared to autotools: while you have to install the bits for autotools it runs on a shell.  There is a bigger downside for meson: you need a minimal python infrastructure up and working.  Over time you need that python infrastructure to keep working.  Sometimes it doesn't.I still vastly prefer meson over cmake and much more so autotools.  If I have to fix cmake or meson builds, well, really, if you know their languages, it's just no comparison to debugging the 1000s of lines of shell code autotools generates.	downut	9.197846	9.040358	comment	4.0	29.0	1651458430	13.541551
29369048	I’ve been having difficulty recently	I’ve been having difficulty recently trying to get bazel and rust to work together nicely.It seems like cargo does a lot of heavy lifting w.r.t. dependencies which Bazel does not like. Do you have to vendor your dependencies- and your dependencies dependencies. Ad infinitum.There is cargo-raze which helps, but only if you’re making a rust library: not if you’re making a binary.So maybe it works for this case.	dijit	8.811783	9.161148	comment	4.0	12.0	1638109016	13.659109
34885962	Bazel has a heavy focus on correctne	"Bazel has a heavy focus on correctness (pretty much to the exclusion of everything else). Where does Moon fall on the correctness gradient? Does it enforce hermecity or deterministic builds or give me tools to accomplish it?In the same vein as those questions how does caching work? Is it content based like Bazel or mtime like Nx et al? If there is no sandboxing does it do input tracking or is there manual ""cache key"" shenanigans?If the configuration language is YAML how am I expected to implement new behavior? Is that in Rust? Is there a plugin architecture? Do I need to rebuild the tool itself and redistribute it to my build machines and developers? The main appeal of Starlark/Python in build systems is ability to create macros or in many cases define entirely new rulesets to support new "	jpgvm	8.809131	9.166768	comment	4.0	28.0	1677008626	13.674383
34892347	I think it's hilarious to say bazel 	I think it's hilarious to say bazel focuses on correctness when it doesn't ship with any hermetic toolchains by default. Properly setting up hermetic toolchains is poorly documented and left as an exercise to the reader.I say this as someone who wants to love bazel... I just can't understand why it picks up impure toolchains from the system at all.	hamandcheese	8.810108	9.168066	comment	4.0	18.0	1677047279	13.669872
19612208	A better question is does it need to	A better question is does it need to have tooling or IDE support to be worked with?It's good to have tooling and IDEs for CMake because CMake is complicated and hand-editing the files is very tedious. But if Meson eliminates the tedium of CMake by providing you with different abstractions then you don't actually need the IDEs or tooling.	jschwartzi	9.201355	9.038612	comment	5.0	17.0	1554790036	13.551481
38262724	As a distro contributor, I don't sha	As a distro contributor, I don't share these views at all. Yes, it's sometimes a bit of a pain when some application needs an older, incompatible library, but in 99% of the cases, the fallout is minor, or there's some compatibility library or shim I can install. The advantage of doing this being that the old application will now support all modern audio/video formats (e.g. ffmpeg) and the new graphical and audio subsystems on linux (e.g. sdl), as well as whatever security fixes.If I really need an old library, it's generally not hard to install that in a temporary prefix and set the relevant PATH variables for it, though I do wish this was easier sometimes. It gets better as more projects just use pkg-config.That all said, Meson[1] solves all of these issues in a way that keeps both develo	mid-kid	9.197895	9.041152	comment	5.0	19.0	1699966538	13.544291
35475149	I'm missing some historical context 	I'm missing some historical context here. This article goes out of its way to compare and contrast with Bazel. Even the usage conventions, build syntax (Starlark), and RBE API are the same as in Bazel.Did FB fork Bazel in the early days but retain basically everything about it except the name? Why didn't they just...adopt Bazel, and contribute to it like any other open source project?	lopkeny12ko	8.809473	9.168661	comment	5.0	19.0	1680818561	13.670778
35475542	Do smaller companies (smaller than M	Do smaller companies (smaller than Meta and Google) use these kinds of build tools much? It seems like a system that rebuilds everything whenever a dependency changes is more suited an environment that has very few, if any, external dependencies.Is anyone using Buck/Bazel and also using frameworks like Spring, or React, for example?	yurodivuie	8.808439	9.157552	comment	5.0	16.0	1680821130	13.671772
28380045	I recently had to build a couple of 	"I recently had to build a couple of external packages that had switched to meson for internal deployment - I wasn't left _terribly_ impressed. Almost all the dependencies either required pkg-config support (which lots of the standard builds of said packages didn't deploy), or leaned heavily on CMake to actually resolve the dependencies (except for the one package with a custom meson dependency resolver - which couldn't use either and needed to be hacked).Am I thinking of it wrong, and using it as a ""layer"" above CMake to do the heavy dependency lifting is an intended part of Meson? Cmake has _huge_ support and mindshare in terms of third party packages and dependencies, even if it is somewhat difficult to learn ""good"" methods of writing CMakeLists.I feel like spending the effort to learn a"	misnome	9.197796	9.039084	comment	5.0	20.0	1630505447	13.532957
27788880	Can anyone who's familiar with Earth	Can anyone who's familiar with Earthly explain why somebody would want to use it instead of Bazel?	wikibob	8.809423	9.168841	comment	5.0	15.0	1625867059	-4.5274634
22787599	Bazel uses a subset of Python for de	Bazel uses a subset of Python for describing build rulesBazel's configuration language is called Starlark[0] (used to be Skylark). It's not a strict subset of Python. It has implementations in Java[1] and Go[2]. I haven't had a chance to use it yet, but it seems very useful as a general-purpose scripting language, especially for embedding into tools.[0] https://docs.bazel.build/versions/master/skylark/language.ht...[1] https://github.com/bazelbuild/bazel/tree/master/src/main/jav...[2] https://github.com/google/starlark-go	conroy	8.810081	9.167057	comment	5.0	20.0	1586113052	13.674719
27229019	I'm in a devops role where we actual	I'm in a devops role where we actually reroll the Tensorflow whl in-house (to get a few tweaks like specific AVX flags turned on), but because the rest of our deployment is apt/debs, we then turn around and wrap that whl in a deb using Spotify's excellent dh-virtualenv:https://github.com/spotify/dh-virtualenvThere's no expertise for Bazel in-house; when we run the build, it seems to fail all its cache hits and then spend 12-13h in total compiling, much of which appears to be recompiling a specific version of LLVM.Every dependency is either vendored or pinned, including some critical things that have no ABI guarantees like Eigen, which is literally pinned to some random commit, so that causes chaos when other binaries try to link up with the underlying Tensorflow shared objects:https://gith	mikepurvis	8.810304	9.167539	comment	5.0	21.0	1621555501	13.681223
21214871	Isn’t Bazel jre based? I don’t think	Isn’t Bazel jre based? I don’t think that something like Qt will ever go for a build tool that requires the whole java runtime as a dependency.(Also, cmake has become the de facto solution for open source libraries, not sure why they would select something else)	dgellow	8.8123	9.165395	comment	5.0	34.0	1570717620	13.664899
21288473	Bazel is almost a standard for build	Bazel is almost a standard for build systems at this point.Did you ever use it, or at least see what a bazel build rule looks like [1] before calling it arcane?[1] https://docs.bazel.build/versions/1.0.0/tutorial/cpp.html#un...	halflings	8.808607	9.167672	comment	5.0	17.0	1571370386	13.672933
24926342	Ran some benchmarking with cmake+nin	"Ran some benchmarking with cmake+ninja vs these bazel BUILD files on a soyoustart GAME-2. Build from scratch...- cmake: ~2900 files @ 28:21.07 total (https://snapshot.raintank.io/dashboard/snapshot/ijkptI1dlteB...)- bazel: ~5k targets @ 23:55.13 total (https://snapshot.raintank.io/dashboard/snapshot/TbOP6L814R3q...)If anyone can recommend a file to modify I'd also be happy to test out incremental build times. Anyway, super glad to see google externalizing some of this stuff! I also have the metrics from this prometheus instance saved so if anyone wants to see any other metrics from node_exporter let me know!fwiw bazel ""felt"" slower because the number of targets is an estimate and that kept going up while cmake was constant progress to ""finish"". I'd love to see how the bazel time looks with"	gravypod	8.808553	9.162667	comment	5.0	18.0	1603937466	13.670187
32376983	One of the nice things about Bazel t	One of the nice things about Bazel that the article didn't get a chance to go into is it uses SHA hashes of files, rather than file timestamps, to determine when an artifact has changed and therefore needs to be updated. It's slightly more costly to compute hashes, but it's necessary if you want to have something like a global cache of build artifacts, since synchronizing time across machines is hard.What I'd recommend for anyone really, is to just do what Google did. For the first six years of Google's lifecycle, they got along just fine with GNU Make. Then they switched to the huge scalable thing once they actually reached that inflection point. I'm obviously not there since I'm just a scrappy open source coder. So for me I'm quite happy to be working with GNU Make and I can foresee myse	jart	8.807747	9.163611	comment	5.0	40.0	1659884360	13.670901
24203915	> It's unfortunate that CMake is the	> It's unfortunate that CMake is the least bad build system we have.With caveats--I've switched to Bazel. Bazel does solve the very real, very hairy problems of compiling C++ programs for different platforms, on different platforms. It is a damn beautiful thing. There are a few places where Bazel really shines. For example, generated sources, multi-language projects, and building third-party dependencies from source (without monorepos or Git submodules--you can get your third-party sources from HTTP, Git, etc).If my project does any of these things (third-party dependencies, uses multiple languages, or generated sources), I reach for Bazel immediately.That said--it is also impossible to give an unqualified recommendation for Bazel. The documentation and community is catching up, and a few 	klodolph	8.809092	9.165686	comment	6.0	37.0	1597782336	13.675588
18319100	Or just switch to Meson+Ninja [1][2]	Or just switch to Meson+Ninja [1][2] and enjoy all features of modern build systems.[1] https://mesonbuild.com/[2] https://ninja-build.org/	xvilka	9.200146	9.037028	comment	6.0	42.0	1540698651	13.544366
21288397	My experience with using the Google-	"My experience with using the Google-internal version of Bazel is that yes, you want to give up all other tools to use this.  Having a proper dependency graph makes it possible to cache maximally and accurately, and that results in fast builds.  You don't need it if you only have like one go program that you're building, but you will start to see the disadvantages when you have a handful of things you build.  Did you build all the apps that depend on the proto you updated?  Do you need to build your PHP app because you change an internal go library?  Tools like ""docker build"" have no idea and tend to rebuild too much or too little, and yield different results on different machines.  This causes a lot of headaches.The thing that kills me about Bazel is that it is quite painful to deal with J"	jrockway	8.808055	9.166598	comment	6.0	26.0	1571369213	13.675244
21289219	One of the major time savers of baze	One of the major time savers of bazel is Remote Build Execution (RBE), which allows you to build modules in parallel in the cloud.  So if you have 1000 CPUs, you can really just have a client do `bazel build -j 1000 //...` and you can get a huge speed-up.  Remote (and local) builds all happen in a sandbox, so you don't have to worry about e.g. preparing a docker image with the worker / build slave environment.  (You do, however, have to register your dependencies with Bazel, which can be a hard at first).  To add to this, bazel also has a remote global cache which can benefit large teams.For fairly large C++ codebases, RBE is really a competitive advantage.  I've seen RBE cut down iteration time by an order of magnitude.  I love CMake, and CMake can get you plenty of parallelism, but CMake	choppaface	8.807526	9.163751	comment	6.0	23.0	1571381632	13.679367
21616363	What do people here think of Bazel [	What do people here think of Bazel [1]? In my understanding it is an open-sourced version of the build system that Google uses internally.[1] https://bazel.build/	kinkrtyavimoodh	8.808971	9.169036	comment	6.0	27.0	1574541332	-10.282276
27972121	> Really there were only two viable 	> Really there were only two viable candidates: CMake and Meson.Would be great to hear why those were the only two candidates that they considered (and not e.g. Bazel or Nix).	rkrzr	9.186581	9.04348	comment	6.0	24.0	1627392422	13.543753
12413547	So many build systems have regressed	So many build systems have regressed in that they don't have incremental process built into their core functionality, like Make did. Ant, Maven, Grunt, SBT, Gulp, Gradle...basically everything sucks at this compared to Make. Awful.But anyone interested in a next generation scalable build tool, check out Google Bazel. https://bazel.io/ (Ex-Googlers built similar build tools elsewhere -- Buck and Pants -- but I'm most optimistic about Bazel.)Like Make, Bazel uses incremental tasks at its core. But where Make uses timestamps, Make hashes inputs, allowing for shared caches. It's also been optimized to work with Google-scale build definitions. In beta now, 1.0 planned for end of 2017.	paulddraper	8.807342	9.153945	comment	6.0	23.0	1472829189	13.66805
35286224	One question I have after all these 	One question I have after all these articles and internal company presentations is: how exactly does Bazel track dependencies? Module A importing module B importing module C is a language-level feature, not a build system-level feature.	illiarian	8.810955	9.1681185	comment	6.0	28.0	1679644207	13.676519
34055006	What's New in Bazel 6.0	What's New in Bazel 6.0	siggi	8.80958	9.167753	story	6.0	69.0	1671471866	13.672475
34111347	Meson still won't have user defined 	Meson still won't have user defined functions, and gives a bad excuse:> Meson does not currently support user-defined functions or methods. The addition of user-defined functions would make Meson Turing-complete which would make it harder to reason about and more difficult to integrate with tools like IDEs.No, user-defined functions won't make Meson Turing-complete as long as recursion is not allowed.User defined functions make it easier to encapsulate complicated build logic and reuse it.	oldgradstudent	9.198896	9.040143	comment	6.0	84.0	1671834735	13.548734
26718760	Exodus: Easily migrate your JVM code	Exodus: Easily migrate your JVM code from Maven to Bazel	zdw	8.809878	9.168293	story	6.0	70.0	1617752573	13.664403
13865427	This looks like a clone of Google's 	This looks like a clone of Google's Blaze/Bazel: https://bazel.build/	spankalee	8.809842	9.166962	comment	6.0	23.0	1489472192	-10.291196
32831847	> Bazel is a fully reproducible and 	> Bazel is a fully reproducible and hermetic build system.Yes, and it's very important to note that Bazel does nothing to solve the problem about having a reproducible and hermetic runtime. Even if you think you aren't linking against anything dynamically, you are probably linking against several system libraries which must be present in the same versions to get reproducible and hermetic behavior.This is solvable with Docker or exceptionally arcane Linux hackery, but it's completely missing from the Bazel messaging and it often leaves people thinking it provides more than it really does.	bobsomers	8.810408	9.1662445	comment	6.0	35.0	1663115371	13.67598
31849149	Anyone got any stories about migrati	"Anyone got any stories about migrating big, crufty, multiplatform cmake C++ projects to Bazel? ""It sucked but was worth it"" or ""it was surprisingly easy"" or ""LOL don't even try?"""	corrral	8.812161	9.164825	comment	6.0	34.0	1655992463	13.677905
32261470	I’m using Bazel to build my rust pro	I’m using Bazel to build my rust project (Using the rules_rust rules) and it’a become quite a pain to use in concert with docker.This is not a complaint about Bazel specifically, its fantastic, and easily my favourite build system bar none.However it cannot cross compile Rust. This means if I’m developing on my MacBook, and I want to compile a Rust binary and put it in an Ubuntu docker container, I can’t do it on my host machine. I need to copy the source into the container and build it there, using multistage builds.But this is -extremely slow- because it cannot take advantage of Rusts build caching. I’m talking 10-15 minutes for my small Rust project.Has anyone run into this? How do you work around it?I’ve considered running a Bazel remote execution server on a local Ubuntu VM, but this 	hazz99	8.810692	9.1598835	comment	6.0	21.0	1658993800	13.64247
32377264	For the first decade and a half of G	"For the first decade and a half of Google's company lifecycle, they got along just fine with GNU Make???   Google was started in 1998, and Bazel was created ~2006 as a replacement for Python + GNU Make (""gconfig"").  I was on that team, though I only worked on Blaze a tiny bit.  The ""google3"" build migration was sometime around 2003 or 2004.So at most there were 6 years of using Make only, i.e. ""google2"".Importantly, pre-Blaze google3 wasn't just GNU make -- Python was a huge part of it, which is why the Bazel build language Starlark looks like Python.  It used to literally be Python, and now it's a Python-like language with parallel evaluation.---If you want to do what ""scrappy Google"" did these days, then you should use Python + Ninja.  Ninja is meant to be generated, just like GNU Make w"	chubot	8.808038	9.163266	comment	6.0	29.0	1659886563	13.678081
16528375	Thanks for the comments on Bazel -- 	"Thanks for the comments on Bazel -- I am evaluating a proper build system for us right now for a data science codebase almost entirely in Python, with a lot of scientific computing dependencies. Bazel doesn't yet seem to have first-class support for Python, so that's out, and I'm running into a lot of problems with Twitter Pants, although their Slack channel is really helpful.Did you ever try using Pants or Buck, or a more barebones approach like Ninja?P.S.: An explanation of the pun on ""Basil Fawlty"" (as a non-Brit, I thought, what on earth is that?) in the article might be helpful."	sarabande	8.809735	9.163298	comment	7.0	22.0	1520339268	13.668445
26719078	To ask the obvious unanswered questi	To ask the obvious unanswered question: Why would someone want to move to Bazel from Maven?   What advantages does it bring?	Twirrim	8.810425	9.168263	comment	7.0	56.0	1617755257	13.648423
35286516	Lol, Googler here, I can't deny  tha	Lol, Googler here, I can't deny  that I have he urge to force Bazel into the world.It's just, when I joined Google I found a build system I didn't hate. This was the first time. I don't actually love Bazel (Blaze internally), but I love that I don't hate it.Every time I have to learn a new build system in open source work I groan. Why are there so many systems for essentially the same thing?	bjackman	8.809888	9.167797	comment	7.0	50.0	1679646937	-10.195027
35472845	Great to see this. I hope it takes o	"Great to see this. I hope it takes off - Bazel is useful but I really like the principled approach behind it (see the Build Systems a la Carte paper), and Neil is scarily good from my experience of working with him so I'd expect that they've come up with something awesome.One thing I find annoying with all of these general, language-agnostic build systems though is that they break the ""citizenship"" in the corresponding language. So while you can usually relatively easily build a Rust project that uses crates.io dependencies, or a Python project with PyPi dependencies, it seems hard to make a library built using Bazel/Buck available to non-Bazel/Buck users (i.e., build something available on crates.io or PyPi). Does anyone know of any tools or approaches that can help with that?"	oggy	8.809431	9.166324	comment	7.0	24.0	1680807655	13.660289
23183238	Might make sense if you use Go or an	"Might make sense if you use Go or any other language with a straightforward tooling landscape (compilers, package management etc.).That changes drastically if your codebase contains a lot of C++ and your SW model doesn't quite match the way Bazel tries to push you into.
For instance doing any of the following things will quickly turn into a nightmare when using the Bazel C++ rules:* dynamically linking libraries* using a containerized approach for library includes (so transitive relative include paths)* using different toolchains and cross compiling* interfacing with thirdparty librariesWe are talking seasoned build engineers ending up frustrated after literally months of trying to achieve something that is easy as pie in CMake.In addition there is still no real IDE support. The CLion plug"	simfoo	8.811043	9.162189	comment	7.0	32.0	1589480080	13.656656
24910704	I wish more people were taking a loo	I wish more people were taking a look at Bazel, and the Bazel-family, of build systems. I've looked at Meson/Ninja/Make and it works but it's truely very complicated and very difficult to get hermetic & reproducible builds from these systems. In my opinion, Bazel will be the future once the currently ongoing external dependency management design doc is implemented. I've migrated quite a few builds to bazel at work and I've seen a dramatic reduction in compile times - not even from compiling source code! Doing things like packaging zips, generating code, generating docs (swagger), etc all adds up in CI time and automating, and caching, absolutely all of it is astonishingly useful.	gravypod	8.808906	9.162565	comment	7.0	30.0	1603825830	13.675267
25239947	> If you're familiar with Blaze / Ba	> If you're familiar with Blaze / Bazel, Buck or Pants you will probably find Please very familiarYes, so why would I use Please over any of them? I've spent close to 10min reading and have no idea why this exists or why anyone would use it. It looks like Bazel with a different config format, in which case why wouldn't one just use Bazel?	japgolly	8.809669	9.168963	comment	7.0	51.0	1606592873	-4.4042892
31847594	Incremental Builds for Haskell with 	Incremental Builds for Haskell with Bazel	ingve	8.807938	9.165511	story	7.0	92.0	1655983743	13.692089
31849779	I really can't emphasize enough how 	"I really can't emphasize enough how much I love using Bazel. The ability to tell a less technical user ""just run `bazel run //amazing/server`"" regardless of language and know that everything will magically work (toolchain installation, future toolchain upgrades, incremental rebuilds) is really freeing. The actions graph with rules and aspects is quite powerful, so you can do things like add Java nullability checks or Python type checking remarkably easily. Recently I put together a simple build rule that strips external dependencies, archives the rest, and uploads it to a cache. Then we can easily run that archive against a pre-built container (which contains the external dependencies) in our cluster, enabling a very fast ML iteration loop on beefy cluster machines. I've also done a lot of"	aschleck	8.80972	9.163508	comment	7.0	31.0	1655995388	13.6972475
32183792	Use the Bazel Build System	Use the Bazel Build System	eka1	8.809058	9.169	story	7.0	19.0	1658431852	13.673961
13865567	I don't work in a shop where perform	"I don't work in a shop where performance/speed is important, but I am looking for other ways to do things I would do in Make but...not in Make.For example, my use-case is similar to what Mike Bostock described in ""Why Use Make"" [0] when explaining how he uses Make to build out his data tranformation process. Most of my work is data transformation/small-scale ETL, but I just haven't been able to get into Make beyond trivial work, and I often end up writing things in Rake (Ruby).So I was wondering if other devs had tried using Buck/Bazel for everyday hobbies and projects, and whether you stuck with the new tool or went back to Make? The portability of Makefiles isn't a high priority for me, and I like experimenting with different systems for my own projects.[0] https://bost.ocks.org/mike/mak"	danso	8.810157	9.16263	comment	8.0	37.0	1489474260	13.6745205
19610947	Meson[0] has been gaining in popular	Meson[0] has been gaining in popularity and has migration tools for cmake projects.Large projects such as systemd and gnome[1] have migrated or have been migrating for years[0] https://mesonbuild.com/[1] https://wiki.gnome.org/Initiatives/GnomeGoals/MesonPorting	2bluesc	9.197317	9.040017	comment	8.0	82.0	1554774216	13.557053
21215225	Bazel may be 1.0 and the internal ab	Bazel may be 1.0 and the internal abstractions of dag solving etc are rock solid from years of use inside Google, but the ecosystem around Bazel is quite bad at the moment. They've been breaking backwards compatibility constantly, so rules authors have struggled to keep up (hopefully done now that it's 1.0).The reason the ecosystem maturity is so important for bazel is because its design encourages complete reimplementations. The rust packaging rules for bazel reimplement a subset of cargo's features from scratch. The docker rules reimplement image building from scratch (they don't actually use docker). The (Google maintained) python rules shell out to pip, but it's got a ton of problems, some packages are unbuildable, and it busts the cache constantly and redownloads everything.If you're 	habitue	8.809838	9.1615715	comment	8.0	53.0	1570719521	13.68188
21289097	We didn't have Bazel on ARM for NixO	We didn't have Bazel on ARM for NixOS because we can't bootstrap openJDK on ARM. There's no source code for a JVM that compiles on ARM afaik. Though in theory we could package binary blobs from oracle and bootstrap JDK and Bazel from there, it means now our trust path for your critical build tool has a random Oracle blob in its trust path there that is extremely hard to get rid off.Build systems should be easy to build. Bazel is not by a far shot due to java being a mess in this area (ironic given it being advertised as a cross platform language).These issues are not important for everyone perhaps. (Heck the entire Kubernetes ecosystem pulls random binaries from docker hub without any cryptographic signatures.) but it's still a shame; especially for a build system.	arianvanp	8.810547	9.166956	comment	8.0	39.0	1571379749	13.673636
34055764	I'm still not sure if I should go th	I'm still not sure if I should go the bazel route... recently found a long good explanation why anki switched away from bazel: https://github.com/ankitects/anki/commit/5e0a761b875fff4c9e4...I'd love to have cachable builds but I wonder how much effort it takes to maintain such a setup - especially in a small team very far away from silicon valley or google were nobody saw bazel before. Would be a perfect fit for my former company but even there I couldn't convince my colleagues - they build a monster using maven which would be more elegant in bazel but maven integration worked different than the maven algorithm at least 2 years ago...so my PoC turned into reading source code of dependency resolution algorithm in the used scala tool coursier... in the end I had to give up after patching mav	nisa	8.809754	9.167749	comment	8.0	40.0	1671474992	13.655441
27953673	Moving SciPy to the Meson Build Syst	Moving SciPy to the Meson Build System	stockholmsin	9.197778	9.040611	story	9.0	94.0	1627253316	13.538427
22947395	Incremental Builds in Gatsby Cloud	Incremental Builds in Gatsby Cloud	Dockson	8.804051	9.1440325	story	9.0	130.0	1587573340	13.643964
24490089	Bazel For Open-Source C/C++ Librarie	Bazel For Open-Source C/C++ Libraries Distribution	todsacerdoti	8.807969	9.166251	story	9.0	64.0	1600237720	13.672367
18738261	Building TypeScript Projects with Ba	Building TypeScript Projects with Bazel	mgechev	8.809001	9.168128	story	10.0	90.0	1545441835	13.689937
14875640	CMake is a big improvement, but it's	CMake is a big improvement, but it's a shame they didn't opt for Buck or Bazel. These two build systems are as much an improvement over the previous generation as autoconf and GNU Make were improvements over random ad-hoc configure scripts. Both take pains to ensure that builds are fully hermetic and fully reproducible, support rich introspection, and run very, very fast.	quotemstr	8.81264	9.160101	comment	10.0	39.0	1501260815	13.59298
24925368	Bazel Build System Support for LLVM	Bazel Build System Support for LLVM	mshockwave	8.809843	9.167426	story	11.0	118.0	1603927880	13.722293
16483112	I wonder if Bazel takes off across m	"I wonder if Bazel takes off across many languages. It wouldn't hurt to have a modern autotools & co. replacement across ecosystems. I don't think it's doable, considering the fact that we have language specific package managers and build tools, but you never know.By ""replacement"", I mean picking up a random open source project and being able to do the equivalent of:./configuremakemake installTo be able to build and run the app directly from sources, when needed.Right now, it's a mess, the ""replacement"" is:curl whatever.io | sudo bash"	oblio	8.808922	9.167132	comment	11.0	45.0	1519827778	13.67871
32829754	Last year I tried doing a side proje	Last year I tried doing a side project with a talented ex-Google buddy who insisted we set up Bazel to replace my simple Makefile. Three weeks later it still wasn’t working on my Windows box. We had a mixed Python and C++ code base and I like to use MinGW64 gcc on Windows. He blamed Windows and tried to get me to switch to Mac (no thanks, lol) and eventually he lost interest and gave up. The project went on to win an OpenCV funded competition and became the basis of a startup — good job, GNU Make!So the answer IMHO to “when to use Bazel” is “never” :)	trzy	8.809796	9.16766	comment	12.0	93.0	1663100763	13.6702585
21385013	Evaluating Bazel for building Firefo	Evaluating Bazel for building Firefox	dochtman	8.809596	9.168692	story	12.0	194.0	1572336361	13.668718
16528112	Bazel Fawlty	Bazel Fawlty	elrodeo	8.809368	9.167235	story	13.0	75.0	1520334259	-4.454733
26721300	I know nothing about Bazel, but I've	I know nothing about Bazel, but I've never understood the JVM community's obsession with getting off Maven.My experience of Gradle is Gradle projects require a PhD in Gradle AND intimate familiarity with the tastes of whoever implemented that particular project .gradle files likes to use it. Is Bazel like that too?When we inherit codebases from other teams, often one of the first things we do is convert it from Gradle to Maven.I honestly couldn't care less about how flexible and powerful Gradle or Bazel or some other build tool is compared to Maven. Maven is simple, the same in every project (this is huuuuuge), just works and gets out the way.	bedobi	8.80975	9.167909	comment	13.0	55.0	1617778770	13.633271
24845031	Cargo-style dependency management fo	Cargo-style dependency management for C, C++ and other languages with Meson	pabs3	9.199522	9.030236	story	14.0	86.0	1603258502	13.547983
35286355	Hey, what a surprise, ex-google engi	Hey, what a surprise, ex-google engineers dragging everyone into bazel...Maybe you have some really complicated use case that makes cargo insufficient, but really, it's pretty damn nice and it's integrated with everything.There are languages that need bazel, rust isn't one of them	habitue	8.8131275	9.159049	comment	14.0	97.0	1679645434	13.655859
35270660	Scaling Rust Builds with Bazel	Scaling Rust Builds with Bazel	zdw	8.811154	9.166267	story	15.0	107.0	1679546951	13.659099
21288388	I only wish Bazel had been written i	I only wish Bazel had been written in a language that produced native binaries like C++ or Go instead of Java. It seems like a waste for me as a non-Java developer to install Java on my dev machine just for Bazel.	RcouF1uZ4gsC	8.809665	9.167886	comment	16.0	117.0	1571368985	13.667848
34109215	Meson Build System 1.0	Meson Build System 1.0	TangerineDream	9.200236	9.03801	story	16.0	150.0	1671820895	13.5387945
28372545	The Rise of Meson	The Rise of Meson	fanf2	9.198072	9.035664	story	17.0	74.0	1630438850	1.1185864
38493940	Ask HN: Anyone using Bazel at startu	Ask HN: Anyone using Bazel at startups? or migrated to/away from Bazel?	grrandalf	8.8095875	9.168768	story	20.0	27.0	1701472761	13.671608
21288185	Bazel 1.0	Bazel 1.0	vips7L	8.809906	9.167044	story	22.0	411.0	1571366239	13.672938
21213240	Bazel Release 1.0	Bazel Release 1.0	klodolph	8.809489	9.168905	story	29.0	263.0	1570707262	13.67457
